COMMENT ⊗   VALID 00014 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	SUBTTL IMP INTERRUPT-LEVEL DRIVERS - JAM, SEPT '71
C00005 00003	 INPUT BEGINS BY COMING TO HERE. READ THE 72-BIT LEADER THEN
C00008 00004	 INPUT ROUTINE, READ SUCCESSIVE WORDS AND ZERO OUT BYTES IN LAST WORD
C00010 00005	 WE GET HERE IF AT INTERRUPT LEVEL WE HAVE A WORD AND NO BUFFER TO PUT IT IN
C00012 00006	 WE GET HERE WHEN INPUT IS DONE.
C00013 00007	 ROUTINE TO SET THE WORD COUNT IN THE LAST BUFFER AND
C00015 00008	 ROUTINE TO SET UP THE BYTE POINTER AND WORD COUNT FOR A BUFFER
C00017 00009	 CLOCK LEVEL ROUTINE TO GET A SPARE BLOCK
C00019 00010	 MAIN OUTPUT LOOP
C00023 00011	 ROUTINE TO QUEUE A MESSAGE FOR OUTPUT.
C00025 00012	 ROUTINE TO SET THE OUTPUT WORD COUNT AND BYTE POINTER
C00027 00013	 INPUT INTERRUPT COMES HERE
C00029 00014	BEND IMPSER
C00030 ENDMK
C⊗;
SUBTTL IMP INTERRUPT-LEVEL DRIVERS - JAM, SEPT '71

; CONO BITS . . .

TEST←←100000		; ENTER TEST MODE (DOES ANAL-CRANIAL INVERSION)
STRIN←←040000		; START INPUT, SETS STOP, CLEARS INPUT END
I32←←020000		; SET INPUT BYTE SIZE TO 32B IF IDPIEN SET
O32←←010000		; SET OUTPUT BYTE SIZE TO 32B IF ODPIEN SET
CLRST←←004000		; CLEAR STOP AFTER INPUT BIT
CLRWT←←002000		; CLEAR WAITING TO INPUT BIT
STROUT←←000200		; START OUTPUT
FINO←←000100		; FINISH OUTPUT (LAST BIT HAS BEEN SENT)
IEPIEN←←000040		; ENABLE CHANGE OF INPUT END INTERRUPT CHANNEL
IDPIEN←←000020		; ENABLE CHANGE OF INPUT BYTE SIZE AND INPUT DONE INTERRUPT CHANNEL
ODPIEN←←000010		; ENABLE CHANGE OF OUTPUT BYTE SIZE AND OUTPUT DONE INTERRUPT CHANNEL

ISTART←←STRIN!CLRWT!IEPIEN!IDPIEN!IMPCHN

; CONI BITS . . .

RDY←←200000		; IMP READY
TEST←←100000		; ENTER TEST MODE (DOES ANAL-CRANIAL INVERSION)
IMPERR←←040000		; IMP ERROR
IDONE←←020000		; INPUT DONE
IEND←←010000		; INPUT END.
ODONE←←004000		; OUTPUT DONE
; INPUT BEGINS BY COMING TO HERE. READ THE 72-BIT LEADER THEN
; SET BYTE SIZE AND READ REST OF MESSAGE.

↑IBEGIN:
	PUSHJ P,SETUP		; SET UP BYTE POINTER AND COUNT
	JRST IHANG		; NO FREE STORAGE, HANG AND WAIT FOR IT
	CONI IMP,AC3
	BLKI IMP,IMPBKO		; READ FIRST WORD
	JFCL
	MOVE AC1,IMPICUR	; SET TOP BLOCK OF INPUT
	MOVEM AC1,IMPITOP
	TRNE AC3,IEND		; IS THAT ALL THE IMP HAS FOR US?
	JRST INPDONE		; YES, GO PUT LIST ON ILIST
	CONO IMP,CLRWT		; CLEAR THE WAIT FLAG AND READ NEXT WORD
	PUSHJ P,ISYNC
SECOND:	CONI IMP,AC3
	BLKI IMP,IMPBKO		; GET SECOND WORD
	JFCL
	TRNE AC3,IEND		; DONE YET?
	JRST INPDONE
	MOVE AC1,IMPITOP	; PICK UP ADDRESS OF BLOCK CONTAINING LEADER
	LDB AC2,SIZEP		; PICK UP BYTE SIZE OF TRANSMISSION
	SETOM IMPIFM		; ASSUME 36-BIT MODE
	SKIPG AC3,BPW(AC2)	; PICK UP BITS PER WORD FOR THIS BYTE SIZE
	MOVEI AC3,44		; IF ILLEGAL BYTE SIZE, IT DOESN'T MATTER
	CAIN AC3,40
	SETZM IMPIFM
	IDIVM AC3,AC2		; NUMBER OF BYTES/WD IN AC2
	MOVEI AC3,(AC2)
	LDB AC2,COUNTP
	IDIVI AC2,(AC3)		; # WORDS IN AC2, # BYTES IN LAST WORD IN AC3
	MOVEM AC2,IMPINW
	SETZM IMPIMS		; PREPARE FOR INTEGRAL NUMBER OF WORDS
	JUMPE AC3,INPLOP	; INTEGRAL NUMBER OF WORDS GETS A ZERO MASK
	LDB AC2,SIZEP
	MOVNS AC2		; GET MASK FOR LAST WORD
	IMULI AC2,(AC3)
	MOVSI AC1,400000
	ASH AC1,1(AC2)		; WE HAVE NOW SPREAD THE BIT OVER THE BYTES
	MOVEM AC1,IMPIMS	; AND THAT IS THE MASK
; INPUT ROUTINE, READ SUCCESSIVE WORDS AND ZERO OUT BYTES IN LAST WORD

INPLOP:	MOVEI AC1,CLRWT!CLRST!IDPIEN!IEPIEN!IMPCHN
	SKIPN IMPIFM		; WHAT BYTE SIZE?
	ORI AC1,I32		; 32, SET BIT
	CONO IMP,(AC1)
	PUSHJ P,ISYNC
INP1:	CONI IMP,AC3
	BLKI IMP,IMPBKO
	JFCL
	SOSL IMPINW		; LAST WORD YET?
	JRST INPET		; NO, PROCEED ALONG
	HRRZ AC2,IMPBKO
	MOVE AC1,IMPIMS		; YES, PICK UP MASK
	ANDM AC1,(AC2)		; ZERO OUT BYTES IN LAST WORD
	SETZM IMPIMS		; AND ZERO ALL SUCCESSIVE WORDS
INPET:	TRNE AC3,IEND
	JRST INPDONE
	SKIPGE IMPBKO		; HAS THE COUNT OVERFLOWED?
	JRST INPLOP		; NO, GO BACK FOR NEXT WORD
	MOVEI AC1,CLRWT!IDPIEN!IEPIEN!IMPCHN
	SKIPN IMPIFM		; IN WHICH CASE, WAIT AFTER NEXT WORD
	ORI AC1,I32
	CONO IMP,(AC1)
	PUSHJ P,ISYNC
	PUSHJ P,SETUP
	JRST IDHANG
	JRST INP1
; WE GET HERE IF AT INTERRUPT LEVEL WE HAVE A WORD AND NO BUFFER TO PUT IT IN

IHANG:	SETOM IMPITOP		;FLAG TO GETSPARE IN CASE 1 WD MSG
	PUSHJ P,HANG
	JRST IHEWAIT
	MOVE AC1,IMPICUR
	MOVEM AC1,IMPITOP	;SET UP POINTER TO FIRST BLOCK OF MSG
	JRST SECOND		; GO PICK UP THE NEXT WORD

IDHANG:	PUSHJ P,HANG
	JRST IHEWAIT
	JRST INP1		; GO FINISH FILLING BUFFER

HANG:	AOS NHANGS
	CONI IMP,AC1
	DATAI IMP,IMPHELP
	SETOM IMPHLF
	TRNE AC1,IEND
	POPJ P,
	MOVEI AC1,IEPIEN!IDPIEN
	SKIPN IMPIFM
	ORI AC1,I32		; CLEAR PI CHANS SO WON'T INTERRUPT
	CONO IMP,(AC1)
	PUSHJ P,ISYNC
	PUSHJ P,HLPWRD
	AOS (P)
	JRST GETSPARE		;WE JUST USED THE SPARE, TRY TO GET A NEW ONE

; ROUTINE TO PICK UP SAVED WORD AND PLACE IT IN BUFFER

HLPWRD:	MOVE AC1,[XWD 1,1]	; BUMP THE IOWD
	ADDB AC1,IMPBKO		; BOTH HALVES
	MOVE AC2,IMPHELP	; PICK UP SAVED WORD
	SETZM IMPIHD		; CLEAR INPUT-END FLAG
	SETZM IMPHLF		; CLEAR SAVED WORD
	MOVEM AC2,(AC1)		; PLACE IT IN BUFFER
	POPJ P,
; WE GET HERE WHEN INPUT IS DONE.

INPDONE:
	PUSHJ P,IFINISH		; SET WORD COUNT IN LAST BUFFER AND PUT IT ON ILIST
	CONO IMP,ISTART		; START THE IMP LISTENING FOR INPUT
INIWAIT:
	PUSHJ P,ISYNC
	JRST IBEGIN		; START A NEW MESSAGE

; GET HERE WHEN WE INPUTTED THE LAST WORD INTO IMPHELP AND THERE
; IS NO BUFFER FOR IT. CLOCK LEVEL WILL CALL IFINISH THEN
; START THE IMP UP LISTENING AGAIN.

IHEWAIT:
	SETOM IMPIHD		; NOTE THAT THE WORD IN IMPHELP IS THE LAST WORD
	CONO IMP,IDPIEN!IEPIEN	; MAKE SURE WE DON'T INTERRUPT AGAIN
	JRST INIWAIT
; ROUTINE TO SET THE WORD COUNT IN THE LAST BUFFER AND
; TAG THE ENTIRE BUFFER LIST ONTO ILIST

IFINISH:
	AOS NMESIN		; BUMP NUMBER OF MESSAGES RECEIVED
	MOVE AC1,IMPICUR	; PICK UP POINTER TO CURRENT BUFFER
	SETZM IMPICUR		; MAKE SURE NOBODY IS HOME, SO SETUP WON'T LINK ONTO A NON-EX BLOCK
	HLRE AC2,IMPBKO		; PICK UP WORD COUNT REMAINING
	ADD AC2,TLEN(AC1)	; GET LENGTH OF CURRENT BUFFER
	MOVEM AC2,TWC(AC1)	; USE THAT AS THE WORD COUNT
	MOVE AC1,IMPITOP	; PICK UP FIRST BLOCK OF MESSAGE
	SKIPN AC2,ILIST		; ANYTHING IN THE INPUT LIST?
	JRST IFINI1		; NO, PUT US AS THE FIRST AND LAST ELEMENT
	MOVSS AC2
	HRLM AC1,TLINK(AC2)	; LINK US ON TO THE LAST ELEMENT
IFINI2:	HRLM AC1,ILIST		; MAKE US THE LAST ELEMENT
	HRRZS TLINK(AC1)	; CLEAR OUR CDR
	POPJ P,

IFINI1:	HRRM AC1,ILIST		; MAKE US THE FIRST ELEMENT
	JRST IFINI2
; ROUTINE TO SET UP THE BYTE POINTER AND WORD COUNT FOR A BUFFER
; IF THERE IS A LIST, IT APPENDS THE NEW BUFFER TO THE END OF THE LIST.
; SKIP RETURNS IF THERE WAS A BUFFER. IF NOT, NO SKIP AND PUT IN
; CLOCK REQUEST TO GET A BUFFER.

SETUP:	PUSHJ P,SETUP0
	JRST NOSPARE		; NO FREE STORAGE, PLANT CLOCK REQUEST, TAKE FAILURE RETURN
	PUSHJ P,GETSPARE	; GET A NEW SPARE BLOCK
	JRST CPOPJ1		; WE WON THIS TIME

SETUP0:	SETZ AC1,
	EXCH AC1,IMPSPARE
	JUMPE AC1,CPOPJ		; NO FREE STORAGE, GIVE FAILURE RETURN
	SETZM TLINK(AC1)
	MOVN AC2,TWC(AC1)	; PICK UP LENGTH OF DATA PORTION OF BLOCK
	HRLI AC1,(AC2)		; PUT NEGATIVE WORD COUNT BESIDE DATA POINTER
	SKIPE AC2,IMPICUR	; IS THERE ALREADY A LIST GOING?
	HRRM AC1,TLINK(AC2)	; YES, APPEND US TO IT
	HRRZM AC1,IMPICUR	; SET US AS CURRENT BLOCK
	ADDI AC1,TDATA-1	; MOVE TO JUST BEFORE DATA PORTION
	MOVEM AC1,IMPBKO	; PUT IN BLKO WORD
	JRST CPOPJ1
; CLOCK LEVEL ROUTINE TO GET A SPARE BLOCK

GETSP:	SETZM IMPCLN		; NOTE CLOCK REQUEST SATISFIED
	SKIPE IMPDEAD		; IS THERE ANY IMP?
	POPJ P,			; NO, FORGET IT
GETSPARE:
	PUSHJ P,IMPGET		; SEE IF THERE IS A BLOCK AVAILABLE
	JRST NOSPARE
	EXCH AC1,IMPSPARE
	SKIPE AC1		; WAS THERE ALREADY ONE?
	PUSHJ P,IMPREL		; YES, GIVE IT BACK
	SKIPN IMPHLF		; IS SOMEONE WAITING FOR IT?
	POPJ P,			; NO, LEAVE NOW
	PUSHJ P,SETUP0		; YES, SET UP BYTE POINTER AND COUNT
	JRST NOSPARE
	SKIPN IMPIHD		; IS IT THE LAST WORD?
	JRST GETSP1		; NO, JUST CLEAR THE WAIT FLAG AND GO
	PUSHJ P,HLPWRD		; PUT LAST WORD IN BUFFER
	MOVE AC1,IMPICUR
	SKIPGE IMPITOP
	MOVEM AC1,IMPITOP	;SET UP POINTER TO FIRST BLK OF MSG IF FROM IHANG
	PUSHJ P,IFINISH		; PUT LIST ON ILIST
	CONO IMP,ISTART		; START THE IMP LISTENING AGAIN
	JRST GETSPARE		; NOW GET A SPARE AGAIN

GETSP1:	SETZM IMPHLF
	MOVEI AC1,CLRWT!ODPIEN!IDPIEN!IMPCHN
	SKIPN IMPIFM
	ORI AC1,I32
	CONO IMP,(AC1)		; START IMP GOING AGAIN, SET UP PI CHANNELS
	POPJ P,

; PLANT A CLOCK REQUEST TO COME BACK AND LOOK FOR FREE STORAGE

NOSPARE:
	SETO AC1,
	EXCH AC1,IMPCLN
	JUMPN AC1,CPOPJ
	MOVE AC1,[XWD GETSP,0]
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
	POPJ P,
; MAIN OUTPUT LOOP

IMPOL:	MOVEI AC2,ODPIEN!IMPCHN
NXTTFR:	SKIPN IMPOFM
	ORI AC2,O32
	CONO IMP,(AC2)
	BLKO IMP,IMPOBK
	JFCL
	PUSHJ P,OSYNC
↑OBEGIN:
	SETOM IMPOACT		; NOTE THAT WE ARE STILL ACTIVE
	SOSN IMPOFC		; DECREMENT COUNT OF WORDS LEFT UNTIL 32-BIT MODE
	SETZM IMPOFM		; SWITCH TO 32-BIT MODE
	SKIPG IMPOBK		; DECREMENT COUNT OF WORDS LEFT IN BUFFER
	JRST IMPOL
NXTBLK:	MOVE AC1,IMPOCUR	; PICK UP POINTER TO CURRENT BLOCK
	SKIPG AC2,RSTHST	; ANY MORE RESETS YET TO BE SENT?
	JRST NOTRST		; NO, RELEASE THIS BLOCK
	SOS AC2,RSTHST		; YES, COUNT DOWN AND LOAD NEW HOST #
	DPB AC2,SRCP		; PUT NUMBER OF NEXT HOST TO BE RESET INTO BLOCK
	CONO IMP,FINO		; WHOLE RESET HAS BEEN SENT
	PUSHJ P,OSYNC
	MOVE AC1,IMPOCUR	; GET BACK THE POINTER TO THE BLOCK
	JRST IMPOD1		; NOW USE SAME BLOCK TO SEND NEXT RESET

NOTRST:	HRRZ AC2,TLINK(AC1)
	MOVEM AC2,IMPOCUR
	PUSHJ P,IMPREL		; RELEASE JUST EMPTIED BLOCK
	SKIPN AC1,IMPOCUR	; IS THERE A NEXT BLOCK?
	JRST IMPODN		; NO, OUTPUT DONE
	PUSHJ P,SETCNT		; YES, SET UP COUNT AND BYTE POINTER
	JRST IMPOL		; START IT GOING

IMPODN:	CONO IMP,FINO		; TELL IMP THE LAST BIT HAS BEEN SENT
	PUSHJ P,OSYNC
	AOS NMESOU		; BUMP NUMBER OF MESSAGES TRANSMITTED
	SKIPN AC1,OLIST		; ANYTHING ELSE IN QUEUE?
	JRST OWAIT		; NO, WAIT FOR OUTPUT TO BEGIN
	PUSHJ P,LEGAL		; IS IT A LEGAL BLOCK?
	JRST [	SETZM OLIST	; NO, FLUSH THE ENTIRE OUTPUT LIST
		JRST OWAIT]	; AND PRETEND IT IS EMPTY
	HLRZ AC2,TLINK(AC1)	; YES, PICK UP FIRST ELEMENT
	HRRM AC2,OLIST
	SKIPN AC2
	SETZM OLIST
	HRRZM AC1,IMPOCUR
IMPOD1:	PUSHJ P,SETMOD		; SET 32 OR 36 BIT MODE
	PUSHJ P,SETCNT
	MOVEI AC2,STROUT!ODPIEN!IMPCHN
	JRST NXTTFR

DONOP1:	CONO IMP,STROUT!ODPIEN!IMPCHN
	DATAO IMP,[BYTE (8) 4]	;NOP
	PUSHJ P,OSYNC
DONOP:	CONO IMP,FINO
	PUSHJ P,OSYNC
	SOSLE NOPCNT
	JRST DONOP1
OWAIT:	SETZM IMPOACT		; WE ARE NO LONGER ACTIVE
	CONO IMP,ODPIEN		; CLEAR PI CHANNEL SO WE HEAR NO EVIL
	PUSHJ P,OSYNC		; WAIT FOR CLOCK LEVEL TO START US UP
	JRST OBEGIN
; ROUTINE TO QUEUE A MESSAGE FOR OUTPUT.
; ENTER WITH MESSAGE IN AC1

QOUT:	PUSHJ P,LEGAL		; REASONABLE BLOCK?
	POPJ P,			; NO, LEAVE NOW
	CONO PI,IMPOFF
	SKIPN IMPOACT		; IS OUTPUT IN PROGRESS?
	JRST QIDLE		; NO, START IT BY HAND.
	PUSH P,AC2
	SKIPN AC2,OLIST		; PUT THIS MESSAGE ON THE END OF THE OUTPUT LIST
	JRST QNOLIST
	MOVSS AC2
	HRLM AC1,TLINK(AC2)
QOXIT:	HRLM AC1,OLIST
	POP P,AC2
	HRRZS TLINK(AC1)
	CONO PI,IMPON
	POPJ P,

QNOLIST:
	HRRM AC1,OLIST
	JRST QOXIT

; GET HERE WHEN THE OUTPUT SIDE OF THE IMP IS IDLE

QIDLE:	CONO PI,IMPON		; NO NEED TO BOTHER WITH INTERLOCKING
	SETOM IMPOACT
	MOVEM AC1,IMPOCUR
	PUSH P,AC3
	PUSHJ P,SETMOD		; SET UP COUNT OF NUMBER OF WORDS IN 36B MODE
	PUSHJ P,SETCNT		; SET UP BYTE POINTER AND COUNT
	MOVEI AC3,MAXCNT	; SET UP OUTPUT TIMEOUT
	MOVEM AC3,IMPOCT
	POP P,AC3
	CONO PI,IMPOFF
	CONO IMP,STROUT!ODPIEN!IMPCHN
	BLKO IMP,IMPOBK
	JFCL
	CONO PI,IMPON
	POPJ P,
; ROUTINE TO SET THE OUTPUT WORD COUNT AND BYTE POINTER

SETCNT:	MOVN AC2,TWC(AC1)	; PICK UP SIZE OF BLOCK
	HRLI AC2,TDATA-1(AC1)	; PUT IN ONE BEFORE DATA PORTION OF BUFFER
	MOVSM AC2,IMPOBK	; PLACE IN OUTPUT BLKO WORD
	POPJ P,

; ROUTINE TO DO SOFTWARE RELOCATION ON ADDESS IN TAC1
; PUTS RESULT IN DSER

DOLOC:	HRRZI DSER,(TAC1)	; MOVE USER ADDRESS TO DSER
	TRNN DSER,400000	; UPPER SEGMENT ADDRESS?
	JRST EOREL		; NO, USE PROG
	PUSH P,TEM
	LDB TEM,PSEGN		; YES, PICK UP REL. OF UPPER
	HRRZ TEM,JBTADR(TEM)
	ADDI DSER,-400000(TEM)
	POP P,TEM
	POPJ P,

EOREL:	ADDI DSER,(PROG)
	POPJ P,

; ROUTINE TO SET THE COUNT OF THE NUMBER OF WORDS IN 36B MODE

SETMOD:	LDB AC2,SIZEP
	MOVEI AC3,2
	CAIN AC2,44		; UNLESS MOVE IS 36B, USE 32B
	SETO AC3,
	MOVEM AC3,IMPOFC	; SET NUMBER OF WORDS IN 36B
	SETOM IMPOFM		; WE ALWAYS START IN 36B MODE
	POPJ P,
; INPUT INTERRUPT COMES HERE

↑IMPINT:
	CONSO IMP,770		; ANY CHANNEL?
	JRST IMPOTS		; NO, CAN'T BE US
	MOVEM AC1,IMPAC1
	MOVEM AC2,IMPAC2
	MOVEM AC3,IMPAC3
	EXCH PID,IMPPID
	EXCH P,IMPIPD
	JRST @IMPIDSP

ISYNC:	POP P,IMPIDSP
	EXCH P,IMPIPD
ACREST:	MOVE AC1,IMPAC1
	MOVE AC2,IMPAC2
	MOVE AC3,IMPAC3
	EXCH PID,IMPPID
	JEN @IMPCHL

; OUTPUT INTERRUPTS COME HERE

↑IMPOUT:
	CONSO IMP,7
	JRST IMPCTS
	MOVEM AC1,IMPAC1
	MOVEM AC2,IMPAC2
	MOVEM AC3,IMPAC3
	HRLOI AC3,377777
	MOVEM AC3,IMPOCT
	EXCH PID,IMPPID
	EXCH P,IMPOPD
	JRST @IMPODSP

OSYNC:	POP P,IMPODSP
	MOVEI AC3,MAXCNT
	SKIPL IMPOACT
	HRLOI AC3,377777
	MOVEM AC3,IMPOCT
	EXCH P,IMPOPD
	JRST ACREST

; GET HERE ON ERROR BIT

↑IMPERB:
	MOVEM AC1,IMPAC1
	MOVEI AC1,IDPIEN!IMPCHN
	SKIPN IMPIFM
	ORI AC1,I32
	CONO IMP,(AC1)		; CLEAR ERROR BIT
	MOVE AC1,IMPAC1
	AOS IMPECT		; NOTE ANOTHER ERROR BIT DETECTED
	JEN @IMPCHL
BEND IMPSER
