COMMENT ⊗   VALID 00038 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00005 00002	BEGIN LINED
C00007 00003	GLOBAL LINE,KBDCHN,CHR
C00010 00004		COMMENT   KBDED IS CALLED AT UUO OR INTERRUPT LEVELS FROM RECINT, WITH CHR CONTAINING
C00014 00005	KBDBEG:
C00020 00006	LECCN:	PUSH P,I		 SAVE THE DPY PROGRAM HEADER ADDRESS
C00021 00007	LEC1:	JUMPE UCHN,LECB
C00023 00008	LE2CR:	PUSHJ P,LECT		SIMULATE A CTRL TAB (GO TO END OF LINE).
C00025 00009	LE2A:	TRNN UCHN,CBIT2		INSERT CHAR. IF CTRL 2. OR CTRL1 (OR BOTH)
C00028 00010	SUBROUTINES FOR INSERTING CHARACTERS IN THE LINE.
C00031 00011	INSTAB:	MOVEI CHR," "		A TAB. PREPARE TO (SIGH) SIMULATE IT.
C00034 00012	 THIS IS THE LINE EDITOR'S GARBAGE COLLECTOR. IT GOES THROUGH THE
C00037 00013	ROUTINES TO PERFORM EDITING FUNCTIONS.
C00040 00014	LEBS:	CAIN UCHN,CBIT2!CBIT1
C00042 00015	LECI:	TLOE I,INSBT		FLAG INSERT MODE.
C00044 00016	 THIS ROUTINE ADJUSTS THE NEXT TAB, AS GIVEN BY THE BYTE POINTER IN TAC.
C00046 00017	SEARCH:	MOVEI AC1,1		PREPARE TO SEARCH FOR INDICATED CHR.
C00048 00018	LEDESC:	CAIN CHR,10044
C00050 00019	 WE GET HERE IF THE LOSER TYPES <ESC>C OR <ESC>¬C WHICH CAUSES
C00052 00020	 ROUTINE TO PUT PAGE PRINTER IN HOLD
C00054 00021	 ROUTINE TO SET PAGE PRINTER GLITCHES/PAGE
C00055 00022	ESCAPE W,Q.
C00058 00023	ESCAPE	O,F,I,X.
C00061 00024	FNTAB:	TLO I,NOTABB		PREPARE TO FIND NEXT TAB IN LINE.
C00063 00025	MOVEIT MOVES THE PTR. FORWARD OR BACKWARD BY THE NO. OF PLACES
C00066 00026	INIT2:	MOVE TAC,ACTMOD(DDB)	GET SPECIAL BITS
C00069 00027	 THIS IS THE INITIALIZE ROUTINE. HERE WE INITIALIZE ALL THE LINE
C00072 00028	↑LACTIV:TDZA UCHN,UCHN		NO SPURIOUS CTRL BITS PLEASE.
C00077 00029	 WE GET HERE WHEN THE LINE EDITOR BUFFER IS EMPTY.
C00079 00030	ACTIV2:	TLO IOS,SYNC!DDTM	FORCE ACTIVATION
C00081 00031	ECHOCB:	TRNN IOS,NOECHB		IS USER SUPPRESSING ECHO OF CTRL. BITS ?
C00083 00032	 HERE IS WHERE WE QUEUE UP LINE EDITOR TRANSFERS
C00084 00033	 THIS IS A ROUTINE THAT GOES THROUGH THE LINE AND SETS UP EXTRA CRLFS TO BREAK
C00086 00034	 WE GET HERE IF THE LINE IS LONG AND MUST BE BROKEN UP.
C00088 00035	 HERE WE SEE IF THE TAB IS A REAL TAB OR IF IT IS JUST
C00090 00036	 WE GET HERE WHEN THE TAB SURROUNDS A BUNCH OF SPACES. FIRST WE
C00093 00037	 AT THIS POINT, WE ARE IN THE PROCESS OF BREAKING A LONG LINE
C00095 00038	MAKE11:	POP P,AC3		 RESTORE COLUMN COUNT
C00096 ENDMK
C⊗;
BEGIN LINED

COMMENT ⊗  THIS IS THE INCREDIBLE INTRA-LINE EDITOR. ITS FEATURES ARE:

	CTRL1 SPACE-- MOVE FORWARD THROUGH LINE.
	CTRL BS-- MOVE BACKWARD.
	BS -- MOVE BACKWARD, DELETING .(END OF LINE ONLY)
	CTRL I	-- ENTER INSERT MODE (MIDDLE OF LINE ONLY).
	CTRL D -- DELETE FORWARD (MIDDLE OF LINE ONLY).
	CTRL TAB -- MOVE TO END OF LINE.
	CLEAR -- DELETE ENTIRE LINE.
	CTRL S<ANY CHR.> -- MOVE POINTER RIGHT TO NEXT OCCURRENCE OF <ANY CHR.>.
	CTRL K<ANY CHR.> -- DELETE RIGHT TO NEXT OCCURRENCE OF <ANY CHR.>.

	CTRL CR  -- AT START OF LINE ONLY, RETRIEVES THE LAST LINE TYPED IN.

CHARACTERS TYPED WITH META IN THE MIDDLE OF THE LINE WILL BE INSERTED.

ANY COMMAND MAY BE PRECEDED BY A REPEAT NUMBER (TYPED WITH CTRL BUTTON).
    FOR EXAMPLE, CTRL 9 CTRL BS MOVES THE POINTER BACK 9 CHARACTERS.
ANY CTRL COMMAND LEAVES INSERT MODE.

WHAT COULD BE MORE WONDERFUL ??
⊗

GLOBAL LINE,KBDCHN,CHR

I←ITEM

CBIT1←←1	;CTRL BIT 1.
CBIT2←←2	;CTRL BIT 2.
EOLCHR←←12	;LINE FEED TERMINATES THE LINE IN THE BUFFER.

	;;STATUS BITS (LEFT HALF OF I).

SRCHBT←←400	;CTRL1 S SEEN, NEXT CHR. IS SEARCH ARGUMENT.
KILLBT←←1000	;CTRL1 K SEEN....
↑WTFLAG←←1	;WAITING FOR PRGM. TO SWALLOW LAST LINE.
EOLBT←←2	;AT END OF LINE.
INSBT←←4	;INSERT MODE (MIDDLE OF LINE).
TABB←←10	;LOCATION OF NEXT TAB IN NTABPT, SIZE IN NTABCT.
NOTABB←←20	;NO TAB BETWEEN CURRENT POS. AND END OF LINE.
XTABBT←←100	;WE ARE INSIDE A TAB IN GETEM.
REEDBT←←2000	;WE ARE RE-EDITING A LINE (AFTER A CTRL1 CR).
NOCRBT←←4000	;WE SHOULD NOT PUT ANOTHER CR INTO THIS LINE.
NOTEXT←←10000	; THIS BIT MEANS THE TEXT HAS NOT BEEN CHANGED, JUST THE CURSOR
NOTFR←←20000	; MEANS THAT NO TRANSFER AT ALL SHOULD TAKE PLACE
CRBIT←←40000	; USED TO SKIP OVER CRLF IN MIDDLE OF LINE
NOBRBT←←100000	; MEANS LINE HAS NOT BEEN BROKEN UP. LONG LINES ONLY.
ACTNOW←←200000	; MEANS WE SHOULD ACTIVATE NOW
SHLDRB←←200	;Loser wants to see every chr. we see.

;; NOW SOME DISPLAY OPCODES AND MACROS FOR GENERATING DP INSTRS.

DISJMP←←20	;DP JMP INSTR. OPCODE.
DISJMS←←4	; JMS (STORES TWO WORDS)
DISJSR←←24	; STORES ONLY RETURN ADDR.
DISRST←←14	;RESTORE.
DISSEL←←10	;SELECT.
DISNOP←←12	;ACTUALLY TSS, BUT A GOOD NOP WITH ALL BITS OFF.

DEFINE LVW(X,Y,TYPE,MODE,BRT,SIZ)	;ASSEMBLES A LONG VECTOR.
  { MVW1 (MODE,TYPE,BRT,SIZ)	;TWIDDLE PARAMS.
	BYTE (11)<X>,<Y>(3)B,S(2)MD,TT(3)3 }	;ASSEMBLE INSTR.
DEFINE MVW1 (M,T,BRT,SIZ)
 {IFIDN {M}{A}{MD←←1;}MD←←0	;MODE = 'A' FOR ABSOLUTE.
  IFIDN {T}{I}{TT←←2;}TT←←0	;TYPE = 'I' FOR INVISIBLE.
  IFIDN {BRT}{}{B←←0;}B←←BRT	;BRT = 0 IF OMITTED.
  IFIDN {SIZ}{}{S←←0;}S←←SIZ	;SAME FOR SIZ.
}

↑↑XDEL:	14B10	;X-SIZE OF A SIZE 2 CHARACTER, POSTIONED AT THE X-FIELD.
XDEL2:	14B11	;ONE HALF OF ABOVE.
	COMMENT ⊗  KBDED IS CALLED AT UUO OR INTERRUPT LEVELS FROM RECINT, WITH CHR CONTAINING
	   THE CHAR. TO BE CONSIDERED WITH ITS CTRL BITS IN PLACE.  UCHN CONTAINS
	   JUST THE CTRL BITS, RIGHT JUSTIFIED, AND DSER CONTAINS THE LOWER-CASE
	   VERSION OF THE CHARACTER IN CHR.  DDB AND LINE ARE SETUP TO THE RIGHT
	   TTY, AS IS IOS.  PROG, IOS, AND UUO ARE PRESERVED BY KBDED.
⊗

↑KBDED:
IFN FTOIKB, <	CAIN CHR,10000		;<CTRL 2> LINE FEED IS FOR ↑O.
		; HANGOVER FOR III KEYBOARDS
		JRST CONTOB		;CONTOB IS IN TTEDIT. >
	MOVE DAT,LINE		;GET DPY NO. AND LINTAB BITS INTO DAT.
	MOVE I,LETAB-DPYL0(DAT)	;LOAD I WITH PRT. TO CONTROL BLOCK AND BITS
	TLZ I,NOTEXT!NOTFR!CRBIT
	SETOM LEINV(I)		; SET BUFFER INVALID
	SETOM LEACT(I)		; MAKE SURE WE STICK AROUND FOR ANOTHER MINUTE
	TLNE I,SHLDRB		;Loser looking over our shoulder ?
	PUSHJ P,LSRSEE		;Hold up chr. for him to see. Hope he likes it.
	PUSHJ P,KBDBEG		; DO LINE EDITOR BIT
	SETZM LEINV(I)
	TLZE I,NOTFR		; WAS THIS A SILENT COMMAND?
	JRST KBDX1		; YES, JUST LEAVE QUIETLY
	TLNE I,NOTEXT		; HAS THE TEXT BEEN CHANGED?
	PUSHJ P,QLECUR		; NO, JUST UPDATE THE CURSOR
	TLZE I,NOTEXT
KBDX1:	SKIPE LEWAKE(I)		; DID WE CAUSE A TRANSFER TO ABORT?
	PUSHJ P,QLETXT		; YES, UPDATE BOTH
	SETZM LEWAKE(I)		; CLEAR ABORT FLAG
	HRRZ DAT,PRGNUM(I)	; PICK UP DPY NUMBER
	HLLM I,LETAB(DAT)
	TLNE I,WTFLAG		;ARE WE CURRENTLY ACTIVATING SOMETHING?
	POPJ P,			;YES, SNEAK WILL GET WOKEN UP LATER!
	TLNE IOS,SNKWAT		; IN SNEAK WAIT?
	SKIPG CCPOS(I)		; ANYTHING FOR HIM TO SEE?
	POPJ P,
KBDX2:	MOVE IOS,[XWD TTYIOW!SNKWAT,IOACT]	;YES, CLEAR FLAGS
	ANDCAB IOS,DEVIOS(DDB)
	JRST STTIOD		;BRING HIM OUT OF WAIT

LSRSEE:	PUSH P,DAT
	MOVEI DAT,TTIBUF(DDB)
	PUSHJ P,PUTCHI		;Put chr. in loser's input buffer.
	JFCL			;Buffer full. Loser loses.
	MOVE AC1,TIFCTR(DDB)
	CAIG AC1,TTICHR/4	;Is his buffer getting full ?
	TLNN IOS,TTYIOW		;Is he waiting for input ?
	JRST LSRSEX		;No.
	PUSHJ P,SYNCHA		;Prepare to activate loser.
	PUSHJ P,KBDX2		;Wake him up.
LSRSEX:	POP P,DAT
	POPJ P,
KBDBEG:
;DONT	MOVE AC2,TIME		; PICK UP TIME OF DAY
;SAVE	SKIPN DPKTIM(I)		; HAS THE TIME BEEN STORED YET?
;TIME	MOVEM AC2,DPKTIM(I)	; NO, DO SO
	SKIPE III(I)
	JRST KBDBG1
	MOVE AC3,CURPP(I)
	MOVE AC2,DPHPOS(AC3)
	SKIPGE LEPOS(I)
	TDZA AC2,AC2
	ADD AC2,LNLNGT(AC3)
	MOVEM AC2,PPHPOS(I)
KBDBG1:	TRNE CHR,10000
	JRST LEDESC		;<ESC>SOMETHING
	TRNN CHR,177		;IS THIS MAYBE A CALL?
	JRST  LECCN		;A CALL WILL BE A NULL NOW.
	JUMPL I,NOINIT		;IS THIS THE FIRST CHAR OF A LINE?
	TLNE I,WTFLAG		;YES, IS LAST LINE IN USER BUFFER YET?
	JRST TPOPJ		;NO, JUST IGNORE HIM
	PUSHJ P,INIT2		;CLEANSE THE WORLD
NOINIT:	ANDI CHR,177		;REMOVE CTRL BITS FROM CHR.
	CAIL CHR,"a"		;IS IT A LOWER CASE LETTER ?
	CAILE CHR,"z"
	JRST LE20		;NO.
;	TLNN IOS,TPMON		;YES. IF MONITOR MODE OR
	TLNN DAT,FCS		; NOT FULL CHAR. SET MODE,
	SUBI CHR,40		; CONVERT TO UPPER CASE.
LE20:	TLZE I,SRCHBT		;WAS LAST CHR. AN S OR K COMMAND ?
	JRST SEARCH		;YES.
	CAIE CHR,177		;IF IT'S A BACKSPACE, PRETEND IT HAS CTRL 1.
	CAIN UCHN,CBIT1		;DO WE HAVE CTRL 1 ONLY ?
	TLNE IOS,DDTM		;YES. IS EDITOR DISABLED ?
	JRST LE2		;NOT A COMMAND. GO PUT IT IN BUFFER.
	CAIG CHR,"9"		;IS IT A DIGIT ?
	CAIGE CHR,"0"
	JRST LEC1		;NO.
	MOVE AC1,NUMARG(I)	;YES. CTRL NUMBERS ARE PART OF REPEAT ARGUMENT.
	IMULI AC1,=10		;DO DECIMAL CONVERSION.
	ADDI AC1,-"0"(CHR)
	ANDI AC1,777		;DON'T LET IT GET TOO BIG.
	MOVEM AC1,NUMARG(I)
	POPJ P,
LECCN:	PUSH P,I		; SAVE THE DPY PROGRAM HEADER ADDRESS
	PUSHJ P,RECINB
	POP P,I
	HRRZ DAT,LINE		; RECINB CLOBBERS THIS
	SETZ AC1,
	EXCH AC1,DPHOLD(I)
	JUMPE AC1,LFLUSH
	HRRZ AC1,PRGNUM(I)
	ADD AC1,[XWD UNHOLD,DPYL0]
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
LFLUSH:	PUSH P,DDB		;SAVE AN AC
	MOVEI DDB,LEB(I)	;TURN OFF EDITOR BUFFER BY
	HRLI DDB,DISJMP		;PUTTING A RETURN JUMP
	MOVSM DDB,LEPPV(I)	;ON TOP OF THE POSITION VECTOR.
;	PUSHJ P,INIT1		;COMMENTED OUT BY FW SO CTRL-CR WILL WORK
	POP P,DDB
	HRRZS I,LETAB-DPYL0(DAT);RESET STATUS
	POPJ P,
LEC1:	JUMPE UCHN,LECB
	MOVE AC1,XDEL		;GET X DIMENSION OF A CHR.
	TLZE I,INSBT		;LEAVE INSERT MODE, IF WE ARE IN IT.
	PUSHJ P,INSP1		;READJUST CURSOR POSITION.
LECB:	SKIPN AC1,NUMARG(I)	;DID GUY TYPE RPT ARG ?
	AOS AC1,NUMARG(I)	;NO. USE 1.
	CAIN CHR,177
	JRST LEBS		;BACKSPACE.
	CAIN CHR," "
	JRST LECSP		;CTRL1 SPACE.
	CAIN CHR,14
	JRST LECFF
	TLNE I,EOLBT		; AT END OF LINE?
	JRST LE2		; YES, USER GETS TO SEE CTRL LETTERS.
	TRZ DSER,40		;CHANGE LOWER CASE LETTERS TO UPPER.
	CAIN DSER,"D"		;COMPARE UNSHIFTED CHAR.
	JRST LECD
	CAIN DSER,"I"
	JRST LECI
	CAIN CHR,11		;A TAB ?
	JRST LECT
	CAIN DSER,"K"
	TLOA I,KILLBT
	CAIN DSER,"S"
	TLOA I,SRCHBT
	JRST LE2		;RANDOM CTRL LETTER.
	JRST LECX1		;STORE NEW BITS IN I AND EXIT.

LECFF:	MOVEI AC1,=200		;SIMULATE 200 CTRL BS'S
	MOVEM AC1,NUMARG(I)
	JRST LEBS
LE2CR:	PUSHJ P,LECT		;SIMULATE A CTRL TAB (GO TO END OF LINE).
	MOVEI CHR,15		; RESTORE THE CR THAT MAKECR CLOBBERS

LE2:		;;HERE IF CHR HAS NO CTRL1 BIT.
	TLNN I,EOLBT		;AT END OF LINE ?
	JRST LE2A		;NO.
	TLNE I,NOCRBT		;ARE WE RE-EDITING THIS LINE ?
	CAIE CHR,15		;YES. DON'T PUT ANOTHER CR AT ITS END.
	SKIPA
	JRST ACTIV1		;JUST ACTIVATE GUY WHEN HE TYPES CR AT A RE-EDITED LINE.
	PUSHJ P,PUTCHR		;PLACE CHAR. IN BUFFER.
	MOVEM TAC,FCPOS(I)	;UPDATE FINAL CHAR. POS. CTR.
	JUMPG UCHN,ACTIV1	;ACTIVATE ON ANY CTRL BITS AT EOL.

LE2X:	MOVE TAC,SPCTAB(CHR)	;SPECIAL BITS.
	TLNN TAC,BREAKB!FCSBRK	;A BREAK CHAR. ?
	TLNE IOS,DDTM		;IS EVERY CHAR. AN ACTIVATOR ?
	JRST ACTIV1		;YES.
	TLZE I,ACTNOW		; ARE WE OUT OF BUFFER SPACE?
	JRST ACTIV1		; YES, ACTIVATE NOW
	TLNE DAT,SPCBRK		;ARE WE IN SPECIAL ACTIVATION MODE?
	TLNE IOS,TPMON
	JRST LE2XA		;NO
	PUSHJ P,SPCACT		;TEST FOR BREAK.
	CAIA
LE2XA:	TRNE UCHN,CBIT1		;YES. ANY CTRL BITS ?
	JRST ACTIV1		;YES.
	JRST LECX
LE2A:	TRNN UCHN,CBIT2		;INSERT CHAR. IF CTRL 2. OR CTRL1 (OR BOTH)
	TLNE I,INSBT		;ARE WE IN INSERT MODE ?
	JRST LEINS		;YES.
	CAIN CHR,15
	JRST LE2CR		;CR'S GO AT END OF LINE.
	TRNE UCHN,CBIT1		;NOW TEST CTRL BIT 1
	JRST LEINS		;INSERT
LEOV:	PUSH P,CHR		;WE'RE OVER-STRIKING. SAVE CHAR.
	MOVEI AC1,1		;FAKE A RPT. ARG. OF 1.
	MOVE TAC,LEPNT1(I)	;IF WE ARE ABOUT TO OVERSTRIKE
LEOVS:	ILDB AC2,TAC		;A TAB, AND IF THE TAB IS MORE
	JUMPE AC2,.-1
	CAIE CHR,11		;ALWAYS OVERTYPE IF NEW CHAR IS TAB
	CAIE AC2,11		; IS THIS A TAB?
	JRST LEOVD		; NO, JUST GO AHEAD AND OVERSTRIKE.
	ILDB AC3,TAC		;WE WILL INSERT INSTEAD.
	JUMPE AC3,.-1		; NO NULLS, PLEASE.
	CAIE AC3," "		; IS THIS REALLY A TAB OR A LONG LINE CRLF?
	JRST LEOVSC		; IS LONG LINE CRLF, READ PAST IT
	ILDB AC3,TAC		; PICK UP CHARACTER PAST SPACE
	JUMPE AC3,.-1
	CAIN AC3,11		;YES. MORE THAN ONE SPACE ?
LEOVD:	PUSHJ P,LECD		;DELETE NEXT CHR. IN LINE.
	POP P,CHR		;NOW INSERT NEW ONE.
LEINS:	TLO I,NOBRBT		; FORCE REPOSITIONING OF THE LONG LINE CRLF
	CAIE UCHN,CBIT2		;IF INSERT VIA META,
	JRST LEINS1
	MOVEI UCHN,		; DON'T LET IT ACTIVATE IN SPECIAL ACT MODE
	PUSHJ P,SPCACT		; UNLESS IT WOULD'VE WITHOUT META
	MOVEI UCHN,CBIT2
LEINS1:	PUSHJ P,PUTCHR		;PLACE NEW CHR. IN LINE.
	AOS FCPOS(I)		;INC. TOTAL CHR. COUNT.
	MOVNI AC3,1(AC3)	;- NO. OF COLUMNS INSERTED.
	MOVE TAC1,LEPNT1(I)	;GET CURRENT POINTER.
	PUSHJ P,ADJTB		;GO FIDDLE NEXT TAB IN LINE.
	JFCL
	JRST LE2X

LEOVSC:	ILDB AC3,TAC		; PICK UP NEXT CHARACTER
	CAIE AC3,11		; IS IT THE FINAL TAB YET?
	JRST LEOVSC		; NO, LOOK SOME MORE
	JRST LEOVS		; YES, NOW LOOK AGAIN.
;;SUBROUTINES FOR INSERTING CHARACTERS IN THE LINE.

PUTLF:	MOVEI CHR,12		;INVENT A LINE FEED.
	AOS FCPOS(I)
PUTCHR:	SETZB AC3,NUMARG(I)	;CLEAR REPEAT ARG.
	PUSHJ P,INSCHR		;PLACE CHAR. INTO LINE.
	MOVE AC2,XDEL		;PREPARE TO MOVE CURSOR.
	CAIN CHR,11		;DID WE INSERT A TAB ?
	PUSHJ P,INSTAB		;YES.
	ADDM AC2,LEPPV(I)	;MOVE CURSOR OVER ONE PLACE.
	AOS DSER,LEHPOS(I)
	CAILE DSER,=72		;ARE WE AT RIGHT SIDE OF SCREEN ?
	PUSHJ P,SHIFTL		;YES. SHIFT THE LINE LEFT SOME.
	AOS TAC,CCPOS(I)	;CURRENT POSITION IN CHARS.
	CAIN CHR,15		;IS IT A CR ?
	JRST PUTLF		;YES.
	SKIPE III(I)		; IS THIS A DD DISPLAY?
	POPJ P,			; NO, LEAVE NOW
	PUSH P,AC3		; SAVE NUMBER OF CHARACTERS INSERTED
	MOVE AC3,CURPP(I)
	MOVE AC1,PPHPOS(I)	;GET INITIAL X POSITION
	ADD AC1,LEHPOS(I)	; ADD IN LINE EDITOR'S HORIZONTAL POSITION
	CAIE CHR,11		; WAS THE CHARACTER A TAB?
	JRST PUTCH1		; NO, BREAK ONLY IF EVENLY AT END OF LINE
	ADDI AC1,4		; CENTER TAB ON END OF SCREEN
	IDIV AC1,LNLNGT(AC3)	; SEE IF SE ARE NEAR THE END OF THE LINE
	CAIG AC2,10		; WITHIN + OR - 4 CHARACTERS?
PUTCH2:	TLO I,NOBRBT		; YES, DO LINE BREAKING CALCULATION THIS TIME
PUTCH3:	POP P,AC3		; RESTORE NUMBER OF CHARACTERS INSERTED
	POPJ P,

PUTCH1:	SUBI AC1,1
	IDIV AC1,LNLNGT(AC3)	; SEE IF WE ARE EXACTLY AT THE END OF THE LINE
	JUMPE AC2,PUTCH2	; YES, BREAK OUR LINE THIS TIME
	JRST PUTCH3		; RESTORE ACCUMULATOR AND LEAVE
INSTAB:	MOVEI CHR," "		;A TAB. PREPARE TO (SIGH) SIMULATE IT.
	MOVE AC1,LEHPOS(I)	;GET LINE EDITOR HPOS
	SKIPN III(I)
	ADD AC1,PPHPOS(I)	;MAKE IT ABSOLUTE ON DD
	ANDCAI AC1,7		;HOW MANY SPACES TO INSERT (LESS 1).
	ADDM AC1,LEHPOS(I)
	SKIPA AC3,AC1		;REMEMBER THE MAGIC NUMBER.
INST1:	ADDM AC2,LEPPV(I)	;MOVE CURSOR OVER ONE PLACE.
	PUSHJ P,INSCHR		;INSERT A SPACE IN THE LINE.
	SOJGE AC1,INST1		;BACK FOR MORE IF APPROPRIATE .
	MOVEI CHR,11		;NOW FINISH OFF WITH ANOTHER TAB.
INSCHR:	ILDB TAC,LEPNT1(I)	;LOOK AT NEXT CHR.
	JUMPE TAC,INSCH1	;IF NULL, PUT NEW CHR. ON TOP OF IT.
	MOVE TAC,LEPNT1(I)	;GET PTR.
	PUSHJ P,LEINSW		;INSERT A WORD OF NULLS.
INSCH1:	DPB CHR,LEPNT1(I)	;PUT NEW CHR. IN LINE.
	POPJ P,

LEINSW:	AOS DSER,LELWD(I)	;UPDATE PTR. TO RETURN JMP.
	CAMLE DSER,MAXPT(I)	;MORE ROOM IN BUFFER ?
	PUSHJ P,GCOLL		; BUFFER NEARLY FULL, COMPRESS OUT ALL THE NULLS
INSW1:	MOVE TAC1,(DSER)	;GET WORD FROM BUFFER AND
	MOVEM TAC1,1(DSER)	;MOVE IT UP ONE.
	CAILE DSER,(TAC)	;ARE WE DOWN TO WHERE WE WILL INSERT THE NULLS ?
	SOJA DSER,INSW1		;NO.
	MOVEI DSER,0		;PREPEARE TO INSERT NULLS.
	MOVE TAC1,TAC
	IDPB DSER,TAC1		;NULL NEXT CHAR. AFTER CURRENT ONE..
	IDPB DSER,TAC1		;..AND ALSO NEXT 3 AFTER THAT.
	IDPB DSER,TAC1
	IDPB DSER,TAC1
	TLZ I,TABB		;WE NO LONGER KNOW WHERE NEXT TAB IS.
	POPJ P,
; THIS IS THE LINE EDITOR'S GARBAGE COLLECTOR. IT GOES THROUGH THE
; BUFFER AND COMPRESSES OUT ALL THE NULL CHARACTERS. IT MUST RESET THE
; POINTER TO THE LAST WORD IN THE TABLE, LELWD, MUST RESET THE BYTE POINTERS
; IN LEPNT1 AND IN TAC.

GCOLL:	PUSH P,AC1		; FIRST, SAVE A FEW ACCUMULATORS
	PUSH P,AC2
	PUSH P,AC3
	PUSH P,UUO
	MOVSI AC1,440700	; NOW MAKE UP TWO BYTE POINTERS TO THE BUFFER
	MOVSI AC2,440700
	HRRI AC1,LEBUF(I)
	HRRI AC2,LEBUF(I)
	SETZ AC3,		; THIS WILL BE THE COUNT OF THE NULLS WE SQUEEZED OUT
GCOLL1:	MOVE UUO,AC1		; NOW, TEST FOR END OF BUFFER
	IBP UUO			; SEE WHAT ADDRESS WE WOULD HAVE ENDED UP ON
	HRRZS UUO		; CLEAN IT UP
	CAML UUO,LELWD(I)	; COMPARE TO END OF BUFFER
	JRST GCOLL4
	ILDB UUO,AC1		; PICK UP FIRST CHARACTER IN LINE
	JUMPN UUO,GCOLL2	; IF NOT A NULL, JUST STUFF IT IN THE BUFFER
	ADDI AC3,1		; ANOTHER NULL, COUNT IT
GCOLL3:	PUSHJ P,PCHK		; UPDATE BYTE POINTERS IF NECESSARY
	JRST GCOLL1		; GO BACK FOR MORE

PCHK:	CAMN AC1,LEPNT1(I)	; ARE WE TO THE MAIN POINTER YET?
	MOVEM AC2,LEPNT1(I)	; YES, UPDATE IT
	CAMN AC1,TAC		; HAVE WE GOTTEN TO THE POINTER IN TAC YET?
	MOVEM AC2,TAC		; YES, UPDATE IT TOO
	POPJ P,

GCOLL2:	IDPB UUO,AC2		; PUT THE CHARACTER DOWN IN ITS NEW POSITION
	JRST GCOLL3		; GO BACK FOR MORE

GCOLL4:	PUSHJ P,PCHK		; UPDATE FINAL POINTER
	CAIGE AC3,5		; DID WE COLLECT A FULL WORD OF NULLS?
	TLO I,ACTNOW		; NO, ACTIVATE JOB NOW
	HRRZI AC2,1(AC2)	; POINT FINAL POINTER TO LAST WORD IN BUFFER
	MOVE UUO,@LELWD(I)	; PICK UP RETURN JUMP
	MOVEM UUO,(AC2)		; PUT IT DOWN IN ITS NEW PLACE
	MOVEM AC2,LELWD(I)	; AND THIS IS THE NEW END OF BUFFER POINTER
	POP P,UUO		; RESTORE OUR ACCUMULATORS
	POP P,AC3
	POP P,AC2
	POP P,AC1
	POPJ P,
;;ROUTINES TO PERFORM EDITING FUNCTIONS.

LECT:	MOVEI AC1,=200		;A CTRL TAB. SIMULATE 200 CTRL SPACES.
LECSP:	JSP TAC,CKNFOR		;CTRL SPACE. PREPARE TO MOVE CURSOR FORWARD.
	PUSHJ P,MOVEIT		;MOVE IT.
	MVFOR			;MOVE FORWARD, PLEASE.
	TLO I,NOTEXT		; NOTE THAT WE HAVE ONLY CHANGED THE CURSOR POSITION, NOT THE TEXT
MVX1:	MOVEM TAC1,LEPNT1(I)	;UPDATE THE BYTE POINTER.
	MOVE DSER,AC2
MVX2:	IMUL AC2,XDEL2		;CALC. AMOUNT TO MOVE CURSOR.
	LSH AC2,1		;THIS IS TO HANDLE OVERFLOW.
SHIFT2:	ADDM AC2,LEPPV(I)	;UPDATE THE POSITION VECTOR.
	ADDB DSER,LEHPOS(I)	;UPDATE HORIZONTAL POS. CNT.
	CAIG DSER,=72		;PAST RIGHT HAND MARGIN ?
	JUMPGE DSER,.+2		;OR MAYBE PAST LEFT ?
	PUSHJ P,SHIFT
LECX:	TLZ I,SRCHBT!KILLBT
	SETZM NUMARG(I)
LECX1:	MOVE AC3,PPHPOS(I)
	EXCH AC3,LSTHP(I)	; SEE THAT AS OUR NEW HORIZONTAL STARTING POSITION
	CAMN AC3,LSTHP(I)	; IS IT THE SAME AS LAST TIME
	TLZE I,NOBRBT		; OR HAS THIS LINE BEEN UNTOUCHED
	PUSHJ P,MAKECR		; VIRGIN LINE OR DIFFERENT HORIZONTAL POSITION
	TLZE I,ACTNOW		; DO WE HAVE TO ACTIVATE NOW?
	JRST ACTIV1		; YES, DO SO
	HLLM I,LETAB-DPYL0(DAT)	;UPDATE THE STATUS BITS.
	POPJ P,

CKNFOR:	TLOE I,EOLBT		;AT END OF LINE ALREADY ?
	JRST LECX		;YES. CAN'T MOVE FORWARD.
	ADD AC1,CCPOS(I)	;FIND POS. AFTER MOVE.
	CAMGE AC1,FCPOS(I)	;WILL MOVE TAKE US TO END OF LINE ?
	TLZA I,EOLBT		;NO. RESET FLAG SAYING WE ARE THERE.
	MOVE AC1,FCPOS(I)	;YES. DON'T LET IT TAKE US PAST END.
	EXCH AC1,CCPOS(I)	;PUT BACK NEW POSITION.
	SUB AC1,CCPOS(I)	;GET -NO. OF PLACES TO MOVE.
	JRST (TAC)		;RETURN.
LEBS:	CAIN UCHN,CBIT2!CBIT1
	JRST LE2		;LET USER SEE CTRL-META BS
	SKIPN CCPOS(I)		;BACKSPACE OR CTRL BACKSPACE.
	JRST LECX		;AT START OF LINE.
	TRZE UCHN,CBIT2
	JRST .+3		;META-BS ALWAYS DELETES
	TLNN I,EOLBT!INSBT	;ARE WE AT END OF LINE OR IN INSERT MODE ?
	HRRI UCHN,10		;NO. FORCE NON-DELETING BS.
	MOVN AC1,NUMARG(I)	;- RPT. ARG.
	ADDM AC1,CCPOS(I)	;POSITION AFTER MOVE.
	SKIPL AC2,CCPOS(I)	;WILL MOVE GO PAST START OF LINE 
	JRST BSP1		;NO.
	SUB AC1,AC2		;YES. RE-ADJUST CNT. SO IT WON'T.
	SETZM CCPOS(I)		;MARK AT BEGINNING OF LINE.
BSP1:	JUMPG UCHN,BSP3		;CTRL BITS ?
BSP2:	ADDM AC1,FCPOS(I)	;NO. WE WILL ACTUALLY DELETE CHRS.
	TLZ I,NOCRBT		;THIS IS FOR BENEFIT OF INIT4.
	TDZA CHR,CHR		;SET CHR TO 0 SO MOVEIT WILL DELETE.
BSP3:	TLZ I,EOLBT		;CTRL BACKSPACE. NO LONGER ARE WE AT END OF LINE.
	PUSHJ P,MOVEIT
	MVBAK			;MOVE BACKWARD RIGHT AMOUNT.
	MOVNS DSER,AC2		;- NO. OF COLUMNS MOVED.
	TLO I,NOTEXT		; MARK CURSOR CHANGE ONLY
	JUMPG UCHN,MVX1		;IF NON-DELETING BACKSPACE, JUST UPDATE CURSOR AND LEAVE.
	TLZ I,NOTEXT		; AHA, TEXT IS CHANGED TOO!
	MOVEM TAC1,LEPNT1(I)
	PUSHJ P,ADJTB
	SKIPA AC2,DSER
	MOVE AC2,DSER
	JRST MVX2
LECI:	TLOE I,INSBT		;FLAG INSERT MODE.
	JRST LECX		;ALREADY IN THAT MODE !
	TLO I,NOTFR		; THIS IS A SILENT ONE
	PUSHJ P,LECX		;UPDATE STATUS WORD.
	MOVN AC1,XDEL
INSP1:	ASH AC1,-1		;FOR INSERT MODE, WE MOVE CURSOR BY
	ADDM AC1,LEPPV(I)	; 1/2 A CHAR. WIDTH.
	LDB AC2,[POINT 11,LEPPV(I),21]
				;NOW THE Y POS.
	ASH AC1,-=26		;(MOVE IT BY 1/4 CHAR. WIDTH.)
	SUB AC2,AC1		;(MOVE IT IN OTHER DIRECTION,TOO.)
	DPB AC2,[POINT 11,LEPPV(I),21]
	POPJ P,

LECD:	JSP TAC,CKNFOR		;CTRL D. PREPARE TO MOVE FORWARD.
	ADDM AC1,FCPOS(I)	;DECREMENT NO. OF CHRS. IN LINE.
	ADDM AC1,CCPOS(I)	;DON'T INCREMENT THE CURRENT POSITION.
	MOVEI CHR,0		;SET TO DELETE...
	PUSHJ P,MOVEIT		;MOVE FORWARD, DELETING.
	MVFOR
	JRST ADJNTB		; ADJUST NEXT TAB
; THIS ROUTINE ADJUSTS THE NEXT TAB, AS GIVEN BY THE BYTE POINTER IN TAC.
; THE COUNT OF THE NUMBER OF COLUMNS THE LINE HAS BEEN MOVED BY IS IN AC3.

ADJNTB:	PUSHJ P,ADJTB		; ADJUST OUR TABS
	JRST LECX
	JRST LECX

ADJTB:	TLNN I,TABB+NOTABB	;DO WE KNOW ABOUT NEXT TAB ?
	PUSHJ P,FNTAB		;NO. FIND OUT.
	TLNN I,TABB		;IS THERE ONE ?
	POPJ P,			;NO.
	ANDI AC3,7		;COUNT MOD 8 OF CHRS. DELETED.
	JUMPE AC3,CPOPJ		;NO CHANGE IF MULTIPLE OF 8.
	MOVE AC2,NTABCT(I)	;GET SIZE OF NEXT TAB.
	ADD AC2,AC3		;NEW SIZE OF NEXT TAB.
	MOVE TAC,NTABPT(I)	;PTR. TO LAST SPACE IN NEXT TAB.
	CAIG AC2,10		;IS NEW SIZE TOO BIG ?
	JRST LECD5		;NO. TAB NEEDS TO GROW.
	SUBI AC2,10
	EXCH AC2,NTABCT(I)	;YES. TAB MUST SHRINK.
	SUB AC2,NTABCT(I)	;FIND OUT HOW MUCH TO SHRINK IT.
	MOVEI AC1,0
LECD4A:	DPB AC1,TAC		;NULL ONE OF THE SPACES IN THIS TAB.
	ADD TAC,[XWD 70000,0]	;DECREMENT POINTER.
	JUMPG TAC,.+2
	SUB TAC,[XWD 430000,1]
	SOJG AC2,LECD4A
LECD6:	MOVEM TAC,NTABPT(I)	;STORE UPDATED PTR.
	JRST CPOPJ1

LECD5:	MOVEI AC1," "		;PREPARE TO MAKE TAB GROW.
	MOVEM AC2,NTABCT(I)	;STORE NEW SIZE.
LECD5A:	ILDB TAC1,TAC
	JUMPE TAC1,.+2		;IS THERE A NULL NEXT ?
	PUSHJ P,LEINSW		;NO. PUT SOME IN.
	DPB AC1,TAC		;ADD A SPACE.
	SOJG AC3,LECD5A
	JRST LECD6
SEARCH:	MOVEI AC1,1		;PREPARE TO SEARCH FOR INDICATED CHR.
	MOVEM CHR,TAC		;SAVE CHR. TO BE SEARCHED FOR.
	MOVE AC3,LEPNT1(I)	;MAKE COPY OF CURRENT POINTER.
	MOVEI TAC1,AC3		;PARAMETER FOR GETEM.
	PUSHJ P,GETEM		;SKIP OVER CURRENT CHR. BEFORE STARTING SEARCH.
SRCHL:	PUSHJ P,GETEM		;GET NEXT CHR. FROM LINE.
	CAIN CHR,EOLCHR		;ARE WE AT END OF LINE ?
	JRST LECX		;YES. DO NOTHING, CHR. NOT FOUND.
	CAMN CHR,TAC		;HAVE WE FOUND IT ?
	SOSLE NUMARG(I)		;YES. IS THE REPEAT COUNT EXHAUSTED ?
	AOJA AC1,SRCHL		;NO. COUNT PLACES MOVED AND LOOK SOME MORE.
	TLZN I,KILLBT		;YES.  ARE WE KILLING OR JUST MOVEING UP TO IT ?
	JRST LECSP		;MOVEING.
	JRST LECD		;KILLING.

GETEM:	ILDB CHR,(TAC1)		;GET A NON-NULL CHAR. FROM LINE.
	JUMPE CHR,.-1
	CAIN CHR,11		;IS IT A TAB ?
	TLCN I,XTABBT		;YUP. ALREADY INSIDE A TAB ?
	TLNN I,XTABBT		;INSIDE A TAB ?
	JRST GETEM1		; NO, EXIT
	CAIE CHR,11		; ARE WE INSIDE A CRLF?
	CAIN CHR," "
	JRST GETEM2		; NO. PASS OVER THE TAB.
	TLO I,CRBIT		; YES, MARK THIS AS A LONG LINE CRLF
	JRST GETEM		; LOOP BACK FOR NEXT CHARACTER

GETEM1:	TLZE I,CRBIT		; ARE WE COMING OUT OF A CRLF?
	JRST GETEM		; YES, GET NEXT CHARACTER PAST IT
	POPJ P,			; NO

GETEM2:	TLZ I,CRBIT
	JRST GETEM
LEDESC:	CAIN CHR,10044
	JRST CLEAR
	CAIN CHR,10041
	JRST ESCHX
	TLO I,NOTFR		; THIS IS A SILENT TRANSFER
	TRZ DSER,40		; CHANGE LOWER TO UPPER CASE
	CAIN DSER,"F"		;AN F ?
	JRST ESCF		;YES. GO SEE ABOUT FCS MODE.
	CAIN DSER,"O"
	JRST ESCO
	CAIN DSER,"I"
	JRST ESCI
	CAIN DSER,"W"
	JRST ESCW
	CAIN DSER,"Q"
	JRST ESCQ		;GET WHO LINE FOR NEXT JOB WITH SAME PROG NAME
	CAIN DSER,"X"
	JRST ESCX		;SET OR CLEAR UPDATE BIT IN XTIME FOR THIS JOB
	CAIN DSER,"G"
	JRST ESCG
	CAIN DSER,"L"
	JRST ESCL
	CAIN DSER,"Y"
	JRST ESCY
	CAIN DSER,"N"
	JRST ESCN
	CAIN DSER,"E"
	JRST ESCE
	CAIN DSER,"J"
	JRST ESCJ
	CAIN DSER,"C"		; CLEAR SCREEN?
	JRST ESCC		; YES, GO QUEUE UP AN ERASE REQUEST
	CAIN DSER,"P"		; REFRESH HIS PAGE PRINTER?
	JRST ESCP		; YES, GO QUEUE UP A PAGE PRINTER REQUEST
	SKIPE III(I)		; THE REST OF THESE COMMANDS ONLY APPLY TO DATA DISK
	JRST LECX1		; IF III, JUST IGNORE
	CAIN DSER,"H"
	JRST ESCH		;HIDE (OR UNHIDE) HIS CHANNEL
	CAIE DSER,"R"		; REFRESH HIS LINE EDITOR?
	JRST LECX1		; NO, LEAVE
ESCR:	TLZ I,NOTEXT!NOTFR	; QUEUE UP A COMBINED TEXT AND CURSOR TRANSFER
	JRST LECX1

ESCP:	JUMPL AC1,BRKP		;<BREAK>P DOES THE WORKS
	HRLI AC2,LERFP		; USE THE MAGIC CLOCK LEVEL ROUTINE FOR REFRESHING THE PAGE
	JRST ESCC1
; WE GET HERE IF THE LOSER TYPES <ESC>C OR <ESC>¬C WHICH CAUSES
; HIS SCREEN (IF HE IS A DATA DISC TYPE) TO GET ERASED TO BLACK OR
; WHITE RESPECTIVLY.

ESCC:	SKIPE III(I)
	JRST ESCC0
	HRRZ AC2,CURPP(I)	; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	MOVSI AC3,(1B5)	; PICK UP BLACK BIT
	JUMPL AC1,.+3
	ORM AC3,DDCW(AC2)
	JRST .+2
	ANDCAM AC3,DDCW(AC2)
ESCC0:	MOVSI AC2,LEERS		; USE CLOCK LEVEL ROUTINE IN DPYSER THAT QUEUES IT UP
ESCC1:	HRRI AC2,(I)		; PUT IN THE DPY PROGRAM HEADER ADDRESS
ESCC2:	CONO PI,PIOFF
	IDPB AC2,CLKQ
	CONO PI,PION
	JRST LECX1

; <BREAK>P CLEARS THE SCREEN AND REFRESHES BOTH THE PAGE
; PRINTER AND THE LINE EDITOR.

BRKP:	HRLI AC2,RFPCS
	JRST ESCC1

CLEAR:	CAIN UCHN,CBIT1		; <CTRL>CLEAR?
	JRST ESCU		; YES, UNHOLD
	JUMPN UCHN,CPOPJ	; NO, JUST FLUSH LINE UNLESS IT'S GOT <META>
				; (FALL THROUGH INTO LECLR)

; THIS ROUTINE CLEARS THE LINE EDITOR BUFFER WITHOUT DISTURBING
; ITS STATUS. THIS MEANS THAT THE INFORMATION AS TO WHETHER
; THIS IS A RE-EDITED LINE IS PRESERVED.

LECLR:	SKIPN FCPOS(I)
	POPJ P,
	TLZ I,TABB!NOTABB!EOLBT
	PUSHJ P,INIT3
	MOVE AC1,FCPOS(I)	; JUST DELETE THAT MANY CHARACTERS
	JRST LECD
; ROUTINE TO PUT PAGE PRINTER IN HOLD

ESCHX:	SETOM DPHOLD(I)
	JRST LECX1

; ROUTINE TO SET NUMBER OF GLITCHES BEFORE HOLD

ESCJ:	DPB AC1,[POINT 9,GWORD(I),26]
	MOVEM AC1,GLHCNT(I)
	TRNN AC1,-1
	SETOM GLHCNT(I)
	JRST LECX1

; SET NUMBER OF LINES BEFORE HOLD

ESCE:	DPB AC1,[POINT 9,GWORD(I),17]
	MOVEM AC1,LHCNT(I)
	TRNN AC1,-1
	SETOM LHCNT(I)
	JRST LECX1

; ROUTINE TO UNHOLD THE PAGE PRINTER

ESCU:	SETZ AC1,
	EXCH AC1,DPHOLD(I)
	JUMPE AC1,LECX1
	HRRZ AC2,PRGNUM(I)
	ADD AC2,[XWD UNHOLD,DPYL0]
	JRST ESCC2

;SET OR CLEAR CONSOLE PRIVACY BIT

ESCH:	MOVSI AC3,400000
	HLR AC1,PRGNUM(I)
	JUMPL AC1,UNHIDE	;BREAK-H MEANS UNHIDE
	TDNE AC3,DDTAB(AC1)
	JRST LECX1
	IORM AC3,DDTAB(AC1)
	PUSHJ P,DDFLSH
	JRST LECX1

UNHIDE:	ANDCAM AC3,DDTAB(AC1)
	JRST LECX1
; ROUTINE TO SET PAGE PRINTER GLITCHES/PAGE

ESCG:	HRLI AC2,PPGSET
	JRST ESCY1

; LINES/GLITCH

ESCL:	HRLI AC2,PPLSET
	JRST ESCY1

; Y-POSITION

ESCY:	HRLI AC2,PPYSET
ESCY1:	HRRZM AC1,LEARG(I)
	JRST ESCC1

; NORMALIZE PAGE PRINTER

ESCN:	MOVE DSER,AC1
	HRREI TAC,-DDL0(LINE)
	JUMPL TAC,.+2
	PUSHJ P,VDESCN		;NORMALIZE VDS ON DD
	MOVSI AC2,LEERSN
	JUMPL DSER,ESCC1
	MOVSI AC2,PPNSET
	JRST ESCC1
;ESCAPE W,Q.

ESCW:	JUMPGE AC1,ESCW1	;TURN ON WHO LINE?
	SETZM WHOTAB(I)		;TURN OFF WHO LINE
	JRST LECX1

ESCW2:	TLZ AC1,-1		;THIS IS WHERE [ESC] # Q DOES [ESC] # W
ESCW1:	TRNN AC1,-1
	LDB AC1,PJOBN		;GET JOB NUMBER OUT OF DDB IF NO ARGUMENT.
	CAIL AC1,JOBN		;LEGAL JOB?
	JRST LECX1		;NO
				;PUT INTO WHO TIME TABLE
	MOVE AC2,JBTSTS(AC1)	;GET JOB STATUS WORD.
	TLNE AC2,JNA		;IS IT LOGGED IN?
	HRROM AC1,WHOTAB(I)	;YES, STORE JOB #.  ALSO PUT -1 IN INCR TIME SLOT.
	SETZM WHORUN(I)		;CLEAR TIME TO UPDATE RUNTIME NEXT
	JRST LECX1		;THAT'S ALL.

ESCQ:	TRNE	AC1,-1		;ANY ARGUMENT?
	JRST	ESCW2		;[ESC] # Q AND [BRK] # Q ARE SAME AS [ESC] # W
	SKIPN	TAC,WHOTAB(I)	;GET NUMBER OF JOB ON WHO LINE
	LDB	TAC,PJOBN	;NO WHO LINE.  USE USER'S JOB.
	ANDI	TAC,-1		;MAKE SURE TAC HAS ONLY THE JOB NUMBER
	JUMPE	TAC,LECX1	;IF NOT LOGGED IN AND NO WHO LINE UP, FORGET IT
	HRRZ	AC2,PRJPRG(TAC)	;GET PROGRAMMER NAME OF OLD WHO LINE JOB
	MOVEI	AC3,1		;ASSUME POSITIVE INCREMENT FOR GOING THRU TABLE
	JUMPGE	AC1,.+2		; UNLESS HE SAID [BRK] Q
	SETO	AC3,		; IN WHICH CASE WE USE NEGATIVE INCREMENT
	PUSHJ	P,ESCQ1		;LOOK FROM TAC TO END OF TABLE
	XORI	TAC,JOBN	;START OVER AT OTHER END OF TABLE
	PUSHJ	P,ESCQ1		; AND LOOK THROUGH WHOLE TABLE
	JRST	LECX1		;NO JOB FOUND WITH SAME PN, NOT EVEN ORIGINAL JOB.

ESCQ1:	ADD	TAC,AC3		;MOVE ON TO NEXT JOB
	CAIGE	TAC,JOBN	;AT END OF TABLE YET?
	JUMPG	TAC,.+2		; OR AT BEGINNING OF TABLE?
	POPJ	P,		;YES TO ONE OF THESE
	HRRZ	AC1,PRJPRG(TAC)	;GET PROGRAMMER NAME FOR THIS JOB
	CAIE	AC1,(AC2)	;IS IT THE ONE WE ARE LOOKING FOR?
	JRST	ESCQ1		;NO
	HRROM	TAC,WHOTAB(I)	;YES!  SAVE JOB NUMBER.  -1 INTO INCR TIME.
	SETZM	WHORUN(I)	; AND CLEAR TIME TO UPDATE RUNTIME NEXT
	SUB	P,[1,,1]	;DONT POPJ.  ADJUST STACK
	JRST	LECX1
;ESCAPE	O,F,I,X.

ESCO:	MOVEI IOS,IOSUPR	;ASSUME AN UN-↑O.
	ANDCAB IOS,DEVIOS(DDB)
	JUMPL AC1,LECX1
	PUSHJ P,LECX1		;GET STATUS BITS STORED AND RESET.
	PUSH P,I		; SAVE THE DPY PROGRAM HEADER
	PUSHJ P,CONTOB		; DO A ↑O.
	PUSHJ P,UTYPET		;AND MAKE SURE IT GETS OUT
	POP P,I
	POPJ P,

ESCF:	JUMPL AC1,.+2
	TLOA DAT,FCS		;TURN ON THE ↑F BIT (FULL CHR. SET).
	TLZ DAT,FCS		;WRONG. TURN IT OFF.
	HLLM DAT,LINTAB(DAT)
	JRST LECX1

; <ESC>I INTERRUPTS ON THE INTTTI BIT IN THE LEFT HALF

ESCI:	MOVSI AC1,INTTTI
	LDB AC2,PJOBN
	TDNN AC1,JBTIEN(AC2)
	JRST LECX1
	ORM AC1,JBTIRQ(AC2)
	SETOM INTREQ(PID)
	JRST LECX1

ESCX:	LDB	AC2,PJOBN	;GET JOB NUMBER OF THIS GUY
	JUMPE	AC2,LECX1	;IF YOU'RE NOT LOGGED IN, I CANT HELP YOU
	MOVSI	TAC,400000	;THIS IS THE BIT WE WILL SET OR CLEAR
	JUMPN	AC1,.+3		;WAS IT PLAIN [ESC]X?
	ANDCAM	TAC,XTIME(AC2)	;YES.  TURN OFF THE NO-UPDATE BIT IN XTIME
	JRST	LECX1		;BYE
	TRNE	AC1,-1		;WAS THERE AN ARGUMENT TO ESCAPE COMMAND?
	JRST	.+3		;YES
	ORM	TAC,XTIME(AC2)	;NO.  MUST HAVE BEEN [BRK]X.  TURN ON NO-UPDATE FLAG
	JRST	LECX1
	SETZ	AC3,
	HRRZS	DSKOPS(AC2)	;MAKE ALL DISK OPS "RECENT"
	JUMPL	AC1,ESCX1	;WAS IT [ESC] OR [BRK]?
	SKIPGE	AC3,JBTWAT(AC2)	;[ESC]1 X.  UPDATE JB2WAT
	ADD	AC3,UPTIME	;MAKE WAIT TIME HONEST
	HRLS	DSKOPS(AC2)	;ZERO INCREMENTAL COUNT OF DISK OPERATIONS
	ADD	TAC,TTIME(AC2)	;[ESC]1 X.  UPDATE XTIME AND SET NO-UPDATE BIT
ESCX1:	MOVEM	TAC,XTIME(AC2)	;[BRK]1 X MEANS CLEAR XTIME AND SET NO-UPDATE BIT
	MOVEM	AC3,JB2WAT(AC2)	;SAVE NEW VALUE OF OLD WAIT TIME
	JRST	LECX1
FNTAB:	TLO I,NOTABB		;PREPARE TO FIND NEXT TAB IN LINE.
FNT1:	ILDB TAC,TAC1		;LOOK AT NEXT CHR.
	CAIN TAC,EOLCHR		;ARE WE AT END OF LINE ?
	POPJ P,			;YUP. RETURN LEAVING 'NO TAB' BIT SET.
	CAIE TAC,11		;A TAB ?
	JRST FNT1		;NO.
	MOVE AC2,TAC1		; SEE IF THIS TAB IS REALLY A LONG LINE CRLF
	ILDB AC2,AC2		; PICK UP CHARACTER PAST TAB
	CAIN AC2," "		; IS IT A SPACE?
	JRST FNT3		; YES, MUST BE REAL TAB
FNT4:	ILDB TAC,TAC1		; NO, MUST BE LONG LINE CRLF. READ PAST IT.
	CAIE TAC,11		; IS THIS A TAB?
	JRST FNT4		; NO, READ SOME MORE
	JRST FNT1		; YES, GET NEXT CHARACTER PAST CRLF

FNT3:	MOVEI AC2,0		;COUNT NO. OF SPACES IN TAB.
	TLC I,TABB!NOTABB	;SET BITS PROPERLY.
FNT2:	ILDB TAC,TAC1
	JUMPE TAC,.-1		; SKIP NULLS
	CAIE TAC," "		;ARE WE OUT OF SPACES YET ?
	JRST FNT5
	MOVEM TAC1,NTABPT(I)	;STORE PTR. TO LAST SPACE IN TAB.
	AOJA AC2,FNT2		;NO. KEEP COUNTING.

FNT5:	CAIE TAC,11		; IS THIS REALLY THE TERMINATING TAB?
	JRST FNT2		; NO, GO BACK FOR MORE
	MOVEM AC2,NTABCT(I)	;STORE SIZE OF TAB.
	POPJ P,
;;MOVEIT MOVES THE PTR. FORWARD OR BACKWARD BY THE NO. OF PLACES
;; IN AC1, AND DELETES CHARS. PASSED OVER IF CHR=0.

MOVEIT:	MOVE TAC1,LEPNT1(I)	;GET CURRENT POINTER.
	SETZB AC2,AC3
	POP P,DSER		;GET PTR. TO ARGUMENT.
	MOVEM AC1,1(P)		;REMEMBER COUNT.
	SKIPN CHR		; ARE WE DELETING?
	TLO I,NOBRBT		; YES, REDO THE LONG-LINE CRLF WHEN DONE
	TLZ I,XTABBT		; CLEAR TAB BIT
	JRST @(DSER)		;GO TO EITHER MVFOR OR MVBAK.

MVFOR:	ILDB TAC,TAC1		;LOOK AT NEXT CHR.
	JUMPE TAC,.-1		;IGNORE NULLS.
	JUMPN CHR,MVA		;DON'T DELETE UNLESS CHR =0.
	DPB CHR,TAC1		;DELETE IT.
	JRST MVA
	
MVBAK:	LDB TAC,TAC1		;LOOK AT CURENT CHR.
	JUMPN CHR,.+2		;DELETE IT IF APPROPRIATE,
	DPB CHR,TAC1
	ADD TAC1,[XWD 070000,0]	;DECREMENT POINTER.
	JUMPG TAC1,.+2
	SUB TAC1,[XWD 430000,1]
	JUMPE TAC,MVBAK		;IF CURRENT CHR. WAS NULL,GET ANOTHER.
MVA:	CAIN TAC,11		;HAVE WE JUST ENCOUNTERED A TAB ?
	ADDI AC3,1		;YES.
	TRNN AC3,1		;ARE WE INSIDE A TAB ?
	JRST MVA1		; NO
	CAIN TAC,11		; YES, IS THIS A REAL TAB OR A LONG LINE CRLF?
	AOJA AC2,@(DSER)
	CAIN TAC," "
	JRST MVA2		; MUST BE A REAL TAB, SET THE BIT THAT SAYS SO
	SKIPE CHR		; IF WE ARE DELETING, WE MUST REPOSITION THE CRLF
	TLO I,NOBRBT		; DO SO BY PRETENDING THERE HAVEN'T BEEN ANY
	CAIE TAC,15		; BUMP COUNT ONE AT THE CR TO MAKE THE ENTIRE CRLF INVISIBLE
	JRST @(DSER)		; OTHERWISE, JUST LOOP AROUND
	TLNE I,XTABBT		; IF THIS IS A LONG LINE CRLF ONLY, THEN
	JRST @(DSER)
	SUBI AC1,1		; CORRECT COUNT
	AOJA AC2,@(DSER)

MVA1:	TLZ I,XTABBT
	AOJL AC1,@(DSER)	; COUNT DOWN RPT. CNT AND LOOP.
	JUMPE AC3,.+2		;ALL DONE. DID WE PASS ANY TABS ?
	TLZ I,TABB!NOTABB	;YES. WE NO LONGER KNOW WHERE NEXT ONE IS.
	SUB AC2,1(P)		;ADD NO. OF CHRS. PASSED TO NO. OF SPACES IN TABS PASSED.
	SUBB AC2,AC3		;SUB. 2⊗NO. OF TABS. THIS (MIRABILE DICTU!) GIVES NO. OF COLUMNS MOVED.
	JRST 1(DSER)

MVA2:	TLO I,XTABBT
	AOJA AC2,@(DSER)
INIT2:	MOVE TAC,ACTMOD(DDB)	;GET SPECIAL BITS
	TRNN TAC,SUPCCR		;SUPPRESS CTRL CR?
	CAIE CHR,1B28!15	;HAS LOSER TYPED CTRL1 CR ?
	JRST INITIT		;NO. RESET EVERYTHING FOR NEW LINE.
	SKIPN LEPNT1(I)		; HAVE WE INITIALIZED AT LEAST ONCE?
	JRST INITIT		; NO, DO SO NOW.
	PUSHJ P,QLETXT		; QUEUE UP A TRANSFER IF DD
INIT4:	HRLI I,400000!REEDBT!NOCRBT
	SETZM LCH(I)
	JUMPGE UCHN,INIT4B
	TLNE DAT,LERSEE
	TLO I,SHLDRB
				;LET LOSER EDIT PREVIOUS LINE SOME MORE.
INIT4B:	MOVEI UUO,2		;PREPARE TO REMOVE THE CR LF FROM END OF LINE.
INIT4A:	LDB TAC,LEPNT1(I)	;(WE DON'T WANT TO LET THE LOSER EDIT THEM. )
	MOVNI AC1,1		;TELL BACKSPACE ROUTINE TO DELETE ONE CHR.
	CAIE TAC,12		;IF IT IS A LF ...
	CAIN TAC,15		;... OR A CR ...
	PUSHJ P,CRKILL		;... THEN WE THROW IT OUT.
	SOJG UUO,INIT4A		;ALLOW FOR BOTH A LF AND A CR.
	DPB UUO,PLASTC
	TLZ I,NOTABB		;BS ROUTINE WILL HAVE SET THIS LOSER...
	SKIPN FCPOS(I)		;IS LINE EMPTY?
	TLO I,EOLBT		;YES, TELL SOMEONE PLEASE!!!!!
	SOJA P,INIT3		;RESET ONLY THE POINTER POSITION, AND RETURN UPLEVEL.

; THIS IS A ROUTINE FOR DELETING THE CRLF FROM THE END OF A LINE THAT
; WE GOT FROM PTLOAD OR <CTRL-1>CR.

CRKILL:	ADDM AC1,FCPOS(I)	; DECREMENT THE TOTAL NUMBER OF CHARACTERS IN THE BUFFER
	TLZ I,NOCRBT
	SETZ CHR,		; FLAG DELETING OPERATION TO MOVEIT
	PUSHJ P,MOVEIT		; BACK THE POINTER UP, DELETING THE CRLF AS IT GOES
	MVBAK
	MOVEM TAC1,LEPNT1(I)	; STORE THE UPDATED POINTER
	POPJ P,
; THIS IS THE INITIALIZE ROUTINE. HERE WE INITIALIZE ALL THE LINE
; EDITOR VARIABLES

INITIT:	MOVEI TAC,EOLCHR*2+1	;GET DPY CHAR. WORD WITH LINE TERMINATING CHR. IN IT.
	MOVEM TAC,LEBUF(I)	;PLACE IN FIRST WORD OF BUFFER.
	MOVEI TAC,LEB(I)	; PUT RETURN JUMP IN SECOND WORD
	HRLI TAC,DISJMP
	MOVSM TAC,LEBUF+1(I)
	SETZM FCPOS(I)		;NO. OF CHARS. IN LINE.
	HRLI I,EOLBT+400000
	SETZM LCH(I)
	MOVEI TAC,LEBUF(I)	;GET START OF LINE BUFFER.
	HRRZM TAC,LELWD(I)	;INIT. PTR. TO RETURN JMP.
INIT3:	SETZM LEHPOS(I)		;HORIZONTAL POSITION.
	SETZM NUMARG(I)		; CLEAR THE REPEAT ARGUEMENT
	HLLM I,LETAB-DPYL0(DAT)	; STORE THE FLAG BITS BACK INTO THE LINE EDITOR TABLE
	SETZM CCPOS(I)		;CHARS. FROM START OF LINE.
	MOVE TAC,[LVW (12,-4,I,R,2,2)]
	MOVEM TAC,LEPPV(I)	;INITIAL POS. OF CURSOR.
	HRRZS LELMARG(I)	;RESET LEFT MARGIN.
INIT1:	HRLI TAC,440700		;MAKE INITIAL BYTE PTR.
	HRRI TAC,LEBUF(I)
	MOVEM TAC,LEPNT1(I)
	POPJ P,

SHIFT:	JUMPG DSER,SHIFTL	;OVER LEFT MARGIN ?
SHIFTR:	SKIPA AC2,.+1		;SHIFT LINE RIGHT.
SHIFTL:	MOVNI AC2,30		;SHIFT LINE LEFT.
	SKIPN III(I)		; ARE WE A DD DISPLAY?
	POPJ P,			; IF SO, DON'T SHIFT LINE OVER, CAUSE IT SCREWS UP DPHPOS
	HRRES DSER,AC2
	IMUL AC2,XDEL
	ADDM AC2,LELMARG(I)	;MOVE WHOLE LINE OVER.
	JRST SHIFT2		;SEE THE HAPPY RECURSIVE EDITOR !
↑LACTIV:TDZA UCHN,UCHN		;NO SPURIOUS CTRL BITS PLEASE.
PTLLX:	PUSHJ P,STLNAC		;SETUP LINE!
	TLNN LINE,DISLIN!DDDLIN	;IF A DPY, XFER EDITOR BUFFER TO INPUT BUFFER NOW.
	POPJ P,			; IF NOT A DPY, RETURN NOW
	MOVE DAT,LINE
	SKIPGE I,LETAB-DPYL0(DAT)
	SKIPG CCPOS(I)
	POPJ P,			;NOTHING IN EDITOR BUFFER. FERGIT IT.
ACTIV1: JUMPGE I,CPOPJ		;POOLE AND HIS RECURSIVE CALLS ON ACTIV1 !
	TLC I,400000!WTFLAG	;READY FLAG OFF, WAIT FLAG ON.
	SETZ AC1,
	EXCH AC1,DPHOLD(I)
	JUMPE AC1,ACTNH		; IF NOT HOLDING, DON'T UNHOLD!
	HRRZ AC1,PRGNUM(I)
	ADD AC1,[XWD UNHOLD,DPYL0]
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
ACTNH:	AOJG UCHN,.+2		;IS PTYSER PRE-LOADING US WITH A LINE TO EDIT ?	
	PUSHJ P,INIT4		;YOU BETCHUM, R.R.  DON'T ACTIVATE GUY.
	PUSHJ P,INIT1		;RESET LEPNT1.
	MOVEM UCHN,NTABPT(I)	;SAVE CTRL BITS OF ACTIVATION CHR.
	MOVE TAC,FCPOS(I)	;MAKE COPY OF NO. OF CHRS. IN BUFFER.
	TLZN I,REEDBT		;IS THIS A RE-EDIT ?
	JRST ACTNH0
	DPB UCHN,[POINT 2,CHR,28]
	SUBI CHR,200
	DPB CHR,[POINT 9,GWORD(I),35]
	DPB TAC,PLASTC		;YES. REMEMBER LINE LENGTH.
	MOVEI CHR,400
	TLZE I,SHLDRB	;IS loser looking over our shoulder ?
	PUSHJ P,LSRSEE	;Yes. Flag end of edit chrs.
ACTNH0:	MOVEM TAC,NTABCT(I)
	HLLM I,LETAB-DPYL0(DAT)	; STORE NEW STATUS.
	HRLI DAT,ACTIV3		;DO THE DIRTY WORK AT CLOCK LEVEL.
;	JRST DPYTIM
;PATCH BY RPH TO TRANSFER AS MANY CHARS AS WILL FIT IN
;TTY BUFFER NOW!!!!!! NOT LATER AT CLOCK LEVEL
	PUSH P,DAT		;SAVE LINE NUMBER
	PUSHJ P,ACTIV3		;CALL HIM ONCE
	POP P,DAT		;GET BACK LINE NUMBER
	MOVE I,LETAB-DPYL0(DAT)	;AND BITS
	POPJ P,			;AND RETURN TO WHO EVER

ACTIV5:	MOVEI UCHN,TTIBUF(DDB)	;GET POINTER FOR PUTCHI.
	HRRZ DDB,I		; PICK UP ADDRESS OF DPY PROGRAM HEADER
	SKIPN III(I)		; IS IT A DATA DISC DISPLAY?
	TLO DDB,400000		; YES, FLAG THAT FACT TO DPYTYO
ACTIVL:	MOVEM UCHN,DAT		;GIVE PUTCHI A PTR. TO INPUT BUFFER.
	MOVEI TAC1,LEPNT1(I)	;TELL GETEM TO USE LEPNT1.
	PUSHJ P,GETEM		;GET NEXT CHR. FROM BUFFER.
	PUSHJ P,PUTCHI		;PLACE CHAR. IN TTY INPUT BUFFER.
	JRST ACTIV2		;INPUT BUFFER FULL. WAIT A WHILE.
	SOSN CCPOS(I)		;IS THIS THE ACTIVATION CHAR. ?
	SOSG TAC,NTABPT(I)	;YES. DOES IT HAVE CTRL. BITS ?
	JRST ACTIV6		;NO.
	DPB TAC,[POINT 2,CHR,28]
				;YES. PUT CTRL. BITS IN INPUT BUFFER.
	DPB CHR,PUTR(DAT)
	MOVEI CHR,13		;ECHO CTRL. BITS, IF ANY.
	TRNE TAC,CBIT1
	PUSHJ P,ECHOCB
	MOVEI CHR,14	
	TRNE TAC,CBIT2
	PUSHJ P,ECHOCB
ACTIV6:	LDB CHR,LEPNT1(I)	;GET BACK DPY VERSION OF CHAR. CODE.
	PUSHJ P,ECHO		;ECHO IT ON PAGE PRINTER.
	SKIPE III(I)		;ARE WE A DD
	JRST ACTIVQ
	LDB CHR,LEPNT1(I)	;GET LAST CHR PUT OUT
	CAIN CHR,177		;IS IT A BS
	PUSHJ P,ECHO		;YES, ECHO TWICE FOR DD
ACTIVQ:	SOSLE NTABCT(I)		;ALL CHRS. XFERED ?
	JRST ACTIVL
; WE GET HERE WHEN THE LINE EDITOR BUFFER IS EMPTY.
; WE CLEAN UP AND LEAVE.

	MOVEI DDB,LEB(I)	; YES, MAKE EDITOR BUFFER INVISIBLE BY PUTTING
	HRLI DDB,DISJMP		; A RETURN JUMP ON TOP OF THE POSITION VECTOR
	MOVSM DDB,LEPPV(I)
	HRLI I,0		;RESET STATUS BITS.
	TLZ	IOS,SYNC!DDTM	;DONT SCREW UP THE COUNT
ACTIV4:	MOVEI DDB,-TTIBUF(UCHN)	;RECOVER DDB.
	PUSHJ P,STLNAC		;SET UP LINE.
	HLLM I,LETAB-DPYL0(LINE)	;RESET STATUS. 
	PUSH P,TISYNC(DDB)	;REMEMBER CURRENT ACTIVATION COUNT!
	PUSHJ P,SYNCHK		;UPDATE TISYNC
	POP P,TAC		;GET BACK ORIGINAL COUNT
	CAMGE TAC,TISYNC(DDB)	;DID SYNCHK ACTIVATE SOME MORE CHARS?
	JRST RECIN3		;YES, WAKE COMMAND DECODER!
	JRST RECIN4
ACTIV2:	TLO IOS,SYNC!DDTM	;FORCE ACTIVATION
	PUSHJ P,ACTIV4		;GO ACTIVATE JOB.
	MOVE TAC,TTYTAB(LINE)
	TLNN TAC,400000		;DOES HE ALREADY HAVE A COMMAND WAITING?
	PUSHJ P,COMSET		;NO, SET HIM
	MOVE DAT,LINE
	POPJ P,

		;WE WILL GO TO ACTIV3 NEXT TIC.
↑ACTIV3:	;SET UP EVERYTHING AND GO BACK INTO LOOP.
	HRRZ LINE,DAT
	CAIL LINE,DPYL0
	CAIL LINE,DDL0+DDNUM
	POPJ P,
	MOVE I,LETAB-DPYL0(LINE)
	TLNN I,WTFLAG
	POPJ P,			; IF NOT DOING ANY TRANSFER, LEAVE
	SKIPN DDB,TTYTAB(DAT)
	JRST ACTIV7		;SOMEBODY HAS FLUSHED OUR DDB. QUIT NOW.
ACTIV9:	MOVE IOS,DEVIOS(DDB)
	MOVE I,LETAB-DPYL0(LINE)
	JRST 2,@[ XWD 020000,ACTIV5]
				;SUPPRESS INCREMENTING OF NEXT ILDB.

; WE GET HERE IF THE DDB HAS BEEN EATEN FROM UNDERNEATH US
; WE TRY TO GET HIM A NEW DDB.

ACTIV7:	CONO PI,SCNOFF
	SKIPE DDB,TTYTAB(DAT)	; SEE IF IT IS REALLY GONE?
	JRST ACTIV8		; NOT REALLY, GO TO IT
	PUSHJ P,DDBSRC		; GET HIM A DDB
	JRST ACTI10		; NONE AVAILABLE, REPLANT CLOCK REQUEST AND WAIT
	CONO PI,SCNON
	JRST ACTIV9

ACTIV8:	CONO PI,SCNON
	JRST ACTIV9

ACTI10:	CONO PI,SCNON
	JRST DPYTIM
ECHOCB:	TRNN IOS,NOECHB		;IS USER SUPPRESSING ECHO OF CTRL. BITS ?
	TRNE IOS,NOECHO		;OR ALL CHARS?
	TLNE IOS,TPMON		;YES, MONITOR GETS THEM ANYWAY
	JRST DPYTYO		;ECHO BIT
	POPJ P,

ECHO:	TLNE IOS,TPMON		; ALWAYS ECHO IN MONITOR MODE
	JRST DPYTYO
	TRNE IOS,NOECHO		;IS USER SUPPRESSING ALL ECHOING ?
	POPJ P,
	MOVE AC1,LCH(I)
	MOVEM CHR,LCH(I)
	CAIN CHR,12
	CAIE AC1,15
	JRST DPYTYO
	HRRZ AC1,PRGNUM(I)	; PICK UP TTY NUMBER
	MOVE AC1,LINTAB+DPYL0(AC1)	; FILL IN LINE CHARACTERISTICS
	TLNN AC1,XON		; LET THE LOSER TURN OFF LF AFTER CR IF HE WANTS TO
	JRST DPYTYO
	POPJ P,

↑PTLLED:			;IF WE'RE A DPY, WE WILL PRELOAD THE LINE EDITOR.
	TLNE LINE,IMLIN
	JRST IMLOAD
	TLNN LINE,DISLIN!DDDLIN
	POPJ P,
	HRRZS I,LETAB-DPYL0(LINE)
				;SET NTABCT AS SIGNAL TO KBDED (ACTIV1).
	XCTR	XR,[MOVE UUO,(UUO)]	;GET GUY'S PTR.
	TLNN UUO,-1		;IS IT ALREADY (PRESUMABLY) A BYTE PTR. ?
	HRLI UUO,440700		;NO. MAKE IT ONE.
PTLL2:	XCTR	XLB,[ILDB CHR,UUO]	;GET CHR. FROM LOSER.
	MOVSI UCHN,-1		;FLAG TO KBDED SAYING IT'S US.
	JUMPE CHR,PTLLX		;IF NULL, QUIT AND RESET EDITOR.
	PUSHJ P,PTLL3		;FEED IT TO KBDED.
	TRNN UCHN,1		;DID KBDED SEE AN ACTIVATION CHR. ?
	JRST PTLL2		;NO. 
	POPJ P,			;RESET EDITOR AND GO AWAY.

; HERE IS WHERE WE QUEUE UP LINE EDITOR TRANSFERS

↑↑QLETXT: SETOM LETXC(I)		; NOTE THAT TEXT HAS CHANGED
QLECUR:	SKIPE III(I)		; IF III, THIS IS IRRELEVANT
	POPJ P,
	SETO AC2,		; TEST THE FLAG
	EXCH AC2,LECLK(I)	; IS THERE A CLOCK REQUEST ALREADY IN?
	JUMPL AC2,CPOPJ		; IF SO, HE WILL GET IT.
	HRR AC1,I		; IF NOT, MAKE UP ONE WITH THE DPY HEADER ADDRESS IN IT
	HRLI AC1,DPLED		; AND USE THE LINE EDITOR ROUTINE
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
	POPJ P,
; THIS IS A ROUTINE THAT GOES THROUGH THE LINE AND SETS UP EXTRA CRLFS TO BREAK
; LONG LINES.

MAKECR:	TLZ I,TABB!NOTABBT	; NEXT TAB IS UNKNOWN NOW
	TLNE I,400000		; IS IT REALLY THERE?
	SKIPE III(I)
	POPJ P,			; NOT THERE OR III
↑↑LEFIX:SETZ AC3,
	MOVE AC2,CURPP(I)	; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	MOVE AC1,PPHPOS(I)
	SUB AC1,LNLNGT(AC2)	;ROOM LEFT TO END OF LINE
	HRLI TAC,440700		; PICK UP BYTE POINTER TO BEGINNING OF BUFFER
	HRRI TAC,LEBUF(I)
	SETZM NCRS(I)		; INITIALIZE THE TRANSFER LENGTH COUNTER
MAKEC1:	ILDB CHR,TAC		; PICK UP CHARACTER
	JUMPE CHR,.-1		; SKIP NULLS
	CAIN CHR,EOLCHR		; IF END OF BUFFER,
	JRST MAKEC6		; LEAVE
	CAIN CHR,11		; IS THIS A TAB?
	JRST MAKEC2		; YES, IT IS, GO PROCESS IT
	AOJL AC1,MAKEC7		; NORMAL CHARACTER, BUMP COLLUMN COUNT
; WE GET HERE IF THE LINE IS LONG AND MUST BE BROKEN UP.

MAKE12:	MOVE AC1,TAC		; PICK UP BYTE POINTER
MAKE23:	ILDB CHR,AC1		; LOOK AHEAD SOME
	JUMPE CHR,.-1
	CAIE CHR,11		; MAYBE THIS IS JUST THE LONG-LINE CRLF?
	JRST MAKE20		; APPARANTLY NOT, BUMP CR COUNT
	ILDB CHR,AC1		; PICK UP NEXT CHARACTER
	JUMPE CHR,.-1
	CAIE CHR,15		; IF THIS IS A CR, IS DEFINITELY A LONG-LINE CRLF
	JRST MAKE21
MAKE22:	ILDB CHR,AC1		; IN WHICH CASE, READ PAST IT
	CAIE CHR,11
	JRST MAKE22
	JRST MAKE23

MAKE20:	CAIE CHR,EOLCHR		; IF THERE ARE NO MORE CHARACTERS ON NEXT LINE, DON'T BUMP LINE COUNT
MAKE21:	AOS NCRS(I)		; END OF LINE, BREAK THE LINE UP
	MOVEI CHR,11		; END OF LINE, BREAK LINE
	PUSHJ P,MAKINS
	MOVEI CHR,15
	PUSHJ P,MAKINS
	MOVEI CHR,12
	PUSHJ P,MAKINS
	MOVEI CHR,11
	PUSHJ P,MAKINS
	MOVN AC1,LNLNGT(AC2)	; RESET COLUMN COUNT
MAKEC8:	MOVE TAC1,TAC		; SAVE POINTER
MAKEC9:	ILDB CHR,TAC1		; IS NEXT CHARACTER A NULL?
	JUMPN CHR,MAKEC7	; NO, ALL OK
	MOVE TAC,TAC1		; YES, SPACE POINTER OUT PAST NULLS
	JRST MAKEC9

MAKEC7:	ADDI AC3,1		; BUMP COLUMN COUNT
MAKE10:	CAMN AC3,CCPOS(I)	; IS THIS WHERE THE POINTER IS SUPPOSED TO BE?
	MOVEM TAC,LEPNT1(I)	; YES, STORE IT
	JRST MAKEC1
; HERE WE SEE IF THE TAB IS A REAL TAB OR IF IT IS JUST
; THE THING WE USE TO DELIMIT A LONG-LINE CRLF

MAKEC2:	MOVE TAC1,TAC		; SAVE BYTE POINTER
	ILDB CHR,TAC		; PICK UP NEXT CHARACTER
	CAIE CHR,15		; IS IT A CR?
	JRST MAKEC3		; NO, MUST BE REGULAR TAB, GO ADJUST IT
	SETZ DSER,
	DPB DSER,TAC1		; YES, ZERO OUT THE LONG LINE CRLF
	DPB DSER,TAC
	IDPB DSER,TAC
	IDPB DSER,TAC
	JRST MAKE10

MAKEC6:	SETZ CHR,		; ZERO OUT STUFF AFTER END OF LINE CHARACTER
MAKE17:	LDB TAC1,[POINT 6,TAC,5]
	CAIG TAC1,7		; IS THERE ANY MORE ROOM IN THE LAST TEXT WORD
	JRST MAKE18		; NO, SET UP LELWD AND LEAVE
	IDPB CHR,TAC		; YES, PLOP DOWN A ZERO THERE
	JRST MAKE17

MAKE18:	HRRZ TAC1,TAC		; GET BARE ADDRESS OF LAST TEXT WORD IN BUFFER
	EXCH TAC1,LELWD(I)	; STORE IT AND GET THE OLD VALUE
	MOVE AC1,1(TAC1)	; PICK UP THE RETURN JUMP
	MOVEM AC1,1(TAC)	; PUT IT RIGHT AFTER THE END OF LINE CHARACTER
	POPJ P,
; WE GET HERE WHEN THE TAB SURROUNDS A BUNCH OF SPACES. FIRST WE
; DELETE THE ORIGINAL SPACES, THEN WE FIGURE OUT HOW MANY WE NEED
; TO MAKE THE TAB COME OUT RIGHT AND PUT THEM IN.

MAKEC3:	PUSH P,AC3		; SAVE BYTE POINTER
	PUSH P,UUO		; GET AN ACCUMULATOR FOR COUNTING SPACES IN TABS
	SETZB DSER,UUO
MAKEC4:	DPB DSER,TAC		; ZERO OUT THE SPACES IN THE TAB
	CAIN CHR," "		; COUNT IT AS A SPACE ONLY IF IT REALY IS A SPACE
	ADDI UUO,1		; BUMP NUMBER OF SPACES IN THIS TAB
	ILDB CHR,TAC
	CAIE CHR,11		; UNTIL WE GET TO THE TERMINATING TAB
	JRST MAKEC4
	MOVE TAC,NCRS(I)	; FIGURE OUT POSITION FROM BEGINNING OF FIRST LINE
	ADDI TAC,1		; BUMP BY ONE TO CORRECT FOR NEGATIVITY OF AC1
	IMUL TAC,LNLNGT(AC2)	; MULTIPLY NUMBER OF LINES BY LENGTH OF LINES
	ADD TAC,AC1		; ADD IN CHARACTERS INTO LAST LINE
	MOVEM TAC,LECHPS(I)	; SAVE FOR FUTURE REFERENCE
	ANDI TAC,7		; MOD 10
	MOVEI AC3,10
	SUB AC3,TAC		; THIS IS NUMBER OF COLUMNS TO GO
	ADD AC1,AC3		; ADD LENGTH OF TAB INTO COLUMN POSITION
	SUBM AC3,UUO		; GET CORRECTION TO THIS TAB
	JUMPLE AC1,MAKE13	; IF NOT AT END OF LINE, GO ON AND ADJUST TAB
	MOVE TAC,TAC1		; GET POINTER TO TAB
	MOVEI CHR," "		; NOW SPACE OUT TO END OF LINE
MAKE16:	CAML AC1,AC3		; OUT FAR ENOUGH?
	JRST MAKE15		; YES, PUT IN CRLF NOW
	PUSHJ P,MAKINS		; NO, PUT IN ANOTHER SPACE
	SOJA AC3,MAKE16
; AT THIS POINT, WE ARE IN THE PROCESS OF BREAKING A LONG LINE
; IN THE MIDDLE OF A TAB. WE HAVE JUST INSERTED THE APROPRIATE
; NUMBER OF SPACES TO FILL OUT THE LAST LINE, AND NOW WE
; MUST INSERT THE CRLF ITSELF.

MAKE15:	MOVEI CHR,15
	PUSHJ P,MAKINS		; BREAK LINE IN THE MIDDLE OF A TAB
	MOVEI CHR,12
	PUSHJ P,MAKINS
	AOS NCRS(I)		; UPDATE NUMBER OF CRLFS IN LINE
	MOVE TAC1,TAC		; SAVE BYTE POINTER TO TAB
	MOVE AC3,AC1		; NUMBER OF SPACES IS NUMBER OF CHARACTERS INTO LINE
	SUB AC1,LNLNGT(AC2)	; RESET COLUMN COUNT
MAKE13:	MOVE TAC,LECHPS(I)	; PICK UP NUMBER OF CHARACTERS FROM FIRST LINE
	CAMGE TAC,LEHPOS(I)	; ARE WE BEFORE THE HORIZONTAL POSITION POINTER?
	ADDM UUO,LEHPOS(I)	; YES, UPDATE IT
MAKE14:	POP P,UUO
	MOVE TAC,TAC1		; GET BYTE POINTER BACK
	MOVEI CHR,40
	PUSHJ P,MAKINS		; INSERT THAT MANY SPACES
	SOJG AC3,.-1
	LDB CHR,TAC		; NOW UPDATE POINTER TO PAST TAB
MAKEC5:	CAIN CHR,11
	JRST MAKE11		; THEN GET BACK INTO THE LOOP
	ILDB CHR,TAC		; NOT TAB, GET NEXT CHARACTER
	JRST MAKEC5
MAKE11:	POP P,AC3		; RESTORE COLUMN COUNT
	JUMPGE AC1,MAKE12	; IF WE GOT LINE OVERFLOW, BREAK LINE UP
	JRST MAKEC8

MAKINS:	ILDB TAC1,TAC		; IS THIS CHARACTER A NULL?
	JUMPE TAC1,.+2
	PUSHJ P,LEINSW		; NO, INSERT A WORD OF NULLS
	DPB CHR,TAC		; DEPOSIT OUR CHARACTER OVER A NULL
	POPJ P,

BEND LINED
BEND   TTYSER
