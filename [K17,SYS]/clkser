COMMENT ⊗   VALID 00091 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00010 00002	APRINT	8 SEPT 67
C00013 00003	HERE, WE GENERATE ANY USER CLOCK-INTERRUPTS NEEDED.
C00017 00004	 HERE WE REQUEST CH7 INTERRUPT AND DISMISS
C00020 00005	ADDRESS BREAK SYSTEM.
C00023 00006	APRER	OTHER APR INTERRUPTS BESIDES CLOCK
C00026 00007	 THIS ROUTINE REQUESTS USER INTERRUPT FOR VARIOUS APR-TYPE TRAP CONDITIONS
C00030 00008	HERE WE'VE DECIDED THAT THIS LOSER DOESN'T HAVE A VALID TRAP ADDRESS.
C00032 00009	 HERE WE HAVE A NON-TRIVIAL ERROR
C00034 00010	 WE GET HERE ON AN ERROR IN THE EXEC
C00036 00011	SYSTEM CLOBBERED     DETECTED BY SYS WR REF KLUDGE
C00038 00012	CLOCK	24 JULY 67
C00040 00013	HERE AT CLK INTERRUPT LEVEL  -  CLKINT
C00042 00014	P2 CLK INTS COME HERE
C00043 00015	 HERE IT IS NOT TIME TO TAKE A REAL CLOCK INTERRUPT
C00046 00016	SET TIME FLAGS, UPDATE SYSTEM TIME, COUNT DOWN PROCESSOR ALIVE FLAGS
C00052 00017	 KEEP INFORMATION FLOWING BETWEEN THE PROCESSORS
C00055 00018	 HERE IS THE GUY THAT CALLS UP PHANTOM PROCESSES LIKE BATCH MONITORS
C00059 00019	 MAINTAIN P1'S 2-PROCESSOR COMMUNICATION
C00062 00020	 HERE IS SUBROUTINE FOR PHANTOM ROUTINES
C00065 00021	 MORE PHANTOM CLOCK LEVEL ROUTINES, WAITING FOR RESOURCES
C00067 00022	 HERE WE FLUSH THE DISASTER TYPEOUT BUFFER THEN PROCESS CLOCK REQUESTS
C00069 00023	 IF WE ARE SHUFFLING 1K AT A TIME, DO ANOTHER K HERE, THEN CALL SCHEDULER
C00072 00024	DIFFERENT JOB, SAVE SOFTWARE STATE(HARDWARE ALREADY SAVED)
C00075 00025	S2U AND U2S
C00078 00026	RESTORE HARDWARE STATE OF CURRENT JOB
C00080 00027	THE NULL JOB
C00082 00028	 CHECKSUM ROUTINE. CALL WITH IOWD IN TAC, RETURNS CHECKSUM IN TAC1.
C00083 00029	BEGIN	SYSFIX	VERIFY SYSTEM CHECKSUM AND FIX IT IF WRONG.
C00090 00030	 THIS IS WHERE THE USER INTERRUPT HANDLER RESIDES . . .
C00096 00031	 ROUTINE TO GET FIRST SERVICABLE INTERRUPT BIT FROM WORD OF BITS
C00098 00032	 HERE WE CLEAR THE INTERRUPT BIT IN JBTIRQ AND ACTUALLY
C00103 00033	 HERE WE INITIALIZE ALL THE SYSTEM VARIABLES IN PREPARATION FOR RUNNING THE USER INTERRUPT PROCESS
C00107 00034	 HERE, HE IS NOT CONTINUING AFTER A UWAIT, BUT IS BEING RUN REGULARLY
C00110 00035	 ROUTINE TO TYPE OUT ERROR MESSAGE FOR ILL. STARTING ADDRESS
C00112 00036	 ROUTINE TO SWAP A GUY IN SO HE MAY BE INTERRUPTED
C00115 00037	 WE COME BACK TO HERE AFTER AN INTERRUPT - INTCH7,INTDSM,INTOUT,INTERR
C00119 00038	 WE GET HERE FROM A DEBREAK UUO - INTDEB, INTERP, INTAPR
C00122 00039	INTKILL  ROUTINE TO CLEAR A JOB'S INTERRUPT ENABLINGS AND RESET HIS MASKS
C00124 00040	INIJOB		ROUTINE TO INITIALIZE A JOB SLOT
C00130 00041	COMCON	4 AUG 67	 THE COMMAND DECODER
C00133 00042	COMMAND
C00136 00043	COMFND: MOVE	UUO,COMTAB(AC1)	SAVE FULL COMMAND NAME
C00139 00044	CHKACT:
C00142 00045	RETURN FROM COMMAND SETUP ROUTINE
C00145 00046	PCRLF:	TLNE AC2,ERRFLG		DID AN ERROR OCCUR?
C00148 00047	TABLE OF CONSOLE COMMANDS
C00151 00048	DEFINE NAMES
C00156 00049	 MORE COMMANDS . . .
C00160 00050	BEGIN COMTBL			GENERATE TABLE OF SIXBIT COMMAND NAMES
C00162 00051	CALLED FROM COMMAND DECODER WHICH IS CALLED FROM CLOCK ROUTINE
C00165 00052	COR0:		CALLED FROM CORE COMMAND TO ZERO CORE
C00167 00053	PTTY PJOB KJOB
C00173 00054	IFN FTLOGIN,<			 PRINT OUT A JOB'S PROJECT PROGRAMMER NUMBER
C00177 00055	 SERVICE LEVEL COMMAND
C00188 00056	KILL N ---- KILL JOB N IMMEDIATELY! -- OR MAYBE LATER
C00192 00057	PRIVILEGED KILL ROUTINE, FLUSHES THINGS WITHOUT WAITING
C00193 00058	KJOB2:	JUMPE	PROG,JOBKA	DOES JOB HAVE CORE?
C00196 00059	 "START L" OR "START" - START AT LOC. L OR STARTING ADDRESS
C00201 00060	CCONTINUE, CONTINUE, DDT
C00204 00061	SETUWP, CLRUWP, ENABLE, DISABLE
C00209 00062	 "CORE  #" - ASSIGNS #*1024 WORDS OF CORE TO JOB
C00212 00063	COR4:	MOVSI	TAC,NOINCK	DON'T INITIALIZE A JOB
C00215 00064	PRJOB:	PUSHJ P,INLMES
C00218 00065	"HELP" -HELP COMMAND
C00220 00066	ALOGIN, SETTPV, CLRTPV
C00222 00067	"LOGIN" - LOGIN COMMAND
C00226 00068	R, RUN, SAVE, SSAVE, GET COMMANDS
C00231 00069	 "ASSIGN DEV:NAME" - ASSIGN DEVICE TO JOB AND GIVE IT LOGICAL NAME
C00243 00070	ALREADY ASSIGNED TO ANOTHER JOB
C00246 00071	"DEASSIGN DEV" - DEASSIGNS DEVICE FROM CONSOLE
C00249 00072	REASSIGN UUO
C00251 00073	ROUTINE COMMON TO REASSIGN UUO AND COMMAND
C00253 00074	REASS4:	HRRZ DSER,DEVSER(DEVDAT)
C00255 00075	REASE1:	POP PDP,TAC
C00256 00076	"ATTACH DEVNAM" -ATTACHES A PREVIOUSLY PARTITIONED DEVICE
C00259 00077	IFN FTLOGIN,<
C00262 00078	ATT2:	EXCH	DDB,TAC1		PUT LINE NO. OF OUR TTY IN DDB
C00263 00079	FLUSH THIS TTY'S BUFFERS IF NOT IN USE BY A JOB
C00265 00080	"FORK", "CFORK", "DETACH" AND "CDETACH" COMMANDS
C00272 00081	"DAYTIME" - PRINT TIME OF DAY
C00278 00082	"TIME (JOB NO.)" - PRINT TOTAL AND INCREMENTAL RUNNING TIME FOR A JOB
C00286 00083	ROUTINE TO LET TTY TALK TO ANY OTHER RING OF TTYS
C00287 00084	"EXAMINE LOC" - LOOKS A CONTENTS OF LOC AND PRINTS IN OCTAL
C00291 00085	"DEPOSIT LH RH LOC" - DEPOSITS XWD LH,RH IN LOCATION LOC
C00294 00086	"BLANK" OR NO ALPHA NUMERIC BEFORE BREAK CHAR COMMAND
C00295 00087	 "FINISH DEVICE" - CLOSES,RELEASE AND DEASSIGNS DEVICE
C00301 00088	"RESOURCES" - PRINT OUT AVAILABLE DEVICES AND FREE BLOCKS ON THE DISK
C00305 00089	RUNCHK, DLYCOR, DLYCR1
C00308 00090	SEARCH DEVICE CHAIN FOR DSK WITH COUNTS ON
C00310 00091	"FILES <filename or job number>" -- print status of open files.
C00322 ENDMK
C⊗;
SUBTTL	APRINT	8 SEPT 67

;THIS SERVICE ROUTINE RUNS ON A HIGH PRIORITY CHANNEL
;AND REQUESTS INTERRUPTS ON LOWER CLK CHANNEL
;FOR SCHEDULING JOBS AND ERROR HANDLING THAT THE USER
;IS NOT ENABLED TO HANDLE HIMSELF

AP2CHL←CAT(P2CH,\APRCHN)
CL2CHL←CAT(P2CH,\CLKCHN)


↑AP2INT:
	EXCH	PID,APRID+P2PID
	JRST	BREAKX

↑APRINT:
	EXCH	PID,APRID+P1PID
;APR IS ALWAYS ENABLED FOR CLOCK,ILM,NXM,PDLOV, AND CONS.
;ALSO AROV AND PC CHNG IF THE USER REQUESTS.

	CONSZ	APR,ADRBRK	;ADDRESS BREAK?
	JRST	BREAK		;YES, GO PROCESS
BREAKX:	CONSO	APR,1B26	;YES, IS IT CLOCK?
	JRST	APRER		;NO, GO CHECK ERROR FLAGS

;CLOCK HAS TICKED.  DO TIME ACCOUNTING
	AOS	TIME(PID)	;YES, INCREMENT TIME OF DAY
	AOS	UPTIME(PID)	;DEC 3.16 INCREMENT UP TIME.
	SETOM	TIMEFF(PID)	;FLAG THAT APR CLOCK HAS TICKED
	HLLOS	CLKFLG(PID)	;SET FLAG FOR CLK FORCED INTERRUPT
	MOVEM	TAC,APRTAC(PID)	;GET AN ACCUMULATOR
	CONSO	PI,7400		;ARE WE AT INTERRUPT LEVEL (CH4-7)?
	JRST	BREAK3		;NO
	AOS	INTIME(PID)	;BUMP INTERRUPT TIME
	JRST	APRI1		;YES, SKIP TIME ACCOUNTING

BREAK3:	SKIPN	TAC,JOB(PID)	;INCREMENT RUNNING TIME
	JUMPN	PID,APRI1	;IF P2, DON'T BUMP NULL TIME
	AOS	TTIME(TAC)	;TIME ACCOUNTING (RTIME IS NO LONGER COUNTED)
	AOS	JBTRNB(TAC)	;INCREMENT HIS JOB LOADING TOO.
	JUMPE	TAC,APRI1	;ESCHEW OBFUSCATION
	MOVEM	AC1,APRAC1(PID)	;GET AN AC
	HLRZ	AC1,JBTADR(TAC)	;GET CURRENT JOB'S PROTECTION
	LSH	AC1,-12
	ADDI	AC1,1
	ADDM	AC1,JBTKCJ(TAC)	;KILO-CORE*JIFFIES
	MOVE	AC1,APRAC1(PID)	;GET BACK OUR AC
APRI1:	JUMPN	PID,APRADD
	SOSGE	DDCNT		;HAS DATA DISK TIMED OUT??
	JRST	DDCLK		;YES, GO FLUSH IT
	SKIPE	DDSTART		;DO WE NEED TO START IT UP?
	JRST	DDSTRT		;YES, DO SO.

;HERE, WE GENERATE ANY USER CLOCK-INTERRUPTS NEEDED.
; APRLST POINTS TO A LIST, 2-WORDS PER ENTRY
; LH OF FIRST WORD IS TIME BETWEEN INTERRUPTS
; RH OF FIRST WORD IS JOB NUMBER
; SECOND WORD IS NEGATIVE COUNT OF TIME BETWEEN INTERRUPTS

↑APRADD:
	JUMPN	PID,APRI2	;NO CLOCK INTERRUPTS ON P2
	SKIPN	TAC,APRLST	;ANY INTERRUPTS TO GIVE?
	JRST	APRI2		;NO, EXIT NOW
	MOVEM	AC1,APRAC1(PID)	;SAVE SOME AC'S AND PICK UP A PDL
	MOVEM	J,APRJ(PID)
	MOVEM	AC2,APRAC2(PID)
	EXCH	P,APRPDL(PID)
APRCI2:	SKIPN	J,(TAC)		;END OF LIST?
	JRST	APRCI9		;YES, RESTORE ACS AND LEAVE
	AOSGE	1(TAC)		;TIME EXPIRED YET?
	JRST	APRCI4		;NO, LOOP AROUND
	MOVSI	AC2,INTCLK	;MAKE SURE HE IS STILL ENABLED
	TDNN	AC2,JBTIEN(J)
	JRST	APRCI5		;NOT ENABLED, ALLOWABLE TIMING ERROR, JUST DELETE
	HLRZ	AC1,J		;RESET TIME
	MOVNM	AC1,1(TAC)
	IORM	AC2,JBTIRQ(J)
	SETOM	INTREQ(PID)
APRCI4:	ADDI	TAC,2		;LOOP AROUND FOR NEXT ENTRY
	JRST	APRCI2



;APRDEL DELETE CLOCK INT ENTRY POINTED TO BY TAC
;DELETES FS BLOCK AND SKIP RETURNS IF LAST ENTRY IS DELETED
;CALL ONLY AFTER DOING CONO PI,APROFF
↑APRDEL:
	JUMPN	PID,CPOPJ
	MOVEI	AC1,2(TAC)
APRCI6:	SKIPN	(AC1)
	JRST	APRCI7
	ADDI	AC1,2		;FIND END OF LIST AND MOVE LAST ENTRY INTO ENTRY
	JRST	APRCI6		;BEING DELETED

APRCI7:	MOVE	AC2,-2(AC1)	;PICK UP LAST ENTRY
	MOVEM	AC2,(TAC)
	MOVE	AC2,-1(AC1)
	MOVEM	AC2,1(TAC)
	SETZM	-2(AC1)
	MOVEI	AC1,-2(AC1)
	CAME	AC1,APRLST
	POPJ	P,
APRCI8:	AOS	(P)
APRDRL:	MOVEI	AC1,0
	EXCH	AC1,APRLST
	JRST	FSGIVE

APRCI5:	PUSHJ	P,APRDEL	;DELETE THE ENTRY, SKIP IF THAT WAS THE LAST ONE
	JRST	APRCI2
	JRST	APRCI3			;LIST EXHAUSTED
APRCI9:	CAMN	TAC,APRLST		;IS LIST EMPTY?
	PUSHJ	P,APRDRL
APRCI3:	EXCH	P,APRPDL(PID)		;RESTORE THE ACS WE SAVED
	MOVE	AC1,APRAC1(PID)
	MOVE	AC2,APRAC2(PID)
	MOVE	J,APRJ(PID)		;FALL INTO APRI2
; HERE WE REQUEST CH7 INTERRUPT AND DISMISS

APRI2:	SKIPE	SPWUUF(PID)	;SPACEWAR ACTIVE?
	SOSE	SPWTMO(PID)	;YES. DECREMENT SPACEWAR TIMEOUT
	JRST	APRI2Z		;ALL IS OK.

;THIS IS HOW WE BLOW UP THE SPACEWARRIOR.
	MOVEI	TAC,46		;ASSUME PI CHANNEL 3 INTERRUPTED CH 7
	CONSZ	PI,1000		;CH6 IN PROGRESS?
	JRST	APRI2A		;YES
	CONSZ	PI,2000		;CH5 IN PROGRESS?
	JRST	APRI2B		;YES
	CONSO	PI,4000		;CH4 IN PROGRESS?
	JRST	APRI2D		;NO. IT WAS CH3
	JRST	APRI2C
APRI2A:	ADDI	TAC,2		;CHANNEL 6
APRI2B:	ADDI	TAC,2		;CHANNEL 5
APRI2C:	ADDI	TAC,2		;CHANNEL 4
APRI2D:	JUMPN	PID,.+2
	IORI	TAC,100			;MAOFF
	MOVEM	TAC1,SPWBLO(PID)	;SAVE TAC1 A WHILE
	MOVE	TAC1,[JRST SPTMOE]
	MOVEM	TAC1,SPWXCT(PID)	;MAKE SURE WE CATCH UUOCON EXITING
	EXCH	TAC1,@(TAC)		;WHEE!
	TLNE	TAC1,USRMOD		;USER MODE?
	JRST	APRI2Y			;YES. THIS IS EASY
	EXCH	TAC1,@(TAC)		;PUT BACK THE INTERRUPTED PC
	MOVE	TAC1,UUO0(PID)		;GET UUO0
APRI2Y:	EXCH	TAC1,SPWBLO(PID)	;STORE INTERRUPTED ADDRESS.

APRI2Z:	MOVE	TAC,APRTAC(PID)		;RESTORE TAC
	CONO	PI,1B24+1⊗(7-CLKCHN)	;REQUEST INTERRUPT ON CLOCK CHANNEL.
	SETOM	DSFLAG(PID)		;TELL DPYSER CLOCK HAS TICKED.
	CONSZ	APR,@APRIN1(PID)	;IS THE USER ENABLED FOR ANY FLAGS?
					;(APRIN1 SET EACH TIME A USER RUNS)
	JRST	APRER			;YES, GO PROCESS TRAP.
	CONO	APR,1B26+APRCHN		;NO, CLEAR THE CLOCK FLAG
PBRET:	JUMPN	PID,P2RET
P1RET:	EXCH	PID,APRID+P1PID
	JEN	@APRCHL			;DISMISS INTERRUPT

P2RET:	EXCH	PID,APRID+P2PID
	JEN	@AP2CHL

;ADDRESS BREAK SYSTEM.
;PUT THE EXCEPTED PCS (THE ONES YOU WANT TO IGNORE BREAKS FROM) IN BRKTAB,
; AND THE NUMBER OF EXCEPTED PCS IN BRKNUM.
;WHEN A BREAK OCCURS FROM SOME UNEXCEPTED PC, IT EXECUTES THE CODE AT
;BRKHIT, WHICH MAY BE PATCHED TO WHATEVER YOU WANT.
;NOTE THAT IF BRKNUM≤0 ALL BREAKS ARE EXCEPTED AND AN ERROR MESSAGE RESULTS

BREAK:	MOVEM	TAC,BRKTAC	;SAVE A COUPLE OF ACCUMULATORS
	MOVEM	AC1,BRKAC1
	HRRZ	TAC,APRCHL	;PICK UP BREAK PC+1
	SUBI	TAC,1		;MAKE IT HONEST
	SKIPLE	AC1,BRKNUM	;ARE WE READY FOR A BREAK?
	CAILE	AC1,BRKMAX	;YES.  REASONABLE NUMBER OF EXCEPTED PCS?
	JRST	BRKERR		;NO. NOT READY
	CAME	TAC,BRKTAB-1(AC1)	;IS THIS PC EXCEPTED?
	SOJG	AC1,.-1			;NO. TRY NEXT ONE
	JUMPGE	AC1,BRKXIT		;JUMP IF WE MATCHED SOME EXCEPTED PC.
BRKHIT:
REPEAT 10,<JFCL>
↑BRKXIT:
	MOVE	TAC,BRKTAC		;RESTORE ACCUMULATORS
	MOVE	AC1,BRKAC1
	CONO	APR,ADRBRK		;CLEAR BREAK BIT
	JRST	BREAKX			;RETURN TO CH3 CODE

BRKERR:	EXCH	P,APRPDL(PID)
	PUSHACS
	CAIG	AC1,BRKMAX		;SKIP IF ILLEGAL VALUE OF BRKNUM
	JUMPGE	AC1,BRKER1		;JUMPE IF LEGAL VALUE OF BRKNUM
	PUSHJ	P,DISMES
	ASCIZ	/BRKNUM VAL ILLEGAL = /	;VALUE ILLEGAL
	HRRZ	TAC,BRKNUM
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	SETZM	BRKNUM
BRKER1:	PUSHJ	P,DISMES
	ASCIZ	/ADDR BRK, PC=/
	MOVE	TAC,APRCHL
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	POPACS
	EXCH	P,APRPDL(PID)
	JRST	BRKXIT
;APRER	OTHER APR INTERRUPTS BESIDES CLOCK

APRER:				;HERE TOO IF USER MIGHT BE ENABLED FOR CLKINTS
	EXCH	TAC,@APRCH(PID)		;SAVE TAC, GET PC WORD
	CONSZ	APR,ILM
	JRST	APRMPV			;CLEAN UP AFTER CPU ON MPV
	TLNN	TAC,USRMOD		;IS IT IN USER MODE?
	JRST	APRER2			;NO, PRINT MESSAGE AND STOP JOB
APRER1:	CONSO	PI,7000			;SPACEWAR LOSSAGE?
	SKIPN	SPWUUF(PID)		;IN CH7. SPACEWAR ACTIVE?
	JRST	APRER6			;NOT SPACEWAR
	EXCH	TAC,@APRCH(PID)
	JUMPE	PID,APRSWP
	EXCH	PID,APRID+P2PID
	JRST	SP2INT

APRSWP:	EXCH	PID,APRID+P1PID
	JRST	SPWINT

APRER6:	SKIPN	INTACT(PID)		;KILL IF ALREADY AT INT. LEVEL
	CONSO	APR,@APRIN1(PID)	;IS USER ENABLED FOR THIS INTERRUPT?
	JRST	APRER2			;NO, STOP JOB AND PRINT MESSAGE
	EXCH	JDAT,JOBDAT(PID)	;SAVE JDAT, GET CURRENT JOB DATA AREA ADR.

;WHEN THE KA-10 IS FIXED, DELETE ALL OF THIS DOWN TO APRE6A (BUT NOT CONSO)
;ALSO PUT HRRI INTO APRMPV
	CONSZ	APR,ILM			;ILL MEM REF?
	TLNE	TAC,20000		;YES. SKIP IF NOT ILDB/IDPB
	JRST	APRE6A			;NOT ILM OR ILM AND BIS FLAG IS SET
	HRRI	TAC,-1(TAC)		;ASSUME HE WAS DOING A WRITE OF SOME KIND

APRE6A:	CONSO	APR,@APRIN2(PID)	;ENABLED VIA NEW USER INTERRUPT SYSTEM?
	JRST	APRER7			;NO. OLD STYLE.

; THIS ROUTINE REQUESTS USER INTERRUPT FOR VARIOUS APR-TYPE TRAP CONDITIONS

	MOVEM TAC,APRIN3(PID)	; SAVE PC FOR CLKINT
	EXCH J,JOB(PID)
	CONI APR,TAC
	AND TAC,APRIN2(PID)
	EXCH P,APRPDL(PID)
	IORM TAC,JBTIRQ(J)
	EXCH P,APRPDL(PID)
	SETOM INTREQ(PID)	; NOW REQUEST AN INTERRUPT
	EXCH J,JOB(PID)
;	CONSZ APR,ILM
;	AOS APRIN3(PID)		;LET'S LEAVE IT ALONE - FW
	MOVE TAC,[JRST JOBTM5]
	MOVEM TAC,JOBTM5(JDAT)
	MOVE TAC,[XWD USRMOD,JOBTM5]
	EXCH JDAT,JOBDAT(PID)
	HLLOS CLKFLG(PID)
	CONO PI,1B24+1⊗(7-CLKCHN)
	JRST APRER3

;ENABLED VIA OLD-STYLE INTERRUPTS.
APRER7:	MOVEM	TAC,JOBTPC(JDAT)	;STORE LOSER PC IN JOB DATA AREA
	HRRZ	TAC,JOBAPR(JDAT)	;GET TRAP ROUTINE ADDRESS
	CAIGE	TAC,JOBPFI		;LEGAL TRAP ADDRESS? (NO TRAPS TO ACS)
	JRST	APRER5			;NO.
	MOVEM	TAC,APRTAC(PID)		;
	HRRZ	TAC,JOBTPC(JDAT)	;DID FIRST INSTRUCTION OF TRAP ROUTINE
	CAMN	TAC,APRTAC(PID)		;GENERATE A BAD ADDRESS?
	JRST	APRER5			;YES IT WAS, TRAP IT
	ADDI	TAC,1
	CAMN	TAC,APRTAC(PID)		;REMEMBER THAT WE BUGGERED ADDRESS
	JRST	APRER5
	CONI	APR,JOBCNI(JDAT)	;STORE APR IN JOB DATA AREA
	HLL	TAC,JOBTPC(JDAT)	;NOW PUT THE ENTIRE PC TOGETHER AGAIN
	TLO	TAC,USRMOD		;MPV COMES FROM EXEC MODE TOO,
					;MAKE SURE WE GET TO USER MODE
	HRR	TAC,JOBAPR(JDAT)
	EXCH	JDAT,JOBDAT(PID)	;RESTORE JDAT,JOBDAT
APRER3:	TLZ	TAC,440000		;CLEAR PC CHANGE AND AR OVF FLAGS
					;SO INTERRUPT MAY BE DISMISSED
	EXCH	TAC,@APRCH(PID)		;RESTORE TAC & @APRCH(PID)
	CONO	APR,530110+APRCHN	;CLEAR ERROR FLAGS WHICH CAN CAUSE
					;INTERRUPT (EXCEPT CLOCK).
	JUMPN	PID,P2RET
	JRST	P1RET

APRMPV:					;CLEANUP AFTER CPU ON ILM
;	HRRI	TAC,-1(TAC)		;BACK UP PC TO POINT AT LOSER
	CONO	APR,400000!APRCHN	;DON'T MENTION PDLOV YET IF BOMBED ON MPV
	TLNE	TAC,USRMOD		;MAY HAVE TO WORRY IF EXEC LOST
	JRST	APRER1			;NO, JUST LOSER
	CONSO	PI,67400		;PI IN PROGRESS?
	JRST	APRMP1			;NO. MPV FROM UUO LEVEL: GO TO UADERR
	CONSZ	PI,00400		;IN PROGRESS ON CH7?
	SKIPN	SPWUUF(PID)		;IN CH7. AT SPACEWAR LEVEL?
	JRST	APRER6			;NOT SPACEWAR.  MPV FROM EXEC. (HOW??)
APRMP1:	HRRI	TAC,UADERR		;SEND HIM TO ADDRESS CHECK
	JRST	APRER3
;HERE WE'VE DECIDED THAT THIS LOSER DOESN'T HAVE A VALID TRAP ADDRESS.
;SO WE CLEAR APRIN1(PID) TO PREVENT FURTHER DISTRACTION.
APRER5:	MOVE	TAC,JOBTPC(JDAT)	;RESTORE PC AND FLAGS
	EXCH	JDAT,JOBDAT(PID)	;RESTORE JOB DATA AREA ADDRESS
	SETZM	APRIN1(PID)
APRER2:	CONSO	APR,MAOFF
	CONSO	APR,200		;DID 6 GET ENABLED FOR PC CHANGE INTERUPT?
	JRST	APRERA		;NO
	CONO	APR,500!APRCHN		;CLEAR IT.
	EXCH	P,APRPDL+P2PID
	PUSHACS
	PUSH	P,TAC
	PUSHJ	P,DISMES
	ASCIZ	/PC CHANGE TRAP. PC=/	;UNEXPECTED
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
	POPACS
	HLLZS	APRIN1+P2PID	;MAKE SURE IT DOESN'T HAPPEN AGAIN
	EXCH	P,APRPDL+P2PID
APRERA:	CONSZ	APR,630000	;DOES EXEC CARE?	;JS  CONS,PDLOV,NXM,MPV
	JRST	APRERB		;YES!
	CONSO	APR,1B26
	JRST	APRER9
	MOVEM	TAC,APRTAC(PID)
	MOVE	TAC,APRIN1(PID)
	TRNE	TAC,1B26
	CONO	APR,1B26+APRCHN
	MOVE	TAC,APRTAC(PID)
APRER9:	CONSO	APR,110			;ARITHMETIC OVERFLOW?
	JRST	APRER3
	MOVEM	TAC,APRTAC(PID)
	MOVE	TAC,APRIN1(PID)
	TRNN	TAC,10			;USER ENABLED FOR AROV?
	CONO	APR,40!APRCHN
	TRNN	TAC,100			;OR FOV (PC CHANGE ON 6)
	CONO	APR,400!APRCHN
	MOVE	TAC,APRTAC(PID)
	JRST	APRER3
; HERE WE HAVE A NON-TRIVIAL ERROR

APRERB:	MOVEM	TAC,APRPC(PID)	;STORE ERROR PC FOR CLK CHANNEL
	CONI	APR,APRERR(PID)	;STORE ERROR FLAGS
				;(ALSO USED AS ERROR FLAG)
	HLLOS	CLKFLG(PID)	;SET FLAG FOR CLK INTERRUPT
	SETOM	SCHEDF(PID)	;FLAG THAT RESCHEDULING IS NEEDED
				;(EVEN THOUGH PC MAY BE IN EXEC MODE)
	CONO	PI,1B24+1⊗(7-CLKCHN)	;REQUEST INTERRUPT ON CLOCK CHANNEL.
	CONSO	APR,ILM		;ILL MEM REF?
	JRST	APRERC
	MOVEM	TAC,USAVPC(PID)	;SAVE ERROR PC FOR CLKINT
	HRRI	TAC,0		;YES. FORCE LEGAL ADDRESS SO
	JRST	APRER4		;PDP-10 WILL NOT HANG (CROCK!) ON WILD PC.
APRERC:	TLNN	TAC,USRMOD	;PC IN USER MODE?
	CONSO	PI,177B27≠(1B27⊗(7-APRCHN))	;ARE WE SOME OTHER PI CHANEL?
	CAIA			;NO.
	JRST	APRMES		;SYSTEM SCREW-UP!!
↑APRER4:CONSO	APR,NXM		;NON-EXISTANT MEMORY?
	JRST	APRER3		;NO. RESTORE ACS AND DISMISS
	MOVEI	TAC,(TAC)	;YES. IS IT PC?
	CAML	TAC,RMEMSIZ	
	MOVEI	TAC,[CONO PI,1B24!1⊗(7-CLKCHN)]
				;YES. DISMISS TO CLKINT
	HLL	TAC,APRPC(PID)
	JRST	APRER3		;RESTORE ACS AND DISMISS
; WE GET HERE ON AN ERROR IN THE EXEC

APRMES:	EXCH	P,APRPDL(PID)
	PUSHACS
	PUSH	P,TAC
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/CH3 ERROR IN EXEC.  PC = /
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ	/
APR CONI = /
	MOVE	TAC,APRERR(PID)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
	PUSHJ	P,SYSFIX
	JFCL			;NOT IN MONITOR
	CAIA			;ERROR, BUT COULDN'T FIX
	JRST	MONOK		;FOUND ERROR AND FIXED(I HOPE!)
	PUSHJ	P,ALTNOW
	JFCL
	PUSHJ	P,DISFLU	;FLUSH MESSAGES TO CTY
	PUSHJ	P,DDTCALL	;THIS DOES REQUIRE INTERVENTION
	JRST	MONOK1
MONOK:	DEBCHECK
MONOK1:	SKIPE	DISFLAG
	JRST	APREM1
	POPACS
	EXCH	P,APRPDL(PID)
	JRST	APRER4

APREM1:	PUSHJ	P,DISFLUSH
	POPACS
	PUSHJ	P,WDDTCAL	;GET A WIZARD
	HALT	AUTOLOAD
;SYSTEM CLOBBERED     DETECTED BY SYS WR REF KLUDGE
REPEAT 0,<
CLBFIX:	CONO	APR,CLRCLB+APRCHN	;CLEAR IT SO WE DON'T GET BACK HERE AGAIN
	EXCH	P,APRPDL(PID)
	PUSHACS			;GET SOME ACS
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ/π⊗⊗ππSYSTEM CLOBBERED
PC+1 = /]
	DISARG OCT,<@APRCH(PID)>
	[ASCIZ/    /]
	-1
	MOVE TAC,@APRCH(PID)
	TLNE TAC,USRMOD		;WAS IT A LOSER?
	JRST USRCLB		;YES
	PUSHJ P,DISMES
	ASCIZ/PI = /
	CONI PI,TAC
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ/
C(P) = /
	MOVE TAC,APRPDL(PID)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
CLBFX1:	PUSHJ	P,SYSFIX
	JFCL
	JFCL
	SKIPN	DEBMODE		;DO WE WANT TO STOP
	JRST	CLBRET
	SETOM	DISFLAG
	PUSHJ	P,DISFLUSH
	POPACS			;LET DDT LOOK AT THE REAL ACS
	PUSHJ	P,DDTCAL
	JRST	CLBRT1
CLBRET:	POPACS
CLBRT1:	EXCH	P,APRPDL(PID)
	JRST	PBRET

USRCLB:	MOVE	J,JOB(PID)
	PUSHJ	P,DISJOB
	CONI	PI,TAC
	TRNN	TAC,400		;SPACEWAR?
	JRST	USRCL1
	PUSHJ	P,DISMES
	ASCIZ	/  SPCWAR/
USRCL1:	PUSHJ	P,DISCRLF
	JRST	CLBFX1		;NOW TRY TO FIX IT!
>
SUBTTL	CLOCK	24 JULY 67

;THIS ROUTINE RUNS ON THE LOWEST PRIORITY PI CHANNEL AND AT UUO LEVEL
;TO CAUSE AN INTERRUPT ON CLK CHANNEL:
;	SETOM CLKFLG	;FLAG THAT INTERRUPT HAS BEEN REQUESTED
;	CONO PI,CLKREQ	;REQUEST PI INTERUPT ON LOWEST PI CHANNEL
;THE FOLLOWING OTHER FLAGS MUST ALSO BE SET
;APRERR-APR DETECTED ERROR IN CURRENT JOB
;SCHEDF-RESCHEDULING MUST TAKE PLACE(EVEN THOUGH PC IN EXEC MODE)
;TIMEF-APR CLOCK HAS TICKED ON HIGH PRIORITY CHANNEL
;SEE APRSER AND RUNCSS TO SEE HOW THIS ROUTINE IS CALLED

;CLK SERVICE PERFORMS THE FOLLOWING ON A REGULAR BASIS:
;PROCESSES CLOCK QUEUE REQUESTS
;CALLS CONSOLE MONITOR COMMAND DECODER
;CALLS CORE SHUFFLER
;THEN CALLS SCHEDULER
;IF THE CURRENT JOB IS IN EXEC MODE THE ABOVE 4 TASKS ARE
;DELAYED UNTIL THE CURRENT JOB ENTERS A STOPPABLE STATE: I.E., UNTIL
;	1. JOB STARTS TO WAIT FOR A BUSY SHARABLE DEVICE
;	2. JOB STARTS TO WAIT FOR IO TO COMPLETE
;	3. CONTROL ABOUT TO RETURN TO USER MODE
;THEN CLK SERVICE IS ENTERED AT THE UUO LEVEL

;HERE AT CLK INTERRUPT LEVEL  -  CLKINT

↑CLKIN0:EXCH 17,UUO0+P1PID	;GET HERE WHEN CLKFLG < 0
	MOVEM 17,CLKCHL		;SIMULATE INT FROM LOSER
	EXCH 17,UUO0+P1PID
↑CLKINT:SETZM CLKFLG+P1PID
	MOVEM 17,CLKS17+P1PID	;SAVE AC 17
	IFN FTHG, <	MOVEI 17,7
			MOVEM 17,HGCODE	>
	MOVEI 17,P1PID
	SKIPLE INTDISP(17)	; DO WE HAVE SOMEONE TRYING TO SNEAK INTO CH7
	JRST @INTDISP(17)	; YES, GO SERVICE HIM
IFN FTHG,<	SETZM HGCODE	>
	SKIPN 17,USAVPC
	MOVE 17,CLKCHL		;IS CURRENT JOB IN USER MODE?
	TLNN 17,USRMOD
	SKIPE SCHEDF+P1PID	;NO, IS THIS A FORCED RESCHEDULING INTERRUPT?
	JRST CLKIN1
	MOVEI 17,P1PID
	SKIPE INTREQ(17)
	JRST INTNOW
CLKINX:	MOVE 17,[CONO PI,PIOFF]
	MOVEM 17,UUOXIT+P1PID	;DIVERT TO CLKIN0 ON WAY BACK TO LOSER
	MOVE 17,CLKS17+P1PID	;LEAVE TIMEF SET AND DISMISS INT.
	JEN @CLKCHL

CLKIN1:	DATAO PI,[0]		;WE ARE NOW OFFICIALLY IN CHANNEL 7
	MOVEM 17,USRPC+P1PID
	SETZM USAVPC+P1PID
	MOVEI 17,P1PID
	JRST CLKERR
;P2 CLK INTS COME HERE

↑CL2IN0:EXCH 17,UUO0+P2PID
	MOVEM 17,CL2CHL
	EXCH 17,UUO0+P2PID
↑CL2INT:SETZM CLKFLG+P2PID
	MOVEM 17,CLKS17+P2PID
	MOVE 17,[P2PID]
	SKIPLE INTDISP(17)
	JRST @INTDISP(17)
	SKIPN 17,USAVPC+P2PID
	MOVE 17,CL2CHL
	TLNN 17,USRMOD
	SKIPE SCHEDF+P2PID
	JRST CL2IN1
	MOVE 17,[P2PID]
	SKIPE INTREQ(17)
	JRST INTNOW
CL2INX:	MOVE 17,[CONO PI,PIOFF]
	MOVEM 17,UUOXIT+P2PID
	MOVE 17,CLKS17+P2PID
	JEN @CL2CHL

CL2IN1:	MOVEM 17,USRPC+P2PID
	SETZM USAVPC+P2PID
	MOVE 17,[P2PID]
	JRST CLKERR
; HERE IT IS NOT TIME TO TAKE A REAL CLOCK INTERRUPT
; HOWEVER WE WILL GIVE A USER INTERRUPT NOW

INTNOW:	REPEAT 0,<	;LET'S SEE IF ANYBODY REALLY NEEDS THIS SHIT

INTNOW:	MOVEM 16,INTSAC+16(17)	; SAVE ACS IN SPECIAL PLACE,
				;   BECAUSE JOB MIGHT BE IN TRANSIT
	HRRZ 16,@CLKCH(17)
	CAIL 16,USRXT0
	CAIL 16,USRXT5
	SKIPE INTHLD(17)
	JRST INTNW2		;IN USRXIT CODE - COME BACK LATER
	MOVEI 16,INTSAC(17)
	BLT 16,INTSAC+15(17)
	MOVE PID,17
	MOVE TAC,CLKS17(PID)
	MOVEM TAC,INTSAC+17(PID)
	SKIPN TAC,USAVPC(PID)
	MOVE TAC,@CLKCH(PID)	; SAVE PC
	SETZM USAVPC(PID)
	MOVEM TAC,USRPC(PID)
	HRLI P,-CLKPLN		;LENGTH OF PDL
	HRRI P,CLKPDL-1(PID)
	SETOM INTNF(PID)
	PUSHJ P,INTRUN
	SETZM INTNF(PID)
	HRLZI 17,INTSAC(PID)
	JUMPE PID,CLKBLT
	BLT 17,17
	JEN @USRPC+P2PID
CLKBLT:	BLT 17,17
	JEN @USRPC+P1PID

INTNW2:	MOVE 16,INTSAC+16(17)
>
	JUMPE 17,CLKINX		;CLOBBER UUOXIT & DISMISS
	JRST CL2INX
				;STORAGE FOR CURRENT JOB
CLKERR:	JSR @CLKSV(17)		; SAVE ACCUMULATORS
	HRLI P,-CLKPLN
	HRRI P,CLKPDL-1(PID)
	MOVE TAC,UUOXI(PID)
	MOVEM TAC,UUOXIT(PID)	;RESTORE EXIT, NOW THAT WE MADE IT
CIP9:
	SKIPE TAC,APRERR(PID)	;IT THIS AN ERROR INTERRUPT?
	PUSHJ PDP,APRILM	;YES, GO PROCESS ERROR 
	SKIPE INTREQ(PID)		; ANY INTERRUPTS PENDING?
	PUSHJ P,INTRUN
	JUMPN PID,RSCHED
	SKIPE SPWGO
	PUSHJ P,SPWCHK
	SKIPE SP2GO
	PUSHJ P,SP2CHK
	JRST RSCHED

SPWCHK:	SKIPA	TAC1,[,SPWGO(J)]
SP2CHK:	MOVE	TAC1,[,SP2GO(J)]
	SETZ	J,
	MOVSI	TAC,SPWERB	;LOOK FOR ANY SPACEWAR MODE ERRORS
	LDB	J,[POINT 6,@TAC1,5]
	TDNN	TAC,JBTST2(J)
	JUMPN	J,.-2
	JUMPE	J,CPOPJ
	JRST	SPWMES
;SET TIME FLAGS, UPDATE SYSTEM TIME, COUNT DOWN PROCESSOR ALIVE FLAGS

RSCHED:	CONO	PI,APROFF		;SHUT OFF THE REAL-TIME CLOCK
	SKIPN	TIMEFF(PID)		;ARE WE BEHIND IN TIME ACCOUNTING?
	JRST	CIP6			;NO, JUST RESCHEDULE
	SETZM	TIMEFF(PID)		;DECREMENT "BEHIND" COUNT
	CONO	PI,APRON		;ENABLE CHANNEL 3 AGAIN
	SETOM	TIMEF(PID)		;SET "TIME" FLAG
	MOVE	TAC,OTHERID(PID)
	SOS	PALIVE(TAC)
	MOVEI	TAC,30
	MOVEM	TAC,PALIVE(PID)

	JUMPN	PID,MIDCHK		;FLUSH PDP6
	SOSLE	T15CNT		;TIME TO CHECK FOR AUDIO SWITCH?
	JRST	SECCHK
;HERE EVERY 1/4 TH SECOND
	MOVEI	TAC1,=15
	MOVEM	TAC1,T15CNT
	PUSHJ	P,ASSCN		;SEE IF ANY AUDIO SWITCH WORK TO BE DONE(TTYSER)
SECCHK:	SOSLE	DKBCNT		;TIME TO RUN THE 1 SECOND CLOCK?
	JRST	MIDCHK		;NO
;HERE ONCE PER SECOND. 
	MOVEI	TAC1,=60	;CHECK EVERY SECOND
	MOVEM	TAC1,DKBCNT	;RESTORE COUNT WORD (IN APRDAT)
	MOVE	TAC,TIME	;GET CURRENT TIME
	IDIVI	TAC,=60		; AND CONVERT IT TO SECONDS
	HRL	TAC,THSDAT	; PUT DATE IN LEFT HALF
	MOVEM	TAC,TIMDAT	;SAVE <DATE>,,<TIME IN SECS>
;HERE WE MAKE SURE THAT KEY NXM STOP IS ON.  PROCESSOR REALLY LOSES
;WHEN IT GETS A NXM, SO ... REG 8-14-73
	CONSZ	PTP,200		;SKIP IF KEY NXM STOP IS OFF.
	JRST	DDSTAT		;IS OK.
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/TURN NXM STOP ON!
/
	CONO	PI,PIOFF	;NOW SO WE REALLY MAKE OURSELVES NASTY
	PUSHJ	P,DISFLUSH
	CONSO	PTP,200
	JRST	.-1		;WAIT UNTIL SOMEONE NOTICES.
	CONO	PI,PION
	POPACS
DDSTAT:
IFN FTDDSTAT,<
	SOSLE	NDSTAT		;TIME FOR DD STATISTICS?
	JRST	SCNPIC		;NO. CHECK THE SCANNER NEXT
	MOVEI	TAC,5		;HERE EVERY 5 SECONDS
	MOVEM	TAC,NDSTAT

	MOVE	TAC,NDDXCT	;GET NEW COUNT
	EXCH	TAC,NDDXOL	;STORE AS OLD COUNT
	SUB	TAC,NDDXOL	;OLD COUNT - NEW COUNT. RESULT NEGATIVE
	MOVN	TAC,TAC
	CAMLE	TAC,NDDXMX	;BIGGER THAN OLD MAX?
	MOVEM	TAC,NDDXMX	;YES. STORE NEW MAX.

	MOVE	TAC,NDDLCT	;GET NEW COUNT
	EXCH	TAC,NDDLOL	;STORE AS OLD COUNT
	SUB	TAC,NDDLOL	;OLD-NEW. RESULT IS POSITIVE.
	CAMLE	TAC,NDDLMX	;BIGGER THAN OLD MAXIMUM?
	MOVEM	TAC,NDDLMX	;YES. STORE NEW MAX.
>				;END FTDDSTAT
;SCANNER PI CHN CHECK - TEMP. FIX TO HARDWARE PROBLEM - 12 JUNE 72 - JHS
SCNPIC:	CONI	DKB,TAC1
	ANDI	TAC1,7
	CAIN	TAC1,SCNCHN	;DOES DKB STILL THINK IT'S ON CHANNEL 5?
	JRST	MIDCHK		;  YES
	CONO	DKB,10!SCNCHN	;  SET PI'S AND RESET FOR GOOD MEASURE
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/DKB LOST PIA
/
	POPACS
MIDCHK:

;MIDNITE CHECK

	CONO	PI,APROFF		;HOLD UP CHANNEL 3
	MOVE	TAC1,TIME(PID)
	CAMGE	TAC1,MIDNIT		;GONE PAST MIDNITE?
	JRST	CIP2			;NO
	SUB	TAC1,MIDNIT		;KEEP COUNT ACCURATE
	MOVEM	TAC1,TIME(PID)		;REPLACE COUNT
	CONO	PI,APRON		;ENABLE CHANNEL 3 AGAIN
CIP3:	MOVEI	IOS,0			;RESET IOS ALSO.
	AOS	TAC,THSDAT(PID)		;UPDATE DAY.
	IDIVI	TAC,=31
	DIVI	IOS,=12			;NO.
	LDB	IOS,PMONTB
	CAMGE	IOS,TAC1		;END OF MONTH?
	JRST	CIP3			;YES.

;	SETZM	AFOOL			;THESE 4 INSTR. FOR APRIL 1 HACK.
;	JUMPN	TAC1,CIP2		
;	CAIN	TAC,3
;	SETOM	AFOOL

CIP2:	CONO	PI,APRON		;ENABLE CLOCK TRAPS AGAIN
	JUMPN	PID,CIPZZ1		;SKIP THIS STUFF ON THE PDP-6
	HGMAC	(21)
	SOSLE	FSCKCT
	SKIPE	FSNCLK
	PUSHJ	P,FSCLK			;THINK ABOUT FREE STORAGE.
	SKIPLE	SPFSNT
	PUSHJ	P,SFSCLK		;REPLENISH SPARE LISTS IF NECESSARY
IFG DPYNUM,<				;MAINTAIN DISPLAYS
	PUSHJ	PDP,DPYCLK
IFN IMPSW,<	HGMAC	(23)
		PUSHJ	P,IMPCLK>
	HGMAC	(14)
	JUMPE	PID,CIPZZ1
	PUSHJ	P,DISMES
	ASCIZ	/DPYCLK OR TTYCLK CLOBBERED PID
/
	MOVEI	PID,P1PID		;WHICH IS KNOWN TO BE ZERO
>
CIPZZ1:	HGMAC	(0)
; KEEP INFORMATION FLOWING BETWEEN THE PROCESSORS
; MODIFIED CLOCK ROUTINES FOR 2-PROCESSOR SYSTEM

	JUMPE	PID,JLCALC
	PUSHJ	P,JLCAL		;CALCULATE JOB LOADING
	PUSHJ	P,SPWP2		;DO SPACEWAR
	PUSHJ	P,WHOSER	;CALCULATE WHO LINES
	PUSHJ	P,PTRP2		;KEEP PAPERTAPE READER ALIVE
	PUSHJ	P,PTPP2		;KEEP TAPE PUNCH/PLOTTER GOING
	PUSHJ	P,ADP2		;AND THE AD
	SOSG	XGPP2F		;COUNT DOWN TO RUN XGP CLOCK LEVEL.
	PUSHJ	P,XGPP2		;AND THE XGP
	SKIPE	ADCP2L		; ADC?
	PUSHJ	P,ADCP2
	SKIPE	DACP2L
	PUSHJ	P,DACP2

IFN 0,<	;THIS PROBLEM HAS BEEN FIXED?
	SKIPL	AC2,NULDAT+P2PID+JOBDAC+10	;THE ONE THAT GETS IT
	TDNN	AC2,[140000,,140000]	;MAY HAVE COUNTED DOWN TO NEXT BIT
	JRST	NULOK
	PUSHJ	P,DISMES
	ASCIZ	/100000 BIT PICKED: /	;SO GJG WILL KNOW
	TLNN	AC2,140000
	JRST	NULLOK
	PUSHJ	P,DISMES
	ASCIZ	/LEFT /
	JRST	NULROK
NULLOK:	PUSHJ	P,DISMES
	ASCIZ	/RIGHT /
NULROK:	SETZM	NULDAT+P2PID+JOBDAC+10	;RESTART IT
	PUSHJ	P,DISMES
	ASCIZ /HALF.
/
>	;END IFN 0,

NULOK:	SOSL	CRKYET		; TIME TO READ THE CROK AGAIN?
	JRST	CRKT4		; NO, SKIP IT
	MOVEI	TAC,=3600*5	; SET FOR 5 MINS
	MOVEM	TAC,CRKYET
	MOVEI	TAC1,5		; WE WILL TRY FIVE TIMES
	PUSHJ	PDP,DAT2	; READ PETIT CROCK
	JRST	CRKT4		; NO, CRK SICK
	MOVEM	ITEM,CRKTIM	; UPDATE TIME OF DAY
	MOVEM	DAT,CRKDAT	; UPDATE DATE
	JRST	CRKT4

JLCALC:	HGMAC	(16)
	MOVE	TAC,OTHERID(PID)
	SKIPE	P2NUM
	SKIPGE	PALIVE(TAC)
	PUSHJ	P,JLCAL		; RECOMPUTE PRIORITIES
JORD:	SKIPE	ORDYET
	PUSHJ	P,ORDER		; SORT THE JOBS IN THE RUN QUEUE INTO PRIORITY ORDER
; HERE IS THE GUY THAT CALLS UP PHANTOM PROCESSES LIKE BATCH MONITORS

IFN FTBAT,<
	SOSLE	BATYET		;RUN OUR BATCH JOB YET?
	JRST	BAT3A		;NO. NOT YET
	HGMAC	(0)
	MOVEI	TAC,=60*JIFSEC	;RESET TO LOOK AGAIN IN 1 MINUTE
	MOVEM	TAC,BATYET	;SET RETRY TIME
	SKIPE	MAINTM		;MAINTMODE?
	JRST	BAT3A		;FLUSH THIS CODE WHILE MAINTM SET
	MOVSI	TAC,-BATLEN	;LENGTH OF BATMAN
BATLOP:	MOVEM	TAC,BATPNT	;SAVE IT
	SKIPE	AC1,BATMAN(TAC)	;JOBNAM
	SKIPN	AC3,ROBIN(TAC)	;PPN
	JRST	BAT3		;AVOID EMBARASSING CONFUSION!
	SKIPGE	J,ALFRED(TAC)	;GET CIRCUMSTANTIAL CODE
	JRST	BAT3		;NEGATIVE MEANS DON'T START ME
	JUMPE	J,BAT0		;IF ZERO THEN START ME!
	MOVE	TAC,TIME	;GET JIFFIE TIME
	IDIVI	TAC,=60*JIFSEC	;MAKE IT MINUTES
	HRL	TAC,THSDAT	;GET THE DATE
	CAMGE	TAC,ITEM	;COMPARE WITH HIS REQUEST
	JRST	BAT3		;NOT YET.
	HRRZ	TAC,BATPNT	;GET CURRENT POINTER BACK
	SETZM	ALFRED(TAC)	;SO WE DON'T GET HERE AGAIN
BAT0:	MOVEI	J,JOBN-1	;SCAN JOBS LOOKING FOR ONE LIKE THIS.
	MOVSI	TAC,JNA
BAT1:	TDNN	TAC,JBTSTS(J)	;IS THERE A JOB HERE?
	JRST	BAT2		;NO.
	CAMN	AC1,JOBNAM(J)	;WITH A NAME LIKE MINE?
	CAME	AC3,PRJPRG(J)	;AND A PPN LIKE MINE TOO?
	JRST	BAT2		;NO MATCH.
	SKIPL	AC2,JBTSTS(J)	;IS THIS JOB RUNNABLE?
	TLNE	AC2,JLOG	;NOT RUNNABLE. IS IT LOGGED IN?
	JRST	BAT3		;RUNNABLE OR LOGGED IN.
;HERE WE HAVE A DEAD PHANTOM.  KILL IT AND START A NEW ONE.
;TO BE CONTINUED....
	JRST	BAT3		;TO BE CONTINUED. IN THE MEANTIME, DO NOTHING.

BAT2:	SOJG	J,BAT1		;LOOP LOOKING THRU ALL JOBS.
	PUSHJ	P,INIJOB	;ATTEMPT TO MAKE A NEW JOB
	JRST	BAT3A		;NONE AVAILABLE. MAYBE SOON...
	JRST	BAT3B		;AVAILABLE LATER...

BAT4:	PUSHJ	P,GETBAT	;START A PHANTOM JOB.
BAT3:	MOVE	TAC,BATPNT	;GET BACK BAT POINTER
	AOBJN	TAC,BATLOP
	JRST	BAT3A		;DONE
BAT3B:	MOVEI	TAC,=60		;WAIT FOR ONE SECOND
	MOVEM	TAC,BATYET
BAT3A:				;DONE WITH PHANTOM CHECKS FOR THIS MINUTE.
>;END OF FTBAT
; MAINTAIN P1'S 2-PROCESSOR COMMUNICATION

	HGMAC(0)
	CONI	TV,SPWBUT	;READ THE SPACEWAR BUTTONS
	SKIPE	SPWGO		;ONLY RUN SPACEWAR IF SOMEONE WANTS IT
	PUSHJ	P,SPWP1		;RUN SPACEWAR OFF THE CLOCK
	MOVE TAC,OTHERID(PID)	; PICK UP ADDRESS OF PDP-6'S DATA AREA
	SKIPGE PALIVE(TAC)	; IS SIX RUNNING?
	PUSHJ P,WHOSER		; APPARANTLY NOT. REFRESH WHO LINE.
	SKIPN P2NUM		; DOES P2 EXIST?
	JRST CRKT2		; NO, FORGET IT

	SKIPE	PARFLG		; PARITY ERROR ON P2?
	PUSHJ	P,PARCLK	;YES. CALL PARITY ERROR SERVICE

CRKT3:	MOVE ITEM,CRKTIM	; PICK UP TIME OF DAY
	SKIPN DAT,CRKDAT	; IS THE CRK RUNNING? DATES AREN'T = 0
	JRST CRKT1		; CRK DEAD, FORGET IT.
	MOVEM ITEM,TIME(PID)	; UPDATE TIME OF DAY
	MOVEM DAT,THSDAT(PID)	; UPDATE DATE
	SETZM CRKDAT		; CLEAR DATE FLAG

CRKT1:	SKIPE	PTRADV		;RUN CLOCKS FOR PTR,PTP,AD AND XGP
	PUSHJ	P,PTRP1

	SKIPE	PTPSID
	PUSHJ	P,PTPP1

	SKIPLE	ADADV
	PUSHJ	P,ADP1

	SKIPE	XGPP1F		;DO WE HAVE TO LOOK AT XGP STATUS?
	PUSHJ	P,XGPP1		;YES.

	SKIPE	ADCP1L		; ADC CALLING?
	PUSHJ	P,ADCP1		; YES

	SKIPE	DACP1L		; DAC MAYBE?
	PUSHJ	P,DACP1

REPEAT 0,<			;ABOUT TIME THIS CROCK WAS FLUSHED
	HGMAC(20)		;HGCODE FOR SCHCLK, REPLACED BY THE FOLLOWING:
	SKIPGE	J,JBTQ-DIOWQ	;ANYONE IN QUEUE?
	JRST	CRKT2		;NOPE.
	AOS	JBTRNB(J)	;COUNT TIME (WHAT A CROCK!)
	HRRE	J,JBTQ(J)	;GET NEXT GUY IN Q.
	JUMPGE	J,.-2		;JUMP IF REAL JOB THERE.
>
	JRST	CRKT2
; HERE IS SUBROUTINE FOR PHANTOM ROUTINES

IFN FTBAT,<
↑GETBT0:			;ENTER HERE FROM CLKREQ BY XGPSER
	MOVE	J,TAC		;JNA FOR THIS JOB IS TURNED ON ALREADY.
	JRST	GETBTX

GETBAT:
	SKIPE MAINTMODE
	POPJ P,
	MOVE TAC,BATPNT		;GET THE POINTER TO BAT TABLES
	MOVE TAC,GORDON(TAC)	;GET THIS PHANTOM'S PRIVILEGE BITS
	MOVEM TAC,JBTPRV(J)	;SAVE
	MOVEM TAC,JB2PRV(J)	;ALSO IN PASSIVE BITS
	MOVEM AC3,PRJPRG(J)
	MOVEM AC3,JOBPPN(J)
	MOVEM AC1,JOBNAM(J)	;SETUP THIS GUY'S NAME
IFN FTSTAT,<PUSHJ P,NAMSTT>
	MOVSI TAC,JNA		;MAKE SURE NO ONE GETS THIS NUMBER
	ORM TAC,JBTSTS(J)
GETBTX:	MOVSI TAC,'DSK'		;DEVICE DISK. 
	MOVEM TAC,JOBDEV(J)
	MOVSI TAC,'DMP'		;AND DUMP
	MOVEM TAC,JOBLOG(J)
	SETZM JOBCRD(J)		;NO CORE SIZE OR STARTING INCREMENT
	SETZM JBTUFD(J)
IFN FTDSKPPN,<SETZM DSKPPN(J)	;INITIALIZE DISK ALIAS PPN>
	SETZM JBTKCJ(J)
	MOVSI TAC,JLOG
	ANDCAM TAC,JBTSTS(J)
	HLLZS SAVSAI(J)		;JUST IN CASE
GETBT1:	SETOM TAC1
	PUSHJ P,DDBSRC
	JRST DELBTT		; NO DDB, DELAY
GETBT2:	SETZ PROG,
	MOVEI TAC,JOBDA
	PUSHJ P,CORE0		; GET IT SOME CORE
	JRST DELBAT		; NOT AVAILABLE, WAIT FOR IT
GETBT3:	MOVSI TAC,SWP!SHF
	SKIPN XJOB(J)		; IF STILL GETTING CORE, DELAY A WHILE
	TDNE TAC,JBTSTS(J)	; DID JOB GO AWAY DURING ALL THIS?
	JRST BATSWP		; YES, GET IT BACK IN
↑BATSW:		;ENTER HERE FROM SWAPPER WHEN JOB COMES IN
	PUSHJ P,SETLOG		; SET-UP LOGIN STUFF
	MOVE TAC,JOBNAM(J)
	MOVEM TAC,FILNAM(PROG)
	MOVE TAC,JOBDEV(J)	; DEVICE
	MOVEM TAC,DEVWRD(PROG)
	HLLZ TAC,JOBLOG(J)	; EXTENSION
	MOVEM TAC,FILEXT(PROG)
	SKIPN TAC,JOBCRD(J)		; CORE SIZE
	JRST .+3			; DON'T FUTZ WITH ZERO
	LSH TAC,12			; TO WORDS
	SUBI TAC,1			;TO PROT
	MOVEM TAC,JOBCOR(PROG)
	HRRZ TAC,JOBLOG(J)
	MOVEM TAC,INCWRD(JDAT)	;SAVE IN PLACE WE CAN FIND IT LATER
	MOVEI TAC1,PRUNJB	; THIS GUY KNOWS ABOUT INCREMENTAL START-UP
	JRST MONJOB
; MORE PHANTOM CLOCK LEVEL ROUTINES, WAITING FOR RESOURCES

DELBAT:	LSH J,=12		; HERE WE WAIT FOR CORE TO BECOME AVAILABLE
	ADD J,[XWD BATRS,1]
DELB1:	CONO PI,PIOFF
	IDPB J,CLOCK(PID)
	CONO PI,PION
	POPJ P,

BATRS:	MOVE J,TAC
	JRST GETBT2

DELBTT:	LSH J,=12
	ADD J,[XWD BATTT,1]
	JRST DELB1

BATTT:	MOVE J,TAC
	JRST GETBT1

BATSWP:	MOVSI TAC,BATSNB	; SET THIS FLAG AND PUT IN SWAPIN LIST
	JRST SETSIN		; WILL CALL BATSW WHEN SWAPPED IN

;THERE ARE 3 TABLES IN APRDAT OF EQUAL LENGTH WHICH CONTAIN THE NAMES OF
;ALL THE PHANTOM JOBS AND A FLAG TO TELL IF THIS JOB SHOULD BE
;STARTED AT ALL THE JOBS ARE STARTED WHEN THE SYSTEM STARTS UP AND
;CHECKED FOR RESTART EVERY MINUTE.
>;END OF FTBAT
; HERE WE FLUSH THE DISASTER TYPEOUT BUFFER THEN PROCESS CLOCK REQUESTS

CRKT2:	HGMAC(0)
	MOVE TAC,DISPTR
	CAME TAC,DISOPT		; ANYTHING IN THE DISASTER BUFFER?
	PUSHJ P,DISOUT		; YES, GO EMPTY IT

;PROCESS TIMING REQUESTS STORED IN QUEUE

CRKT4:	HGMAC	(17)		;TIMING REQUEST.
	HRRZ DAT,CLOCK(PID)	;GET END OF LIST
CIP4:	CAIG DAT,CIPWT-1(PID)	;END YET?
	JRST CIP5		;YES
	SOS TAC1, (DAT)		;DECREMENT TIMING REQUEST
	TRNE TAC1, 7777		;TIME EXPIRED YET
	SOJA DAT, CIP4		;NO, CONTINUE SCAN
	CONO PI, PIOFF		;YES, MOVE LAST ITEM IN LIST TO THIS
	MOVE TAC, @CLOCK(PID)
	SOS CLOCK(PID)
	MOVEM TAC, (DAT)
	CONO PI,PION
	LDB TAC, [POINT 6, TAC1, 23]
				;GET 6 BIT DATA ITEM
	HLRZS TAC1		; SETUP DISPATCH ADDRESS
	CAMG TAC1,SYSTOP	; IS THIS A REASONABLE ADDRESS?
	JRST CIP5AA
	PUSH P,DAT
	PUSHJ P,ALTNOW
	JFCL
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES	;ILLEGAL ADDRESS FOR CLOCK REQUEST
	ASCIZ	/ILL ADR FOR CLK REQ
/
	POP P,DAT
	SKIPN DISFLAG
	JRST CIP5A
	PUSHJ P,DISFLUSH
	JRST AUTOLOAD

CIP5AA:	PUSH	P, DAT		;SAVE ONLY VALUABLE AC
IFN FTHG, <PUSH	P,HGCODE 
	   HGMAC(22)	>
	PUSHJ	P,(TAC1)	;AND DISPATCH TO TIMING REQUEST ROUTINE
IFN FTHG, <POP	P,HGCODE >
	POP	P,DAT
CIP5A:	SOJA	DAT,CIP4		;GO BACK FOR MORE REQUESTS
; IF WE ARE SHUFFLING 1K AT A TIME, DO ANOTHER K HERE, THEN CALL SCHEDULER

CIP5:	JUMPN PID,CIP6A		;P2 JUMPS TO CIP6A -AVOID RUNNING COMMAND
IFN FTSHF1K,<
	HGMAC	(13)
	SKIPN TAC,SHFTAC	;ANY SHUFFLING TO DO?
	JRST CIP11		;NO.
	MOVE ITEM,SHFJOB	;LOAD NUMBER OF JOB TO BE MOVED
	HRRZ TAC1,TAC		;YES. DO 1K OF IT.
	CAML TAC1,SHFEND	;ARE WE DONE?
	JRST CIP12		;YES.
	BLT TAC,1777(TAC1)	;MOVE THAT CORE.
	MOVE TAC,[XWD 2000,2000]
	ADDM TAC,SHFTAC		;UPDATE SHFTAC
	HRRZ TAC,SHFTAC		;WAS THAT THE LAST?
	CAMGE TAC,SHFEND
	JRST CIP11
CIP12:	PUSHJ P,NOTSH1		; FINISHED. MARK IT DONE.
	PUSHJ P,SHFDONE
>	;END OF IFN FTSHF1K

CIP11:	HGMAC(11)
	SOSG HNGTIM		;DECREMENT HUNG IO DEVICE 
	PUSHJ PDP,DEVCHK	;GO CHECK FOR HUNG IO DEVICES
CIP6:	CONO PI,APRON		; ENABLE CLOCK TRAPS IF THEY WERE OFF
	HGMAC(1)
	SKIPE COMCNT		;ANY COMMANDS TO PROCESS?
	PUSHJ PDP,COMMAND	;YES, CALL COMMAND DECODER.
	HGMAC(6)
CIP6A:	PUSHJ PDP,NXTJOB	;CALL SCHEDULER
	HGMAC(15)
	SETZM SCHEDF(PID)	;CLEAR FORCED SCHEDULING FLAG
	SETZM TIMEF(PID)	;CLEAR "CLOCK FIRED" FLAG
	JUMPN J,CLKSRJ		; IF NULL JOB RUNNING, DO FOLLOWING TEST
	JUMPN PID,CLKSRJ
	MOVE AC1,[XWD -RUNQ,-RUNQ]
	MOVE AC2,[XWD -TQ,-TQ]
	CAMN AC1,JBTQ-RUNQ
	CAME AC2,JBTQ-TQ	; IF ANYBODY RUNNABLE, BUMP COUNT
	AOS NJRNULLS
CLKSRJ:	MOVEI	TAC1,1		;THIS BIT WILL REPRESENT THE NEW JOB
	SETZ	TAC,		; SOMEWHERE IN TAC OR TAC1
	LSHC	TAC,(J)		;MOVE BIT TO APPROPRIATE POSITION
	ORM	TAC,JBSRUN	; AND NOTE THIS JOB HAS BEEN RUN LATELY
	ORM	TAC1,JBSRUN+1

	CAMN ITEM,JOB(PID)	;IS NEXT JOB SAME AS LAST ONE?
	JRST CIP8		;YES, JUST RESTORE ACS AND DISMISS
	SKIPE ITEM		; ARE WE SWITCHING TO THE NULL JOB?
	AOS NJSWITCHES		; NO, MARK ANOTHER SWITCHING
;DIFFERENT JOB, SAVE SOFTWARE STATE(HARDWARE ALREADY SAVED)

	MOVE	JDAT,JOB(PID)	;GET OLD JOB NUMBER
	MOVE	TAC,TIMDAT	;GET <DATE>,,<TIME IN SECS>
	MOVEM	TAC,FTIME(JDAT)	;AND SAVE FOR JOB THAT JUST RAN

	SKIPE JDAT,JOBDAT(PID)	;NULL JOB OR CORE 0 ON OLD JOB?
	PUSHJ P,S2U		; MOVE CHANNEL ASSIGNMENTS INTO USER CORE
↑NULJOB:			;TRANSFER HERE FROM SYSINI WITH ITEM=0
CIP7:	MOVEM ITEM,JOB(PID)	;STORE NEW CURRENT JOB NUMBER
	MOVE PROG,JBTADR(ITEM)	;RELOCATION FOR CURRETN JOB
	MOVEM PROG,JOBADR(PID)	;XWD PROTEC,RELOC
IFN JDMPRG,<
	MOVE JDAT,JBTDAT(ITEM)	;LOC. OF JOB DATA AREA
	MOVEM JDAT,JOBDAT(PID)	;FOR CURRENT JOB
>
	CONO APR,550+APRCHN	; CLEAR APR ENABLED FLAGS
	HLLZS APRIN1(PID)	;DISABLE USER APR INTERRUPTS
	SETZM APRIN3(PID)
	JUMPE ITEM,NULJB	;IS NEW JOB NULL JOB?
	HLRZM PROG,USRREL(PID)	;PROTECTION FOR CURRENT JOB
	HLRZM PROG,JOBREL(JDAT)	;SET PROT. IN JOB DATA AREA FOR USER TO LOOK AT
	PUSHJ P,U2S		; MOVE USER TABLE INTO SYSTEM
	MOVE TAC,JBTIEN(J)	; PICK UP USER INTERRUPT ENABLINGS
	ANDI TAC,CPUMSK
	MOVEM TAC,APRIN2(PID)	; SET SO CH3 CAN TEST FOR THEM
	IOR TAC,JOBENB(JDAT)	;NOW INCLUDE OLD-STYLE INTS
	ANDI TAC,CPUMSK!1000	; SYSTEM ENABLED FOR PDL OV, ILM, NXM, CLK
	HRRM TAC,APRIN1(PID)	; PUT IN USER ENABLED LOC
	XORI TAC,110		; COMPLEMENT FOV, AROV, SO 0 MEANS ENABLE
				; AND 1 MEANS DISABLE
	ADDI TAC,330		; SET BITS 27 AND 30 IF DISABLE
				; SET BITS 28 AND 31 IF ENABLE
	ANDI TAC,660		;MASK OUT ALL BUT PC CHNG+AROVF ENABLE-DISABLE
	CONO APR,APRCHN(TAC)	;ENABLE OR DISABLE PC CHNG AND AR OVF
	JRST CIP8		; JUMP TO PAGE AFTER NEXT
;S2U AND U2S
S2U:	MOVEI TAC,JOBPRT(JDAT)	;DEST.=FIRST LOC PROTECTED FROM USER
	HRLI TAC,USRPRT(PID)	;SOUR.=SYSTEM DATA STORAGE FOR CURRETN JOB
	SKIPL TAC1,USRHCU(PID)
	JRST CIP14
	SUBI JDAT,2
	JRST CIP13
CIP14:	CAILE TAC1,17		;MUST BE 17 OR LESS(IO MIGHT
				;CLOBBER IF ADDRESS CHECKING MISSES)
	MOVEI TAC1,17		;MOVE ALL 20 CHANNELS IF NEG.
				;OR LESS THAN 0.
	ADD JDAT,TAC1		;RELOCATE TO USER AREA
CIP13:	BLT TAC,JOBJDA(JDAT)	;MOVE TO USER JOB DATA AREA
				;STOP WITH USER CHANNEL 0-1+C(USRHCU)
	POPJ P,

U2S:	MOVEI TAC,USRPRT(PID)	;DEST.=PROTECTED AREA IN MONITOR
	HRLI TAC,JOBPRT(JDAT)	;SOURCE=FIRST PROTECTED LOC. IN JB  DATA AREA
	SKIPL TAC1,JOBHCU(JDAT)	;MOVE NO. OF USER IO CHAN. IN USE
	CAILE TAC1,17		;MUST BE 17 OR LESS(IO MIGHT CLOBBER
				;IF ADRRESS CHECKING MISSES
	MOVEI TAC1,17		;MOVE ALL 20 CHAN. IF NEG. OR GREATER THAN 17
	BLT TAC,USRJDA(TAC1)	;AND MOVE INTO MONITOR
	POPJ P,
;RESTORE HARDWARE STATE OF CURRENT JOB

CIP8:	JUMPE	PID,CIP8A
	JUMPE	J,CIP8A
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/PDP-6 TRIED TO RUN JOB!
/
	POPACS
	SETZB	J,JOB(PID)	;MAKE SURE IT IS THE NULL JOB!
	JRST	NULJB

CIP8A:	PUSHJ P,GETPR
	DATAO APR,TAC
IFN FTSWAP,<
	SETOM STIME(ITEM)	; MARK THAT THIS JOB HAS BEEN RUN
	LDB TAC,PSEGN		; AND MARK HIGH SEGMENT TOO
	MOVE TAC1,JBTSTS(TAC)	; IF IT IS NOT WRITE-PROTECTED
	TLNN TAC1,JWP
	SETOM STIME(TAC)	; IF WRITE-ENABLED, MARK USED.
>
	SKIPE JDAT,JBTDAT(ITEM)	;JOB DATA AREA(IS THERE ONE?)
	JRST CIP8B
	SKIPE NULBAD(PID)	; IS THE NULL JOB SICK?
	JRST NULJB		; YES, GO FIX IT
	MOVEI JDAT,NULDAT(PID)	;NO, MUST BE NULL JOB
CIP8B:	MOVE TAC,JOBD17(JDAT)
	MOVEM TAC,CLKS17(PID)
	MOVSI 17,JOBDAC(JDAT)	;RESTORE DUMP ACS
	JUMPE PID,CIP8C
	BLT 17,16
	MOVE 17,[P2PID]
	SKIPE APRERR(17)
	JRST CLKERR
	MOVE 17,CLKS17(17)
	JEN @USRPC+P2PID
CIP8C:	MOVN J,J
	MOVSI TAC,400000
	LSH TAC,(J)
	DATAO PI,TAC
	BLT 17,16
	MOVE 17,[P1PID]
	SKIPE APRERR(17)		;ERROR IN THE EXEC?
	JRST CLKERR			;YES. GO PROCESS.
	MOVE 17,CLKS17(17)
	JEN @USRPC+P1PID	; RETURN TO USER.

PMONTB:	POINT 6,MONTAB(TAC),5	;POINTER TO NO. DAYS IN MONTH
;THE NULL JOB
;RUNS IN USER MODE WITH PC=1 AND COUNTS IN AC 0

NULJB:	SOSL CHKYET(PID)
	JRST NULJB1
	MOVEI TAC1,=1000	; ONLY CHECKSUM EVERY THOUSAND TIMES
	MOVEM TAC1,CHKYET(PID)
	PUSHJ P,SYSFIX		;CHECK FOR ERROR AND FIX
	JRST NULJB1		;NO ERRORS
	JFCL			;ERROR, BUT CAN'T FIX, FIX CHECKSUM
	MOVE TAC,MONPTR		;RECOMPUTE CHECKSUM, ERROR FIXED!
	PUSHJ P,CHECK
	MOVEM TAC1,MONSUM
NULJB1:	SETZM NULBAD(PID)
	JUMPN PID,NULSIX
	MOVSI 17,NULJ10		; SET UP BLT TO ACCUMULATORS
	BLT 17,NULL10		; BLT IN ZINGHEIM'S NULL JOB
	JRST 11,1		;DISMISS IF INTERRUPT IN PROGRESS
NULSIX:	MOVSI 17,NULJ6
	BLT 17,NULL6
	JRST 11,1

NULJ10:	0
	ROT 0,-1	; RING AROUND THE ACCUMULATOR
	TLNN 0,200000
	TLC 0,400000
	MOVEI 10,70000
	SOJGE 10,5
	JRST 1
NULL10←←.-NULJ10

NULJ6:	0
	ROT 0,1		; RING AROUND THE ACCUMULATOR
	TRNN 0,2
	TRC 0,1
	MOVEI 10,34000
	SOJGE 10,5
	XCT SIXRUN	;TRAP IF CORE GETS CLEARED
	JRST 1
NULL6←←.-NULJ6
; CHECKSUM ROUTINE. CALL WITH IOWD IN TAC, RETURNS CHECKSUM IN TAC1.

↑CHECK:	MOVEI TAC1,0
	JCRY0 .+1
	ADD TAC1,(TAC)
	JCRY0 [AOJA TAC1,.+1]
	AOBJN TAC,.-2
	HLRZ TAC,TAC1
	HRRZS TAC1
	ADD TAC1,TAC
	TLZE TAC1,1
	ADDI TAC1,1
	POPJ PDP,
BEGIN	SYSFIX	;VERIFY SYSTEM CHECKSUM AND FIX IT IF WRONG.
; ROUTINE TO RE-READ THE PROTECTED PART OF THE MONITOR FROM LIBRASCOPE
; CALLED BY:
;	PUSHJ P,SYSFIX
;	<NO ERRORS>
;	<ERROR, BUT COULDN'T FIX>
;	<ERRORS FIXED>


↑↑SYSFIX:
	PUSH	P,TAC
	PUSH	P,TAC1
	MOVE	TAC,MONPTR
	PUSHJ	P,CHECK		;CHECKSUM MONITOR
	CAME	TAC1,MONSUM	;IS IT OK?
	JRST	NOTOK
	POP	P,TAC1
	POP	P,TAC
	POPJ	P,		;ALL IS WELL

NOTOK:	POP	P,TAC1
	POP	P,TAC
↑↑SYSCHK:
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/⊗π⊗π⊗π⊗MONITOR CHECKSUM FAILURE.
/
	JUMPN	PID,SIXFIX	;THE PDP-6 CANT FIX ANYTHING
	CONSO	DSK,1B27	;IS THERE ANY DISK TODAY?
	SKIPN	SYSTHERE	;IS THIS SYSTEM OUT THERE?
	JRST	NOFIX
	JRST	GOFIX		;ATTEMPT TO FIX ERRORS

SIXFIX:	SETZM	CHKYET+P1PID	;TELL THE PDP-10 TO LOOK SOON
NOFIX:	POPACS			;IF DISK IS OFF-LINE, NOTHING WE CAN DO.
	JRST	CPOPJ1		;TELL THEM NOTHING FIXED!

GOFIX:	SETOM	ERRYET		
REPEAT 0,<			;12/1/73
	CONI	APR,TAC		;THE REMEMBER STATE OF SYS REF KLUGE
	PUSH	P,TAC		;THE ONLY WAY OUT GOES THRU FIXXIT
	DATAO	PTR,[0]		;SHUT OFF THE SYS REF KLUGE.
>
	CONSO	IOP,777770	;IF NO BITS ON, IS IDLE.
	JRST	IOPOK
	MOVSI	UUO,1
	CONSO	IOP,IOPJDN!IOPANY;IF JOB DONE, OR ANY ERROR IS UP, IS OK
	SOJG	UUO,.-1		;IF OTHER BITS ON BUT NOT JOB DONE, OR ERROR WAIT FOR IT
IOPOK:	CONI	IOP,IOPSAV#	;SAVE THE STATUS OF THE IOP
	SKIPN	UUO,MONPTR	;IOWD FOR THE PROTECTED PART OF THE MONITOR
	JRST	FIXXIT		;IF NOT SET UP YET, FORGET IT! (WHEREDAFUCKAREWE)
	
	HRRZ	AC1,UUO
	LSH	AC1,-5		;THIS SHOULD BE THE STARTING SECTOR COUNT
	MOVEI	AC2,37
	AND	AC2,UUO		;GET OFFSET FOR FIRST 40 WORDS
	SUBI	AC2,FIXLEN	;AND THAT LEAVES....
				;READ FIXLEN WORDS AT A TIME AND COMPARE WITH MEMORY

DONXT:	MOVEI	AC3,40		;WE WILL TRY THIS MENY TIMES
DOAGIN:	CONO	IOP,0
	CONO	DSK,14000
	DATAO	IOP,[XWD -FIXLEN,FIXBUF]
	PUSH	P,AC1		;SAVE SECTOR #
	CAIL	AC1,2300	;WRAP TO NEXT TRACK?
	ADDI	AC1,1B24-2300	;YES, ADJUST
	ADD	AC1,SYSBAND
	DATAO	DSK,AC1
	POP	P,AC1		;RESTORE SECTOR #
	CONSO	IOP,IOPANY!IOPJDN;WAIT FOR IOP TO FINISH
	JRST	.-1
	CONSO	IOP,IOPANY	;ANY ERRORS?
	CONSZ	DSK,3370
	SOJG	AC3,DOAGIN
	JUMPLE	AC3,FIXXIT
CHKWRD:	AOJG	AC2,NXTCHK
	MOVE	AC3,FIXBUF+FIXLEN-1(AC2)
	CAME	AC3,(UUO)
	JRST	PRNDIF		;TELL THE WORLD!
STRDON:	AOBJN	UUO,CHKWRD
	AOSLE	TAC,ERRYET	;DONE WITH CHECK.
	JRST	FIXXTB		;THERE WERE ERRORS.
	PUSHJ	P,DISMES
	ASCIZ	/NO ERRORS FOUND.
/
	JRST	FIXXIT
FIXXTB:	PUSHJ	P,DISDCP
	PUSHJ	P,DISMES
	ASCIZ	/  ERRORS.
/
FIXXIT:	MOVE	UUO,IOPSAV	;SUCCESS. NOW TRY TO PUT THE WORLD BACK.
	TRNE	UUO,IOPJDN	;IF JOB DONE IS ON, PUT UP DATA MISSED ALSO
	TRO	UUO,IOPMIS	;TO DO PREVIOUS TRANSFER OVER FOR GOOD MEASURE
	CONO	IOP,(UUO)	;SINCE WE FORGET THAT THERE WAS AN ERROR
REPEAT 0,<
	POP	P,TAC		;RESTORE STATE OF SYS WR REF KLUGE
	TRNE	TAC,SWRENB	;WAS KLUGE ENABLED?
	DATAO	PTR,[1]		;YES. IT WAS. TURN IT BACK ON.
>
	POPACS
	JRST	CPOPJ2

PRNDIF:	PUSHACS
	AOSLE	TAC,ERRYET
	JRST	PRNDF1
	PUSHJ	P,DISMES
	ASCIZ	/LOC     CORE            DISK
/
	MOVEI	TAC,0
PRNDF1:	CAIL	TAC,10		;ONLY PRINT THE FIRST 8 ERRORS
	JRST	PRNDF2
	MOVEI	TAC,(UUO)
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/   /
	MOVE	TAC,(UUO)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ	/    /
	MOVE	TAC,AC3
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
PRNDF2:	POPACS
	MOVEM	AC3,(UUO)	;FIX THE SYSTEM!
	JRST	STRDON		;AND CONTINUE LOOKING.

NXTCHK:	ADDI	AC1,FIXNUM
	MOVNI	AC2,FIXLEN		;THIS MANY WORDS FROM NOW ON!
	JRST	DONXT


BEND SYSFIX
↑SYSFIX←SYSFIX
; THIS IS WHERE THE USER INTERRUPT HANDLER RESIDES . . .

↑INTRUN:
	SETZM INTREQ(PID)
	SETZM AC1
	EXCH AC1,APRIN3(PID)
	JUMPE AC1,INTR6
	MOVEM AC1,USRPC(PID)	; GET RIGHT USRPC (INSTEAD OF JOBTM5)
INTR6:	PUSH P,LASTPR(PID)	; WE WILL RESET PR FROM THIS
	PUSH P,USRSAV(PID)	; WE MIGHT HAVE INTERRUPTED UUOCON BEFORE IT IS REENTRANT, SO SAVE ALL THIS STUFF . . .
	PUSH P,UUO0(PID)	; THE UUO LOCATION
	PUSH P,@UUOLOC(PID)	; THE UUO ITSELF
IFN FTXCTR,<PUSH P,160
	    PUSH P,@161>	; FOR XCTR SIMULATOR
	MOVE AC1,JOB(PID)
	MOVEM AC1,SJOB(PID)	; NOW SAVE AWAY THE JOB NUMBER WHERE WE CAN FIND IT AGAIN REDILY
	PUSH P,@CLKCH(PID)	; WE MUST ALSO SAVE AWAY CLKINT'S DATA BECAUSE IT IS NOT REENTRANT
	PUSH P,CLKS17(PID)	; IT DEPENDS ON THIS STAYING CONSTANT TOO!
	PUSH P,JOBDAT(PID)	; THESE ARE FOR THE REENTRANT PART OF UUOCON. FIRST THE JOB ADDRESS
	PUSH P,USRREL(PID)	; NEXT THE HIGHEST LOCATION IN THE LOSER'S CORE
	PUSH P,SCHEDF(PID)	; WE MUST SAVE THIS BECAUSE WE MIGHT HAVE INTERRUPTED WSCHED
	PUSH P,APRPC(PID)	; SAVE ANY APR ERRORS THAT MAY BE, BECAUSE THE I-LEVEL PROCESS MAY MAKE ITS OWN
	PUSH P,APRERR(PID)
	PUSH P,APRIN1(PID)
	MOVEI AC1,1(P)		; SAVE USER CHANNEL TABLE TOO
	HRLI AC1,USRPRT(PID)
	MOVEI AC2,(AC1)
	ADDI AC2,USRJDA+17-USRPRT
	BLT AC1,(AC2)
	ADD P,[XWD USRJDA+20-USRPRT,USRJDA+20-USRPRT]
	SETOM INTACT(PID)	; WE ARE NOW AT INTERRUPT LEVEL
	MOVEI J,JOBN-1
INTR2:	SKIPN AC1,JBTIRQ(J)	; INTERRUPT WAITING HERE?
INTR1:	SOJG J,.-1		; NO
	JUMPE J,INTXIT		; IF NONE AT ALL, GO AWAY
	PUSHJ P,GETINT		; GET THE BIT CORRESPONDING TO THE INTERRUPT
	JRST INTR1		; ALL MASKED OUT, LOOP BACK FOR NEXT GUY
	MOVE AC2,JBTSTS(J)
	TLNN AC1,INTSWW!INTSHW	; IF THIS IS A SHUFFLE OR A SWAP INTERRUPT, THE JOB IS REALLY THERE!
	TLNN AC2,SWP!SHF
	SKIPN PROG,JBTADR(J)	; IS THIS JOB REALLY HERE?
	JRST INTSWAPIN		; I GUESS NOT. HAVE HIM SWAPPED IN IF HE IS SWAPPED OUT.
	LDB AC3,PSEGN		; DOES HE HAVE AN UPPER?
	JUMPE AC3,INTR11
	MOVE AC2,JBTSTS(AC3)	; SEE IF IT IS IN CORE
	TLNN AC1,INTSWW!INTSHW
	TLNN AC2,SWP!SHF
	SKIPN JBTADR(AC3)
	JRST INTSWS		; SWAP SEGMENT IN
INTR11:	SKIPE JBTIIP(J)		; IS THIS JOB ALREADY AT I-LEVEL?
	JRST [	SETOM INTREQ(PID)
		JRST INTR1]
INTR9:	MOVE AC1,JBTIRQ(J)	; PICK UP INTERRUPT BITS AGAIN
	PUSHJ P,GETINT		; GET BIT CORRESPONDING TO INTERRUPT
	JRST INTR1		; ALL MASKED OUT
	JRST INTR7		; GOT IT. GO SERVICE INTERRUPT
; ROUTINE TO GET FIRST SERVICABLE INTERRUPT BIT FROM WORD OF BITS
; ENTER WITH COPY OF JBTIRQ IN AC1
; WILL RETURN SINGLE SERVICABLE BIT IN AC1

GETINT:	MOVSI AC2,INTWAIT
	TDNE AC2,JBTIEN(J)
	JRST GTINT1		; HERE IF TRYING TO FINISH UUO (VIA UWAIT)
	MOVEI AC3,
INTR8:	JFFO AC1,.+1		; PICK OFF FIRST BIT. SERVE INTERRUPTS ONLY ONE AT A TIME.
	MOVNS AC2
	MOVSI AC1,(1B0)
	LSH AC1,(AC2)		; AC1 NOW CONTAINS ONLY ONE BIT AND IT IS IN THE POSITION OF THE FIRST BIT IN JBTIRQ(J)
	TDNE AC1,JBTMSK(J)	; SEE IF THIS PROCESSOR IS ENABLED FOR THIS INTERRUPT
	JRST CPOPJ1
	IORB AC1,AC3
	ANDCA AC1,JBTIRQ(J)	; ARE THERE ANY MORE INTERRUPTS PENDING?
	JUMPE AC1,CPOPJ		; NO, GO ON TO NEXT GUY
	JRST INTR8		; YES

GTINT1:	TDNN AC2,AC1		; SKIP IF INTWAIT ENABLED AND REQUESTED
	POPJ P,			; ENABLED BUT NOT REQUESTED YET
	MOVE AC1,AC2
	JRST CPOPJ1		; DO INTWAIT INT FIRST
; HERE WE CLEAR THE INTERRUPT BIT IN JBTIRQ AND ACTUALLY
; START UP THE INTERRUPT PROCESS

INTR7:	TDNN AC1,JBTIRQ(J)
	JRST INTR9		; SOMEONE ATE THE INTERRUPT FROM UNDER US
	ANDCAM AC1,JBTIRQ(J)	; WE HAVE SERVICED THIS INTERRUPT SO FORGET IT.
	TDNN AC1,JBTIEN(J)	; IS THIS GUY ENABLED FOR THIS INTERRUPT?
	JRST INTR2		; NO, FORGET IT.
	SKIPN JBTIIP(J)
	JRST INTR14
	IORM AC1,JBTIRQ(J)
	SETOM INTREQ(PID)
	JRST INTR2		; TRY TO GET BACK NEXT TICK
INTR14:	IORM AC1,JBTIIP(J)	; YES, HE NOW HAS THIS INTERRUPT IN PROGRESS
	HLRZ TAC,PROG
	SKIPN AC3,JOBINT(PROG)	;DOES HE WANT INTS SOMEWHERE ELSE?
	JRST INT14A		;NO
	ADDI AC3,2		;THIS MUST BE LEGAL, TOO
	CAIL AC3,JOBPFI+2
	CAILE AC3,(TAC)
	JRST INTADC		;SHIT ON HIM (MUST BE IN LOWER)
	ADDI AC3,(PROG)
	SKIPA AC2,AC3		;THE BITS GO HERE-2
INT14A:	MOVEI AC2,JOBCNI+2(PROG);OR HERE
	MOVEM AC1,-2(AC2)	; PUT HIS INTERRUPT BITS WHERE HE CAN FIND THEM
	SKIPN AC2,AC3
	MOVEI AC2,JOBAPR(PROG)
	HRRZ AC2,(AC2)		; PICK UP HIS TRAP ROUTINE ADDRESS
	CAIL AC2,JOBPFI
	CAILE AC2,(TAC)
	CAIA
	JRST INTR10
	LDB AC1,PSEGN		; SEE IF PC IS IN UPPER
	JUMPE AC1,INTADC	; NO UPPER, ERROR
	HLRZ AC1,JBTADR(AC1)
	ADDI AC1,400000
	CAIL AC2,400000
	CAMLE AC2,AC1
	JRST INTADC		; OUT OF UPPER, ADDRESS CHECK
; HERE WE INITIALIZE ALL THE SYSTEM VARIABLES IN PREPARATION FOR RUNNING THE USER INTERRUPT PROCESS

INTR10:	PUSH P,UUOPC(J)		; SAVE HIS UUO LEVEL PC TOO
	MOVEM PROG,JOBDAT(PID)	; SET UP ADDRESS OF USER AREA FOR UUOCON.
	HLRZM PROG,USRREL(PID)	; UUOCON NEEDS JOBDAT, USRREL, AND JOB, AND THAT'S ALL
	MOVEM J,JOB(PID)	; THIS IS OUR TEMPORARY JOB NUMBER
	CAME J,SJOB(PID)	;MIGHT ALREADY BE THERE
	PUSHJ P,U2S		; PICK UP JOBJDA
	SETZM APRERR(PID)	; CLEAR OUT THIS BECAUSE PREVIOUS JOB MAY HAVE HAD AN ERROR
	SETZM APRPC(PID)
	SETZM APRIN1(PID)
	SETZM SCHEDF(PID)
	SETOM STIME(J)		; MARK CORE IMAGE AS ALTERED NOW.
	LDB AC1,PSEGN		; SEE IF WE MUST MARK UPPER
	JUMPE AC1,INTR5		; NONE THERE.
	MOVE AC2,JBTSTS(AC1)	; DON'T MARK CORE IMAGE DIRTY IF WRITE PROTECTED
	TLNN AC2,JWP
	SETOM STIME(AC1)
INTR5:	MOVNI AC1,10
	MOVEM AC1,INTQUANT(PID)	; HE GETS 8 TICKS BEFORE DOOM STRIKES
	MOVEI AC1,INTCH7
	MOVEM AC1,INTDISP(PID)	; COUNT DOWN HIS QUANTUM TIME EVERY CLOCK BREAK
	MOVM AC1,JOBQUE(J)	; SEE IF HE IS WAITING FOR AN INTERRUPT
	CAIE AC1,INTWQ
	JRST INTWRJ
	MOVE AC1,JBTIIP(J)	; DO WE WAKE HIM UP?
	TDNN AC1,JBTWKM(J)
	JRST INTWRJ		; NO
	MOVNI AC1,TQ		; YES, WAKE HIM UP WITH HIGH PRIORITY
	MOVEM AC1,JOBQUE(J)
	PUSHJ P,REQUE
INTWRJ:	PUSHJ P,GETPR		; SET UP PROTECTION-RELOCATION
	DATAO APR,TAC
	MOVEM P,INTSP(PID)	; ALL WE NEED TO SAVE IS THE STACK POINTERS.
				; CLKINT DOESN'T DEPEND ON ACCUMULATORS.
	MOVE AC2,JBTIIP(J)
	TLNN AC2,INTWAIT	; IF WE ARE TRYING TO DEBREAK,
				; MUST GIVE HIM HIS UUO-LEVEL ACCUMULATORS
	JRST INTR4
	ANDCAM AC2,JBTIEN(J)	; HE IS NO LONGER ENABLED FOR INTERRUPT-WAIT
	SKIPN AC2,AC3
	MOVEI AC2,JOBTPC+1(PROG)
	MOVE AC1,USRPC(PID)	; GIVE HIM HIS MOST ACCURATE PC
	MOVEM AC1,-1(AC2)
	MOVSI 17,JOBDAC(PROG)	; GIVE HIM HIS UUO-LEVEL ACCUMULATORS TO SAVE AWAY
	MOVE AC1,JBTUPC(J)	; AND RESTART HIM JUST AFTER THE UWAIT UUO
	MOVEM AC1,UUO0(PID)
	JUMPE PID,INTR15
	BLT 17,17
	JRST 13,@UUO0+P2PID
INTR15:	BLT 17,17
	JRST 13,@UUO0+P1PID
; HERE, HE IS NOT CONTINUING AFTER A UWAIT, BUT IS BEING RUN REGULARLY

INTR4:	MOVSI AC1,JOBAC(PROG)
	HRRI AC1,INTACS(PID)	; SAVE HIS UUO-LEVEL ACCUMULATORS, FOR HE WILL DO UUO'S
	BLT AC1,INTACS+17(PID)
	MOVE AC1,USRPC(PID)	;SHOULD BE HERE BY NOW
	TLNE AC1,USRMOD
	JRST INTR4A
	MOVE AC1,UUOPC(J)	; IF IN EXEC, GIVE HIM HIS LAST UUO-LEVEL PC.
	CAIN AC1,USRXT5
	MOVE AC1,UUO0(PID)	;WHICH MAY BE HERE IF WE INTERRUPTED UUOCON EARLY
	TLZN AC1,USRMOD		;FLAG IT AS COMING FROM EXEC
	TDZA AC1,AC1		;OR RET ZERO IF WE DON'T KNOW IT (RECURSION CONFUSION)
	SUBI AC1,1		;ADJUST IT TO POINT AT HIS UUO
INTR4A:	SKIPE AC2,AC3
	JRST .+3
	MOVEI AC2,JOBTPC+1(PROG)
	MOVEI AC3,JOBAPR(PROG)
	MOVE AC3,(AC3)
	MOVEM AC1,-1(AC2)
	MOVE AC2,JBTPRV(J)
	TLNN AC2,LUPPRV
	TLZ AC3,4000		;DON'T SET IOT USER UNLESS LOCAL
	MOVE 16,J		; NOW SET UP HIS ACCUMULATORS
	MOVE 2,PROG
	MOVE 1,SPWBUT
	SETZM 3
	MOVE 15,JBTIIP(16)
	TLNE 15,INTSHW!INTSWW
	SETOM 3			; IF HE IS ABOUT TO GET SHUFFLED OR SWAPPED, TELL HIM
	MOVEI 4,1
	SKIPE PID
	MOVEI 4,2		; PROCESSOR NUMBER IN 4
	SETZM 5			; 5 TELLS WHETHER THE OTHER PROCESSOR IS ALIVE
	MOVE 6,JBTSTS(16)	; HE WANTS HIS STATUS WORD IN 6 TOO
	LDB 7,[POINT 6,JBTSTS(16),35]
	HLRZ 7,JBTADR(7)
	MOVE 10,INTDTM(16)
	MOVM 14,JOBQUE(16)	;TELL HIM HIS CURRENT Q
	SKIPN P2NUM
	JRST SIXDED
	CAIE 4,1
	JRST SIXTST
	SKIPGE PALIVE+P2PID
	SETOM 5
	JRST 13,(AC3)		;AC3 HAD BETTER THE HELL NOT BE CLOBBERED BY SHIT ABOVE
SIXTST:	SKIPGE PALIVE+P1PID
SIXDED:	SETOM 5
	TLZ AC3,37	;AVOID @ LOOPS
	JRST 13,@AC3	;SINCE JRST 2,() DOESN'T WORK ON 6
; ROUTINE TO TYPE OUT ERROR MESSAGE FOR ILL. STARTING ADDRESS

INTADC:	SETZM JBTIIP(J)		; IF ADDRESS CHECK, GET HIM OUT OF INTERRUPT LEVEL
	PUSHJ P,TTYERP		; NOW GIVE HIM A NASTY MESSAGE
	PUSHJ P,INLMES
ASCIZ /INTERRUPT ADDRESS OUT OF BOUNDS
/
	PUSHJ P,HOLD		;PRINT ↑C CRLF . CRLF.  CALL TTYSTC AND ESTOP
	JRST INTR1

INTXIT:	JRST 2,@[.+1]
	SETZM INTACT(PID)	; ALL DONE. RESTORE ALL THE STUFF WE SAVED UP FRONT.
	SETZM INTDISP(PID)
	HRLI AC1,-USRJDA-20+USRPRT+1(P)
	HRRI AC1,USRPRT(PID)
	BLT AC1,USRJDA+17(PID)
	SUB P,[XWD USRJDA+20-USRPRT,USRJDA+20-USRPRT]
	POP P,APRIN1(PID)
	POP P,APRERR(PID)
	POP P,APRPC(PID)
	POP P,SCHEDF(PID)
	POP P,USRREL(PID)
	POP P,JOBDAT(PID)
	POP P,CLKS17(PID)
	POP P,@CLKCH(PID)
IFN FTXCTR,<POP P,@161
	    POP P,160>		; FOR XCTR SIMULATION
	POP P,@UUOLOC(PID)
	POP P,UUO0(PID)
	POP P,USRSAV(PID)
	POP P,LASTPR(PID)	; RESTORE PR
	MOVE J,SJOB(PID)
	MOVEM J,JOB(PID)
	DATAO APR,LASTPR(PID)	; RESTORE JOB'S PROTECTION-RELOCATION
	POPJ P,
; ROUTINE TO SWAP A GUY IN SO HE MAY BE INTERRUPTED

INTSWAPIN:
	MOVE AC3,J		; AC3 IS JOB TO TEST FOR BEING IN
	PUSHJ P,INTSWT		; SWAPIN TEST SUBR
	JRST INTR1		; NO CAN DO
	LDB AC3,PSEGN		; GET SEGMENT #
	JUMPE AC3,INTR1
	MOVE TAC,JBTSTS(AC3)
	TLNE TAC,SWP		; IF SWAPPED OUT,
	JRST INTR1		; NORMAL THING WILL HAPPEN
	MOVSI TAC,JHLDIN	; ELSE HOLD IT IN
	IORM TAC,JBTSTS(AC3)	; FOR LOWER
	JRST INTR1

INTSWS:	PUSHJ P,INTSWT		; AC3 JOB TO BRING IN, J LOWER
	JRST INTR1
	MOVE TAC,JBTSTS(J)
	TLNE TAC,SWP		; IF LOWER IS SWAPPED OUT,
	JRST INTR1		; LET NORMAL THING HAPPEN
	MOVSI TAC,JHLDIN
	IORM TAC,JBTSTS(J)	; ELSE HOLD HIM IN FOR UPPER
	JRST INTR1

INTSWT:				; SEE IF HE IS MASKED OUT
	TDNN AC1,JBTMSK(J)	; ARE ANY OF THOSE BITS ON?
	POPJ P,			; APPARANTLY NOT, DON'T BOTHER TO CALL HIM IN
	SETOM INTREQ(PID)	; COME BACK NEXT TIME AROUND TOO
	MOVE AC2,JBTSTS(AC3)
	TLNN AC2,SWP		; NEED TO GET HIM IN CORE?
	POPJ P,			; NO, MUST BE SHUFFLE, JUST WAIT
	EXCH AC3,J		; GET US IN J
	MOVSI TAC,INTSNB
	PUSHJ P,SETSIN		; PUT INTO SWAP IN LIST
	EXCH AC3,J
	JRST CPOPJ1
; WE COME BACK TO HERE AFTER AN INTERRUPT - INTCH7,INTDSM,INTOUT,INTERR
; NOW WE HAVE TO FIGURE OUT HOW WE GOT HERE AND WHAT TO DO ABOUT IT

INTCH7:	SKIPE APRERR(17)	; THIS IS THE PLACE WE COME UPON CH7 BREAKS WHILE AN I-LEVEL PROCESS IS RUNNING. FIRST CHECK FOR APR ERRORS
	JRST INTAPR
	SKIPE SCHEDF(17)	; SEE IF THE BOOB HAS GOT HIMSELF IN IO WAIT
	JRST INTERP		;MAY HAVE BEEN FROM ESTOP, SO CHECK JERR
	AOSL INTQUANT(17)	; OR MAYBE HIS TIME HAS EXPIRED
	JRST INTOUT		; YES
	JUMPE 17,INTOK
	MOVE 17,CLKS17+P2PID
	JEN @CL2CHL
INTOK:	MOVE 17,CLKS17+P1PID
	JEN @CLKCHL
INTOUT:	JSR @CLKESV(17)		;SETS UP J, PROG, P, DOES S2U SOMETIMES, ETC.
	PUSHJ P,TTYERP
	PUSHJ P,INLMES
ASCIZ /?
I-LEVEL TIME-OUT/
	MOVE TAC1,@CLKCH(PID)
INTERR:	PUSHJ P,PCP
	PUSHJ P,PRCRCC
	PUSHJ P,TTYSTC
	PUSHJ P,ESTOP
INTDSM:	SETZM ESTINT
	MOVE P,INTSP(PID)	; HERE WE ARE AT THE DISMIS UUO
	MOVE J,JOB(PID)		; PICK UP ALL THE ACCUMULATORS
	MOVE PROG,JOBDAT(PID)
	POP P,UUOPC(J)
	MOVEI AC1,JOBAC(PROG)
	HRLI AC1,INTACS(PID)	; PUT BACK EVERYTHING
	BLT AC1,JOBAC+17(PROG)
	CAME J,SJOB(PID)	;DON'T BOTHER IF ALREADY OK
	PUSHJ P,S2U		; MOVE JOBJDA BACK
	SETZM JBTIIP(J)		; GET HIM OUT OF INTERRUPT LEVEL
	JRST INTR2
; WE GET HERE FROM A DEBREAK UUO - INTDEB, INTERP, INTAPR

INTDEB:	MOVE P,INTSP(PID)
	MOVE J,JOB(PID)
	MOVE PROG,JOBDAT(PID)
	MOVE AC1,UUOPC(J)	;ADDRESS OF WHERE WE WANT TO BE AT MAIN LEVEL
	MOVEM AC1,USRPC(PID)
	CAMN J,SJOB(PID)
	MOVEM AC1,-USRJDA-20+USRPC(P)	;THIS IS WHAT WILL BE PUT INTO USRPC!!
	HRLI AC1,JOBAC(PROG)
	HRRI AC1,JOBDAC(PROG)
	HRRI AC2,17(AC1)
	BLT AC1,(AC2)		;REAL ACS WILL BE UUO ACS AT TIME OF DEBREAK UUO
	MOVM AC1,JOBQUE(J)
	CAIE AC1,IOWQ
	JRST INTDB1
	MOVNI AC2,RUNQ		;IN CASE WE ARE FAILING TO GO BACK TO A UUO IN IOWQ
	MOVEM AC2,JOBQUE(J)
	PUSHJ P,REQUE		;(THIS USED TO BE INLINE CODE - REG)
INTDB1:	CAME J,SJOB(PID)	;NOT NECESSARY IF CURRENT JOB
	PUSHJ P,S2U
	POP P,UUOPC(J)
	SETZM JBTIIP(J)
	JRST INTR2

INTERP:	JSR @CLKESV(17)
	SKIPE ESTINT
	JRST INTDSM		;GOT HERE FROM ESTOP
	PUSHJ P,TTYERP
	PUSHJ P,INLMES
ASCIZ /?
ATTEMPT TO SCHEDULE I-LEVEL PROCESS, UUO/
	MOVE TAC1,UUOPC(J)
	SOJA TAC1,INTERR

INTAPR:	JSR @CLKESV(17)
	PUSHJ P,TTYERP
	PUSHJ P,INLMES
ASCIZ /?
USER I-LEVEL /
	MOVEI TAC,[ASCIZ /CH3 ERROR/]
	MOVE AC1,APRERR(PID)
	TRNE AC1,ILM
	MOVEI TAC,[ASCIZ /ILL. MEM. REF./]
	TRNE AC1,NXM
	MOVEI TAC,[ASCIZ /NON-EX. MEM./]
	TRNE AC1,POV
	MOVEI TAC,[ASCIZ /PDL OV/]
	PUSHJ P,CONMES
	MOVE TAC1,APRPC(PID)
	JRST INTERR
;INTKILL  ROUTINE TO CLEAR A JOB'S INTERRUPT ENABLINGS AND RESET HIS MASKS

↑INTKILL:
	PUSH P,AC1
	PUSH P,AC2
	SETZM JBTIEN(J)		; CLEAR THE ENABLE BITS FIRST
	SETZM JBTIRQ(J)		; NOW CLEAR ANY PENDING INTERRUPTS
	SETZM JBTIIP(J)
	SETOM JBTWKM(J)		; INITIALIZE THE WAKE UP MASK
	SETOM JBTMSK(J)		; NOW CLEAR THE PROCESSOR MASK
	PUSHJ P,APRDKL		;FLUSH CLOCK REQUESTS
	POP P,AC2
	POP P,AC1
	SETZM UUOPTR(J)		;ALSO DISABLE UUO INTERPRETER
	POPJ P,
;INIJOB		ROUTINE TO INITIALIZE A JOB SLOT
;CALL AT CLOCK LEVEL OR UUO LEVEL
;	PUSHJ	P,INIJOB
;	<JOB CAPACITY EXCEEDED>
;	<CANNOT GET FREE STORAGE - TRY AGAIN LATER>
;	<SUCCESS. J IS SET UP; PROG IS ZERO, JDAT IS ZERO>
;	IF YOU WANT TO MAKE THIS A REAL JOB, YOU MUST CLAIM JOB
;	SLOT BY MARKING JNA OR CMWB IN JBTSTS.

;CLOBBERS TAC
;SETS UP: JBTADR,JBTPRV,JBTBTM,JBTSTS,TTIME,RTIME,JBTUFD,DSKPPN,JBTRNB,JBTPR2,
;	  JBTKCJ,J

INIJB0:	MOVSI	TAC,JNA!CMWB
INIJB1:	MOVEI	J,1			;SEEK JOB SLOT
INIJB2:	TDNN	TAC,JBTSTS(J)
	JRST	CPOPJ1			;THIS ONE IS FREE.
	CAMGE	J,JOBNM1		;HAVE WE REACHED MAXIMUM SLOT NUMBER?
	AOJA	J,INIJB2		;NOT YET.
	MOVEI	J,0			;RETURN A ZERO
	POPJ	P,			;AND LOSE.

↑INIJOB:
	JUMPN	PID,CPOPJ		;GOD FORBID THE PDP-6 SHOULD TRY THIS
	PUSHJ	P,INIJB0		;SEEK A JOB SLOT
	POPJ	P,			;NONE AVAILABLE
	SKIPE	JBTADR(J)		;MAKE SURE THERE'S NO CORE  FOR THIS JOB
	PUSHJ	P,INIJXX		;COMPLAIN
	SKIPE	JBTPDL(J)		;DO WE HAVE A PDL YET?
	JRST	INIJB4
	PUSH	P,AC3
	PUSH	P,AC1
	PUSHJ	P,MAKPDL
	JRST	INIJB5			;HERE IF NO FREE STORAGE.
	MOVSI	TAC,JNA!CMWB		;IS THIS JOB SLOT STILL THERE?
	TDNN	TAC,JBTSTS(J)
	JRST	INIJB3			;YES. THIS SLOT IS STILL THERE.
	PUSHJ	P,INIJB1		;SEEK A NEW SLOT.
	JRST	INIJB6			;NO SLOTS
INIJB3:	MOVEM	AC1,JBTPDL(J)		;SET JOB PDL.
	POP	P,AC1
	POP	P,AC3
INIJB4:	SETZB	PROG,TTIME(J)		;NO CORE ANYWHERE.
	SETZB	JDAT,RTIME(J)
	SETZM	DSKOPS(J)		;NO DISK USAGE YET
	SETZM	JBTWAT(J)		;HAVEN'T WAITED FOR SYSTEM YET
	SETZM	JB2WAT(J)		;DITTO
	SETZM	XTIME(J)		;MAKE SURE NO-UPDATE BIT IS CLEAR IN XTIME
	MOVSI	TAC,JERR
	MOVEM	TAC,JBTSTS(J)		;AN NICE WAY TO START: JERR.
	SETZM	JBTADR(J)		;NO CORE.
	SETZM	JBTPRV(J)		;NO ACTIVE PRIVILEGES
	SETZM	JB2PRV(J)		;OR PASSIVE ONES
	SETZM	JBTTPV(J)		;OR TEMPORARY ONES
	SETZM	JBTRNB(J)
	SETZM	JBTPR2(J)		;NO PEEK-POKE
IFN FTDISK,<
	SETZM	JBTUFD(J)		;NO UFD ADDRESS
IFN FTDSKPPN,<
	SETZM	DSKPPN(J)		;NO DSKPPN
>>
	SETZM	JBTKCJ(J)		;NO KILO-CORE JIFFIES
	MOVE	TAC,TIMDAT		;GET <DATE>,,<TIME IN SECS>
	MOVEM	TAC,JBTBTM(J)		;SAVE JOB BEGINING TIME.
	MOVEM	TAC,FTIME(J)		;SET TIME LAST RUN.
	JRST	CPOPJ2			;GIVES THE (DOUBLE) SKIP RETURN.

INIJB6:	MOVEI	AC1,1(AC1)		;SET UP RIGHT ADDRESS FOR FSGIVE.
	PUSHJ	P,FSGIVE
	SOS	(P)			;NO JOBS RETURN # 0
INIJB5:	POP	P,AC1			;NO FREE STORAGE
	POP	P,AC3
	JRST	CPOPJ1			;NO F.S.  RETURN # 1

;HERE TO RELEASE AN ILL-GOTTEN JOB.
RELJOB:	JUMPN	PID,CPOPJ		;GOD FORBID THE PDP-6 SHOULD EVER TRY
	MOVEI	AC1,0
	EXCH	AC1,JBTPDL(J)
	MOVSI	TAC,JNA	
	ANDCAM	TAC,JBTSTS(J)
	JUMPE	AC1,CPOPJ
	MOVEI	AC1,1(AC1)
	JRST	FSGIVE

↑MAKPDL:				;ALSO CALLED BY SYSINI
	MOVEI	AC3,JBTPLN		;GET A PDL FOR THIS JOB.
	PUSHJ	P,FSGET			;FROM FREE STORAGE.
	POPJ	P,			;NO FREE STORAGE.
	HRLI	AC1,1-<JBTPLN+JOBPRT-JOBPFI>	;SET LEFT SIDE TO COUNT.
	SETZM	(AC1)			;ZERO FIRST LOCATION OF PDL
	MOVSI	AC3,(AC1)		;SOURCE OF BLT
	HRRI	AC3,1(AC1)		;DESTINATION
	BLT	AC3,JBTPLN-1(AC1)	;ZERO THE ENTIRE PDL.
	SOJA	AC1,CPOPJ1		;AC1 SET AS PDL POINTER. SKIP RETURN.

INIJXX:	PUSHACS				;CALLED FROM INIJOB OR ESTSG2
	PUSHJ	P,DISMES
	ASCIZ	/JBTADR NOT 0 AT INIJXX /
	PUSHJ	P,DISJOB
	PUSHJ	P,DISTAB
	MOVE	TAC,JBTADR(J)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
	POPACS
	DEBCHECK
	POPJ	P,
SUBTTL	COMCON	4 AUG 67	 THE COMMAND DECODER

;CALLED FROM CLOCK ROUTINE WHEN 'COMCNT' IS GREATER THAN 0
;AS SET BY TTY SERVICE ROUTINE
;ALL AC'S HAVE BEEN SAVED BY CLOCK CHANNEL
;THE COMMAND DECODER CALLS TTYCOM WHICH SCANS FOR TTY WHICH TYPED
;THE COMMAND AND THEN DISPATCHES(PUSHJ) TO APPROPRIATE
;COMMAND SETUP ROUTINE OF THE SAME NAME WITH AC'S SET AS:
;ITEM = JOB NUMBER
;TAC = BYTE POINTER TO COMMAND STRING(SPACE OR CR AFTER COMMAND NAME)
;DAT = BYTE POINTER TO LAST OUTPUT CHARACTER
;DEVDAT = ADDRESS OF DEVICE DATA BLOCK TYPING COMMAND
;JDAT = ADDRESS OF JOB AREA, = 0 IF NO JOB AREA
;PROG = ADDRESS OF PROGRAM AREA, 0 MEANS NOT IN CORE OR NO CORE
;IOS IS SET TO 0, USED FOR ADDRESS OF SUBSEQUENT CALLS
;DEVDAT IS ALSO PUSHED ON END OF PD LIST SO IT MAY BE DESTROYED.
;UPON RETURN FROM COMMAND SETUP ROUTINE, A CR-LF IS ADDED TO
;MESSAGE AND TTY IS STARTED ON TTY SPECIFIED BY -1(PDP)
;SEVERAL COMMAND FLAGS ARE CHECKED BEFORE DISPATCHING TO
;COMMAND SETUP ROUTINES TO SEE IF COMMAND IS LEGAL AT THIS TIME
;SEVERAL MORE FLAGS ARE CHECKED UPON RETURN FROM COMMAND SETUP
;ROUTINES(UNLESS AN ERROR HAS OCCURRED) FOR STANDARD
;COMMAND RESPONSE
;IF AN ERROR OCCURS, THE JOB NO.(ITEM) SHOULD BE 0 ON RETURN
;SO THAT JOB WILL NOT BE INITIALIZED IF FIRST COMMAND.
;ERRMES ROUTINE WILL SET ITEM TO 0

;SINCE THE COMMAND DECODER IS CALLED FROM THE CLOCK ROUTINE
;COMMAND SETUP ROUTINE MUST RUN TO COMPLETION QUICKLY
;IF A COMMAND FUNCTION CANNOT DO THIS, IT MUST JUST SET
;THE JOB TO RUNABLE STATUS AND RETURN IMMEDIATELY
;OR DELAY THE COMMAND FOR LATER EXECUTION
;COMMAND

;	HERE IF TTYCOM DIDN'T FIND ANYONE
NOCOMS:
IFN FTTTYBUG,<
	AOSG	LINSV1		;SKIP IF WE FAILED TO FIND A COMMAND TWICE
	POPJ	P,		;NO THIS IS OUR FIRST LOST COMMAND
	JRST	CNTCOM
;>	POPJ	P,		;THIS IS A NO-OP IF THERE ARE NO COMMANDS

↑COMMAND:
	PUSHJ	P,TTYCOM	;SETUP DEVDAT,DAT,TAC,AND ITEM
				;FOR ANY TTY WHICH HAS TYPED A COMMAND
	JRST	NOCOMS		;THERE WERE NO TTY'S WITH COMMANDS
	SETOM	LINSV1		;MARK THAT WE SAW A COMMAND
COM0:	PUSH	P,DDB		;SAVE TTY DEVICE DATA BLOCK ADDRESS
	PUSHJ	P,CTEXT		;SCAN COMMAND NAME, RETURN IT IN TAC1
	CAMN	TAC1,['HAL   ']	;LET ↑C THROUGH
	JRST	NOSCRU
	JUMPE	J,NOSCRU
	MOVE	AC1,JBTSTS(J)
	TLNN	AC1,JLOG
	TLNN	AC1,JNA
	JRST	NOSCRU
	MOVSI	TAC1,'K  '	;ANY COMMAND BUT ↑C FORCES LOGOUT IF NOT LOGGED IN
NOSCRU:	MOVE	AC1,TAC1	;COPY COMMAND.
	MOVNI	AC2,1		;SET MASK ALL ONES
	LSH	AC2,-6		;CLEAR OUT ONE MORE CHAR.
	LSH	AC1,6		;SHIFT 1 COMMAND CHAR OFF
	JUMPN	AC1,.-2		;IF NOT END OF COMMAND, GO AROUND
	MOVEI	DSER,0		;CLEAR FLAG REGISTER
	MOVSI	AC1,-DISPL	;SEARCH COMMAND TABLE FOR MATCH
COMLP:	CAMN	TAC1,COMTAB(AC1);EXACT MATCH?
	JRST	COMFND		;YES, THIS IS IT. (AC1 SET WITH INDEX)
	MOVE	UUO,COMTAB(AC1)	;GET FULL ENTRY NAME FROM COMMAND TABLE
	TDZ	UUO,AC2		;MASK OFF UNSPECIFIED CHARACTERS
	CAME	TAC1,UUO	;MATCH UNDER MASK?
	JRST	COMNEQ		;NO. NOT EVEN GOOD MATCH
	JUMPE	DSER,.+2
	TLOA	DSER,400000	;SET SIGN BIT TO DENOTE AMBIGUOUS MATCH
	MOVEI	DSER,1(AC1)	;COPY INDEX TO DSER - FIRST MATCH UNDER MASK
COMNEQ:	AOBJN	AC1,COMLP	;NO, KEEP LOOKING
	JUMPLE	DSER,.+2	;DID ONE AND ONLY ONE COMMAND MATCH?
	MOVEI	AC1,-1(DSER)	;YES. GET COMMAND INDEX THAT WE SAVED.
				;FALL INTO COMFND.
				;IF NOTHING MATCHES, WE HAVE ILLEGAL COMMAND
COMFND: MOVE	UUO,COMTAB(AC1)	;SAVE FULL COMMAND NAME
	MOVE	TAC1,DISP(AC1)	;GET DISPATCH TABLE ENTRY.
	PUSH	P,TAC1		;SAVE RH(DISPATCH ADR.+BITS)
	MOVE	AC1,JBTSTS(J)	;JOB STATUS WORD FOR THIS JOB
IFN FTLOGIN,<
	TLNN	AC1,JLOG	;IS JOB LOGGED IN?
	TLNE	TAC1,NOLOGIN	;NO, CAN COMMAND PROCEED WITH NO LOGIN?
	JRST	CHKNO		;YES
	TLNE	TAC1,DOLOG	;THE REG KLUGE?
	JRST	CHKNOX		;YES.  ALLOW THIS USER TO LOGIN NOW.
	JSP	TAC,COMER	;NO, TYPE "LOGIN PLEASE"
	ASCIZ	/LOGIN PLEASE
/
CHKNOX:	MOVE	TAC1,DISP-1	;INDEX FOR THE REG KLUDGE
	MOVEM	TAC1,(P)	;STORE THE BITS ON THE STACK AGAIN
>
CHKNO:
	JUMPN	J,CHKRUN 	;JUMP IF JOB NUMBER ALREADY ASSIGNED.
	TLNE	TAC1,NOJOBN	;NO, DOES THIS COMMAND NEED A JOB NUMBER?
	JRST	COMGO		;NO
	PUSHJ	P,INIJOB	;INITIALIZE A JOB
	JRST	JBCPEX		;NO JOBS AVAILABLE.
	JRST	[MOVEI	TAC1,DLYCM1	;WE NEED TO WAIT FOR FREE STORAGE.
		JRST	COMDIS]	;SO WE DELAY THIS COMMAND FOR A TICK.
	MOVE	TAC1,(P)	;RESTORE TAC1 - CLOBBERED BY INIJOB
	SETZM	DEVLOG(DDB)	;CLEAR LOGICAL NAME OF TTY
	JRST	CHKCO1

CHKRUN:
	TLNE AC1,RUN		;DEC 3.16
	TLNN TAC1,NORUN		;DEC 3.16
	JRST CHKACT		;DEC 3.16
	MOVM AC3,JOBQUE(J)
	CAIE AC3,STOPQ
	JRST CNCMES
	MOVSI AC3,RUN
	ANDCAM AC3,JBTSTS(J)	;NOTE!!!! THIS IS A FIX TO A BUG!!!!!!
	JRST CHKACT

CNCMES:	JSP TAC,COMER		;DEC 3.16
	ASCIZ /PLEASE TYPE ↑C FIRST
/

JBCPEX:	JSP TAC,COMER
	ASCIZ /JOB CAPACITY EXCEEDED
/
CHKACT:
IFN JDMPRG,<
	MOVE JDAT,JBTDAT(ITEM)	;ADDRESS OF JOB DATA AREA
>
	MOVE PROG,JBTADR(ITEM)	;XWD PROTECTION,RELOCATION
IFN FTSWAP,<
	TLNE AC1,SWP		;ARE WE SWAPPED OUT?
	SETZB PROG,JDAT		;YES. PRETEND NO CORE.
	TLNE AC1,SWP		;IS JOB ON DISK OR ON ITS WAY?
	TLNN TAC1,INCORE	;MUST JOB BE IN CORE?
	JRST CHKCO2		;NO
	TLNN TAC1,SHRINK	;SHALL WE SHRINK HIM BEFORE BRINGING HIM IN
	JRST CHKCO3		;NO.
	PUSHJ P,INTKILL		;REG 11-11-72 KILL INTERRUPTS BEFORE SHRINK
	PUSHJ P,CORX		;SHRINK BEFORE SWAP IN. RPH 8-15-71
CHKCO3:	MOVEI TAC1,DLYCOR	;YES, DELAY COMMAND.
	JRST COMDIS
>
CHKCO2:	TLNE TAC1,NOACT		;CAN COMMAND BE PERFORMED WITH ACTIVE DEVICES?
	PUSHJ PDP,RUNCHK	;NO, RETURN IF JOB STOPPED AND NO ACTIVE DEVICES
CHKCO1:	TLNE TAC1,NOCORE	;DOES THIS COMMAND NEED CORE?
	JRST COMGO		;NO. GO DISPATCH
	JUMPN PROG,COMGO	;NO, IS CORE IN MEMORY?
	JSP TAC,COMER		;NO, PRINT "NO CORE ASSIGNED"
	ASCIZ /NO CORE ASSIGNED
/
COMER:	MOVSI TAC1,NOINCK
	MOVEM TAC1,(PDP)
	MOVEI TAC1,CERR		;CALL ERROR MESSAGE ROUTINE
COMGO:	MOVSI IOS,NOSKPB
	ANDCAM IOS,(PDP)	;NO. CLEAR REQUE FLAG ON STAT	;DEC 3.16
	TLZ AC1,CMWB		;WAS JOB IN CMW?	;DEC 3.16
	MOVEM AC1,JBTSTS(ITEM)	;DEC 3.16
COMDIS:	TLNE TAC1,NOPRIV	;NEED TO CLEAR TEMPORARY PRIVILEGES?
	PUSHJ P,CLRTPV		;YES, DO IT
	MOVEI IOS,0		;CLEAR IOS FOR SETTING DISPATCH ADDRESSES
	AOS NCOMS
	PUSHJ PDP,(TAC1)	;DISPATCH TO COMMAND SETUP ROUTINE.
;RETURN FROM COMMAND SETUP ROUTINE

COMRET:	POP	P,AC2		;RESTORE COMMAND FLAGS
	POP	P,DDB		;RESTORE TTY DDB ADDRESS.
	TLNN AC2,NOSKPB
	PUSHJ P,COMR2A		;SKIP TO BREAK CHAR UNLESS REQUESTED NOT TO
	PUSHJ	P,COMR2B	;DECREMENT COMCNT
	TLNN	AC2,NOACT		;DID WE STOP SPACEWAR?
	JRST	COMRE1			;NO.
	MOVSI	AC1,SPWSUS!SPWST1!SPWST2	;PREPARE TO RESTART IT
	PSYNC	SPWCSC			;GET CONTROL OF SPW TABLES
	ANDCAM	AC1,JBTST2(J)		;ZERO OUT THE SUSPENSION BIT
	XSYNC	SPWCSC			;RELEASE CONTROL
COMRE1:	JUMPN	J,COMRT1		;DID AN ERROR OCCUR?
	TLNN	AC2,NOJOBN		;I.E., J=0 AND NOJOBN=0?
	MOVSI	AC2,NOINCK!ERRFLG	;YES, PRINT ERROR MESSAGE ONLY.
COMRT1:	MOVE	AC1,JBTSTS(J)		;JOB STATUS WORD
	TLNN	AC2,NOINCK		;SUPPRESS JOB INIT. CHECK?
	TLOE	AC1,JNA			;NO, IS JOB INIT BIT ALREADY SET?
	JRST	PCRLF			;YES.
	MOVSI	AC1,JNA			;NO, SET IT THIS COMMAND
	IORM	AC1,JBTSTS(J)
	PUSHJ	P,TTYATI		;ATTACH TTY TO JOB
	JFCL				;IGNORE IF CAN NOT(SHOULD NEVER HAPPEN)
	PUSHJ	P,PRJOB			;TYPE JOB # & CONFIG LINE
IFE FTLOGIN,<
	PUSHJ	P,PRSPC			;DEC 3.16
	PUSHJ	P,DAYTIM		;DEC 3.16	;JS
>
					;FALL INTO PCRLF
PCRLF:	TLNE AC2,ERRFLG		;DID AN ERROR OCCUR?
	PUSHJ PDP,PRQM		;YES. APPEND ?
	TLNN AC2,NOCRLF		;SUPRESS CRLF?
	PUSHJ PDP,CRLF		;NO
	TLNN AC2,NOPER		;SUPRESS PRINTING PERIOD?
	PUSHJ PDP,PRPER		;NO
	JUMPE ITEM,PCRLF1	;JOB DOES NOT RUN IF ERROR 
				;OR NO JOB NUMBER ASSIGNED.
	TLNE AC2,TTYRNU		;JOB TO RUN WHEN TTY FINISHED TYPING?
				;COMMAND RESPONSE (TTY TO USER MODE)?
	PUSHJ PDP,TTYUSR	;YES, CALL SCANNER ROUTINE
	TLNE AC2,TTYRNC		;NO, JOB TO RUN AND REMAIN IN MONITOR MODE?
	PUSHJ PDP,SETRUN	;YES, CALL SCANNER ROUTINE	;MCF(JS)
PCRLF1:	TLNN AC2,NOMESS		;IS THERE A MESSAGE?
	JRST TTYSTR		;YES, START TTY TYPING IT OUT
	POPJ PDP,

COMR2A:	LDB	TEM,TITAKR(DDB)	;GET BREAK CHARACTER
	ANDI	TEM,177
	MOVEI	DAT,TTIBUF(DDB)	;IN CASE SOMEONE CLOBBERED IT.
SKPBRK:	PUSH PDP,TAC
SKPBR2:	PUSHJ PDP,SPCHEK
	JRST SKPBR1
	TLNE TAC,BREAKB		; IS THIS CHAR THE BREAK?
	JRST TPOPJ		; YES, RESTORE TAC AND RETURN
SKPBR1:	PUSHJ PDP,GETLCCHR	; GET A CHARACTER FROM COMMAND LINE
	JUMPN TEM,SKPBR2	; LOOK FURTHER FOR BREAK CHAR
	JRST TPOPJ		; UNLESS NO MORE CHARS

;CALLED FROM COMMAND RETURN AND FROM DETACH (CDET,FORK,CFORK) COMMAND
COMRT2:	PUSHJ	PDP,COMR2A	;SKIP TO BREAK CHAR
COMR2B:	MOVSI	AC1,COMBIT
	LDB	TAC,PUNIT
	CONO	PI,SCNOFF
	SKIPGE	TTYTAB(TAC)
	SOS	COMCNT
	ANDCAM	AC1,TTYTAB(TAC)
IFN FTTTYBUG,<
	PUSHJ	P,COMBCK
	PUSHJ	P,CNTCOM
>
	CONO	PI,SCNON
	POPJ	P,
;TABLE OF CONSOLE COMMANDS


;BITS CHECKED BEFORE DISPATCHING TO COMMAND SETUP ROUTINE

NOCORE←←400000	;NO CORE NEEDED FOR COMMAND
NOJOBN←←200000	;NO JOB NUMBER NEEDED FOR COMMAND
NOLOGIN←←100000	;JOB DOES NOT NEED TO BE ALREADY LOGGED IN.
NOACT←←40000	;COMMAND MUST BE DELAYED IF JOB HAS ACTIVE DEVICES.
INCORE←←20000	;COMMAND MUST BE DELAYED IF JOB HAS CORE ASSIGNED
		;AND IS NOT IN CORE.
NORUN←←10000		;↑C MUST BE TYPED BEFORE COMMAND CAN BE
		;EXECUTED.
SHRINK←←4000	;IF JOB ON DISK, SHRINK BEFORE BRINGING HIM IN!!!
		;THIS SHOULD SAVE A LOT OF TIME
NOPRIV←←2000	;CLEAR TEMPORARY PRIVILEGE BITS BEFORE DISPATCHING


;BITS CHECKED AFTER RETURN FROM COMMAND SETUP ROUTINE
NOSKPB←←4000	;DON'T CALL SKPBRK (SEE US RECYCLE THOSE BITS!)
;NODATE←←1000	;DONT PRINT DATE AFTER JOB INITIALIZATION
NOINCK←←400	;NO CHECK FOR JOB INITIALIZATION (JNA=0)
NOCRLF←←200	;NO PRINTING OF CRLF
NOPER←←100	;NO PRINTING OF PERIOD
TTYRNU←←40	;SET TTY TO USER MODE AND START JOB
		;WHEN COMMAND RESPONSE STOPS TYPING
TTYRNC←←20	;KEEP TTY IN COMMAND MODE AND START JOB
		;WHEN COMMAND RESPONSE STOPS TYPING
NOMESS←←10	;NO COMMAND RESPONSE EVER, DO NOT CALL TTYSTR
DOLOG←←4	;ALLOW LOGIN FIRST


ERRFLG←←1	;COMMAND ERROR

RPGBIT←←NOCORE!NOPER!NOCRLF!INCORE!NORUN!NOACT!TTYRNU!SHRINK!DOLOG!NOPRIV
			;BITS FOR THE RPG COMMANDS
DEFINE NAMES
<
	C KJOB,KJOB,NOCORE!NOJOBN!NOINCK!NOLOGIN!NOACT!NORUN!NOCRLF!NOPER!NOMESS!INCORE!SHRINK
	C LOGOUT,KJOB,NOCORE!NOJOBN!NOINCK!NOLOGIN!NOACT!NORUN!NOCRLF!NOPER!NOMESS!INCORE!SHRINK
	C K,KJOB,NOCORE!NOJOBN!NOINCK!NOLOGIN!NOACT!NORUN!NOCRLF!NOPER!NOMESS!INCORE!SHRINK
	C KATTACH,KJOB,NOCORE!NOJOBN!NOINCK!NOLOGIN!NOACT!NORUN!NOCRLF!NOPER!NOMESS!INCORE!SHRINK
	C KLOG,KJOB,NOCORE!NOJOBN!NOINCK!NOLOGIN!NOACT!NORUN!NOCRLF!NOPER!NOMESS!INCORE!SHRINK
	C START,START,NOPER!TTYRNU!INCORE!NOACT!NORUN
	C S,START,NOPER!TTYRNU!INCORE!NOACT!NORUN	;JS
	C HALT,STOP,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C KILL,KILCOM,NOCORE
	C FLUSH,FLUSH,NOINCK!NOLOGIN!NOJOBN!NOCORE
	C <>,CBLANK,NOCORE!NOJOBN!NOLOGIN!NOINCK!NOCRLF
	C R,RCOM,NOCORE!NOPER!TTYRNU!NOCRLF!INCORE!NOACT!NORUN!SHRINK!DOLOG!NOPRIV
	C RUN,RUNCOM,NOCORE!NOPER!TTYRNU!NOCRLF!INCORE!NOACT!NORUN!SHRINK!DOLOG!NOPRIV
IFN FTLOGIN,<
	C CORE,CORE,NOCORE!NOACT!NOLOGIN!NORUN!NOINCK!NOJOBN
	C C,CORE,NOCORE!NOACT!NOLOGIN!NORUN!NOJOBN!NOINCK
>
IFE FTLOGIN,<	;IN NON-LOGIN SYSTEM, CORE COMMAND MAY MAKE A JOB.
	C CORE,CORE,NOCORE!NOACT!NOLOGIN!NORUN
	C C,CORE,NOCORE!NOACT!NOLOGIN!NORUN
>
	C SETUWP,SETWPS,NOACT!NOCORE!NOPRIV		;RPH SET SEGMENT WRITE PROT
	C CLRUWP,CLRWPS,NOACT!NOCORE!NOPRIV		;RPH CLEAR SEGMENT WRITE PROT
	C ENABLE,ENABLE,NOCORE
	C DISABLE,DISABLE,NOCORE
	C GET,GET,NOCRLF!NOPER!TTYRNU!INCORE!NOCORE!NOACT!NORUN!SHRINK!DOLOG!NOPRIV
	C G,GET,NOCRLF!NOPER!TTYRNU!INCORE!NOCORE!NOACT!NORUN!SHRINK!DOLOG!NOPRIV
	C SAVE,SAVE,NOCRLF!NOPER!TTYRNU!INCORE!NOACT!NORUN!NOPRIV
	C SSAVE,SSAVE,NOCRLF!NOPER!TTYRNU!INCORE!NOACT!NORUN!NOPRIV
	C CONTINUE,CONT,NOPER!TTYRNU!INCORE!NORUN
	C DE,DCOM,INCORE!NOPRIV
	C E,ECOM,NOCRLF!INCORE
	C PJOB,PJOBDV,NOCORE!NOLOGIN!NOJOBN!NOINCK
	C PTTY,PTTY,NOCORE!NOJOBN!NOINCK!NOLOGIN
IFN FTDSKPPN,<
	C ALIAS,SDSKPPN,NOCORE!NOPRIV			;RPH
>
	C SLEVEL,SLEVEL,NOCORE
	C ASSIGN,ASSIGN,NOCORE!DOLOG!NOPRIV
	C A,ASSIGN,NOCORE!DOLOG!NOPRIV			;JS
	C DEASSI,DEASSIGN,NOCORE
	C D,DEASSIGN,NOCORE
	C DDT,DDTGO,NOPER!TTYRNU!INCORE!NORUN!NOPRIV
	C TTY,TTYSUB,NOLOGIN!NOCORE!NOJOBN!NOINCK	;RPH
	C FINISH,FINIS,NOPER!NOACT!INCORE!NORUN!NOPRIV
	C F,FINIS,NOPER!NOACT!INCORE!NORUN!NOPRIV
	C REENTER,REENTER,TTYRNU!NOPER!INCORE!NORUN
	C CSTART,STARTC,TTYRNC!INCORE!NORUN
	C CCONTINUE,CONTC,TTYRNC!INCORE!NORUN
	C DETACH,DETACH,NOCORE!NOINCK!NOPER!NOCRLF!NOMESS
	C CDETACH,CDETACH,NOCORE!NOINCK
	C ATTACH,ATTACH,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C DAYTIME,DAYTIM,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C EDDT,CEDDT,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C TIME,RUNTIM,NOCORE!NOLOGIN!NOINCK!NOJOBN
	C RESOURCES,FREDEV,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C FILES,FILCOM,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C REASSI,REASS,NOCORE!NOACT!INCORE!NORUN
	C TALK,TALK,NOCORE!NOJOBN!NOLOGIN!NOMESS!NOINCK!NOCRLF!NOPER
	C HELLO,HELLO,NOCORE!NOLOGIN!NOJOBN!NOINCK	;JS
IFN FTLOGIN,<
	C LOGIN,CLOGIN,NOCORE!NOLOGIN!NOPER!TTYRNU!INCORE!NOACT!NORUN
	C L,CLOGIN,NOCORE!NOLOGIN!NOPER!TTYRNU!INCORE!NOACT!NORUN
	C PPPN,PPPN,NOLOGIN!NOCORE!NOJOBN!NOINCK
	C FORK,FORK,NOINCK!NOMESS!NOPER!NOCRLF!NOCORE!NOPRIV
	C CFORK,CFORK,NOINCK!NOMESS!NOPER!NOCRLF!NOCORE!NOPRIV
>
; MORE COMMANDS . . .
IFN FTDISK,<
	C HELP,HELP,RPGBIT!NOLOGIN
	C WHERE,WHECOM,RPGBIT!NOLOGIN
	C SYSTAT,WHOCOM,RPGBIT!NOLOGIN
	C WHO,WHOCOM,RPGBIT!NOLOGIN
	C W,WHOCOM,RPGBIT!NOLOGIN
	C FINGER,FINGER,RPGBIT!NOLOGIN
	C FIND,FNDCOM,RPGBIT!NOLOGIN
	C FIXIML,FIXIML,RPGBIT!NOLOGIN

	C LISP,LSPCOM,RPGBIT
	C RSL,RSLCOM,RPGBIT

	C COMPILE,RPGCOM,RPGBIT			;RPG COMMANDS
	C DEBUG,RPGCOM,RPGBIT
	C PREPARE,RPGCOM,RPGBIT
	C LOAD,RPGCOM,RPGBIT
	C EXECUTE,RPGCOM,RPGBIT
	C CREF,RPGCOM,RPGBIT
	C TV,RPGCOM,RPGBIT
	C CTV,RPGCOM,RPGBIT
	C EDIT,RPGCOM,RPGBIT
	C ED,RPGCOM,RPGBIT
	C CREATE,RPGCOM,RPGBIT
	C TECO,RPGCOM,RPGBIT
	C MAKE,RPGCOM,RPGBIT
	C TRY,RPGCOM,RPGBIT
	C PUB,RPGCOM,RPGBIT

	C READ,ETCOM,RPGBIT
	C ETV,ETCOM,RPGBIT
	C CETV,ETCOM,RPGBIT

	C LIST,CPYCOM,RPGBIT			;COPY COMMANDS
	C DIRECTORY,CPYCOM,RPGBIT
	C DI,CPYCOM,RPGBIT
	C DELETE,CPYCOM,RPGBIT
	C RENAME,CPYCOM,RPGBIT
	C TYPE,CPYCOM,RPGBIT
	C COPY,CPYCOM,RPGBIT
	C PRINT,CPYCOM,RPGBIT
	C TRANSFER,CPYCOM,RPGBIT
	C XGPLIST,CPYCOM,RPGBIT

	C SEND,MAICOM,RPGBIT			;MAIL AND REMINDERS
	C MAIL,MAICOM,RPGBIT
	C GRIPE,MAICOM,RPGBIT
	C REMIND,MAICOM,RPGBIT
	C CANCEL,OBLCOM,RPGBIT			;DELETE REMINDERS
	C LATER,MAICOM,RPGBIT
	C RCV,RCVCOM,RPGBIT!NOLOGIN
	C PLAN,MAICOM,RPGBIT

	C SPOOL,SPLCOM,RPGBIT			;SPOOLER
	C QSPOOL,SPLCOM,RPGBIT!NOLOGIN
	C UNSPOOL,SPLCOM,RPGBIT
	C XSPOOL,SPLCOM,RPGBIT

	C ZERO,ZERCOM,RPGBIT
	C XEROX,XERCOM,RPGBIT
	C DO,DOCOM,RPGBIT
	C TEST,TSTCOM,RPGBIT

	C REWIND,DSCCOM,RPGBIT		;DUMP COMMAND RUN DART NOW.
	C DUMP,DSCCOM,RPGBIT		;IDUMP COMMAND IS FLUSHED.
	C RESTOR,DSCCOM,RPGBIT
	C ADVANC,DSCCOM,RPGBIT
	C BACKSP,DSCCOM,RPGBIT
	C TLIST,DSCCOM,RPGBIT
	C EOT,DSCCOM,RPGBIT
	C LOCATE,DSCCOM,RPGBIT

	C TN,TNCOM,RPGBIT
	C TELNET,TNCOM,RPGBIT
	C FTP,FTPCOM,RPGBIT

	C DIAL,DILCOM,RPGBIT

	C NS,NSCOM,RPGBIT		;NEWS SERVICE--USES TEMPORARY PRIVILEGES
	C HOT,HOTCOM,RPGBIT		;NEWS SERVICE HOT LINE WITH TEMP PRIV

	C UDPUFD,UDPCOM,RPGBIT		;UDP UFD MUNGER LOTSA PRIVS
>>
BEGIN COMTBL			;GENERATE TABLE OF SIXBIT COMMAND NAMES

DEFINE C(A,B,C),<
	<SIXBIT /A/>		;ONLY FIRST SIX CHARACTERS.
>

↑↑COMTAB:
	XLIST
	NAMES
	LIST
↑↑DISPL←.-COMTAB	;LENGTH OF TABLE

;GENERATE THE DISPATCH TABLE AND SPECIAL BITS

DEFINE C!(A,B,D)
<	XWD D,B>

;SPECIAL HACK TO FORCE LOGIN FROM "ANY" COMMAND.
	XWD NOCORE!NOLOGIN!NOPER!TTYRNU!INCORE!NOACT!NORUN,CXLOGI
↑DISP:
	XLIST
	NAMES
	LIST

	XWD NOCORE+NOJOBN+NOLOGIN+NOINCK,NOCOM	;CATCH ANYTHING THAT'S NOT A COMMAND

BEND COMTBL
;CALLED FROM COMMAND DECODER WHICH IS CALLED FROM CLOCK ROUTINE
;WITH FOLLOWING AC'S SET:
;TAC= BYTE POINTER TO COMMAND STRING(SPACE OR CR AFTER COMMAND NAME)
;ITEM = JOB NUMBER
;DAT = BYTE POINTER TO LAST OUTPUT CHARACTER
;DEVDAT= ADDRESS OF DEVICE DATA BLOCK INITIATING COMMAND
;JDAT = ADDRESS OF JOB DATA AREA, = 0 IF NO JOB AREA
;PROG=XWD PROTECTION,RELOCATION; 0 IF NO CORE
;IOS=0

;UPON RETURN FROM COMMAND SETUP ROUTINE, A CR-LF IS ADDED IF
;NEEDED AND TTY IS STARTED

;SINCE THE COMMAND DECODER IS CALLED FROM THE CLOCK ROUTINE
;COMMAND SETUP ROUTINES MUST RUN TO COMPLETION QUICKLY
;IF A COMMAND FUNCTION CANNOT DO THIS, IT MUST JUST SET
;THE JOB TO A RUNABLE STATUS AND RETURN IMMEDIATELY



CEDDT:	PUSHJ P,STLNAC		;SET UP LINE(TAC1)
	TLNN TAC1,CTYLIN	;IS HE ON THE CTY?
	JRST COMERR		;NO, FLUSH HIM
	JRST DDTCAL		;YES, GET EXEC DDT
COR0:		;CALLED FROM CORE COMMAND TO ZERO CORE
	JUMPE PROG,CPOPJ	;RETURN IF JOB DOES NOT HAVE CORE
	MOVSI TAC,TTYRNU!NOPER!NOCRLF
	IORM TAC,-1(P)		;TELL COMRET TO PUT TTY IN USER MODE
	JSP TAC1,MONJOB		;SET TO RUN MONITOR JOB(PC IN EXEC MODE)
				;RETURN HERE AT UUO LEVEL(NO ACS SET UP)
	MOVEI TAC1,HOLD		;PUT ERROR STOP ON END OF PDL
	JSP TAC,MONSTR		;START MONITOR JOB BY SETTING UP ACS AND
JOB1:	PUSHJ	P,RESET		;RELEASE ALL IO DEVICES ASSIGNED TO THIS JOB
	PUSHJ	P,TTYFNU	;FIND TTY FOR THIS JOB(SETUP ITEM WITH JOB NO.)
	PUSHJ	P,NOCORQ	;PUT JOB IN NO CORE Q
	MOVEI	TAC,0		;FLUSH ALL CORE
	SOS	(P)		;CORE1 WILL SKIP RETURN
IFN FTSWAP,<
	SETZM	JBTSWP(J)	;CLEAR IMGIN AND IMGOUT
	SETOM	STIME(J)	;MARK CORE IMAGE ALTERED
	LDB	DAT,PSEGN
	MOVE	TEM,JBTSTS(DAT)
	TLNN	TEM,JWP
	SETOM	STIME(DAT)
>
	JRST	CORE1
;PTTY PJOB KJOB
; "PTTY" GIVES THE LOGICAL NAME OF THE TTY THE LOSER IS ON.
; "PTTY N" GIVES THE LOGICAL NAME OF THE TTY FOR JOB N.

PTTY:	PUSHJ P,DECIN	;JOB NUMBER MAYBE?
	JRST PTTY1
	JRST COMERA
	JUMPE TAC1,NOTLOG
	CAIL TAC1,JOBN		;LEGAL?
	JRST NOTLOG		;NONE SUCH JOB
	MOVE TAC,JBTSTS(TAC1)
	TLNN TAC,JNA		;DOES HE HAVE A JOB NUMBER?
	JRST NOTLOG		;NO, LOSE
	MOVE AC1,JBTLIN(TAC1)	;LINE NUMBER
	CAMN AC1,[-1]		;DETACHED?
	JRST PTTYDT		;YES
	TLNN AC1,CTYLIN		;CTY?
	JRST NOTCTY
	JSP TAC,CONMES
	ASCIZ/CTY
/
NOTCTY:	PUSH P,AC1
	PUSHJ P,INLMES
	ASCIZ/TTY/
	POP P,TAC
	HRRZS TAC
	PUSHJ P,OCTPNT
	JRST PTTY2

PTTY1:	MOVE TAC1,DEVNAM(DDB)
	PUSHJ P,PRNAME
	LDB AC1,PUNIT
	HLL AC1,LINTAB(AC1)
PTTY2:	TLNN AC1,DDDLIN
	JRST CRLF
	PUSHJ P,INLMES
	ASCIZ /, DD/
	MOVE AC1,LETAB-DPYL0(AC1);NONZERO IT SAYS HERE
	HLRZ TAC,PRGNUM(AC1)
	PUSHJ P,OCTPNT
	JRST CRLF

PTTYDT:
	JSP TAC,CONMES
	ASCIZ/DETACHED.
/

; "PJOB" PRINT JOB NUMBER OF JOB TTY IS ATTACHED TO
; "PJOB TTYN" PRINT JOB NUMBER OF JOB USING TTYN.

PJOBDV:	PUSHJ P,CTEXT1		;ARG
	JUMPN TAC1,PJOBX
	JUMPE ITEM,LOGPLS
↑PJOB:	MOVE TAC,ITEM		;JOB NO.
↑DECLF:	PUSHJ PDP,RADX10	;PRINT TAC AS DEC. THEN CRLF
	JRST CRLF

PJOBX:	MOVE TAC,TAC1
	PUSH P,TAC
	PUSHJ P,DEVPHY
	SKIPA DDB,-3(P)			;(SO I DON'T CARE IF DEVPHY MUNGS IT)
	JRST FNDDEV
	PUSHJ P,DADD00			;NOT DEVICE, PERHAPS DD CHAN
	JRST PJDVLZ			;NOPE, NO SUCH FROBULE
	LDB TAC1,[DDUSR+<(TAC)>]	;YES, GET USE CODE
	JUMPE TAC1,DEVFRE		;0, NOT IN USE
	CAIGE TAC1,100			;IF LESS THAN 100,
	JRST FNDDV1			;  IT'S ASSIGNED TO THAT JOB
	CAIL TAC1,200			;ABOVE 200,
	JRST DEVFR2			;  DETACHED FROM SYS (OR AVLCHN)
	SUBI TAC1,100-DDL0		;ELSE MAKE IT A TTY LINE NUMBER
	PUSH P,TAC1
	MOVEI AC1,(TAC1)
	PUSHJ P,NOTCTY			;THIS WILL TYPE THE TTY NUMBER
	POP P,TAC1
FNDDV0:	SKIPN DDB,TTYTAB(TAC1)	;DOES IT HAVE A DDB
	JRST DEVFRE		;NO ONE HAS IT
FNDDEV:	MOVE TAC1,DEVMOD(DDB)		;SPECIAL HAIR FOR UDP AS USUAL
	TLNE TAC1,DVUDP
	JRST PJBUDP
	LDB TAC1,PJOBN
FNDDV1:	JUMPE TAC1,DEVFR1
	PUSH P,TAC		;SORRY ABOUT THIS
	PUSHJ P,PJPRNM
	POP P,TAC
	PUSHJ P,INLMES
	ASCIZ/ ASSIGNED TO JOB /
	POP P,TAC
	JRST DECLF

PJBUDP:	LDB TAC,PUNIT			;UDP: GET INDEX TO TABLES
	SKIPL TAC1,UDPOWN-1(TAC)
	JRST FNDDV1			;PRIVATELY OWNED, DO THE USUAL THING
	SKIPN UDPCNT-1(TAC)
	JRST DEVFRE			;NO DDBS, NOT IN USE
	PUSH P,TAC
	PUSHJ P,PJPRNM
	POP P,TAC
	SKIPLE TAC,SATADR(TAC)
	PUSHJ P,SATTAC			;PRINT SATID IF ANY
	POP P,(P)
	JSP TAC,CONMES
	ASCIZ / PUBLIC
/

PJDVLZ:	POP P,(P)
	MOVE DDB,-2(P)
	MOVEI DAT,TTOBUF(DDB)
	JRST NOTDEV

DEVFR1:	MOVE TAC1,DEVMOD(DDB)
	TRNN TAC1,ASSCON		;DETACHED MAYBE?
	JRST DEVFRE
DEVFR2:	JSP TAC,PJBMSG
	ASCIZ/DETACHED FROM SYSTEM.
/

DEVFRE:	JSP TAC,PJBMSG
	ASCIZ/NOT IN USE.
/

PJBMSG:	POP P,(P)
	MOVE DDB,-2(P)
	MOVEI DAT,TTOBUF(DDB)
	JRST CONMES

PJPRNM:	MOVE DDB,-5(P)
	MOVEI DAT,TTOBUF(DDB)
	EXCH TAC1,-2(P)
	JRST PRNAME

;  "KJOB" KILL ATTACHED JOB



KJOB:	JUMPE ITEM,JOBKB	;WAS JOB INITIALIZED?	;DEC 3.16
IFN FTSWAP,<
	TLNN AC1,SWP		;DEC 3.16
	JRST KJOB1		;DEC 3.16
	JUMPN PROG,DLYCR1	;DEC 3.16
CORX:	MOVEI TAC,1		;DEC 3.16
	PUSH PDP,CORX1		;DEC 3.16
	JRST CORE0K		;DEC 3.16
KJOB1:
>	
IFN FTLOGIN,<
	PUSHJ P,STLNAC		;GET TTY BITS
	TLNN TAC1,IMPBIT	;IMP'S GET LOGGED OUT ANYWAY
	TLNN TAC1,PTYLIN	;FLUSH PTY JOBS INSTANTLY!
	TLZN AC1,JLOG!JACCT	;SHALL WE RUN LOGOUT?
	JRST KJOB2		;NO.
	TLO AC1,JACCT		;SET "ACCOUNTING PGM RUNNING"
	HLLM AC1,JBTSTS(ITEM)
IFN FTSWAP,<
	PUSHJ PDP,ALOGN1
>
	MOVSI TAC,TTYRNU+NOMESS
	XORM TAC,-1(PDP)
	PUSH PDP,['LOGOUT']
	JRST ARCOM		;RUN LOGOUT
>
IFN FTLOGIN,<			; PRINT OUT A JOB'S PROJECT PROGRAMMER NUMBER

PPPN:	PUSHJ	P,DECIN		;GET ARGUMENT, IF ANY
	JRST	PPPN6		;NO ARGUMENT. PPN FOR CURRENT JOB.
	JRST	COMERA		;ILL. ARGUEMENT
	MOVSI	TAC,NOINCK	;DON'T INITIALIZE A JOB JUST FOR ME!
	IORM	TAC,-1(P)
	CAIGE	TAC1,JOBN	; OUT OF BOUNDS?
	CAIG	TAC1,0
	JRST	ECOMA		; PRINT "OUT OF BOUNDS"
	MOVE	AC1,TAC1	; USE THAT JOB NUMBER
PPPN5:	MOVE	TAC,JBTSTS(AC1)
	SKIPE	PRJPRG(AC1)
	TLNN	TAC,JNA
	JRST	NOTLOG
	MOVE	TAC,[POINT 6,PRJPRG(AC1)]
	PUSHJ	P,PPPN7		;WRITE 3 SIXBIT CHARACTERS
	MOVEI	TEM,","
	XCT	TYO
	PUSHJ	P,PPPN7		;TYPE THE REST
IFN FTDSKPPN,<
	SKIPN	DSKPPN(AC1)	;ANY ALIAS PPN?
	JRST	NOALIAS
	PUSHJ	P,INLMES
	ASCIZ/  ALIAS  /
	MOVE	TAC,[POINT 6,DSKPPN(AC1)]
	PUSHJ	P,PPPN7
	MOVEI	TEM,","
	XCT	TYO
	PUSHJ	P,PPPN7
NOALIAS:
>;FTDSKPPN
	PUSHJ	PDP,INLMES
	ASCIZ /
/
	POPJ	PDP,

PPPN6:	MOVEI	AC1,(J)		; NO ARGUMENT USE PPN OF CURRENT JOB
	MOVE	AC2,JBTSTS(J)
	TLNN	AC2,JLOG
	JRST	LOGPLS
	JRST	PPPN5

PPPN7:	MOVEI	TAC1,3		;3 CHARACTERS
PPPN8:	ILDB	TEM,TAC		;LOAD THE NEXT BYTE
	JUMPE	TEM,PPPN9	;FLUSH NULL BYTES
	ADDI	TEM," "		;MAKE SIXBIT INTO ASCII
	XCT	TYO		;TYPE ONE CHARACTER
PPPN9:	SOJG	TAC1,PPPN8	;LOOP
	POPJ	P,
>

;COMMAND	"ALIAS P,PN"  OR  "ALIAS P"  OR  "ALIAS"
;THE FIRST SETS DSKPPN(J) AND THE SECOND RESETS IT
IFN FTDSKPPN,<
SDSKPPN:
	CAIE	TEM,";"
	CAIN	TEM,12		;TERMINATOR SEEN ALREADY?
	JRST	CDSKPPN		;YES. RESET ALIAS.
	PUSHJ	P,GETWRB	;LOOK FOR ARG
	JUMPE	TAC1,[	CAIE TEM,12	;NO ARG AT ALL?
			CAIN TEM,";"
			JRST CDSKPPN	;NO ARG IS OK
			JRST COMERA]	;BAD ARG, ERROR
	HLLZ	AC2,TAC1	;SAVE P
	TRNE	TAC1,-1		;CHECK SYNTAX, RPH YOU LAZY ...
	JRST	COMERA
	CAIE	TEM,";"
	CAIN	TEM,12		;ONE ARG?
	JRST	[HRR AC2,PRJPRG(J)	;COPY PRG
		JRST CNGPRJ]
;	CAIE	TEM,","		;COMMA FOR SEPERATOR?
;	CAIN	TEM,"/"		;OR SLASH?
;	CAIA			;YES
;	JRST	COMERA		;NO
	PUSHJ	P,GETWRB	;TRY TO GET PN
	JUMPE	TAC1,COMERA	;MUST BE ONE
	HLR	AC2,TAC1	;DON'T CARE ABOUT TERMINATOR HERE
	TRNE	TAC1,-1
	JRST	COMERA
CNGPRJ:	CAMN	AC2,MFDENT	;SAME AS 1,1?
	JRST	COMERA		;SOME THINGS NOT ALLOWED.
	CAMN	AC2,PRJPRG(J)	;RESETING EXPLICITLY
CDSKPPN:SETZ	AC2,
	CAME	AC2,DSKPPN(J)	;CHANGING?
	SETZM	JBTUFD(J)	;YES, CLEAR JBTUFD
	MOVEM	AC2,DSKPPN(J)
	POPJ	P,

GETWRB:	PUSHJ P,CTEXT
	JUMPE TAC1,NOJUST
	TLNN TAC1,7777
	LSH TAC1,-14
	TLNN TAC1,77
	LSH TAC1,-6
NOJUST:	PUSHJ P,SKIPSB		;CAREFUL, THIS GUY CAN CALL TPOPJ
	POPJ P,
>;FTDSKPPN

↑NOTLOG:JSP TAC,ERRMES
	ASCIZ /NO SUCH JOB
/
; SERVICE LEVEL COMMAND
; SLEVEL
; YOUR CURRENT SERVICE LEVEL IS PRINTED.

MAXLEV ←← =80		;NOBODY CAN HAVE MORE THAN 80% OF THE MACHINE

SLEVEL:
TYPSL:	PUSHJ	P,SPRSSL		;MAKE SURE CURRENT SERVICE LEVEL IS SPREAD
					;SPRSSL IS IN UUOCON
	HRRZ	TAC,JBTGSL(J)
	IMULI	TAC,=100
	ADDI	TAC,400000		; TRY TO CORRECT FOR ROUNDOFF ERROR
	HLRZS	TAC
	PUSHJ	P,RADX10
	JSP	TAC,CONMES
	ASCIZ	/% SL
/
;KILL N ---- KILL JOB N IMMEDIATELY! -- OR MAYBE LATER
KILCOM:	PUSHJ	P,DECIN			;GET ARGUMENT
	JRST	NOTENF			;NONE
	JRST	COMERA			;ILLEGAL
	CAMN	J,TAC1			;NO SUICIDE!
	JRST	ILLKIL
	CAIL	TAC1,JOBN		;LEGAL?
	JRST	NOTLOG			;TOO BIG
	JUMPLE	TAC1,NOTLOG		;TOO SMALL
	MOVE	TAC,JBTSTS(TAC1)
	TLNN	TAC,JNA			;LEAVE US NOT FLUSH NON-EX JOBS
	JRST	NOTLOG
	TLNE	TAC,JSEG		;IS IT SEG2.
	JRST	KILCM5			;JUST CHANGE NAME OF UPPER SEGMENT.
	MOVSI	AC1,KILPRV		;LOOK FOR KILL PRIVILEGE
	TDNE	AC1,JBTPRV(J)		;...
	JRST	KILOK			;HE HAS THE POWER
	HRRZ	AC1,PRJPRG(ITEM)	;GET PROGRAMMER NAME
	HRRZ	TAC,PRJPRG(TAC1)	;GET PRG OF GUY WE'RE KILLING
	CAME	TAC,AC1			;SAME
	JRST	NOTYRS			;LOSE!
KILOK:	MOVE	TAC,JBTSTS(TAC1)
	TLNE	TAC,SHF
	JRST	DLYCM			;WAIT A WHILE
	PUSH	P,J			;SAVE ME
	PUSH	P,PROG			;AND MY JOB
	MOVE	J,TAC1			;MAKE BELIEVE I'M HIM
	MOVE	PROG,JBTADR(J)		;AND HIS JOB
	TLNE	TAC,SWP			;SWAPPED OUT?
    ;NEXT INSTRUCTION MAY BE HAZZARDOUS TO YOUR HEALTH IF TWIDDLED.
	JRST	KILCM3			;GET HIM IN
	JUMPE PROG,KILCM7		;ANY CORE?
	MOVE TAC,(P)
	MOVE TAC,JBTPRV(TAC)		;GET PRIVILEGES OF GUY WHO TYPED COMMAND
	TLNE TAC,KILPRV			;IF HE HAS THE PRIV
	JRST KILCM6			;HE CAN KILL WITH ACTIVE IO
	PUSHJ PDP,ANYACT		;YES, ARE DEVICES ACTIVE?
	JRST KILCM3			;YES, DELAY
	JRST KILCM6			;WE HAVE CORE AND NO ACTIVE DEVICES

KILCM7:	MOVEI	TAC,JOBDA		;NO, JUST GET A JOB DATA AREA
	PUSHJ	P,CORE0			;MAKE SURE HE HAS CORE
	JFCL
	JUMPE	PROG,KILCM4		;IF WE DON'T HAVE CORE HERE WE LOSE.
KILCM6:	MOVSI TAC1,CMWB			;CLEAR COMMAND WAIT BIT
	ANDCAM TAC1,JBTSTS(J)		;SO HE WILL RUN
	MOVEI TAC1,KILCM1		;THIS IS THE PLACE TO START HIM
	MOVE TAC,JBTPRV(J)		;GET PRIV AGAIN
	TLNN TAC,KILPRV			;SKIP IF HE HAS IT
	MOVEI TAC1,JOBKL		;ELSE NORMAL KJOB ROUTINE
	PUSHJ P,MONJOB			;MAKE HIM A MONITOR JOB
KILCM2:	POP P,PROG			;SUPRISE
	POP P,J				;IT'S ME AGAIN
	POPJ P,				;DIDN'T SEE A THING

KILCM3:	PUSHJ P,DLYCOM			;SET CMWB AND GET IN CORE IF NECESSARY
KILCM4:	POP P,PROG			;NOW LETS BE OURSELVES AGAIN
	POP P,J
	JRST DLYCM			;NOW DELAY US.

KILCM5:	MOVE TAC,PRJPRG(TAC1)
	MOVEM TAC,JOBNAM(TAC1)		;NO ONE WILL BELIEVE THIS NAME.
IFN FTSTAT,<PUSH P,J
	MOVE J,TAC1
	PUSHJ P,NAMSTT
	POP P,J
>
	POPJ P,

NOTYRS:	JSP TAC,ERRMES
	ASCIZ /NOT ONE OF YOUR JOBS.
/

ILLKIL:	JSP TAC,CONMES
	ASCIZ /USE "KJOB" TO LOG YOURSELF OFF.
/
;PRIVILEGED KILL ROUTINE, FLUSHES THINGS WITHOUT WAITING
KILCM1:	MOVEI	TAC1,ESTOP
	JSP	TAC,MONSTR		;MAKE ME SOME PDL
	PUSHJ	P,RESETSEG		;FLUSH HIS SEGMENT
	PUSHJ	P,IOKILL		;KILL ALL IO WITHOUT WAITING
	PUSHJ	P,TTYFND		;FIND TTY
	PUSHJ	P,TSETBF		;CLEAR IO
	MOVSI IOS,TOIP
	ANDCAB IOS,DEVIOS(DDB)		;CLEAR TOIP SO ESTOP WON'T HANG
	PUSHJ	P,KILSPW		;KILL SPACEWAR
	JRST	JOBKL1			;LET KJOB ROUTINE DO THE REST
KJOB2:	JUMPE	PROG,JOBKA	;DOES JOB HAVE CORE?
	JSP	TAC1,MONJOB	;YES, SCHEDULE MONITOR JOB.
↑JOBKL:	MOVEI	TAC1,ESTOP2	;ESTOP AT END OF PDL
	JSP	TAC,MONSTR	;SET UP ACS AND PDL LIST
JOBKL1:	PUSHJ	P,DSFLUSH	;SET UP TO FLUSH SPECIAL DETACHED SEGMENTS

IFN FTDRD,<
	CAMN	PROG,JBTADR(J)	;THE FOLLOWING IS BROUGHT TO YOU BY THE DRD.
	JRST	JOBKL2
	PUSHAC
	PUSHJ	P,DISMES
	ASCIZ	/PROG CLOBBERED AT JOBKL1 /
	PUSHJ	P,DISJOB
	PUSHJ	P,DISCRLF
	POPACS
JOBKL2:
>
	PUSHJ	P,RESET		;FINISH IO BEFORE DEASSIGNING
	PUSHJ	P,DEASTY	;WHILE WE STILL HAVE CORE, DEASSIGN DEVICES XCPT TTY
	PUSHJ	P,JOB1		;CALL RESET(AGAIN!), RELEASE CORE.

IFN FTDRD,<
	SKIPN	JBTADR(J)	;THE FOLLOWING IS MORE DRD CODE
	JRST	JOBKA
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/JBTADR NOT 0 AT JOBKA-1 /
	PUSHJ	P,DISJOB
	PUSHJ	P,DISCRLF
	POPACS
>

JOBKA:
IFE FTLOGIN,<
	MOVE	TAC,TTIME(J)	;TOTAL TIME
	SUB	TAC,RTIME(J)	;MINUS INCREMENTAL TIME
	JUMPE	TAC,.+2		;SKIP IF ZERO
	PUSHJ	P,PRTIME	;TYPE INCREMENTAL TIME
	MOVE	TAC,TTIME(J)
	PUSHJ	P,PRTIME	;TYPE TOTAL TIME.
>
JOBKK:	PUSHJ	P,DEASTY	;DEASSIGN ALL BUT TTY
	PUSHJ	P,TTYERR	;GET TTY FOR OUTPUT
	PUSHJ	P,INLMES
	ASCIZ	/KJOB
/
	PUSHJ P,PRPER
	PUSHJ	P,TTYSTR
	PUSHJ	P,TTYKIL	;RETURN TTY TO VIRGIN STATE
	SKIPE	AC1,JBTJL(J)	;AND JOB PRIORITY HISTORY
	PUSHJ	P,FSGIVE
	SETZM	JBTJL(J)
	SKIPE	AC1,JBTFS(J)	; ANY SPARE FREE STORAGE?
	PUSHJ	P,FSGIVE
	SETZM	JBTFS(J)
	PUSHJ P,TMPKIL		;FLUSH ALL HIS TMPCOR FILES (IGNORING ALIAS)
	PUSHJ	P,RELPDL	;RELEASE THE PDL, IF ANY.
				;RETAIN USE OF PDL AS LONG AS WE'RE AT
				;UUO LEVEL OR CHANNEL 7
	HLRZ	AC1,SAVSAI(J)
	JUMPE	AC1,.+2
	PUSHJ	P,FSGIVE	;RETURN SWAP UUO AC SAVE BLK
	SETZM	SAVSAI(J)
	JRST	KSTOP		;CLEAR JOB STATUS WORD AND STOP JOB


;ERROR IN COMMAND


CERR:	JRST ERRMES

JOBKB:	SETZM -1(PDP)		;CLEAR NOJOBN SO COMRET WILL PRINT MESSAGE
	JRST LOGPLS		;"LOGIN PLEASE"
; "START L" OR "START" - START AT LOC. L OR STARTING ADDRESS
; "CSTART L" OR  "CSTART" - START AT LOC. L(TTY IN COMMAND MODE)

START:					;SAME AS STARTC
STARTC:	PUSHJ P,SKIPSJ
	CAIE TEM,"+"
	CAIN TEM,"-"			;REQUESTING INCREMENT?
	JRST STARTA			;YES, SCAN
	PUSHJ P,OCTIN			;CONVERT POSSIBLE OCTAL NO ARG.
	SKIPA TAC1,JOBSA(JDAT)		;NO START ADR. SPECIFIED RETURN
	JRST COMERA			;ILLEGAL CHARACTER
	CAME TAC1,JOBSA(JDAT)		;STARTUP ADDRESS TYPED?
	PUSHJ P,CLRTPV			;YES, CLEAR TEMP PRIVILEGES
	HRRZ TAC,TAC1			;GET STARTUP ADDR
	TDZA TAC1,TAC1
STARTB:	HRRZ TAC,JOBSA(JDAT)
	JUMPN TAC,STRTCK		;ADD INCREMENT AND START
	JSP TAC,ERRMES
	ASCIZ /NO STARTUP ADDRESS!
/

STARTA:	CAIE TEM,"+"			;+?
	JRST STARTE			;NO, MUST BE -
	PUSHJ P,OCTINS			;YES, READ INC
	SKIPA TAC1,[1]			;INVENT 1 FOR NO ARG
	JRST COMERA
	JRST STARTB

STARTE:	PUSHJ P,OCTINS			;GET - INC
	SKIPA TAC1,[1]			;INVENT 1 FOR NO ARG
	JRST COMERA
	MOVN TAC1,TAC1			;NOW NEGATE
	JRST STARTB

;"REENTER" - REENTER USER PROGRAM
REENTE:	PUSHJ P,SKIPSJ
	CAIN TEM,"-"
	JRST REENTM			;GET - INC
	PUSHJ P,OCTIN
	TDZA TAC1,TAC1			;0 FOR NO ARG
	JRST COMERA			;ILL CHAR
REENTN:	HRRZ TAC,JOBREN(JDAT)
	JUMPN TAC,STRTCK		;ADD INCREMENT AND START
	JSP TAC,ERRMES
	ASCIZ /NO REENTER ADDRESS
/

REENTM:	PUSHJ P,OCTINS
	SKIPA TAC1,[1]
	JRST COMERA
	MOVN TAC1,TAC1
	JRST REENTN

STRTCK:	JUMPE TAC1,.+2			;ANY INCREMENT?
	PUSHJ P,CLRTPV			;YES, CLEAR TEMP PRIVILEGES
	ADD TAC1,TAC			;ADD INCREMENT
	JRST USTART			;NOW START IT UP

; "HALT" OR "<CONTROL>C"
;SCANNER ROUTINES DUMMY UP STOP WHEN CONTROL C TYPED IN
;STOP MUST BE DELAYED IF THIS JOB IS SYSTEM TAPE USER
;AND SYSTEM TAPE IS ACTIVE. OTHERWISE, THE JOB WILL NOT BE
;STOPPED WHEN DONE USING THE SYSTEM TAPE.


↑STOP:	JUMPE	ITEM,STOPB1
	CAMN	ITEM,STUSER	;IS THIS SYSTEM TAPE USER?
	JRST	STOPA		;YES
IFN FTDISK,<

	PUSHJ	P,STOPCK	;CAN THE JOB STOP?
	JRST	MAKCNC		;PUT BACK CONTROL C.
>
	PUSHJ	P,STOP1		;STOP JOB
STOPB:
REPEAT 0,<
	MOVSI	TAC,INTHAL	;↑C USER INTERRUPT BIT
	TDNN	TAC,JBTIEN(J)
	JRST	STOPB1
	IORM	TAC,JBTIRQ(J)	;ENABLED, GIVE HIM THE INTERRUPT
	SETOM	INTREQ(PID)	;AS IF THE 6 WOULD EVER DO THIS
>;END REPEAT 0.
STOPB1:	MOVSI	TAC,JACCT
	ANDCAM	TAC,JBTSTS(J)	;GOODBYE LOSER!
	JSP	TAC,CONMES	;PRINT "↑C CRLF CRLF PERIOD"
	ASCIZ	/↑C
/
	POPJ	P,

STOPA:	POP	P,TAC1		;DOES THE JOB HAVE ACTIVE DEVICES?
	PUSHJ	P,ACTCHK
	PUSHJ	P,ESTOP		;NO, STOP THE JOB AND LET GO OF SYSTEM TAPE
	MOVEI	TAC1,COMRET
	PUSH	P,TAC1
	JRST	STOPB

MAKCNC:	MOVE	TAC1,LINSAV
	MOVE	TAC1,TTYTAB(TAC1)
	MOVEI	TAC,600
	DPB	TAC,TITAKR(TAC1)
	JRST	DLYCR1		;DON'T REQUE, OR HE WON'T GET OUT OF THIS STATE!!!
;CCONTINUE, CONTINUE, DDT

; "CCONT" - CONTINUE EXECUTION(TTY REMAINS IN COMMAND MODE)
; "CONT" - CONTINUE EXECUTION FROM WHERE LEFT OFF

CONTC:				;SAME AS CONT
CONT:	MOVSI	TAC1,JERR
	TDNE	TAC1,JBTSTS(J)	;IS JOB ERROR BIT SET?
	JRST	NOCONT		;YES, LOSE
	MOVNI	TAC1,RUNQ	;NO, REQUE TO RUN QUEUE
	MOVEM	TAC1,JOBQUE(J)
	JRST	REQUE

NOCONT:	JSP TAC,ERRMES		;YES, PRINT CANT CONTINUE
	ASCIZ /CAN'T CONTINUE
/


; "DDT" - START EXECUTION AT DDT IN USER AREA

DDTGO:	HRRZ	TAC1,JOBDDT(JDAT)	;DDT STARTING ADR. IN JOB DATA AREA
	JUMPN	TAC1,DDTG1		;IS IT NON-ZERO? IF YES, STORE
					;OLD PC IN JOBOPC IN JOB DATA AREA
					;THEN START WITH PC IN USER MODE
	JSP TAC,ERRMES			;ZERO PRINT "NO DDT"
	ASCIZ /NO DDT
/

;KLUDGE TO MAKE SURE DDT MEMORY IS WRITEABLE
DDTG1:	HLRZ	TAC,PROG
	CAIG	TAC1,(TAC)
	JRST	USTART			;ADR IN LOWER - GO AHEAD
	MOVE	TAC1,JOBPC(PROG)
	TLNN	TAC1,USRMOD
	JRST	DDTG2
	MOVSI	TAC,JOBDAC(PROG)	;MAKE SURE ACS ARE IN RIGHT PLACE
	HRRI	TAC,(PROG)
	BLT	TAC,17(PROG)
DDTG2:	JSP	TAC1,MONJOB		;GET TO UUO LEVEL
	JSP	TAC,MONSTR
	PUSHJ	P,UNPURE		;TRY TO UNPURIFY UPPER
	JRST	DDTPUR
DDTG3:	HRRZ	TAC,JOBDDT(PROG)	;WHERE TO GO
	HLL	TAC,JOBOPC(PROG)	;WITH HIS OLD FLAGS
	TLO	TAC,USRMOD		;DEFINITELY IN USER MODE
	TLZ	TAC,4037		;CLEAR IOT-USER AND @() BITS
	MOVEM	TAC,UUOPC(J)
	JRST	USRXIT			;"RETURN" FROM THIS "UUO"

DDTPUR:	MOVE	J,JOB(PID)		;J WAS CLOBBERED BY UNPURE.
	PUSHJ	P,TTYERP
	PUSHJ	P,INLMES
	ASCIZ	/COULDN'T UNPURIFY UPPER. CONTINUE TO TRY ANYWAY./
	PUSHJ	P,PRCRCC
	PUSHJ	P,TTYSTC		;NOW, FORCE TTY TO TYPE STUFF.
	PUSHJ	P,SETSTP		;MAKE US STOP SOON
	JRST	DDTG3
;SETUWP, CLRUWP, ENABLE, DISABLE
SETWPS:	PUSH P,[-1,,0]			;NO PRO BITS YET
	CAIA
CLRWPS:	PUSH P,[0]			;NO PRO BITS YET
	PUSHJ P,OCTIN
	JRST NOSPRO			;NO SET PRO
	JRST [	POP P,(P)
		JRST COMERA]
	CAILE TAC1,777			;LEGAL?
	JRST ILLPRO
	TRO TAC1,400000
	HRRM TAC1,(P)
NOSPRO:	PUSH P,J
	LDB J,PSEGN
	JUMPE J,NXSEG
	PUSHJ P,ACCESS
	JRST WPSEG
	JRST WPSEG
	HRRZ TAC1,-1(P)			;GET PRO BITS
	TRNN TAC1,400000		;IS HE REQUESTING BIT SETTINGS?
	JRST NOSPR1			;NO
	MOVE TAC1,(P)			;JOB #
	MOVE TAC1,JBTPRV(TAC1)
	TLNN TAC1,SEGPRV		;DOES HE HAVE PRIV?
	TRNN TAC,400			;NO, CHECK PROTECTION PROTECTION
	CAIA				;OKAY TO DIDDLE
	JRST WPSEG			;LOSE
	HRRZ TAC1,-1(P)			;GET BITS AGAIN
	ANDI TAC1,377			;DON'T LET HIM SET UNPURIFIED BIT
	DPB TAC1,[POINT 9,JOBCRD(J),8]
NOSPR1:	MOVSI TAC,JWP
	SKIPGE -1(P)
	IORB TAC,JBTSTS(J)
	SKIPL -1(P)
	ANDCAB TAC,JBTSTS(J)
	POP P,-1(P)			;MOVE J BACK ONTO FLAG
	HLRZ TAC1,JBTADR(J)		;GET SEGMENT PROT
	TLNE TAC,JWP
	TLO TAC1,400000			;SET WP BIT IF JWP SET
	MOVE TAC,J			;SAVE J HERE
	MOVEI J,JOBN-1			;PREPARE TO SCAN ALL JOBS
SETRLC:	LDB AC1,PSEGN
	CAMN AC1,TAC			;USING THIS SEGMENT?
	SKIPN PROG,JBTADR(J)		;YES, IS JOBRL2 AVAILABLE?
	CAIA				;NO
	MOVEM TAC1,JOBRL2(PROG)		;STORE NEW JOBRL2
	SOJG J,SETRLC
	POP P,J
	POPJ P,

NXSEG:	POP P,J
	POP P,(P)
	JSP TAC,ERRMES
	ASCIZ /NO UPPER SEGMENT!
/

WPSEG:	POP P,J
	POP P,(P)
	JSP TAC,ERRMES
	ASCIZ /SORRY, PROTECTION FAILURE!
/

ILLPRO:	POP P,(P)
	JSP TAC,ERRMES
	ASCIZ /ILLEGAL PROTECTION CODE!
/

DISABL:	PUSHJ P,PRVSET			;GET BIT INTO TAC
	JRST NXPRV			;NO SUCH PRIVILEGE
	HRLOI TAC,-1-LUPPRV		;CR TYPED, CLEAR ALL BITS (EXCEPT TNTPRV)
	JFCL				;NOT LEGAL PRIV FOR THIS USER (OK TO CLEAR)
	ANDCAM TAC,JBTPRV(J)
	POPJ P,

ENABLE:	PUSHJ P,PRVSET
	JRST NXPRV
	SKIPA TAC,JB2PRV(J)		;CR, COPY PRIVILEGES FROM PASSIVE
	JRST ILLPRV			;NOT LEGAL FOR THIS USER
	IORM TAC,JBTPRV(J)
	POPJ P,

NXPRV:	JSP TAC,ERRMES
	ASCIZ /NO SUCH PRIVILEGE!
/

ILLPRV:	JSP TAC,ERRMES
	ASCIZ /SORRY, YOU CAN'T HAVE THAT PRIVILEGE!
/


DEFINE XLPRIV(NAM,VAL)<	'NAM',,VAL>
DEFINE XRPRIV(NAM,VAL)<>

↑LFTTAB:PRIVS
↑LFTLEN←←.-LFTTAB


DEFINE XLPRIV(NAM,VAL)<>
DEFINE XRPRIV(NAM,VAL)<'NAM',,VAL>

↑RHTTAB:PRIVS
↑RHTLEN←←.-RHTTAB


PRVSET:	PUSHJ P,CTEXT1
	JUMPE TAC1,CPOPJ1		;CR OR DELIM TYPED
IFG LFTLEN,<
	MOVSI TAC,-LFTLEN		;LENGTH OF LEFT TABLE
FNDLFT:	HLLZ AC1,LFTTAB(TAC)
	CAMN AC1,TAC1
	JRST ISLFT
	AOBJN TAC,FNDLFT
>;LFTLEN
IFG RHTLEN,<
	MOVSI TAC,-RHTLEN
FNDRHT:	HLLZ AC1,RHTTAB(TAC)
	CAMN AC1,TAC1
	JRST ISRHT
	AOBJN TAC,FNDRHT
>;FNDRHT
	POPJ P,				;NO SUCH PRIVILEGE

ISLFT:	HRLZ TAC,LFTTAB(TAC)		;LEFT HALF BIT
	CAIA
ISRHT:	HRRZ TAC,RHTTAB(TAC)		;RIGHT HALF BIT
	AOS (P)
	AOS (P)				;AT LEAST 2 SKIPS
	TDNE TAC,[RSPRVS]		;IS HE REQUESTING A RESTRICTED PRIVILEGE?
	POPJ P,				;YES, FLUSH
	MOVE AC1,JB2PRV(J)		;GET PASSIVE PRIVILEGES
	TLNN AC1,PRIPRV			;IF HE HAS PRIV PRIV, ALL IS OK
	TDNE TAC,AC1			;OR IF THE PRIV HE WANTS IS IN PASSIVE TABLE
	AOS (P)				;SKIP IF PRIV OK
	POPJ P,
; "CORE  #" - ASSIGNS #*1024 WORDS OF CORE TO JOB
;   "CORE" WITH NO ARG. WILL PRINT NO OF FREE BLOCKS LEFT
;	WITHOUT AFFECTING CURRENT ASSIGNMENT OF CORE



CORE:	PUSHJ	P,DECIN		;GET NO. OF 1K BLOCKS
	JRST	COR4		;NO ARG. SPECIFIED, JUST TYPE FREE BLOCK LEFT
	JRST	COMERA		;ILLEGAL DECIMAL CHARACTER RETURN
IFN FTLOGIN,<
	MOVE	TAC,JBTSTS(J)	;GET JOB STATUS WORD
	TLNN	TAC,JLOG	;IS JOB LOGGED IN?
	JRST	LOGPLS		;NO, TYPE OUT MESSAGE
>
	PUSHJ	P,CLRTPV	;CLEAR TEMPORARY PRIVILEGES
IFN FTSWAP,<
	MOVE	AC1,SWAPLIMIT	;GET THE SWAPLIMIT
	LSH	AC1,-12		;CONVERT SWAPLIMIT TO K
	CAMLE	TAC1,AC1	;TOO BIG?
	JRST	CORFX1		;YES. TELL HIM SO.
	TLNN	TAC,SWP		;IS HE SWAPPED OUT?
	JRST	COR3		;NO. CONTINUE
	JUMPN	PROG,DLYCR1	;DELAY UNTIL HE IS IN CORE
	SKIPN	TAC,TAC1	;DEC 3.16
	JRST	CORX		;DEC 3.16
	SOS	(PDP)		;DEC 3.16
	JRST	CORE0K		;DEC 3.16


COR3:>
	JUMPE	TAC1,COR0	;RELEASE DEVICES IF ASKING FOR 0 CORE
	MOVE	TAC,TAC1	
	LSH	TAC,12		;CONVERT 1K BLOCKS TO WORDS
	SUBI	TAC,1		;HIGHEST REL. LOC.
	PUSH	P,JBTADR(J)	;SAVE OLD CORE ASSIGNMENT
	LDB	TAC1,PSEGN	;SEE IF HE HAS AN UPPER
	SKIPE	TAC1
	PUSHJ	P,CORSGT	;YES, GET ITS SIZE INTO TAC1
	ADD	TAC1,TAC	;ADD LOWER SIZE + UPPER SIZE
	CAMLE	TAC1,CORMAX	;WILL IT FIT?
	JRST	CORFX		;NO
	PUSHJ	P,CORE0		;TRY TO ASSIGN CORE
	JRST	CORFX		;CAN'T DO IT
	POP	P,AC1		;GET BACK OLD CORE ASSIGNMENT
	SKIPE	AC1		;IF NO CORE ASSIGNED PREVIOUSLY
CORX1:	POPJ	P,DLYCOR-1	;DEC 3.16 
	PUSHJ	P,CLRJOB
	SETZM	JOBSA(PROG)
	JRST	CORX1

CORFX:	POP	P,(P)		;POP OFF OLD CORE ASSIGNMENT
CORFX1:	MOVE	DDB,-2(P)	;GET TTY DDB BACK
	JSP	TAC,ERRMES
	ASCIZ	/NOT ENOUGH CORE!
/
COR4:	MOVSI	TAC,NOINCK	;DON'T INITIALIZE A JOB
	IORM	TAC,-1(PDP)
	MOVE	DEVDAT,-2(P)	;RESTORE TTY DDB
IFE FTSWAP,<
	MOVE	TAC,CORTAL	;NO. OF FREE 1K BLOCKS
	PUSHJ	P,RADX10	;PRINT NO. OF FREE 1K BLOCKS LEFT
	PUSHJ	P,INLMES
CORMES:	ASCIZ	/K CORE LEFT
/
	POPJ	P,
>
IFN FTSWAP,<
IFN FTLOGIN,<
	MOVE	TAC,JBTSTS(J)	;GET JOB STATUS WORD
	TLNN	TAC,JLOG	;IS JOB LOGGED IN?
	JRST	COR2.1		;NOT LOGGED IN. HE HAS NO CORE.
>
	MOVEI	TAC1,(J)	;GET JOB NUMBER
	PUSHJ	P,CORSGT	;GET CORE SIZE IN WORDS
	LSH	TAC1,-12	;DIVIDE TO GET K
	MOVEI	TAC,(TAC1)
	PUSHJ	P,RADX10
	PUSHJ	P,INLMES
	ASCIZ	/K IS YOUR JOB SIZE.
/
	LDB	TAC1,PSEGN
	JUMPE	TAC1,COR2.1
	PUSHJ	P,CORSGT	;GET SIZE OF UPPER IN WORDS IN TAC1
	LSH	TAC1,-12	;CONVERT TO K
	MOVEI	TAC,(TAC1)
	PUSHJ	P,RADX10
	PUSHJ	P,INLMES
	ASCIZ	/K IS YOUR UPPER.
/
COR2.1:	MOVE	TAC,CORMAX		;LOAD AVAIL CORE ;REG
	CAMLE	TAC,SWAPLIMIT		;BIGGER THAN SWAPLIMIT?
	MOVE	TAC,SWAPLIMIT		;YES, PRINT IT INSTEAD
	LSH	TAC,-12			;CONVERT TO K
	PUSHJ	P,RADX10		;WRITE
	PUSHJ	P,INLMES
	ASCIZ	/K MAX.
/
	MOVE	TAC,CORMAX		;GET MAX AGAIN
	CAMG	TAC,SWAPLIMIT		;BIGGER THAN MAX?
	POPJ	P,
	LSH	TAC,-12
	PUSHJ	P,RADX10		;YES, PRINT IT ALSO
	PUSHJ	P,INLMES
	ASCIZ	/K USER CORE.
/
	POPJ	P,
>
↑LOGPLS:JSP TAC,ERRMES
	ASCIZ /LOGIN PLEASE
/
PRJOB:	PUSHJ P,INLMES
	ASCIZ /JOB /
	MOVE TAC,J
	PUSHJ P,RADX10
	PUSHJ P,PRSPC
PRCONF:	MOVEI TAC,CONFIG
	JRST CONMES

;HELLO 				;JS, REST OF PAGE
HELLO:	PUSHJ	P,PRCONF	;TELL HIM WHAT FLAVOR SYSTEM WE ARE!
	JRST	CRLF		;TYPE CRLF

IFN FTLOGIN,<
;AUTOMATIC LOGIN AFTER DISK REFRESH OR WHEN REFLAG SET	;DEC 3.16, REST OF PAGE

LOGREF:	MOVEM	TAC,PRJPRG(J)		;PJ,PG NOS IN REFLAG
	MOVSI	TAC,JLOG
	IORM	TAC,JBTSTS(J)		;LOG HIM IN.
	MOVSI	TAC,LUPPRV!PRIPRV	;SET JOB PRIVILEGES
	MOVEM	TAC,JBTPRV(J)
	MOVEM	TAC,JB2PRV(J)
	SETZM	-1(P)			;CLEAR ALL FLAGS FOR COMRET.
	SETZM	REFLAG			;ONLY ONCE.
	POPJ	P,
>
;"HELP" -HELP COMMAND


IFN FTLOGIN,<	;DEC 3.16
HELP1:	MOVE	TAC,HELPPP
	TLNE	AC1,JLOG
	POPJ	P,
	PUSHJ	P,ALOGIN
	MOVSI	TAC1,LUPPRV		;GIVE 100,100 THE LOCAL USER PRIV
	IORM	TAC1,JBTPRV(J)		;BECAUSE HE CAN'T HARM US
	JRST	SETLOG			;AND SET-UP LOGIN STUFF
>

HELP:
IFN FTLOGIN,<
	PUSHJ PDP,HELP1
>
	PUSH P,['HELP  ']
	JRST ARCOM

WHECOM:
IFN FTLOGIN,<
	PUSHJ P,HELP1
>
	PUSH P,['WHERE ']
	JRST ARCOM

WHOCOM:
IFN FTLOGIN,<
	PUSHJ P,HELP1
>
	PUSH P,['WHO   ']
	JRST ARCOM

FIXIML:
IFN FTLOGIN,<
	PUSHJ P,HELP1
>
	PUSH P,['FIXIML']
	JRST ARCOM

FNDCOM:
IFN FTLOGIN,<
	PUSHJ	P,HELP1
>
	PUSH	P,['FIND  ']
	JRST	ARCOM
;ALOGIN, SETTPV, CLRTPV

ALOGIN:
IFN FTLOGIN,<	
		MOVEM	TAC,PRJPRG(J)
IFN FTDISK,<
		SETZM	JBTUFD(J)
IFN FTDSKPPN,<	SETZM	DSKPPN(J)	;INTIALIZE DISK ALIAS PPN>
	>
		SETZM	JBTKCJ(J)
		MOVSI	TAC,JLOG
		ANDCAM	TAC,JBTSTS(J)
>
IFN FTSWAP,<
ALOGN1:	PUSHJ	P,TTYATI	;MAKE SURE TTY IS ATTACHED IN CASE
				;THIS COMMAND MUST BE DELAYED
				;BECAUSE NO CORE YET.
	JFCL
>
	POPJ	P,

SETTPV:	ANDCM	TAC,JBTPRV(J)	;DON'T NEED ANY TEMPORARY PRIVS HE REALLY HAS
	IORM	TAC,JBTPRV(J)	;GIVE HIM THE TEMP PRIVS
	IORM	TAC,JBTTPV(J)	;REMEMBER TEMP PRIVILEGES WE ARE GIVING HIM
	POPJ	P,

CLRTPV:	EXCH	TAC,JBTTPV(J)	;SAVE TAC, PICK UP TEMP PRIVILEGES
	ANDCAM	TAC,JBTPRV(J)	;TURN OFF TEMP PRIVS
	MOVEI	TAC,0
	EXCH	TAC,JBTTPV(J)	;RESTORE TAC, NO TEMP PRIVILEGES NOW
	POPJ	P,
;"LOGIN" - LOGIN COMMAND

IFN FTLOGIN,<

LOGDET:	JSP	TAC,ERRMES
	ASCIZ	/PLEASE KJOB OR DETACH
/

CLOGIN:	TLNE	AC1,JLOG	;IS HE LOGGED IN?
	JRST	LOGDET		;YES. FORCE LOGOUT FIRST
	SKIPE	TAC,REFLAG	;DEC 3.16
	JRST	LOGREF		;DEC 3.16
	JRST	.+2		;(TAC HAS A ZERO)
CXLOGI:	MOVEI	TAC,1
	HRRM	TAC,SAVSAI(J)	;SET STARTING OFFSET.
	MOVE	TAC,DUMPPN	;SET PRJPRG TO DMPPPN
	PUSHJ	P,ALOGIN	;AUTOMATIC LOGIN
	MOVSI	TAC,JACCT	;FLAG ACCOUNTING PROGRAM RUNNING
	IORM	TAC,JBTSTS(J)
	PUSHJ	P,SKPBRK
	MOVE	TAC,[SIXBIT /LOGIN/]	;LOGIN FILE NAME.
	MOVEM	TAC,JOBNAM(J)	;STORE FILE NAME
IFN FTSTAT,<PUSHJ P,NAMSTT>
	MOVSI	TAC1,'DSK'	;READ FROM DSK, DMPPPN AREA.
	JRST	RUNCO2
>

;ONE OF THE RPG COMMANDS -- COMPILE, DEBUG, ECT

RPGCOM:	PUSH PDP,[SIXBIT /RPG/]
	JRST ARCOM

ETCOM:	PUSH P,['E     ']
	JRST ARCOM

DSCCOM:	PUSH PDP,[SIXBIT /DART  /]
	JRST ARCOM

CPYCOM:	PUSH PDP,[SIXBIT /COPY/]
	JRST ARCOM

MAICOM:	PUSH P,[SIXBIT/MAIL/]
	JRST ARCOM

OBLCOM:	PUSH	P,['FORGET']
	JRST	ARCOM

RCVCOM:	PUSH	P,[SIXBIT /RCV/]
IFN FTLOGIN,<
	PUSHJ	P,HELP1
>
	JRST	ARCOM

NSCOM:	PUSH	P,[SIXBIT /NS/]
NSCOM1:	MOVE	TAC,JBTPRV(J)	;GET USER'S REAL PRIVS
	TLNN	TAC,LUPPRV	;IS HE LOCAL?
	JRST	NSCOM2		;NOPE, FLUSH HIM
	MOVSI	TAC,REAPRV
	PUSHJ	P,SETTPV	;SET TEMPORARY PRIVILEGES
	PUSH	P,[SIXBIT /  1  2/]
	JRST	ARPCOM

NSCOM2:	POP	P,TAC
	JRST	COMERR		;PRETEND IGNORANCE

UDPCOM:	PUSH	P,[SIXBIT /UDPUFD/]
	MOVE	TAC,JBTPRV(J)	;GET USER'S REAL PRIVS
	TLNN	TAC,LUPPRV	;IS HE LOCAL?
	JRST	NSCOM2		;NOPE, FLUSH HIM
	MOVSI	TAC,INFPRV!DAWPRV!WRTPRV!PROPRV	;BOY IS THIS A HAIRY PROGRAM
	PUSHJ	P,SETTPV	;SET TEMPORARY PRIVILEGES
	PUSH	P,[SIXBIT /  1  2/]
	JRST	ARPCOM

HOTCOM:	PUSH	P,[SIXBIT /HOT/]
	JRST	NSCOM1

SPLCOM:
IFN FTLOGIN,<
	PUSHJ	P,HELP1
>
	PUSH	P,[SIXBIT /SPOOL/]
	JRST	ARCOM

FINGER:
IFN FTLOGIN,<
	PUSHJ	P,HELP1
>
	PUSH	P,[SIXBIT /FINGER/]
	JRST	ARCOM

LSPCOM:	PUSH	P,[SIXBIT /LISP/]
	JRST	ARCOM

DOCOM:	PUSH	P,[SIXBIT /DO/]
	JRST	ARCOM

ZERCOM:	PUSH	P,[SIXBIT /ZERO/]
	JRST	ARCOM

XERCOM:	PUSH	P,[SIXBIT /XEROX/]
	JRST	ARCOM

TSTCOM:	PUSH	P,[SIXBIT /TEST/]
	JRST	ARCOM

RSLCOM:	PUSH	P,[SIXBIT /RSL/]
	JRST	ARCOM

TNCOM:	PUSH	P,[SIXBIT /T/]
	JRST	ARCOM

FTPCOM:	PUSH	P,[SIXBIT /FTP/]
	JRST	ARCOM

DILCOM:	PUSH	P,[SIXBIT /DIAL/]
	JRST	ARCOM
;R, RUN, SAVE, SSAVE, GET COMMANDS

;ARCOM:  CALL WITH JOBNAM STACKED.  RUN IT FROM SYS:
;AXCOM:	 SAME AS ARCOM, EXCEPT JOB STARTS AT C(JOBSA)+1

ARCOM:	TDZA	TAC,TAC		;AUTOMATIC RUN COMMAND
AXCOM:	MOVEI	TAC,1		;START WITH OFFSET=1
	PUSHJ	P,SKPBRK
ARCOM1:	HRRM	TAC,SAVSAI(J)	;SET STARTUP OFFSET
	POP	P,JOBNAM(J)	;STORE FILE NAME
IFN FTSTAT,<	PUSHJ	P,NAMSTT>
	MOVSI	TAC1,'SYS'	;READ FROM SYSTEM DEVICE
	JRST	RUNCO2

;START UP WITH DOUBLE-SKIP C(JOBSA)+2, TTY POINTS TO THE REST OF LINE
AXXCOM:	MOVSI	TAC,NOSKPB	;DOUBLE-SKIP ENTRY
	IORM	TAC,-2(P)	;TELL COMRET NOT TO CALL SKPBRK (JOBNAME STILL ON STACK)
	MOVEI	TAC,2		;SET FOR DOUBLE-SKIP ENTRY
	JRST	ARCOM1

;ARPCOM: CALL WITH JOBNAM STACKED, AND PPN STACKED TOO!

ARPCOM:	HLLZS	SAVSAI(J)	;ZERO STARTING OFFSET
	POP	P,JOBPPN(J)	;SETUP SGSET KLUDGE
	PUSHJ	P,SKPBRK	;SKIP TO END OF LINE
	POP	P,JOBNAM(J)
IFN FTSTAT,<	PUSHJ	P,NAMSTT>
	MOVSI	TAC1,'DSK'	;READ FROM DSK
	JRST	RUNCO4

;"R CUSPNAME CORE" - DOES "RUN SYS:CUSPNAME"
RCOM:	PUSH	P,[0]		;ZERO OUT PROGRAM NAME
	MOVEI	TAC,0
	JRST	ARCOM1

;"RUN DEVICE:FILE[PROJ.,PROG.] (CORE)"
;DOES A CORE,GET,START ALL IN ONE
;IF CORE ARG IS MISSING, SIZE IN DIRECTORY IS USED


RUNCOM:	PUSHJ	P,CTEXT1	;GET DEVICE NAME FROM COMMAND STRING
	SETZM	JOBNAM(J)	;CLEAR OUT OLD JOB NAME
IFN FTSTAT,<	PUSHJ	P,NAMSTT>
	HLLZS	SAVSAI(J)	;CLEAR STARTUP INCREMENT
RUNCO2:	SETZM	JOBPPN(J)	;DISABLE JOBPPN KLUGE FOR SGSET
RUNCO4:	MOVEI	IOS,RUNJOB
RUNCM:	PUSH	P,IOS		;SAVE DISPATCH
	JUMPN	PROG,RUNCO1	;NO. DOES JOB HAVE CORE?
	PUSH	P,TAC1		;SAVE DEVICE NAME
	MOVEI	TAC,ASSPRG	;CLEAR TTY "ASSIGNED BY PROGRAM" BIT
	ANDCAM	TAC,DEVMOD(DDB)
	MOVEI	TAC,JOBDA	;REQUEST JUST ENOUGH CORE FOR A JOB DATA AREA
	PUSHJ	P,CORE0		;IF OLD CORE(DEVICE ASSIGNMENTS RETAINED
	JFCL			;NO ROOM(PROG=0) OR ACTIVE IO (PROG NON ZERO)
	POP	P,TAC1		;RESTORE DEVICE NAME
RUNCO1:	POP	P,IOS		;ADR. OF MONITOR JOB
IFE FTSWAP,<	JUMPN	PROG,RUNCO3	;AND SCAN REST OF ARG. IF CORE ASSIGNED
		JSP	TAC,ERRMES
		ASCIZ	/CORE IS FULL
/
RUNCO3:>
IFN FTSWAP,<	JUMPE	PROG,DLYCOR	;DELAY IF ON DISK >
	MOVEM	UUO,COMWRD(PROG)	;PUT COMMAND IN AC FOR PROG TO SEE
	MOVEM	TEM,CHRWRD(PROG)	;ALSO DELIMITER CHAR
	SKIPN	AC2,JOBPPN(J)		;SPECIAL PPN HACK?
	JRST	SGSET			;NO
	JRST	SGSET0			;YES. SPECIAL ENTRY

;"GET DEVICE:FILE-NAME[PROJ.,PROG.] CORE" - SETS UP JOB AREA FROM RETREIVABLE
;DEVICE AND ASSIGNS CORE.


GET:	MOVEI	IOS,GETJOB	;SETUP TO RUN GETJOB
	PUSHJ	P,CTEXT1	;GET DEVICE NAME
	SETZM	JOBNAM(J)	;CLEAR JOB NAME
	SETZM	JOBPPN(J)	;DISABLE JOBPPN KLUGE FOR SGSET
IFN FTSTAT,<	PUSHJ	P,NAMSTT>
	JRST	RUNCM


;"SAVE FILE-NAME[PROJ.,PROG.] CORE" - SAVES JOB AREA ON RETRIEVABLE DEVICE
;ONLY A SAVE OR A GET IN PROGRESS FOR EACH JOB
;NO ATTEMPT IS MADE TO SAVE DEVICE ASSIGNMENTS, AC'S, OR PC


SSAVE:	TROA	IOS,SSAVJB	;SAVE UPPER ALSO (IOS CLEARED BEFORE DISPATCH)
SAVE:	MOVEI	IOS,SAVJOB	;SETUP TO RUN SAVJOB 
	PUSHJ	P,CTEXT1	;GET THE FIRST COMMAND ARGUMENT (DEV OR FILENAME)
	SETZM	JOBNAM(J)	;CLEAR JOB NAME.
IFN FTSTAT,<	PUSHJ	P,NAMSTT>
	JRST	SGSET		;SCAN THE REST OF THE ARGUMENTS
; "ASSIGN DEV:NAME" - ASSIGN DEVICE TO JOB AND GIVE IT LOGICAL NAME

ASSIGN:	MOVEI AC1,0			;START WITH NO ATTRIBUTES
ASSPP9:	PUSHJ P,CTEXT1			;GET FIRST ARGUMENT
	JUMPE TAC1,NOTENF		;NO ARGUMENT TYPED IF 0
	MOVEI AC2,0
	MOVSI TAC,770000
ASSPP1:	TDNN TAC,TAC1
	JRST ASSPP2
	IORM TAC,AC2			;MAKE MASK FOR NUMBER OF CHARACTERS TYPED
	LSH TAC,-6
	JUMPN TAC,ASSPP1
ASSPP2:	MOVSI TAC,-NASATT
ASSPP3:	CAMN TAC1,ASATTT(TAC)
	JRST ASSPP0			;EXACT MATCH.  GET BITS AND LOOP
	MOVE AC3,ASATTT(TAC)		;GET NAME OF ATTRIBUTE
	AND AC3,AC2			;AND WITH MASK
	CAMN TAC1,AC3
	TLON AC1,400000(TAC)
	AOBJN TAC,ASSPP3
	JUMPL TAC,ASSPPX		;AOBJN DIDN'T FALL THROUGH (TOO MANY MATCHES)
	JUMPGE AC1,ASSPPX		;IF SIGN BIT OFF THERE WERE NO MATCHES
	LDB TAC,[POINT 17,AC1,17]	;GET INDEX OF MATCHING ENTRY
ASSPP0:	TDNE AC1,ASATBB(TAC)		;CHECK FOR EXCLUDED BITS
	JRST COMERR			;NAUGHTY NAUGHTY
	IOR AC1,ASATTB(TAC)		;OK, TURN ON NEW BIT
	MOVEI AC1,(AC1)			;FLUSH CRUFT IN LH
	JRST ASSPP9

PUBBIT←←1
PRIBIT←←2
OLDBIT←←4

ASATTT:	'PUBLIC'
	'PRIVAT'
	'OLD   '
NASATT←←.-ASATTT

ASATTB:	PUBBIT
	PRIBIT
	OLDBIT
IFN .-ASATTB-NASATT,<PRINTS /SOMEONE CAN'T COUNT AT ASATTB
/>

ASATBB:	PRIBIT!OLDBIT			;TABLE OF BITS NOT ALLOWED WITH NEW ONE
	PUBBIT!OLDBIT
	PUBBIT!PRIBIT
IFN .-ASATBB-NASATT,<PRINTS /ASATBB WRONG SIZE
/>

ASSPPX:	MOVE	AC2,TAC1		;SAVE DEVICE NAME
	PUSHJ	P,CTEXT1		;GET LOGICAL NAME, IF ANY
	MOVEM TAC1,ASSLGN		;SAVE FOR LATER
	MOVE TAC1,AC2			;RESTORE TAC1 TO PHYS NAME
	HRRZS	(P)			;CLEAR PARTIAL MATCH FOUND FLAG
	PUSH	P,DDB			;SAVE TTY DDB ADDRESS
	MOVE	TAC,TAC1
	PUSH P,AC1			;SAVE ATTRIBUTE BITS
	PUSHJ	P,DEVPHY
	JRST	ASSG3
	POP P,AC1
	MOVEI	TAC1,ASSCON
	JRST	ASSG4

ASSG3:	POP P,AC1
	MOVEI TAC1,ASSCON		;SETUP ASSIGNED BY CONSOLE BIT
	HLRZ DDB,DEVLST
ASSG0:	MOVE TAC,DEVNAM(DDB)
	CAME AC2,DEVNAM(DDB)		;DOES PHYSICAL NAME MATCH?
	JRST ASSG1			;NO
ASSG4:	CAMN AC2,[SIXBIT /DSK/]		;IS THIS A DISK?
	JRST ASSG5			;YES.  BYPASS CHECK FOR SYSTEM TAPE
	CAMN TAC,SYSTAP			;IS NEXT DEVICE IN LIST THE SYSTEM TAPE?
	JRST ASSFIN			;YES, DO NOT ASSIGN. CLEAR DIRECTORY IN CORE BIT
ASSG5:	PUSHJ P,ASSUDP			;TEST VARIOUS UDP CASES
	JRST ASSR1A			;CAN'T GET UDPN SINCE PRIVATE AND NOT OURS
	PUSHJ P,ASSCKS			;NOW CHECK FOR RECYCLABLE DDB
	JRST ASLNOK			;I.E., SHARABLE DEVICE AND OUR ASSCON DDB
	PUSHJ P,ASSASG			;TRY TO ASSIGN DEVICE
	JRST ASSER1			;ALREADY ASSIGNED TO ANOTHER JOB
	JRST ASSFIN			;ASSIGNED

ASSUDP:	HLRZ AC3,TAC
	CAIE AC3,'UDP'
	JRST CPOPJ1			;NOT UDP.
	LDB AC3,PUNIT
	CAME AC2,[SIXBIT /UDP/]
	JRST ASSUD1			;ASKED FOR UDPN.  SEE IF PUBLIC OR OURS
	SKIPE UDPCNT-1(AC3)		;ANY DDBS IN USE FOR THIS UDP?
	POPJ P,				;YES.
ASSUD2:	TRNE AC1,PUBBIT			;WANTS TO MAKE IT PUBLIC?
	JRST AUDPPB			;YES.
	TRNE AC1,OLDBIT			;WANTS TO MAKE IT OLD STYLE?
	JRST AUDPOL			;YES.
	TRNN AC1,PRIBIT			;MAKE IT PRIVATE?
	JRST CPOPJ1			;NO.
	PUSHJ P,AUDPNU			;YES, FIRST MAKE IT NEW STYLE
	PUSHJ P,AUDPPV			;THEN MAKE IT PRIVATE
	JFCL				;IGNORE FAILURE RETURN
	JRST CPOPJ1

AUDPPV:	SKIPN UDPCNT-1(AC3)
	JRST ASSUD3			;OK TO PRIVATIFY UNUSED UDP
	PUSH P,DDB
ASSUD4:	HLRZ DDB,DEVSER(DDB)
	JUMPE DDB,ASSUD5
	CAME AC2,DEVNAM(DDB)
	JRST ASSUD5			;NO MORE DDBS FOR THIS UDP
	LDB TAC,PJOBN
	CAIN TAC,(J)
	JRST ASSUD4			;SAME JOB SAME UDP IS OK
	MOVE DDB,-3(P)			;TTY DDB
	PUSHJ P,INLMES
	ASCIZ /ALREADY IN USE, CAN'T MAKE PRIVATE.
/
	POP P,DDB
	MOVE TAC,DEVNAM(DDB)
	POPJ P,				;FAILURE RETURN

ASSUD5:	POP P,DDB
ASSUD3:	MOVE TAC,DEVNAM(DDB)
	MOVEM J,UDPOWN-1(AC3)		;MAKE UDP PRIVATE
	JRST CPOPJ1			;SUCCESS RETURN

ASSUD1:	SKIPL UDPOWN-1(AC3)		;WANTS UDPN
	CAMN J,UDPOWN-1(AC3)
	JRST ASSUD2			;OK SINCE PUBLIC OR OURS
	POPJ P,				;CAN'T GET UDPN SINCE PRIVATE NOT OURS

AUDPPB:	PUSHJ P,AUDPNU			;WANTS PUBLIC: FIRST MAKE NEW-STYLE
	LDB AC3,PUNIT
	MOVE TAC,DEVMOD(DDB)		;DDB POINTS TO MODEL DDB IT SAYS HERE
	TLNE TAC,DVDSK			;IF WE MANAGED NEW-STYLE,
	SETOM UDPOWN-1(AC3)		;PUBLICIFY IT
	JRST CPOPJ1

AUDPNU:	LDB AC3,PUNIT			;TRY TO MAKE IT NEW-STYLE UDP
	MOVE TAC,DEVMOD(DDB)
	TLON TAC,DVDSK			;OK IF ALREADY NEW-STYLE
	SKIPN UDPCNT-1(AC3)		;OR IF NO DDBS YET
	JRST AUDNOK
	EXCH DDB,-2(P)			;TTY DDB
	PUSHJ P,INLMES
	ASCIZ /ALREADY IN USE, CAN'T CHANGE FORMAT.
/
	EXCH DDB,-2(P)
	MOVE TAC,DEVNAM(DDB)
	POPJ P,

AUDNOK:	MOVEM TAC,DEVMOD(DDB)		;SET FORMAT BIT
	MOVEI TAC,DSKDSP
	HRRM TAC,DEVSER(DDB)		;SIGH, SET THE NEW DISPATCH TABLE TOO
	MOVE TAC,DEVNAM(DDB)
	POPJ P,

AUDPOL:	PUSHJ P,AUDPPV			;WANTS OLD-STYLE.  FIRST PRIVATIFY
	JRST CPOPJ1			;FAILED TO PRIVATIFY, SO NO OLD-STYLE
	AOS (P)				;WIN OR LOSE, WE'VE ESTABLISHED ACCESS
	LDB AC3,PUNIT			;TRY TO MAKE IT OLD-STYLE UDP
	MOVE TAC,DEVMOD(DDB)
	TLZE TAC,DVDSK			;OK IF ALREADY OLD-STYLE
	SKIPN UDPCNT-1(AC3)		;OR IF NO DDBS YET
	JRST AUDOOK
	EXCH DDB,-2(P)			;TTY DDB
	PUSHJ P,INLMES
	ASCIZ /ALREADY IN USE, CAN'T CHANGE FORMAT.
/
	EXCH DDB,-2(P)
	MOVE TAC,DEVNAM(DDB)
	POPJ P,

AUDOOK:	MOVEM TAC,DEVMOD(DDB)		;SET FORMAT BIT
	MOVEI TAC,UDPDSP
	HRRM TAC,DEVSER(DDB)		;SIGH, SET THE OLD DISPATCH TABLE TOO
	MOVE TAC,DEVNAM(DDB)
	POPJ P,

;ROUTINE TO TRY TO RECYCLE ASSCON-TYPE DDB FOR SHAREABLE DEVICE
ASSCKS:	MOVE AC3,DEVCMR(DDB)		;FIRST OF ALL, GOTTA BE SHARABLE DEV
	TLNN AC3,DEVSHR			;OR ASSASG WON'T COPY IT ANYWAY
	JRST CPOPJ1
	MOVE AC3,DDB			;NOW SEARCH ALL DDBS FOR THIS DEV
ASCKS1:	LDB TAC,[POINT 6,DEVCHR(AC3),5]	;PJOBN
	CAIE TAC,(J)			;MUST MATCH OUR JOB TO BE A CANDIDATE
	JRST ASCKS9			;ELSE CONTINUE THROUGH DDBS
	MOVE TAC,DEVMOD(AC3)		;MUST HAVE ASSCON
	TRNN TAC,ASSCON			;PERHAPS NEEDLESSLY CONSERVATIVE, BUT
	JRST ASCKS9			;PERHAPS SOMEONE NEEDS NOT CON+PRG SAME DDB
	SKIPE TAC,DEVLOG(AC3)		;OK IF NO LOGICAL NAME IN THE DDB
	CAMN TAC,ASSLGN			;OR IF IT'S THE SAME AS LOG NAME ARG NOW
	JRST ASCKS2
	SKIPE ASSLGN			;ALSO OK IF NO LOG NAME ARG IN COMMAND
	JRST ASCKS9			;BUT LOSE IF 2 DIFFERENT LOG NAMES
ASCKS2:	MOVE DDB,AC3			;GOT ONE!  SAVE POINTER
	POPJ P,

ASCKS9:	HLRZ AC3,DEVSER(AC3)		;CONTINUE THROUGH DDB CHAIN
	JUMPE AC3,CPOPJ1		;CAN'T HAPPEN MAYBE
	MOVE TAC,DEVNAM(AC3)		;MAKE SURE THIS IS SAME DEVICE
	CAMN TAC,DEVNAM(DDB)
	JRST ASCKS1			;OK, CONTINUE TESTING
	JRST CPOPJ1			;NO, POP AC3, SKIP RET

;SYSTEM TAPE OR NOT MATCH OF ARG AND PHYSICAL NAME.

ASSG1:	CAMN	TAC,SYSTAP		;IS THIS SYSTEM TAPE?
	JRST	ASSG2			;YES
	LDB	AC3,PJOBN		;SAVE OLD JOB NUMBER FOR THIS DEVICE
	MOVEM	AC3,ASSJBN
	TRZ	TAC,-1			;COMPARE LEFT HALF ONLY
	CAME	TAC,AC2
	JRST	ASSG2
	HRROS	-1(P)			;FLAG PARTIAL NAME MATCH FOUND
	PUSHJ P,ASSUDP			;DO UDP CHECKS
	JRST ASSG2			;THIS UDP NOT FREE TRY NEXT
	PUSHJ P,ASSCKS			;NOW CHECK FOR RECYCLABLE DDB
	JRST ASLNOK			;NONSKIP RETURN MEANS SUCCESS, GOT A DDB
	PUSHJ	P,ASSASG		;MATCH, TRY TO ASSIGN IT
	JRST	ASSG2			;KEEP LOOKING
	SKIPN ASSJBN
	JRST ASSFIN		;IF OLD JOB NUMBER 0,
					; DEVICE PREVIOUSLY UNASSIGNED

ASSG2:	HLRZ	DDB,DEVSER(DDB)
	JUMPN	DDB,ASSG0
	POP	P,DDB
	SKIPL	(P)			;DID WE HAVE ANY PARTIAL MATCHES?
	JRST	NOTDEV			;PRINT NO SUCH DEVICE
	MOVE	DDB,-2(P)		;RESTORE TTY DDB
	PUSHJ	P,INLMES
	ASCIZ	/SORRY, NO /
	MOVE	TAC1,AC2
	PUSHJ	P,PRNAME
	JSP	TAC,CONMES		;PRINT 'NO SUCH DEVICE'
	ASCIZ	/'S AVAILABLE.
/
;ALREADY ASSIGNED TO ANOTHER JOB

ASSR1A:	LDB TAC,PUNIT
	SKIPA TAC,UDPOWN-1(TAC)		;GET JOB NUMBER OF PRIVATE OWNER OF UDPN
ASSER1:	LDB	TAC,PJOBN		;GET JOB NUMBER FOR DEVICE
	POP	P,DDB			;GET DDB FOR TTY
	PUSH	P,TAC			;SAVE JOB NUMBER
	MOVEI	TAC,ASSMS2		;TYPE ERROR MESSAGE
	PUSHJ	P,ERRMES
	POP	P,TAC			;GET JOB NUMBER BACK
	JRST	DECLF

ASSMS2:	ASCIZ /ALREADY ASSIGNED TO JOB /

;DEVICE ASSIGNED, GIVE IT A LOGICAL NAME

ASSFIN:	SETZM	DEVLOG(DDB)		;CLEAR LOGICAL NAME
ASLNOK:	EXCH	DDB,(P)			;GET TTY DDB, SAVE DEVICE DDB
	MOVE	TAC1,ASSLGN		;RETRIEVE SAVED LOGICAL NAME ARG
	SKIPN	TAC,TAC1		;IS THERE A LOGICAL NAME SPECIFIED?
	JRST	DEFASS			;NO.  CHECK FOR DEFAULTING ASSIGNMENT
	PUSHJ	P,DEVLG			;SEE IF IT IS ALREADY IN USE BY THIS USER
	JRST	ASSF1			;NO
	MOVEI	TAC,LOGERR		;YES, PRINT ERROR
	MOVE	DDB,-3(P)		;RESTORE TTY DDB
	PUSHJ	P,ERRMES
DEFLOS:	MOVEI	TAC,0			;CLEAR LOGICAL NAME FOR THIS DEVICE
ASSF1:	POP	P,DDB
	SKIPN DEVLOG(DDB)		;WILL BE NONZERO ONLY FOR RECYCLED DDB
	MOVEM	TAC,DEVLOG(DDB)		;STORE IN DEVICE DATA BLOCK
	MOVSI	TAC1,DVDIRIN		;CLEAR DIRECTORY IN CORE BIT
	ANDCAM	TAC1,DEVMOD(DDB)
	MOVE	TAC1,DEVNAM(DDB)	;PHYSICAL NAME
	MOVE	AC2,DDB
	MOVE	DDB,-2(P)		;RESTORE TTY DDB
	PUSHJ	P,PRNAME		;PRINT IT
	PUSHJ	P,INLMES
	ASCIZ	/ ASSIGNED/
	SKIPN	DEVLOG(AC2)
	JRST	NOLOGP
	PUSHJ	P,INLMES
	ASCIZ	/ AS /
	MOVE	TAC1,DEVLOG(AC2)
	PUSHJ	P,PRNAME
NOLOGP:	JSP	TAC,CONMES
	ASCIZ/
/

LOGERR:	ASCIZ 	/LOGICAL NAME ALREADY IN USE, /

DEFASS:	MOVE	DDB,(P)
	CAME	AC2,DEVNAM(DDB)
	CAMN	AC2,['TTY   ']		;DON'T DO IT FOR TTY
	JRST	ASSF1
	MOVE	TAC,AC2
	PUSHJ	P,DEVLG			;INUSE?
	JRST	ASSF1
	JRST	DEFLOS
;"DEASSIGN DEV" - DEASSIGNS DEVICE FROM CONSOLE


DEASSI:	JUMPE ITEM,CPOPJ	;NO-OP IF NO JOB NUMBER
	PUSHJ PDP,CTEXT1	;GET DEVICE NAME
	JUMPE TAC1,DEALL 	;NO ARG. IF 0, DEASSIGN ALL BUT TTY
	MOVE TAC, TAC1		;DEVICE NAME
DEAER4:	PUSHJ PDP,DEVLG		; SEARCH LOGICAL NAMES FIRST
	JRST DEAER3
	PUSHJ PDP,DEASG
	CAIA
	JRST DEADON
	PUSH PDP,[DEAER4+1]
	JRST DEV0
DEAER3:	PUSHJ PDP,DEVPHY	; NOT FOUND, TRY PHYSICAL NAMES
	JRST DEAER2		; NOT FOUND AT ALL, LOSE!
	PUSHJ PDP,DEASG		; FOUND, DEASSIGN IT
	CAIA
	JRST DEADON
	MOVE AC1,DEVMOD(DDB)
	TLNE AC1,DVTTY		; STOP IF FOUND A TTY
	POPJ P,			; QUIT HERE OR WILL LOOP INDEFINITELY!!!!
				; ALSO FLUSH UNUSED TTY'S
	PUSH PDP,[DEAER3+1]
	JRST DEVLP2

DEADON:	MOVE AC1,DEVMOD(DDB)
	TLNE AC1,TTYATC		; NOT FOR CONSOLE OF LOSER
	POPJ P,
	TRNN AC1,ASSPRG		; STILL ASSIGNED BY PROGRAM?
	JRST DEADN1
	MOVE TAC1,DEVNAM(DDB)
	MOVE DDB,-2(P)
	PUSHJ P,PRNAME
	JSP TAC,ERRMES
	ASCIZ/ DEASSIGNED, BUT STILL INITED!
/

DEADN1:	TLNN AC1,DVTTY		; IF TTY
	POPJ P,
	JRST TTYREL		; RELEASE IT SO DDB WILL BE LET GO

↑NOTDEV:
DEAER1:	MOVE DEVDAT,-2(PDP)	; RESTORE TTY DDB
	JSP TAC,ERRMES		; PRINT 'NO SUCH DEVICE'

	ASCIZ /NO SUCH DEVICE
/

DEAER2:	MOVE TAC1,TAC			;PRINT PHYSICAL DEVICE NAME
	MOVE DEVDAT,-2(PDP)		; RESTORE TTY DDB FIRST
	PUSHJ PDP,PRNAME
	JSP TAC,ERRMES

	ASCIZ / WASN'T ASSIGNED
/

DEALL:	PUSH P,DDB
	SETZ DDB,
	PUSHJ P,DEASTY
	POP P,DDB
	POPJ P,
;REASSIGN UUO
;CALL	MOVE AC,JOB NUMBER
;	MOVE AC+1,SIXBIT /DEVICE/
;	CALL AC,[SIXBIT /REASSIGN/]
;IF C(AC)=0, JOB HAS NOT BEEN INITIALIZED
;IF C(AC+1)=0, DEVICE NOT ASSIGNED TO THIS JOB OR DEVICE IS A TTY



↑REASSI:
	LDB UUO,PUUOAC
	HRLI UUO,PROG
	PUSH PDP,@UUO		;STACK JOB NUMBER TO BE REASSIGNED TO
	AOS UUO
	MOVE TAC1,@UUO		;DEVICE NAME
	MOVE ITEM,JOB(PID)	;THIS JOB NUMBER
	SOJA UUO,REASS1

;"REASSIGN DEV:JOB" - REASSIGN DEVICE "DEV" TO JOB "JOB"


REASS:
	PUSHJ PDP,CTEXT1	;GET DEVICE NAME
	JUMPE TAC1,NOTENF	;NULL NAME?
	MOVE UUO,TAC1		;SAVE IT IN UUO
	PUSHJ PDP,DECIN1	;GET NEW JOB NUMBER
	JRST NOTENF		;NONE SPECIFIED. DOESN'T RETURN IF ERROR
	JRST COMERA		;ILLEGAL CHARACTER
	PUSH PDP,TAC1		;PUT JOB NUMBER ON STACK, DEVICE
	MOVE TAC1,UUO		;NAME IN TAC1
	SETZM UUO		;SET COMMAND SWITCH

;ROUTINE COMMON TO REASSIGN UUO AND COMMAND


REASS1:	EXCH ITEM,(PDP)		;NEW JOB NO. IN ITEM
	MOVE TAC,JBTSTS(ITEM)	;NEW JOB STATUS
	EXCH ITEM,(PDP)		;RESTORE ITEM AND STACK
	TLNN TAC,JNA		;DOES NEW JOB EXIST?
	JRST REASE1		;NO.
	MOVE TAC,TAC1
	PUSHJ PDP,FNDDDB	;SEARCH FOR DEV (USE CHANNEL # IF UUO)
	JRST REASE2		;NOT FOUND
	LDB TAC,PJOBN
	CAME TAC,ITEM		;ASSIGNED TO THIS JOB
	JRST REASE3		;NO
	MOVE TAC,DEVMOD(DEVDAT)
	TLNE TAC,TTYATC		;IS IT HIS CONSOLE?
	JRST REASE6		;YES. CAN'T BE REASSIGNED.
	TRNN TAC,ASSPRG		;IS DEVICE INITED?
	JRST REASS3		;NO.
	JUMPN UUO,REASS4	;YES. COMMAND LEVEL?
	HRL DEVDAT,(PDP)	;YES. SCHEDULE RELEASE
	MOVEM DEVDAT,JOBFDV(JDAT)
	POP PDP,TAC1
	MOVE DEVDAT,-2(PDP)
	MOVSI TAC1,TTYRNC	;SET TTYRNC SO JOB WILL RUN
	IORM TAC1,-1(PDP)
	JSP TAC1,MSTART
	JSP TAC,MONSTR
	HLRZ TAC,JOBFDV(JDAT)
	PUSH PDP,TAC
	HRRZ DEVDAT,JOBFDV(JDAT)
	MOVE ITEM,JOB(PID)
	SETOM UUO		;SET FLAG TO STOP JOB
REASS4:	HRRZ DSER,DEVSER(DEVDAT)
	HRRZM DEVDAT,JOBFDV(JDAT)
	SKIPGE UCHN,USRHCU(PID)	; HAS MONDMP BEEN HERE?
	JRST REASS3		;YES, WE CAN'T BE IN USRJDA LIST
REASS2:	HRRZ DEVDAT,USRJDA(UCHN)
	PUSH PDP,UCHN
	CAME DEVDAT,JOBFDV(JDAT)
	JRST REASS8
	HLL DEVDAT,USRJDA(UCHN)	; PICK UP UUO FLAGS FIRST
	PUSHJ PDP,RELEA5	; NOW RELEASE DEVICE
REASS8:	POP PDP,UCHN
	SOJGE UCHN,REASS2
	SKIPL UCHN,JBTIOP(J)
	JRST REAST1
REAST2:	HRRZ DDB,(UCHN)
	CAME DDB,JOBFDV(JDAT)
	JRST REAST3
	MOVE DDB,USRJDA
	EXCH DDB,(UCHN)
	MOVEM DDB,USRJDA
	PUSH P,UCHN
	SETZ UCHN,
	PUSHJ P,RELEA5
	POP P,UCHN
	MOVE DDB,(UCHN)
	EXCH DDB,USRJDA
	MOVEM DDB,(UCHN)
REAST3:	ADD UCHN,[1,,1]
	AOBJN UCHN,REAST2
REAST1:	MOVE DEVDAT,JOBFDV(JDAT)
REASS3:	MOVEI TAC,ASSCON	;ASSIGN IT BY CONSOLE
	IORM TAC,DEVMOD(DEVDAT)
	POP P,J
	DPB J,PJOBN		;PUT IN NEW JOB NUMBER
	SETZM DEVLOG(DDB)	;FLUSH LOGICAL DEVICE NAME!
	MOVE J,JOB(PID)
	JUMPL UUO,ESTOP
	POPJ PDP,
REASE1:	POP PDP,TAC
	JUMPE UUO,NOTLOG	;PRINT NO SUCH JOB
REASE4:	SETZM @UUO		;CLEAR C(AC)
	POPJ PDP,

REASE2:	MOVEI TAC,NOTDEV	;NO SUCH DEVICE
REASE5:	POP PDP,TAC1
	JUMPE UUO,(TAC)
	AOJA UUO,REASE4

REASE3:	MOVEI TAC,REASSX	;WASN'T ASSIGNED
	JRST REASE5

REASE6:	MOVEI TAC,REASE7
	JRST REASE5
REASE7:	MOVE TAC1,DEVNAM(DEVDAT)
	MOVE DEVDAT,-2(PDP)	; RESTORE TTY DDB
	PUSHJ PDP,PRNAME
	JSP TAC,ERRMES
	ASCIZ / CAN'T BE REASSIGNED
/

REASSX:	MOVE TAC1,DEVNAM(DEVDAT)
	JRST DEAER2+1
;"ATTACH DEVNAM" -ATTACHES A PREVIOUSLY PARTITIONED DEVICE
;	NOTE-MUST BE LOGGED IN UNDER [1,1] TO DO THIS
; "ATTACH N [PROJ.,PROG.]" - ATTACH CONSOLE TO JOB N
;CHANGES ADDRESS OF TTY DEVICE DATA BLOCK STORED IN -2(PDP)
;BY THE COMMAND DECODER



↑ATTACH:
	PUSHJ	P,DECIN		;GET JOB NO.
	JRST	NOTENF		;NOT A NUMBER OR NONE SPECIFIEED
IFN FTLOGIN,<
	JRST	DEVATT		;WANTS TO ATTACH A DEVICE
>
IFE FTLOGIN,<
	JRST	NOTLOG		;NO SUCH JOB
>
	JUMPE	TAC1,NOTLOG	;0 IS ILLEGAL
	CAIL	TAC1,JOBN	;IS JOB NUMBER TOO BIG?
	JRST	NOTLOG		;ILLEGAL JOB NUMBER.  PRINT NO SUCH JOB
	MOVSI	AC2,JNA		;HAS THIS JOB NO BEEN ASSIGNED?
	TDNN	AC2,JBTSTS(TAC1)
	JRST	NOTLOG		;NO, PRINT NO SUCH JOB
IFN FTLOGIN,<
	PUSH	P,TAC1		;SAVE JOB NO.
	PUSHJ	P,PJPGNO	;GET PROJ.-PROG. NOS. ARG
	MOVE	AC2,PRJPRG(J)	;NO PP NO. USE CURRENT ONE
	POP	P,TAC1		;RESTORE
	CAME	AC2,PRJPRG(TAC1);MATCHES THE DETACHED JOB'S PPN?
	JRST	ATT3		;NO-ERROR
				;YES
>
	LDB	TAC,PUNIT	;GET LINE NUMBER OF TTY THAT'S TYPING.
	JRST	.+2
ATTILA:	HRRE	TAC,JBTLIN(J)	;GET LINE NUMBER OF CONTROLING JOB.
	CAIGE	TAC,PTYL0	;IS THIS ON A PTY?
	JRST	THEHUN		;NO. ATTACH IS LEGAL.
	MOVE	J,PTYJOB-PTYL0(TAC)	;GET JOB NUMBER OF CONTROLING JOB.
	CAIE	J,(TAC1)	;CONTROLLER=JOB TO ATTACH TO?
	JRST	ATTILA		;NO.  KEEP LOOPING
	MOVEI	J,0
	JSP	TAC,ERRMES
	ASCIZ	/ILLEGAL ATTACH LOOP
/

THEHUN:	MOVE	J,TAC1		;JOB NUMBER TO J
	PUSHJ	P,COMRT2	;FIX COMCNT
	PUSHJ	P,TTYATT	;NO, ATTACH TTY
	JRST	ATT2		;ERROR CAN'T ATTACH
	MOVEM	DDB,-2(P)	;CHANGE DEV DATA BLOCK ADDRESS
	JRST	TTYFND		;ATTACHED. GO SET UP OUTPUT BYTE PTR.
IFN FTLOGIN,<
DEVATT:
	ADDI	TEM,20		; MAKE FIRST CHAR OF DEVICE NAME INTO SIXBIT
	PUSH	P,TEM		; NOW SAVE IT
	PUSHJ	P,CTEXT		;GET DEVICE ARGUMENT
	JFCL			;SHOULD NEVER RETURN
	POP	P,TEM		; GET CHARACTER BACK
	MOVE	AC1,JBTPRV(J)	;GET JOB PRIVILEGES.
	TLNN	AC1,DEVPRV	;HAS HE THIS PRIV?
	JRST	ATT5		;NO - ERROR
	MOVE	TAC,TAC1	;YES-SET UP DEVICE NAME
	LSH	TAC,-6
	DPB	TEM,[POINT 6,TAC,5]
	PUSH	P,DDB		;SAVE DDB FOR THIS TTY
	PUSHJ	P,DEVSRC	;SEARCH FOR DEVICE
	JRST	DADD01		;NOT FOUND
	LDB	AC1,PJOBN	;GET JOB NUMBER
	JUMPN	AC1,ATT6	;IS IT = 0?
	MOVE	TAC,DEVMOD(DDB) ;CHECK TO SEE IF THIS IS A TTY
	TLNE	TAC,DVUDP
	JRST	ATTUDP		;UDP IS SPECIAL
	TRNE	TAC,ASSPRG	;IN USE BY JOB 0?
	JRST	ATT5A		;YES, CAN'T ATTACH IT
	DPB	J,PJOBN		;SET JOB NUMBER
	LDB	TAC1,PUNIT	;
	TLNE	TAC,DVTTY	;IS IT A TTY?
	HRRM	DDB,TTYTAB(TAC1);DEC 3.16
DADD02:	POP	P,DDB		;
	POPJ	P,		;RETURN

ATTUDP:	LDB TAC,PUNIT		;TRYING TO ATTACH UDP
	SKIPN UDPCNT-1(TAC)	;MUST BE NO DDBS
	SKIPE UDPOWN-1(TAC)	;AND OWNER 0
	JRST ATT6		;ELSE IN USE, PUBLIC, OR SWAPPING DEVICE!
	SETOM UDPOWN-1(TAC)	;OK, MAKE IT PUBLIC
	JRST DADD02		;NOTE THAT YOU DON'T HAVE IT ASSIGNED NOW!

;NOTE: THIS ROUTINE IS ALSO CALLED FROM PJOB COMMAND
DADD00:	MOVEI TAC1,0		;SUBROUTINE TO CHECK "DEV" NAME FOR DD
	ROTC TAC,14
	CAIN TAC1,'DD'		;NOT A DEVICE, IS IT A DD CHANNEL?
	PUSHJ P,SIX2LN		;YES, GOBBLE NUMBER
	POPJ P,			;NOT DD OR NO NUMBER
	CAIL TAC1,=32
	POPJ P,
	MOVSI TAC,DDDETU!DDANYW	;DETACHED USE CODE
	HRRI TAC,(TAC1)
	JRST CPOPJ1

DADD01:	PUSHJ P,DADD00		;NOT A REAL DEVICE, TRY DD CHAN
	JRST TEMP1		;NOPE
	LDB TAC1,[DDUSR+<(TAC)>];YES, LOOK AT ITS USE CODE
	CAIE TAC1,DDDETU
	JRST ATT6		;WASN'T DET
	PUSHJ P,DDREL		;LET GO!!
	JRST DADD02
>
ATT2:	EXCH	DDB,TAC1		;PUT LINE NO. OF OUR TTY IN DDB
	MOVE	TAC1,DEVNAM(TAC1)	;PRINT PHYSICAL NAME
	MOVE	DDB,TTYTAB(DDB)		;PRINT MESSAGE ON RIGHT TTY !!
	PUSHJ	P,PRNAME
	JSP	TAC,ERRMES
	ASCIZ	/ ALREADY ATTACHED
/

ATT3:	JSP	TAC,ERRMES
	ASCIZ	/PROJECT-PROGRAMMER NUMBER MISMATCH
/

ATT5A:	POP	P,DDB
ATT5:	JSP	TAC,ERRMES
	ASCIZ	/CAN'T ATT DEV
/

ATT6:	POP	P,DEVDAT
	JSP	TAC,ERRMES
	ASCIZ	/WASN'T DET
/
;FLUSH THIS TTY'S BUFFERS IF NOT IN USE BY A JOB

FLUSH:	PUSHJ P,CTEXT1
	JUMPE TAC1,NOTENF	;NO ARG?
	MOVE TAC,TAC1
	PUSHJ P,LOG2LN		;CONVERT TO LINE NUMBER
	JRST NOTTTY
	SKIPN DDB,TTYTAB(TAC1)
	JRST FLUSH1
	LDB TAC,PJOBN
	CAME TAC,J		;LET HIM DO IT TO HIMSELF
	JUMPN TAC,INUSE		;JOB ON IT
	PUSHJ P,TSETBF		;CLEAR BUFFERS
	MOVSI TAC,TPMON!IOFST
	MOVEM TAC,DEVIOS(DDB)	;MAKE HIM A VIRGIN
FLUSH1:	MOVE DDB,-2(P)		;GET BACK OUR DDB
	MOVEI DAT,TTOBUF(DDB)
	JSP TAC,CONMES
	ASCIZ/FLUSHED./

NOTTTY:	MOVE DDB,-2(P)
	MOVEI DAT,TTOBUF(DDB)
	JSP TAC,ERRMES
	ASCIZ/NOT A TTY.
/

INUSE:	MOVE DDB,-2(P)
	MOVEI DAT,TTOBUF(DDB)
	JSP TAC,ERRMES
	ASCIZ/IN USE.
/
;"FORK", "CFORK", "DETACH" AND "CDETACH" COMMANDS
;"DETACH" - DETACH CONSOLE FROM JOB 
;"DETACH DEVNAM" - DETACHES DEVICE FROM THE SYSTEM SOFTWAREWISE

MFORK:	PUSH	P,J		;SAVE J
	PUSHJ	P,INIJOB	;INITIALIZE A JOB
	JRST	[POP	P,J	;NO JOBS AVAILABLE.
		POP	P,(P)	;FLUSH CALL TO MFORK
		MOVSI	TAC,NOMESS	;LET ERROR MESSAGE THROUGH
		ANDCAM	TAC,-1(P)
		JRST	LOSEJB]	;
	JRST	[POP	P,J
		POP	P,(P)
		JRST	DLYCM1]	;DELAY THIS COMMAND UNTIL FREE STORAGE AVAILABLE
	MOVE	TAC,J
	POP	P,J
	POPJ	P,

CFORK:	MOVSI	TAC,JERR
	TDNE	TAC,JBTSTS(J)
	JRST	NOCONT
	MOVM	TAC,JOBQUE(J)
	CAIE	TAC,STOPQ	;START HIM ONLY IF STOPPED.
	JRST	FORK		;ALREADY RUNNING(MIGHT NOT BE IN RUNQ)
	PUSHJ	P,MFORK		;GET A NEW JOB NUMBER IN TAC
	PUSH	P,TAC
	MOVNI	TAC,RUNQ
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,REQUE
	PUSHJ	P,SETRUN
	JRST	FORK1		;WE HAVE NEW JOB NUMBER ON STACK.

FORK:	PUSHJ	P,MFORK		;GET US A NEW JOB NUMBER IN TAC
	PUSH	P,TAC		;ALL SET.
FORK1:	PUSH	P,JBTLIN(J)
	PUSHJ	P,DETCH1
	POP	P,TAC1		;GET BACK OLD LINE NUMBER
	HRLM	J,-1(P)		;SAVE THE OLD JOB NUMBER ON TOP OF PC FLAGS
	PUSHJ	P,DDBSRC	;GET A NEW DDB
	JRST	[POP	P,J	;LOSE.
		PUSHJ	P,RELJOB	;RELEASE THE JOB WE GOT
		MOVEI	J,0	;SIGNAL ERROR TO COMRET
		POPJ	P,]
	MOVSI	TAC,NOMESS
	ANDCAM	TAC,-2(P)	;OK TO TALK NOW
	MOVEM	DDB,-3(P)	;AND WHERE TO SAY IT
	MOVEI	DAT,TTOBUF(DDB)
	POP	P,J		;GET THE JOB NUMBER OF NEW JOB.
	PUSHJ P,FORKC		;COPY OLD JOB'S POOP
	PUSHJ P,PRJOB
	PUSHJ P,INLMES
	ASCIZ/
FORK YOU VERY MUCH!/
	JRST PRCRCC

↑FORKC:	MOVSI	TAC,JLOG!JNA
	IORM	TAC,JBTSTS(J)	;MAKE THIS JOB HIS
	SETZM	DEVLOG(DDB)	;ZERO LOGICAL NAME OF TTY
	PUSHJ	P,TTYATI
	HLRZ	TAC,-1(P)	;GET THE OLD JOB NUMBER BACK
	MOVE	TAC,PRJPRG(TAC)
	MOVEM	TAC,PRJPRG(J)	;GIVE HIM SAME PPN
	HLRZ	TAC,-1(P)
	MOVE	TAC,JBTPRV(TAC)
	MOVEM	TAC,JBTPRV(J)	;COPY PRIVILEGES
	HLRZ TAC,-1(P)
	MOVE TAC,JB2PRV(TAC)
	MOVEM TAC,JB2PRV(J)	;ALSO PASSIVE ONES
	PUSHJ	P,SETLOG	;GET GOOD STUFF
	HLRZ	TAC,-1(P)	;GET THE OLD JOB NUMBER BACK
	MOVE	TAC,DSKPPN(TAC)
	MOVEM	TAC,DSKPPN(J)	;GIVE HIM THE SAME ALIAS
	POPJ P,

LOSEJB:	JSP	TAC,ERRMES
	ASCIZ/JOB CAPACITY EXCEEDED!
/

CDETACH:MOVSI	TAC,JERR
	TDNE	TAC,JBTSTS(J)
	JRST	NOCONT
	MOVM	TAC,JOBQUE(J)
	CAIE	TAC,STOPQ
	JRST	DETCH1
	MOVNI	TAC,RUNQ
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,REQUE
	PUSHJ	P,SETRUN
IFE FTLOGIN,<DETACH:>
DETCH1:	PUSHJ	P,COMRT2	;FIX COMMAND BIT, COMCNT BEFORE DETACHING.
	JRST	TTYDET		;GO DETACH TTY.

IFN FTLOGIN,<

DETACH:	PUSHJ	P,CTEXT		;GET ARGUMENT
	JUMPE	TAC1,DETCH1	;ONLY "DET" TYPED
	MOVE	AC1,JBTPRV(J)	;GET PRIV BITS
	TLNN	AC1,DEVPRV	;DEVICE DETACH-ATTACH PRIV?
	JRST	LOGER1		;NO-PRINT ERROR MSG.
	MOVE	TAC,TAC1	;YES-SET UP DEVICE NAME
	PUSH	P,DDB		;SAVE TTY DDB
	PUSHJ	P,DEVSRC	;SEARCH FOR DEVICE
	JRST	DDDD01		;DEVICE NOT FOUND
	MOVE	TAC,DEVMOD(DDB)	;CHECK TO SEE IF THIS IS DSK
	TLNE	TAC,DVUDP	;IS IT A UDP?
	JRST	DDDUDP		;YES, BIG MESS
	TLNE	TAC,DVDSK	;IS IT THE DSK?
	JRST	TEMP1		;YES-PRINT ERROR MSG.
	MOVEI	TAC1,ASSCON	;FOUND-SET UP ASSIGNED BY CONSOLE
	PUSHJ	P,ASSASG	;TRY TO ASSIGN
	JRST	ASSER1		;CAN'T ASSIGN
	TLNE	DDB,SYSDEV	;IS THIS SYSTEM DEVICE?
	JRST	TEMP1		;YES-PRINT ERROR MSG.
	XOR	AC1,AC1		;NO-SET TO ZERO
	DPB	AC1,PJOBN	;SET JOB NO. TO NULL JOB
	MOVE	TAC,DEVMOD(DDB)	;CHECK TO SEE IF THIS IS A TTY
	TLNN	TAC,DVTTY	;IS IT A TTY?
	JRST	DDDD03		;NO-GO AHEAD
	LDB	TAC,PUNIT	;YES-SET UP FOR SCNSER
	MOVEI	TAC1,-1		;SET LEFT HALVE OF TTYTAB TO -1
	HRRM	TAC1,TTYTAB(TAC);SO THAT SCNSER CHECKS FOR THIS
DDDD03:	POP	P,DEVDAT	;RESTORE OUR TTY DDB
	MOVSI	TAC,NOPER!NOCRLF!NOMESS	; ASK TO TYPE OUT A CRLF AND A PERIOD
	ANDCAM	TAC,-1(P)	; BY ZEROING THESE IN THE COMMAND FLAGS
	POPJ	P,		;SUCCESSFUL RETURN

DDDUDP:	LDB TAC,PUNIT		;TRYING TO DETACH UDP, GET UNIT NUMBER
	SKIPE UDPCNT-1(TAC)	;MUST HAVE NO OUTSTANDING DDBS
	JRST ASSER1		;ELSE LOSE
	SETZM UDPOWN-1(TAC)	;OK, SET JOB 0 AS OWNER
	JRST DDDD03		;ANNOUNCE WIN

TEMP1:	POP	P,DDB		;RESTORE TTY DDB
	JRST	DEAER1		;PRINT ERROR MSG. AND RETURN

LOGER1:	JSP	TAC,ERRMES
	ASCIZ	/CAN'T DET DEV
/

DDDD01:	PUSHJ P,DADD00		;NOT A DEV, TRY DD CHAN
	JRST TEMP1		;N
	PUSHJ P,DDCGET
	JRST DDDD02		;IN USE
	JRST DDDD03		;WIN
DDDD02:	POP P,DDB
	JSP TAC,ERRMES
	ASCIZ /CHANNEL IN USE
/
>	;CLOSE FTLOGIN
;"DAYTIME" - PRINT TIME OF DAY
↑DAYTIM:
	PUSHJ	P,DECIN		;PICK UP JOB NUMBER ARGUMENT
	JRST	DAYT2		;NO ARGUMENT.  GIVE HIM DAY, DATE & TIME
	JRST	COMERA		;ILLEGAL DECIMAL ARGUMENT
	JUMPN	TAC1,.+2	;ZERO ARGUMENT?
	MOVE	TAC1,J		;YES.  "DAYTIME 0" GETS TIMES FOR OWN JOB
	MOVE	TAC,JBTSTS(TAC1)
	TLNE	TAC,JNA
	TLNE	TAC,JSEG
	JRST	NOTLOG		;NO JOB OR A SEGMENT.  PRINT NO SUCH JOB.

	PUSH	P,[0]		;INITIALIZE A FLAG: DONT PRINT DATES
	HLRZ	TAC,JBTBTM(TAC1);GET LOGIN DATE
	CAME	TAC,THSDAT	;DID HE LOGIN TODAY?
	SETOM	(P)		;NO.  FLAG TO PRINT DATES
	MOVEI	TAC,[ASCIZ /LOGIN   RUN    NOW
/]
	SKIPE	(P)		;PRINTING DATES?
	MOVEI	TAC,[ASCIZ /  LOGIN      RUN       NOW
/]				;YES, LEAVE ROOM FOR DATES
	PUSHJ	P,CONMES	;PRINT TITLES
	MOVE	TAC,JBTBTM(TAC1);GET LOGIN DATE/TIME
	PUSHJ	P,PRDATM	; AND PRINT IT
	MOVE	TAC,FTIME(TAC1)	;GET DATE/TIME LAST RUN
	PUSHJ	P,PRDATM	; AND PRINT IT
	MOVE	TAC,TIMDAT	;GET CURRENT DATE/TIME
	PUSHJ	P,PRDATM	; AND PRINT IT
	SUB	P,[1,,1]	;POP FLAG
	JRST	CRLF		;PRINT CRLF, AND RETURN

PRDATM:	SKIPN	-1(P)		;ARE WE PRINTING DATES?
	JRST	PDTIM0		;NO.  JUST PRINT TIME
	PUSH	P,TAC1		;YES.
	PUSH	P,TAC
	HLRZ	TAC,TAC		;GET DATE
	IDIVI	TAC,=31		;CONVERT TO DAY OF MONTH
	MOVEI	TAC,1(TAC1)	; WHICH IS THE REMAINDER+1
	MOVEI	TEM," "
	PUSHJ	P,PRTIM3	;PRINT DATE IN 2 COLS PADDING WITH LEADING BLANK
	MOVEI	TEM,"-"
	XCT	TYO
	POP	P,TAC
	ANDI	TAC,-1		;CLEAR THE DATE HALF OF TAC
	JRST	PDTIM1		;PRINT TIME (no use POPing TAC1 and then PUSHing it)

↑DAYT2:	PUSH	P,DAT		; SAVE DAT OVER CALL ON DATIME
	PUSH	P,ITEM		;AND ITEM		;JS
	MOVE	TAC,THSDAT	;PICKUP DATE	;REG
	PUSHJ	P,DAYCNT	;CALCULATE
	IDIVI	TAC,7
	LSH	TAC1,1
	MOVEI	TAC,DAYTAB(TAC1)	;LOAD ADDRESS OF ASCIZ STRING
	PUSHJ	P,CONMES
	PUSHJ	P,PRSPC
	POP	P,ITEM		;RESTORE STACK 
	POP	P,DAT
	MOVE	TAC,THSDAT	;END REG STUFF
	IDIVI	TAC,=31
	EXCH	TAC,TAC1	;YEAR AND MONTH IN TAC1
	AOS	TAC		;DAY IN TAC
	PUSHJ	P,RADX10	;PRINT DAY
	MOVEI	TAC,0
	DIVI	TAC,=12
	EXCH	TAC,TAC1
	MOVE	TAC,MONTAB(TAC)	;MONTH
	DPB	TAC,[POINT 21,DAMESS,27]
	MOVEI	TAC,DAMESS
	PUSHJ	P,CONMES	;PRINT DAY
	MOVEI	TAC,=64(TAC1)
	PUSHJ	P,RADX10	;PRINT YEAR
	PUSHJ	P,PRSPC		;ADD SPACES
	HRRZ	TAC,TIMDAT	;PRINT TIME OF DAY
	PUSHJ	P,PDTIME
	JRST	CRLF

↑DAYTAB:
	ASCIZ/WEDNESDAY/
	ASCIZ/THURSDAY/
	ASCIZ/FRIDAY/
	ASCIZ/SATURDAY/
	ASCIZ/SUNDAY/
	ASCIZ/MONDAY/
	ASCIZ/TUESDAY/

MONTHB:	0			;JAN
	=31			;FEB
	=59			;MAR
	=90			;APR
	=120			;MAY
	=151			;JUN
	=181			;JUL
	=212			;AUG
	=243			;SEP
	=273			;OCT
	=304			;NOV
	=334			;DEC

;CALL WITH TAC SET UP W/ SYSTEM FORMAT DATE.
;RETURN W/ TAC= NUMBER OF DAYS SINCE JAN 1, 1964
;TAC1 AND AC2 CLOBBERED
↑DAYCNT:
	IDIVI	TAC,=31		;DAY OF THE MONTH IN TAC1
	MOVEI	DAT,1(TAC1)	;DAY INTO DAT
	IDIVI	TAC,=12		;MONTHS IN TAC1, YEARS IN TAC
	ADD	DAT,MONTHB(TAC1)	;ADD NUMBER OF DAYS BEFORE THE 1st OF MONTH
	TRNN	TAC,3		;SKIP UNLESS LEAP YEAR
	CAIGE	TAC1,2		;LY. SKIP IF AFTER FEBRUARY
	SUBI	DAT,1		;NOT LEAP YEAR. OR BEFORE MARCH
	MOVEI	TAC1,3(TAC)
	LSH	TAC1,-2		;NUMBER OF LY SINCE '64 NOT INCLUDING THIS YEAR
	IMULI	TAC,=365	;NUMBER OF YEARS TIMES 365
	ADDI	TAC,(TAC1)	;PLUS NUMBER OF PRIOR LEAP YEARS
	ADDI	TAC,(DAT)	;PLUS NUMBER OF DAYS SO FAR THIS YEAR.
	POPJ	P,
;"TIME (JOB NO.)" - PRINT TOTAL AND INCREMENTAL RUNNING TIME FOR A JOB
;"TIME 0" IMPLIES RUNTIME FOR NULL JOB AND THE TOTAL TIME SPENT SHUFFLING USERS
;	IF NO JOB NO. GIVEN-TIME WILL BE FOR CURRENTLY LOGGEN IN JOB NO.

RUNTIM:	PUSHJ	P,DECIN		;GET JOB NO. ARG.
	JRST	CRUN1		;NO ARG. GIVEN
	JRST	COMERA		;ILLEGAL DECIMAL CHARACTER RETURN
	JUMPE	TAC1,CRUN2	;RUNTIME 0 GIVEN?
	CAIL	TAC1,JOBN	;JOB NO. TOO BIG?
	JRST	NOTLOG		;YES, ILLEGAL JOB NUMBER
CRUN3:	MOVE	TAC,JBTSTS(TAC1);IS THIS A REAL JOB WE HAVE HERE?
	TLNE	TAC,JNA		;SKIP IF NO NUMBER ASSIGNED.
	TLNE	TAC,JSEG	;THERE IS A JOB HERE. SKIP IF NOT A SEGMENT
	JRST	NOTLOG		;NO JOB OR A SEGMENT. PRINT NO SUCH JOB.
	PUSHJ	P,INLMES	;PRINT TITLES
	ASCIZ	/     TOTAL   INCREMENT        WAIT  KCS
/
	MOVE	TAC,TTIME(TAC1)	;CPU TIME SINCE LAST LOGIN
	PUSHJ	P,PRTIME	;PRINT COMPUTE TIME USED
	MOVE	TAC,TTIME(TAC1)	;CALCULATE INCREMENTAL RUN TIME
	SUB	TAC,RTIME(TAC1)
	PUSHJ	P,PRTIME	; AND PRINT IT
	MOVE	TAC,TTIME(TAC1)
	CAMN	J,TAC1		;PRINTING TIME OUT FOR OWN JOB?
	MOVEM	TAC,RTIME(TAC1)	;YES.  RESET INCREMENTAL TIME.

	SKIPGE	TAC,JBTWAT(TAC1);GET TIME WAITING FOR SYSTEM
	ADD	TAC,UPTIME	;MAKE THIS TIME REAL
	PUSHJ	P,PRTIME	; AND PRINT IT
	MOVE	TAC,JBTKCJ(TAC1);GET KILO-CORE-JIFFIES USED
	IDIVI	TAC,=60		; AND CONVERT TO KILO-CORE-SECONDS
	JRST	DECLF		; AND PRINT IT WITH A CRLF AND RETURN

CRUN1:	SKIPE	TAC1,J		;LOGGED IN?
	JRST	CRUN3		;YES.  GIVE HIM HIS OWN TIME.
CRUN2:	PUSHJ	P,INLMES	;"TIME 0" OR UNLOGGED IN "TI"
	ASCIZ	/UP /
	MOVE	TAC,UPTIME
	IDIVI	TAC,=60*=60	;CONVERT TO MINUTES
	IDIVI	TAC,=60		;CALCULATE HOURS
	PUSH	P,TAC1		;SAVE MINUTES
	PUSHJ	P,RADX10	;PRINT HOURS
	PUSHJ	P,INLMES
	ASCIZ	/ hr /
	POP	P,TAC		;RETRIEVE MINUTES
	PUSHJ	P,RADX10	;PRINT MINUTES
	PUSHJ	P,INLMES
	ASCIZ	/ min;  SHFL /
	MOVE	TAC,SHFWRD	;NO. WORDS SHUFFLED
 	IDIVI	TAC,=1000000/<=60*3>	;ABOUT THIS MANY WORDS PER TICK.
	PUSHJ	P,PERCNT	;PRINT AS A PERCENTAGE OF UPTIME
	PUSHJ	P,INLMES
	ASCIZ	/;  NULL /
	MOVE	TAC,TTIME	;GET NULL TIME
	PUSHJ	P,PERCNT	;AND PRINT AS A PERCENTAGE OF UPTIME
	PUSHJ	P,INLMES
	ASCIZ	/;  ILEV /
	MOVE	TAC,INTIME
	PUSHJ	P,PERCNT
	PUSHJ	P,INLMES
	ASCIZ	/;  RIT /
	MOVE	TAC,JLRIT
	PUSHJ	P,PERCN1
	JRST	CRLF

;ROUTINE TO PRINT A PERCENTAGE OF UPTIME IN FORM "DD.D%"
;CALL WITH TIME (IN TICKS) IN TAC: PUSHJ P,PERCNT

PERCNT:	IMULI	TAC,=1000
	IDIV	TAC,UPTIME
PERCN1:	IDIVI	TAC,=10		;CALCULATE PERCENTAGE
	PUSH	P,TAC1		;SAVE FRACTION
	PUSHJ	P,RADX10	;PRINT INTEGRAL PART OF PERCENTAGE
	PUSHJ	P,PRPER		;PRINT A PERIOD
	POP	P,TEM
	ADDI	TEM,"0"
	XCT	TYO		;PRINT TENTHS OF A PERCENT
	MOVEI	TEM,"%"
	XCT	TYO		;PRINT PERCENT SIGN
	POPJ	P,

PR2SP:	MOVEI	TEM," "
	XCT	TYO
TYOPOP:	XCT	TYO		;PRINT TWO SPACES AFTER TIME
	POPJ	P,

PRCOLN:	MOVEI	TEM,":"		;PRINT COLON
	JRST	TYOPOP

;ROUTINE TO PRINT A TIME IN FORMAT "H:MM:SS'TT  " (HOURS, MINS, SECS, TICKS)
;CALL WITH TIME IN TICKS IN TAC.  PRESERVES TAC1!
PRTIME:	PUSH	P,TAC1
	IDIVI	TAC,=60*=60*=60	;HOURS INTO TAC
	JUMPE	TAC,PRTIM1	;PRINT 2 SPACES INSTEAD OF 0: FOR HOURS
	PUSHJ	P,RADX10
	PUSHJ	P,PRCOLN	;PRINT COLON
	TRCA	TEM,"0"≠":"	;MAKE SURE MINUTES GET PADDED WITH 0 IF NECESSARY
PRTIM1:	PUSHJ	P,PR2SP		;PRINT 2 SPACES
	MOVE	TAC,TAC1
	IDIVI	TAC,=60*=60	;MINUTES INTO TAC
	PUSHJ	P,PRTIM3
	PUSHJ	P,PRCOLN
	MOVE	TAC,TAC1
	IDIVI	TAC,=60		;SECONDS INTO TAC
	PUSHJ	P,PRTIM2	;PRINT WITH LEADING 0 IF NECESSARY
	MOVEI	TEM,"'"		;USE RIGHT QUOTE TO PUNCTUATE TICKS
	XCT	TYO
	MOVE	TAC,TAC1	;TICKS INTO TAC
	PUSHJ	P,PRTIM2
	PUSHJ	P,PR2SP
	POP	P,TAC1		;RESTORE TAC1 FROM STACK
	POPJ	P,		;AND RETURN

PRTIM2:	MOVEI	TEM,"0"		;PAD WITH LEADING 0 IF NECESSARY
PRTIM3:	CAIGE	TAC,=10		;ANY PADDING NEEDED?
	XCT	TYO		;YES.  ONE CHARACTER OF PADDING PLEASE
	JRST	RADX10		;NOW PRINT TAC AS DECIMAL NUMBER AND RETURN

;ROUTINE TO PRINT TIME OF DAY IN FORMAT "HH:MM  "
;CALL WITH TIME IN SECONDS IN TAC.  PRESERVES TAC1
PDTIM0:	ANDI	TAC,-1		;CLEAR DATE IN LEFT HALF OF TAC
PDTIME:	PUSH	P,TAC1		;SAVE TAC1
PDTIM1:	IDIVI	TAC,=60*=60	;HOURS INTO TAC
	PUSHJ	P,PRTIM2	;PRINT HOURS WITH LEADING 0 IF NECESSARY
	PUSHJ	P,PRCOLN
	MOVE	TAC,TAC1
	IDIVI	TAC,=60		;MINUTES INTO TAC
	PUSHJ	P,PRTIM2	;PRINT MINUTES WITH LEADING 0 IF NECESSARY
	PUSHJ	P,PR2SP		;PRINT 2 SPACES
	POP	P,TAC1		;RESTORE TAC1
	POPJ	P,
;ROUTINE TO LET TTY TALK TO ANY OTHER RING OF TTYS
;	"TALK TTYN"
;	TTYN NEED NEVER HAVE BEEN TYPED ON BEFORE

TALK:	PUSHJ PDP,CTEXT		;GET ARGUMENT
	JUMPE TAC1,TALK2	;NONE SPECIFIED
	MOVE TAC,TAC1
	PUSHJ PDP,DEVSRC	;SEARCH FOR DEVICE
	JRST TALK1		;NONE AVAIL
	PUSHJ PDP,TTYTLK
	JRST TALK1
	POPJ PDP,

TALK2:
	MOVEM ITEM,-1(PDP)
	JRST NOTENF

TALK1:	MOVE DEVDAT,-2(PDP)	; RESTORE TTY DDB
	MOVSI ITEM,NOINCK	; SET FLAGS TO PRINT RESPONSE
	MOVEM ITEM,-1(PDP)
	JSP TAC,ERRMES
	ASCIZ /BUSY
/
;"EXAMINE LOC" - LOOKS A CONTENTS OF LOC AND PRINTS IN OCTAL
;IF LOC IS MISSING, NEXT LOC IS PRINTED
;TAB. IS PRINTED INSTEAD OF CRLF(LIKE DDT)


ECOM:	PUSHJ PDP,OCTIN		;GET OCTAL LOCATION
	JRST ECOM2		;NO ARG - GET CURRENT LOC
	JRST COMERA		;ILLEGAL CHARACTER
ECOM1:	PUSHJ P,TESTIN		;GET SET UP
	 JFCL			;OK IF WRITE-PROT
	HLRZS TAC		;GET RELOCATION IN RIGHT HALF OF TAC
	PUSH PDP,TAC		;PUSH IT
	PUSHJ PDP,DEAT		;CHECK FOR AC REFERENCE
	SUBI TAC1,(AC3)		;MAKE REL TO APPROP SEG
	ADDM TAC1,(PDP)		;RELOCATE ADDR
	HRRZ TAC,JOBEXM(JDAT)	;PRINT LOC BEING EXAMINED
	PUSHJ PDP,OCTPNT
	PUSHJ PDP,INLMES	;PRINT SLASH TAB
	ASCIZ %/	%
	HLRZ TAC,@(PDP)		;PRINT LEFT HALF
	PUSHJ PDP,OCTPNT
	PUSHJ PDP,INLMES	;PRINT SPACE
	ASCIZ / /
	HRRZ TAC,@(PDP)		;PRINT RIGHT HALF
	PUSHJ PDP,OCTPNT
	PUSHJ PDP,INLMES	;PRINT FINAL TAB
	ASCIZ /	/
	JRST TPOPJ

;HERE WE GET THE LAST LOC+1. NOTE WE DO NOT CHANGE JOBEXM YET SINCE WE MAY
;GO TO DLYCOM FROM TESTIN AND DON'T WANT TO AOS IT SEVERAL TIMES.
ECOM2:	MOVE TAC1,JOBEXM(PROG)
	AOJA TAC1,ECOM1

;SETUP ROUTINE FOR EXAMINE/DEPOSIT COMMANDS
;ADDRESS CHECKS, AND WAITS FOR SWAP (VIA DLYCOM) IF NEEDED FOR UPPER
;EXECUTES INSTRUCTION FOLLOWING CALL IF WRITE-PROTECTED UPPER
TESTIN:	ANDI TAC1,-1		;FLUSH EXTRANEOUS GARBAGE
	MOVEI AC3,		;INITIALLY ASSUME LOWER
	MOVS TAC,JBTADR(ITEM)	;PROT. RELOC.
	CAIG TAC1,(TAC)		;LEGAL LOC
	JRST CPOPJ1		;YES, GO ON.
	MOVEI AC3,1(TAC)	;COMPUTE POSSIBLE UPPER ORIGIN
	LDB AC1,PSEGN		;# OF UPPER
	JUMPE AC1,ECOMP		;NONE
	MOVE AC2,JBTSTS(AC1)
	TLNE AC2,JWP		;IF WRITE-PROTECTED,
	XCT @(P)		;CHECK LEGALITY BEFORE TRYING TO SWAP
	SKIPE TAC,JBTADR(AC1)	;PROT. RELOC OF UPPER
	JRST TESTU1
	LDB TAC,IMGIN	;SWAPPED OUT, GET SIZE
	ASH TAC,12	;MAKE IT WORDS
	SOJA TAC,.+2	;MAKE IT HONEST
TESTU1:	MOVS TAC,TAC
	CAIGE AC3,400000
	MOVEI AC3,400000	;AC3 IS NOW ORIGIN OF UPPER
	ADDI TAC,(AC3)		;RELOCATE PROT TO UPPER
	CAIL TAC1,(AC3)
	CAILE TAC1,(TAC)	;LEGAL
	JRST ECOMP		;NO
	TLNN AC2,SWP		;IS UPPER IN CORE
	JRST CPOPJ1
	MOVSI TAC,JHLDIN
	IORM TAC,JBTSTS(J)	;KEEP US IN
	EXCH J,AC1
	MOVSI TAC,COMSNB
	PUSHJ P,SETSIN		;AND GET HIM IN
	MOVE J,AC1
	POP P,(P)
	JRST DLYCM1		;AND DELAY

ECOMP:	POP P,TAC		;POP OFF RETURN
ECOMA:	JSP TAC,ERRMES		;ILLEGAL MEMORY REFERENCE

	ASCIZ /OUT OF BOUNDS
/
;"DEPOSIT LH RH LOC" - DEPOSITS XWD LH,RH IN LOCATION LOC
;IF LOC IS MISSING ASSUMB CURRENT LOC


DCOM:	PUSHJ PDP,OCTIN		;GET LH
	JRST NOTENF		;NOT ENOUGH ARGUMENTS
	JRST COMERA		;ILLEGAL CHARACTER
	HRLM TAC1,IOS		;SAVE
	PUSHJ PDP,OCTIN		;GET RH
	JRST NOTENF		;NOT ENOUGH ARGUMENTS
	JRST COMERA		;ILLEGAL CHARACTER
	HRRM TAC1,IOS		;SAVE RH
	PUSHJ PDP,OCTIN		;GET LOC
	SKIPA TAC1,JOBEXM(JDAT)	;NOT SPECIFIED (DEPOSIT THIS)!
	JRST COMERA		;ILLEGAL CHARACTER
	PUSHJ P,TESTIN		;RETURN IF READY FOR DEPOSIT.
	 JRST ECOMP		;LOSE IF WRITE-PROT
	CAIGE TAC1,20		;IN USER ACS
	JRST .+3
	CAIG TAC1,JOBPFI	;NO, GREATER THAN HIGHEST LOC. PROTECTED
				;FROM IO IN JOB DATA AREA?
	JRST ECOMA
	HLLM TAC,(PDP)		;SAVE RELOCATION
	PUSHJ PDP,DEAT		;CHECK FOR AC REFERENCE
	HLRZ TAC,(PDP)		;GET RELOCATION
	SUBI TAC1,(AC3)		;ADJUST ADR FOR POSSIBLE SEGMENT
	ADD TAC1,TAC
	MOVEM IOS,@TAC1
IFN FTSWAP,<
	JUMPE AC3,.+2		;UPPER?
	SETOM STIME(AC1)	;YES, MARK IT ALTERED (LOWER WAS GOTTEN BY DEAT)
>
	POPJ PDP,



DEAT:	MOVEM TAC1,JOBEXM(JDAT)	;STORE FOR NEXT TIME
IFN FTSWAP,<
	SETOM STIME(J)		;AND NOTE THIS CORE IMAGE CHANGED
>	MOVE TAC,JOBPC(JDAT)
	CAMN J,JOB		;MIGHT BE RUNNING IF HE SAID CCONT ETC.
	MOVE TAC,USRPC
	CAIL TAC1,20		;IS IT AN AC?
	POPJ PDP,		;NO
	TLNE TAC,USRMOD		;USER MODE?
	ADDI TAC1,JOBDAC	;YES USER ACS ARE HERE
	POPJ PDP,
;"BLANK" OR NO ALPHA NUMERIC BEFORE BREAK CHAR COMMAND
;DISPATCHED TO LIKE ANY OTHER COMMAND(O IN COMMAND TABLE)


CBLANK:
	CAIE TEM,12	; WAS BREAK A L.F.?
	CAIN TEM,";"	;NO, IS IT SEMI COLON(MONITOR COMMENT)
	POPJ PDP,	;YES, IGNORE
			;FALL IN UNKNOWN COMMAND

;COMMAND NOT IN COMMAND DIRECTORY

NOCOM:	JRST COMERR	;NO, APPEND ? TO WHAT HE TYPED IN
; "FINISH DEVICE" - CLOSES,RELEASE AND DEASSIGNS DEVICE
FINIS:	JUMPE	PROG,CPOPJ	; NO CORE, NO FINISH!
	PUSHJ	PDP,CTEXT1	; READ IN THE DEVICE NAME
	MOVEM	TAC1,JOBFDV(JDAT)	; SAVE THE SIXBIT OF THE DEVICE NAME
	MOVSI	TAC,TTYRNU	; PUT TTY INTO USER MODE
	IORM	TAC,-1(P)	; TELL COMRET
	JSP	TAC1,MSTART	; MAKE US A MONITOR JOB
	JSP	TAC,MONSTR	; NOW GET SOME ACS AND A PDL
	MOVE	TAC,JOBFDV(JDAT)	; SET UP TO SEARCH FOR THIS DEVICE
	JUMPE	TAC,FINALL	; NO DEVICE... FINISH ALL.
FIN3:	PUSHJ	P,DEVLG		; TRY LOGICAL NAMES FIRST
	JRST	FIN1		; NOT FOUND, TRY PHYSICAL NAMES
	PUSHJ	P,FINRDV	; TRY TO FINISH IT
	PUSH	P,[FIN3+1]	; IF WE RETURN, THAT WASN'T THE RIGHT DEVICE
	JRST	DEV0		; CONTINUE SCANNING THE DEVICES

FIN1:	PUSHJ	P,DEVPHY	; SEARCH PHYSICAL NAMES
	JRST	FIN2		; NO NAMES, ERROR
	PUSHJ	P,FINRDV
	PUSH	P,[FIN1+1]
	MOVE	AC1,DEVMOD(DDB)
	TLNN	AC1,DVTTY
	JRST	DEVLP2		; SEARCH FOR ANOTHER DEVICE OF SAME NAME

FIN2:	PUSHJ	P,TTYFNU	; GET A TTY FOR US
	PUSHJ	P,INLMES	; GIVE AN ERROR MESSAGE
	ASCIZ /
FINISH WHAT?/
	PUSHJ P,PRCRCC
	JRST	FINXIT		; LEAVE TTY IN COMMAND MODE,
				; STOP JOB, AND RESCHEDULE


; ROUTINE TO FINISH A DEVICE BY RELEASING IT
; IT FIRST MATCHES IT TO A DEVICE DATA BLOCK IN USRJDA

FINRDV:	SKIPGE	UCHN,USRHCU(PID)
	JRST	FIN2		; NO CHANNELS, NO DEVICES
				;BEWARE- YOU'D BETTER BE RUNNING ON P1
FINRD1:	HRRZ	AC1,USRJDA(UCHN); GET DDB ADDRESS
	CAME	AC1,DEVDAT	; IS THIS IT
	SOJGE	UCHN,FINRD1	; NO, GET ANOTHER
	JUMPL	UCHN,FINSTK	; IF NOTHING FOUND, CHECK IO PDL
	PUSHJ P,FINREL		;RELEASE IT
FINRD2:	PUSHJ	P,TTYFNU	; GET A TTY
	PUSHJ	P,PRCRCC
FINXIT:	PUSHJ	P,TTYSTC	; KEEP THE TTY IN COMMAND MODE
	JRST	MSTOP		; STOP THE JOB NOW

FINREL:	PUSH P,UCHN
	MOVSI UUO,(<RELEAS>)	; NOW SET UP TO RELEASE IT
	DPB UCHN,PUUOAC
	MOVE UCHN,DEVMOD(DDB)
	TRNE UCHN,ASSCON	;WILL DDB BE THERE AFTER RELEASE?
	JRST FINRL1		;YES
	XCT UUO			; RELEASE THE DEVICE
FINRL2:	POP P,UCHN
	POPJ P,

FINRL1:	PUSH P,DDB
	XCT UUO
	POP P,DDB
	MOVSI UCHN,DVDIRIIN	; CLEAR DIRECTORY IN CORE BIT
	ANDCAM UCHN,DEVMOD(DDB)
	JRST FINRL2

FINSTK:	MOVE J,JOB(PID)
	SKIPL UCHN,JBTIOP(J)
	POPJ P,			;NOTHING ON STACK
FINST1:	HRRZ AC1,(UCHN)
	CAME AC1,DDB
	JRST FINST2
	MOVE DDB,USRJDA
	EXCH DDB,(UCHN)
	MOVEM DDB,USRJDA
	PUSH P,UCHN
	MOVEI UCHN,0
	PUSHJ P,FINREL
	POP P,UCHN
	MOVE DDB,(UCHN)
	EXCH DDB,USRJDA
	MOVEM DDB,(UCHN)
	JRST FINRD2

FINST2:	ADD UCHN,[1,,1]
	AOBJN UCHN,FINST1
	POPJ P,

FINALL:	SKIPGE	UCHN,USRHCU(PID)	;SEE IF HE HAS CHANNELS OPEN
	JRST	FINAL3			;NONE LEFT OPEN.
FINAL1:	SKIPE	DEVDAT,USRJDA(UCHN)	;IS THERE ANYONE HERE?
	PUSHJ P,FINREL
	SOJGE	UCHN,FINAL1
FINAL3:	MOVE	J,JOB(PID)		;DEPARTMENT OF REDUNDANCY DEPARTMENT
	SKIPL UCHN,JBTIOP(J)		;ANY IO PDL?
	JRST FINST3
FINST4:	SKIPN DDB,(UCHN)
	JRST FINST5
	SETZM (UCHN)
	MOVEM DDB,USRJDA
	PUSH P,UCHN
	SETZ UCHN,
	PUSHJ P,FINREL
	POP P,UCHN
FINST5:	ADD UCHN,[1,,1]
	AOBJN UCHN,FINST4
	HRRZ AC1,JBTIOP(J)
	SETZM JBTIOP(J)
	PUSHJ P,FSGIVE
FINST3:	PUSHJ	P,FKALL
	JRST	FINRD2

;HERE WE CHASE THROUGH ALL THE DDBS AND MAKE SURE NONE OF THEM BELONG TO THIS JOB
;FINISH (BY SUPPRESS CLOSE OUTPUT) ANY THAT MAY BE HUNG-OVER

FKALL:	MOVEI	DDB,DEVLST-DEVSER
FKALL1:	HLRZ	DDB,DEVSER(DDB)
	JUMPE	DDB,CPOPJ
	LDB	AC1,PJOBN
	CAIE	AC1,(J)
	JRST	FKALL1
	MOVE	AC1,DEVMOD(DDB)
	TRNN	AC1,ASSPRG		;SKIP IF ASSIGNED BY PROGRAM.
	JRST	FKALL1			;NO.
	MOVEM	DDB,USRJDA		;SAVE DDB POINTER. (CHANNEL 0)
	MOVSI	AC1,DVDIRIN
	ANDCAM	AC1,DEVMOD(DDB)
	CLOSE	0,3			;CLOSE CHANNEL 0. INHIBIT INPUT/OUTPUT CLOSE
	RELEAS	0,3			;RELEASE CHANNEL 0. INHIBIT I/O CLOSE
	JRST	FKALL			;START OVER FROM THE FRONT OF DEVICE CHAIN
;"RESOURCES" - PRINT OUT AVAILABLE DEVICES AND FREE BLOCKS ON THE DISK

FREDEV:
IFN FTDISK,<				;JS
	PUSHJ	P,INLMES
	ASCIZ	/DSK /
	MOVEI AC2,0		;UNIT 0 IS DSK, NOT UDP
FRUDP1:	MOVEI TAC1,(AC2)
	PUSHJ	P,DSKRES	; GET FREE BLOCK COUNT FROM DISK SERVICE ROUTINE
	PUSHJ	P,RADX10	;CONVERT TO DECIMAL

FRUDP2:	ADDI AC2,1		;NOW DO THE SAME FOR UDPS
	CAILE AC2,UPACKS
	JRST FRUDP9		;NO MORE UDPS
	PUSHJ P,INLMES
	ASCIZ /
/
	MOVE TAC,DKDBML(AC2)	;ELSE GET NAME
	MOVE TAC1,DEVNAM(TAC)
	PUSHJ P,PRNAME
	SKIPLE TAC,SATADR(AC2)
	PUSHJ P,SATTAC		;TYPE SATID IF ANY
	MOVEI TAC,[ASCIZ / FREE/]
	SKIPE UDPCNT-1(AC2)
	MOVEI TAC,[ASCIZ / PUBLIC /]
	SKIPL UDPOWN-1(AC2)
	MOVEI TAC,[ASCIZ / PRIVATE /]
	SKIPE UDPOWN-1(AC2)
	JRST FRUDP3
	MOVEI TAC,[ASCIZ / DETACHED FROM SYSTEM/]
	SKIPE UDPCNT-1(AC2)
	MOVEI TAC,[ASCIZ / SWAPPING DEVICE/]
FRUDP3:	PUSHJ P,CONMES
	SKIPLE SATADR(AC2)
	JRST FRUDP1
	JRST FRUDP2
>
FRUDP9:	PUSHJ P,INLMES
	ASCIZ /
DDC /
	MOVE TAC,DDFCNT		;GET NBR OF DD CHANNELS LEFT
	PUSHJ P,RADX10		; AND PRINT IT
	PUSHJ P,INLMES
	ASCIZ /
JSA /
	MOVE TAC1,JOBNM1
	SETZ TAC,
	MOVSI AC2,JNA
LOP03:	TDNN AC2,JBTSTS(TAC1)	;IS THIS JOB SLOT AVAILABLE?
	ADDI TAC,1		;YES
	SOJG TAC1,LOP03		;CHECK NEXT SLOT
	PUSHJ P,DECLF		;PRINT NUMBER OF JOB SLOTS AVAILABLE

	PUSH P,[0]
	HLRZ AC1,DEVLST		;GET DDB POINTER
LOP01:	MOVEI AC2,ASSCON+ASSPRG	;MASK FOR DEVICE ASSIGNED
	TDNN AC2,DEVMOD(AC1)	;ASSIGNED BY CONSOLE OR PROGRAM?
	PUSHJ PDP,LOP02		;DEV NOT ASG-CHECK AND PRINT
	HLRZ AC1,DEVSER(AC1)	;GET NEXT DDB
	JUMPN AC1,LOP01		;END OF CHAIN?
	PUSHJ P,CRLF		;YES
	JRST TPOPJ		;GET THAT EXTRA WORD OFF THE STACK

LOP02:	MOVE TAC,DEVMOD(AC1)	;GET DEVICE CHARACTERISTICS
	TLNE TAC,DVTTY!DVDSK!DVIMP!DVUDP  ;IS IT A TTY OR DSK OR YE OLE IMP?
	POPJ PDP,		;YES - RETURN
LOP04:	MOVEI TEM,","		;AND A COMMA
	SKIPE -1(P)
	XCT TYO
	MOVE TAC1,DEVNAM(AC1)	;NO-SET UP TAC1 AGAIN
	HRRZ AC2,DEVSER(AC1)	;IS THIS SAME DEVICE AS PREVIOUS ONE?
	CAMN AC2,-1(P)
	HRLZ TAC1,TAC1		;YES.  DONT PRINT NAME, ONLY NUMBER
	MOVEM AC2,-1(P)		;AND SAVE FOR NEXT DEVICE
	PUSHJ P,PRNAME		;GO AND PRINT IT OUT
	POPJ P,

SATTAC:	PUSH P,TAC		;SAVE SAT ADDR JUST IN CASE
	MOVEI TEM,"("		;(SATTAC CALLED BY PJOB FOR UDP)
	XCT TYO
	POP P,TAC
	MOVE TAC1,SATID(TAC)	;THIS IS VOLUME ID FOR UDPS
	PUSHJ P,PRNAME		;(IBM VOCABULARY TAKES OVER THE WORLD)
	MOVEI TEM,")"
	XCT TYO
	POPJ P,
;RUNCHK, DLYCOR, DLYCR1
RUNCHK:	CAMN ITEM,STUSER	;SYSTEM TAPE USER?
	JRST DLYCM1		;YES. DELAY
ACTCHK:	JUMPE PROG,ACTCH1	;DOES JOB HAVE CORE IN MEMORY?
	TLNE AC1,SWP		;DEC 3.16
	JRST ACTCH1		;DEC 3.16
	PUSHJ PDP,ANYACT	;YES, ARE DEVICES ACTIVE?
	JRST DLYCM1		;YES, DELAY COMMAND.
ACTCH1:	MOVE TAC1,-1(PDP)	;RESTORE COMMAND DISPATCH ADDRESS
	MOVE DDB,-2(PDP)	;RESTORE TTY DDB ADDRESS
	MOVE AC1,JBTSTS(ITEM)	;RESTORE JOB STATUS
	POPJ PDP,

;ROUTINE TO DELAY A COMMAND

;DELAYS COMMAND TO BE EXECUTED WHEN JOB IN CORE MEMORY
;AND POPS LEVEL UP ONE.



DLYCR2:	MOVE	TAC1,LINSAV	;GET THE LINE NUMBER
	MOVSI	TAC,COMBIT
	CONO	PI,SCNOFF
	TDNE	TAC,TTYTAB(TAC1)
	SOS	COMCNT		;DECREMENT IF COMMAND BIT WAS SET
	ANDCAM	TAC,TTYTAB(TAC1)
IFN FTTTYBUG,<
	PUSHJ	P,COMBCK
	PUSHJ	P,CNTCOM
>
	CONO	PI,SCNON
	POPJ	P,

DLYCR1:	PUSHJ	P,DLYCR2	;CLEAR COMBIT
	JRST	DLYCM1		;

DLYCOR:	PUSHJ	P,DLYCR2	;CLEAR COMBIT
DLYCM:	PUSHJ	PDP,DLYCOM	;REQUEUE JOB TO CMWQ 
↑DLYCM1:AOS	NDLYCMS		;COUNT A DELAYED COMMAND
	POP	P,TAC		;FLUSH THE RETURN TO COMRET
	POP	P,TAC1		;AND FLUSH THE COMMAND BITS
	POP	P,TAC1		;AND FLUSH THE TTY DDB POINTER.
	PUSHJ	P,TTYCM		;DELAY PRESENT COMMAND AND GET A NEW COMMAND
	POPJ	P,		;THERE ARE NO NEW COMMANDS
	JRST	COM0		;PROCESS A COMMAND.
;SEARCH DEVICE CHAIN FOR DSK WITH COUNTS ON
;CALL	MOVE ITEM,JOB NO
;	PUSHJ PDP,STOPCK
;	CAN'T STOP RETURN
;	OK TO STOP RETURN

IFN FTDISK,<

↑STOPCK:PUSH PDP,DEVDAT
	MOVEI DEVDAT,DSKDDB
	MOVSI TAC1,DSKFGS
STOPD:	LDB TAC,PJOBN
	CAIE ITEM,(TAC)		;ASSIGNED TO THIS JOB?
	JRST STOPC		;NO
	TDNE TAC1,DEVIOS(DEVDAT)	;DUMP MODE I/O IN PROGRESS ?
	JRST STOPR1		;YES. DELAY
STOPC:	HLRZ DEVDAT,DEVSER(DEVDAT)
	MOVE TAC,DEVMOD(DDB)	;LOOP THRU DSK AND UDP DDBS
	TLNE TAC,DVDSK
	JRST STOPD		;ONLY LOOK AT DVDSK ONES
	TLNE TAC,DVUDP
	JRST STOPC		;BUT KEEP SEARCHING IF DVUDP
	AOS -1(PDP)		;OK TO STOP
STOPR1:	POP PDP,DEVDAT
	POPJ PDP,
>
;"FILES <filename or job number>" -- print status of open files.

FILCOM:	MOVEI	AC1,DSKDDB
	PUSHJ	P,CTEXT1	;GET ARG OF COMMAND
	JUMPE	TAC1,FIL2	;NO ARG
	PUSH	P,TAC1		;SAVE ARG
	CAIN	TEM,"."		;DELIMITING PERIOD MEANS FILENAME EXT COMING
	JRST	FIL3		;READ EXT
	CAIN	TEM,"["		;DELIMITING LEFT BRACKET MEANS PPN COMING
	JRST	FIL4		;READ PPN
	PUSHJ	P,FIL2JB	;SEE IF ARG WAS A JOB NUMBER RATHER THAN FILENAME
	JRST	FIL5		;GOT JOB NUMBER
	PUSH	P,[0]		;MUST BE FILE NAME WITH ZERO EXTENSION.
FIL6D:	SKIPN	AC2,DSKPPN(J)	;GET APPROPRIATE PPN FOR FILE
	MOVE	AC2,PRJPRG(J)
FIL6:	PUSH	P,AC2		;SAVE PPN
	PUSHJ	P,FIL99		;SEE IF ANYTHING LEFT IN COMMAND LINE
	PUSHJ	P,CRLF		;BLANK LINE TO INDICATE STARTING NEW FILE SEARCH
FIL6A:	PUSHJ	P,NXTDSK	;GET NEXT DSK DDB
	JRST	FIL6B		;NONE, DONE
	MOVE	TAC,DEVFIL(AC1)	;GET NAME OF FILE OPEN
	CAME	TAC,-2(P)	;SAME AS FILE OF INTEREST?
	JRST	FIL6A		;NOPE
	HLLZ	TAC,DEVEXT(AC1)	;GET EXT OF FILE OPEN
	CAME	TAC,-1(P)	;SAME AS FILE OF INTEREST?
	JRST	FIL6A		;NOPE
	MOVE	TAC,FILPPN(AC1)	;AND PPN
	CAMN	TAC,(P)		;SAME?
FIL6C:	PUSHJ	P,PTFILE	;YES.  PRINT STATUS OF THIS FILE
	JRST	FIL6A		;NOT SAME, OR STATUS PRINTED OK.
	HRRZM	AC1,SAVDDB(DDB)	;NO ROOM TO PRINT FILE NAME.  SAVE OUR PLACE.
	JRST	.+2
FIL6B:	SETZM	SAVDDB(DDB)	;WE FINISHED.  INDICATE NO PLACE TO CONTINUE.
	SUB	P,[3,,3]	;RE-ADJUST STACK, FLUSHING FILE NAME, EXT, PPN
	POPJ	P,

FIL4:	SKIPA	TAC1,[0]	;ZERO FILE EXTENSION
FIL3:	PUSHJ	P,CTEXT		;READ FILE EXTENSION
	PUSH	P,TAC1		;SAVE EXT
FIL3A:	PUSHJ	P,PJPGNO	;READ PPN
	JRST	FIL6D		;NONE TYPED, GET DEFAULT PPN
	JRST	FIL6		;GO SAVE PPN TYPED

FIL99:	PUSHJ	P,SKIPS1	;SEE IF ANYTHING EXTRANEOUS AT END OF LINE
	SUB	P,[4,,4]	;YES.  ERROR
	JRST	COMERA		;(SKIPS1 RETURNS UP A LEVEL IF FINDS END OF LINE)

FIL88:	PUSHJ	P,SKIPS1	;COMEND MAKES THIS CHECK ALSO BUT ONLY REMOVES
	SUB	P,[2,,2]	;	ONE ENTRY FROM STACK INSTEAD OF TWO
	JRST	COMERA

FIL5:	SUB	P,[1,,1]	;DISCARD SIXBIT JOB NUMBER ON STACK
	JUMPN	TAC,FIL5D	;ZERO JOB NUMBER MEANS OWN JOB,
FIL5C:	SKIPN	TAC,J		; IF ANY.
	JRST	LOGPLS		; IF NONE, CANT HELP YOU
FIL5D:	MOVE	TAC1,JBTSTS(TAC);SEE IF THIS JOB NUMBER IS ASSIGNED
	TLNE	TAC1,JNA
	TLNE	TAC1,JSEG	;NO SEGMENTS PLEASE
	JRST	NOTLOG		;NO SUCH JOB
	PUSH	P,TAC		;SAVE JOB NUMBER
	PUSHJ	P,FIL88		;MAKE SURE NOTHING EXTRANEOUS AFTER JOB NUMBER
	PUSHJ	P,CRLF		;BEGINNING NEW FILE SEARCH
FIL5A:	PUSHJ	P,NXTDSK	;GET NEXT DSK DDB
	JRST	FIL5B		;NONE, DONE
	LDB	TAC1,[POINT 6,DEVCHR(AC1),5] ;PICK UP JOB NUMBER FROM DDB
	CAMN	TAC1,(P)	;IS IT THE JOB OF INTEREST?
FIL5E:	PUSHJ	P,PTFILE	;YUP.  PRINT FILE STATUS
	JRST	FIL5A		;NOT CORRECT JOB, OR FILE STATUS PRINTED OK
	HRL	AC1,(P)		;NO ROOM TO PRINT FILE STATUS.  SAVE JOB NUMBER
	MOVEM	AC1,SAVDDB(DDB)	; AND CURRENT DSK DDB.
	JRST	TPOPJ		;RE-ADJUST STACK AND RETURN.
FIL5B:	SETZM	SAVDDB(DDB)	;WE FINISHED.  INDICATE NO PLACE TO CONTINUE.
	JRST	TPOPJ

FIL2JB:	TDNE	TAC1,[77,,-1]	;CONVERT SIXBIT TEXT TO JOB NUMBER
	JRST	CPOPJ1		;MORE THAN TWO CHARS MEANS NOT JOB NUMBER
	SETZ	TAC,
	LSHC	TAC,6		;GET FIRST SIXBIT CHAR
	SUBI	TAC,'0'		;CONVERT DIGIT TO BINARY
	JUMPL	TAC,CPOPJ1	;NOT DIGIT MEANS NOT JOB NUMBER
	CAILE	TAC,=9
	JRST	CPOPJ1		;NOT DIGIT
	JUMPE	TAC1,CPOPJ	;IF NO SECOND DIGIT, THEN DONE
	ROT	TAC1,6		;GET SECOND DIGIT
	SUBI	TAC1,'0'	;CONVERT SIXBIT DIGIT TO BINARY
	JUMPL	TAC1,CPOPJ1	;NO DIGEE, NO JOBEE
	CAILE	TAC1,=9
	JRST	CPOPJ1		;LOSE
	IMULI	TAC,=10		;SHIFT HIGH-ORDER DIGIT
	ADD	TAC,TAC1	; AND ADD IN LOW-ORDER DIGIT
	POPJ	P,		;DIRECT RETURN WITH JOB NUMBER IN TAC

FIL2:	PUSHJ	P,COMEND	;MAKE SURE REALLY NO ARG
	HRRZ	TAC,SAVDDB(DDB)	;NO ARGUMENT.  GET PLACE WE QUIT LAST TIME.
	JUMPE	TAC,FIL5C	;FINISHED LAST TIME.  START OVER.
FIL2A:	PUSHJ	P,NXTDSK	;GET NEXT DSK DDB
	JRST	FIL5C		;NO MORE.  CANT FIND PLACE TO CONTINUE.  START OVER.
	CAME	TAC,AC1		;IS THIS THE DDB WHERE WE QUIT?
	JRST	FIL2A		;NO, TRY AGAIN.
	HLRZ	TAC,SAVDDB(DDB)	;YES.  PICK UP JOB NUMBER WE WERE WORKING ON
	PUSH	P,TAC		;PUT JOB NUMBER ON STACK
	JUMPN	TAC,FIL5E	; AND CONTINUE PRINTING FILES FOR THAT JOB.
	MOVE	TAC,DEVFIL(AC1)	;NO JOB NUMBER.  MUST BE WORKING ON SPECIFIC FILE.
	MOVEM	TAC,(P)
	PUSH	P,DEVEXT(AC1)	; SAVE NAME, EXT, AND PPN OF FILE
	HLLZS	(P)		; CLEAR RIGHT HALF OF EXT WORD
	PUSH	P,FILPPN(AC1)
	JRST	FIL6C		;AND CONTINUE PRINTING REFERENCES TO THAT FILE

PTFILE:	TRNN AC2,ASSPRG		;AC2 HAS DEVMOD
	POPJ P,			;DON'T TYPE ASSCON DDBS
	MOVEI	TAC,=39+4	;PRINT A FILE'S STATUS, AT MOST =39 CHARS NEEDED.
	CAML	TAC,TOFCTR(DDB)	;SEE IF WE HAVE ENOUGH ROOM IN OUTPUT BUFFER
	JRST	PTFIL1		;NOT ENOUGH ROOM.  PRINT " ..." (4 CHARS)
	LDB	TAC,[POINT 6,DEVCHR(AC1),5] ; GET NUMBER OF JOB WITH FILE OPEN
	MOVEI	TEM," "
	CAIGE	TAC,=10		;IF JOB NUMBER LESS THAN =10,
	XCT	TYO		; THEN PAD NUMBER WITH A SPACE
	PUSHJ	P,RADX10	;PRINT JOB NUMBER
	MOVE	TAC1,DEVFIL(AC1);GET FILE NAME
	PUSHJ	P,PR6SIX	; AND PRINT 6 CHARS AFTER SPACE
	HLLZ	TAC1,DEVEXT(AC1);GET FILE EXT
	PUSHJ	P,PR3SIX	; AND PRINT 3 CHARS AFTER SPACE
	MOVE	TAC1,FILPPN(AC1);GET FILE PPN
	PUSHJ	P,PR6SIX	; AND PRINT 6 CHARS AFTER SPACE
	MOVE	TAC,FILLNG(AC1)	;GET FILE LENGTH
	PUSHJ	P,DGETL1	; AND CONVERT TO RECORDS (DGETL1 IS IN DSKSER)
	SKIPE	TAC1,TAC	;IF NON-ZERO, SUBTRACT ONE TO GET NUMBER
	SUBI	TAC1,1		; OF LAST RECORD, NOT FIRST FREE RECORD
	PUSHJ	P,PRREC		; PRINT FILE LENGTH IN RECORDS
	MOVE	TAC1,USETP(AC1)	;GET CURRENT USET POINTER
	PUSHJ	P,PRREC		; AND PRINT IT
	MOVEI	TEM," "
	XCT	TYO		;PRINT A SPACE
	MOVEI	TEM,"U"
	TLNE	AC2,DVUDP	;IS THIS A UDP?
	XCT	TYO		;YES, PRINT "U"
	MOVE	TAC,DEVIOS(AC1)	;SEE WHAT IS HAPPENING TO THIS FILE
	TLNN	TAC,READB	;BEING READ?
	JRST	PTFIL2		;NO
	MOVEI	TEM,"R"		;YES.  PRINT "R"
	XCT	TYO
	MOVEI	TEM,"A"
	TLNE	TAC,ALTERB	;OPEN IN READ-ALTER MODE?
	XCT	TYO		;YUP,  PRINT "A" AFTER THE "R"
	MOVEI	TEM,"E"
	TLNE	TAC,IOEND	;END OF FILE?
	XCT	TYO		;YES, PRINT "E"
	JRST	CRLF		;PRINT CRLF AND RETURN FROM PTFILE
PTFIL2:	MOVEI	TEM,"W"
	TLNE	TAC,WRITEB	;IS FILE BEING WRITTEN?
	XCT	TYO		;YES, PRINT "W"
	JRST	CRLF		;PRINT CRLF AND RETURN FROM PTFILE

PTFIL1:	PUSHJ	P,INLMES
	ASCIZ	/ .../
	JRST	CPOPJ1

PR3SIX:	MOVEI	UCHN,3		;PRINT 3 SIXBIT CHARS
	JRST	.+2
PR6SIX:	MOVEI	UCHN,6		;PRINT 6 SIXBIT CHARS
	MOVEI	TEM," "
	XCT	TYO
PRSIXA:	SETZ	TAC,
	LSHC	TAC,6		;GET NEXT SIXBIT CHAR
	MOVEI	TEM,40(TAC)	;PRINT ASCII
	XCT	TYO
	SOJG	UCHN,PRSIXA	;PRINTED ENOUGH CHARS YET?
	POPJ	P,		;YUP

PRREC:	MOVEI	UCHN,5		;PRINT OCTAL NUMBER IN 6 CHARS WITH LEADING BLANKS
	MOVEI	TEM," "
	HRLZ	TAC1,TAC1	;PUT OCTAL NUMBER IN LEFT HALF OF TAC1
PRREC2:	SETZ	TAC,
	LSHC	TAC,3		;GET NEXT OCTAL DIGIT
	JUMPN	TAC,PRREC1	;IF NON ZERO, GO PRINT
	XCT	TYO		;OTHERWISE, PRINT SPACE
	SOJG	UCHN,PRREC2	;PRINTED 5 LEADING SPACES YET?
PRREC3:	SETZ	TAC,
	LSHC	TAC,3		;GET NEXT OCTAL DIGIT
PRREC1:	MOVEI	TEM,"0"(TAC)	;PRINT ASCII DIGIT
	XCT	TYO
	SOJGE	UCHN,PRREC3	;PRINTED 6 CHARS YET?
	POPJ	P,		;YES.  DONE AT LAST

NXTDSK:	HLRZ	AC1,DEVSER(AC1)	;GET LINK TO NEXT DDB
	JUMPE	AC1,CPOPJ	;DIRECT RETURN IF NONE
	MOVE	AC2,DEVMOD(AC1)	;GET DEVICE CHARACTERISTICS
	TLNN	AC2,DVDSK	;IS THIS A DSK DDB?
	JRST	NXTDSK		;NO.  GET NEXT DDB
	JRST	CPOPJ1		;YES.  SKIP RETURN WITH DSK DDB
