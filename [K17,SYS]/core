COMMENT ⊗   VALID 00033 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	CORE ROUTINES FOR SWAPPING SYSTEM. 4 AUG 67 ↔ BEGIN CORE
C00007 00003	CORINI	INITIALIZE CORE TABLES
C00010 00004	CORE UUO
C00017 00005	SHUFFLER   CHKSHF
C00026 00006	ANYACT	ROUTINE TO TEST FOR ANY ACTIVE DEVICES
C00034 00007	CORE0
C00038 00008	ENTER HERE FROM CORE UUO OR RUN COMMAND WHEN IT REASSIGNS
C00043 00009	BAKOLD:
C00045 00010	MOVE OLD CORE TO NEW AREA
C00051 00011	DIDDLE
C00055 00012	CSTAT, STAPUT, STAPTT		STATISTICS SERVICE
C00058 00013	HOLSRC	
C00061 00014	CORCHK AND CORTCK  -- CHECK CORTAL AGAINST CORTAB AND CHECK CORTAB AGAINST WORLD
C00066 00015	CORSTG		ROUTINE TO SET AND CLEAR CORE USE TABLE
C00069 00016	CLRJOB
C00071 00017	GETPR
C00074 00018	RELOCA
C00079 00019	LOCK AND UNLOCK UUOS.
C00089 00020	FREE STORAGE	AND OTHER POLITICAL PRISONERS
C00090 00021	$	INITIALIZE FREE STORAGE
C00097 00022	$	FSGET:	GET FREE STORAGE AT ANY LEVEL.
C00108 00023	SWIPE 1K FROM AVAILABLE USER SPACE.
C00113 00024	$FSCLK:	CLOCK LEVEL (CHANNEL 7) ROUTINES TO KEEP FREE STORAGE HAPPY!
C00118 00025	$	FSGIVE:	RETURN FREE STORAGE TO SYSTEM.
C00128 00026	GET FREE STORAGE AT UUO LEVEL.
C00129 00027	 ROUTINES TO GET AND RELEASE THE PDL AT UUO LEVEL ONLY. - GETPDL
C00133 00028	SPARE LIST HANDLER FOR DPYSER & TTYSER
C00136 00029	VERSION OF FSGET TO USE SPARE LIST
C00139 00030	ARRRGH! PI LEVEL AND NO FAILURE POSSIBLE! HERE WE CURL UP AND DIE
C00140 00031	VERSION OF FSGIVE TO THINK ABOUT PUTTING RETURNED BLOCK INTO SPARE LIST
C00142 00032	YES FANS, IT'S THE INFAMOUS RELEX, FORMERLY SCATTERED THROUGH TTYSER & DPYSER
C00145 00033	BEND CORE
C00146 ENDMK
C⊗;
SUBTTL	CORE ROUTINES FOR SWAPPING SYSTEM. 4 AUG 67 ↔ BEGIN CORE

COMMENT $
	REVISED, MAY 1972 BY REG

	CORE IS ALLOCATED ON A 1K BLOCK BASIS.  A TABLE OF 257  9-BIT
BYTES  (CORTAB)  IS  KEPT.  EACH  BYTE  CORRESPONDS  TO A 1K BLOCK OF
ADDRESSABLE MEMORY (EXCEPT THE LAST WHICH IS ALWAYS NON-EXISTANT).  A
BYTE IS MARKED WITH THE FOLLOWING CODES:

	0	BLOCK IS AVAILABLE.
	1-77	BLOCK IS IN USE BY THE JOB NAMED IN THIS CODE
	101	BLOCK IS OCCUPIED BY THE SYSTEM
	103	BLOCK DOES NOT EXIST.
	105	BLOCK IS IN USE BY SYSTEM FREE STORAGE.

	WHEN THE SYSTEM IS LOADED OR  INITIALIZED,  CORINI  SETS  THE
CORTAB  TABLE TO REFLECT BLOCKS IN USE BY THE SYSTEM AND NON-EXISTANT
BLOCKS.  CORINI ALSO SETS  RMEMSIZ,  THE  SIZE  OF  PHYSICAL  MEMORY,
MEMSIZ,  THE  BOTTOM OF FREE STORAGE, AND LOCATION 37, SYSTEM JOBREL.
CORINI ALSO MAKES TWO BYTE POINTERS, CORLST IS  A  POINTER  PAST  THE
FIRST  NON-EX  BLOCK IN CORTAB; CORE2P IS A POINTER TO THE LAST BLOCK
USED  BY  SYSTEM  CODE.  CORTAL  IS  SET TO THE NUMBER OF FREE BLOCKS
AVAILABLE.

	CORE1  ASSIGNS  CORE TO A JOB, IF POSSIBLE, SETS THE USE CODE
IN CORTAB, AND MOVES THE JOB IF THIS ASSIGNMENT  IS  AT  A  DIFFERENT
PLACE THAN THE OLD.

THE TABLE, JBTADR, IS ALSO UPDATED BY THE CORE ROUTINES.
	JBTADR CONTAINS: PROTECTION,,RELOCATION OF A JOB.
	JBTADR  IS  MODIFIED  IF  CORE  FOR  CURRENT JOB THE HARDWARE
PROTECTION/RELOCATION REGISTER IS RESET IF THIS IS  THE  CURENT  JOB.
ALSO, JOBREL IN USER'S JOB DATA AREA IS ALWAYS UPDATED.

$

;LIST OF GLOBALS AFFECTED:
;JBTADR,CORTAL,CORTAB,HOLEF,SHFWAT,JOBADR

;ACS USED(BESIDES TAC,TAC1,JDAT,IOS,DEVDAT,AND P)
BLK←AC1		;HIGHEST REL. ADR. IN USER AREA
LOC←DSER	;ABS. LOC. OF FIRST BLOCK IN USER AREA
;CORINI	INITIALIZE CORE TABLES
;REG THIS PAGE. 1972: 22 FEB, 15 APRIL, 28 APRIL.

COREP:	POINT	9,CORTAB
	POINT	9,CORTAB,8
	POINT	9,CORTAB,17
	POINT	9,CORTAB,26
↑CORINI:
	MOVE	TAC,[XWD CORBEG,CORBEG+1]
	SETZM	CORBEG
	BLT	TAC,COREND

	SETZM	LOCKNO		;NO JOB IS ATTEMPTING TO LOCK
	MOVE	TAC,SYSTOP
	MOVEM	TAC,LOKTOP	;TOP OF LOCKED CORE IS SAME AS SYSTEM TOP.

	MOVE	TEM,COREP	;BYTE POINTER TO CORTAB
	MOVEI	TAC,CORBLK	; =256, MAXIMUM MEM SIZE
	CONO	APR,NXM		;SHUT OFF NXM FLAG
	TDZA	TAC1,TAC1	;BEGIN ZERO AND SKIP INCREMENT
CORI1:	ADDI	TAC1,2000	;INCREMENT ADDRESS
	HLLZ	DAT,(TAC1)	;REFERENCE MEMORY - ZERO RIGHT SIDE OF DAT
	CAMGE	TAC1,SYSSIZ	;SKIP IF ADDRESS IN SYSTEM
	TROA	DAT,2		;IN SYSTEM CODE WILL BE 103
	CONSZ	APR,NXM		;SKIP UNLESS NXM
	TRCA	DAT,103		;NXM CODE IS 103, IF SYSTEM, SET TO 101
	AOS	CORTAL		;THIS BLOCK OF CORE IS AVAILABLE.
	IDPB	DAT,TEM		;MARK THIS BLOCK IN CORTAB
	TRNE	DAT,2		;SKIP IF NO NXM
	JRST	CORI2		;NXM. QUIT NOW.
	TROE	DAT,103		;SET NXM CODE, SKIP IF BEYOND SYSTEM
	MOVEM	TEM,CORE2P	;SAVE CORE2P
	SOJG	TAC,CORI1	;LOOP IF STILL INSIDE POSSIBLE MEMORY
	ADDI	TAC1,2000	;FULL HOUSE.
	IDPB	DAT,TEM
CORI2:	MOVEM	TAC1,RMEMSIZ	;SAVE FIRST PHYSICAL NON-EX ADDRESS 
	MOVEM	TAC1,MEMSIZ	;SETUP LOWEST ADDRESS IN FREE STORAGE
	SUBI	TAC1,1		;DECREMENT TO MAKE SYSTEM JOBREL
	MOVEM	TAC1,37		;SAVE SYSTEM JOBREL FOR EXEC DDT AND UEDDT
	IBP	TEM		;INCREMENT TO POINT TO 2ND NONEX DATA IN CORTAB
	MOVEM	TEM,CORLST	;SAVE AS POINTER PAST ALL REAL MEMORY,
IFN FTSWAP,<
	MOVE	TAC,CORTAL	;GET SIZE OF USER CORE
	LSH	TAC,=10		;TURN K INTO WORDS
	MOVEM	TAC,CORMAX	;SAVE AS MAX SIZE OF USER CORE
	MOVEI	TAC,%SWPL
	MOVEM	TAC,SWAPLI	;SET SYSTEM SWAPLIMIT.
>
	POPJ	P,
SUBTTL	CORE UUO

COMMENT $
CALL BY:
	MOVEI	AC,<HIGHEST RELATIVE ADDRESS DESIRED>
	CALL	AC,['CORE  ']	OR 	CALLI	AC,11
	<ERROR RETURN: CAN'T ASSIGN CORE>
	OK RETURN.  JOB MAY HAVE BEEN SHUFFLED OR SWAPPED.

THE NUMBER OF 1K BLOCKS THAT A JOB MAY HAVE IS RETURNED IN AC.
IF AC CONTAINS 0 THEN DO NOT CHANGE CORE ALLOCATION, JUST
RETURN NUMBER OF AVAILABLE BLOCKS IN AC (ERROR RETURN).

$


↑CORUUO:
	JUMPE	TAC,ZERCOR		;IS ARGUMENT ZERO?
	AOS	(P)			;ASSUME SUCCESS RETURN.
	PUSHJ	P,UNLOCK		;CORE UUO WILL FORCE UNLOCK.
	PUSHJ	P,UCORE			;DO IT!!
	SOS	(P)			;BAD ASSUMPTION. FAILURE RETURN.
ZERCOR:	MOVE	TAC,CORMAX		;GET CURRENT FREE SPACE.
	CAMLE	TAC,SWAPLIMIT		;MORE THERE THAN HE CAN HAVE?
	MOVE	TAC,SWAPLIMIT		;YES. TELL HIM MAX WE'LL ALLOW.
	ASH	TAC,-12			;CONVERT TO BLOCKS!
	JRST	STOTAC			;RETURN CORMAX TO USER

↑UCORE:	IORI	TAC,1777		;ROUND UP TO A 1K BOUNDARY.
	MOVE	TAC1,JBTSTS(J)		;GET JOB STATUS
	TLNN	TAC1,JSEG		;AND SKIP IF THIS IS AN UPPER.
	JRST	CORCS2			;NOT AN UPPER.
	PUSH	P,J			;SAVE UPPER'S JOB NUMBER.
	MOVEI	J,JOBN-1		;LOOK THRU ALL JOBS...
CORCSO:	LDB	TAC1,PSEGN		;DOES THIS GUY POINT TO ME?
	CAME	TAC1,(P)		;SKIP IF A USER OF THIS UPPER.
	JRST	CORCSL			;NO.
	MOVE	TAC1,J			;TAC ← JOB NUMBER OF THIS LOWER.
	PUSHJ	P,CORSGT		;GET THE SIZE OF THIS LOWER.
	ADDI	TAC1,1(TAC)		;LOWER SIZE + MY REQUEST SIZE.
CORCS3:	CAMG	TAC1,CORMAX		;TOO BIG?
	JRST	CORCSL			;NOT TOO BIG. CHECK OTHER LOWERS.
	POP	P,J			;THIS LOWER AND ME WONT FIT
	POPJ	P,			;GIVE THE ERROR RETURN.

CORCSL:	SOJG	J,CORCSO		;CONTINUE SCAN THRU ALL JOBS.
	POP	P,J			;RESTORE J
	JRST	CORXOK			;SO FAR, SO GOOD.

CORCS2:	LDB	TAC1,PSEGN		;NOT A SEGMENT. HAS IT AN UPPER?
	SKIPE	DAT,TAC1		;SKIP IF NO UPPER. GET NUMBER IN DAT
	PUSHJ	P,CORSGT		;GET SIZE OF UPPER IN TAC1.
	ADDI	TAC1,1(TAC)		;UPPER'S SIZE + THIS REQUEST.
	CAMLE	TAC1,CORMAX		;DOES IT FIT?
	POPJ	P,			;NOPE.
CORXOK:	PUSH	P,TAC			;SAVE SIZE WE WANT TO BE.
	PUSH	P,UUO			;SAVE
	PUSH	P,J			;SAVE J IF THIS IS A SEGMENT.
	PUSHJ	P,IOWAIT		;WAIT FOR ALL IO TO STOP.
	JRST	.+2
CORYOK:	PUSHJ	P,WSCHED
	PUSHJ	P,ANYACT		;MAKE SURE WE CAN BE MOVED.
	JRST	CORYOK			;NO. WAIT UNTIL WE CAN.
	POP	P,J			;RESTORE J
	POP	P,UUO
	POP	P,TAC			;HIGHEST REL. LOC. DESIRED
	AOS	(P)			;SET SKIP RETURN.
CORUU1:	SKIPE	PROG,JBTADR(J)		;PICK UP PROG 
					;COULD HAVE BEEN CLOBBERED IF IT'S AN UPPER.
	JRST	CORUU5			;JUMP IF WE HAVE CORE ALREADY.
	PUSHJ	P,CORGET		;NO: DON'T RELEASE PREVIOUS CORE
	SOS	(P)			;FAILURE RETURN.
	JRST	CORUU3

CORUU5:	PUSHJ	P,CORE1			;TRY TO REASSIGN CORE
	SOS	(P)			;NOT AVAILABLE, ERROR RETURN

CORUU3:
IFN FTSWAP,<
	PUSHJ	P,WSCHED		;CALL SCHEDULER TO STOP JOB
					;IN CASE CORE NOW ON DISK.
>
	MOVE	TAC1,JBTSTS(J)
	TLNN	TAC1,JSEG		;SKIP IF THIS IS AN UPPER.
	JRST	SPWCNT			;CONTINUE SPACEWAR FOR THIS JOB
	JRST	NOTSH9			;CONTINUE SPACEWAR FOR ALL LOWERS.

;RUNCOR IS CALLED FROM SAVGET, (NOT CORUUO) (SINCE IT DOESN'T STORE ANYTHING?)

↑RUNCOR:
	AOS	(P)			;ASSUME SUCCESS.
	PUSHJ	P,CORE1			;TRY TO ASSIGN CORE.
	SOS	(P)			;WE SET FAILURE RETURN
	JRST	WSCHED			;HOLD UP IF CORE IS NOW ON DISK.

↑CORSGT:				;GET SIZE OF THIS JOB, WHETHER IN OR OUT.
	PUSH	P,TAC			;SAVE TAC
	MOVE	TAC,JBTSTS(TAC1)	;GET JOB STATUS
	TLNN	TAC,SWP			;SKIP IF ON DISK,
	JRST	CORSG1			;HE'S IN CORE.
	LDB	TAC1,[POINT 9,JBTSWP(TAC1),35]	;GET THE SIZE OF THE IMAGE
	LSH	TAC1,=10		;SHIFT TO MAKE WORDS.
	JRST	TPOPJ			;RESTORE TAC AND RETURN.
CORSG1:	HLRZ	TAC1,JBTADR(TAC1)	;GET THE PROTECTION SIZE
	AOJA	TAC1,TPOPJ		;INCREMENT PROT, POP TAC AND RETURN
SUBTTL	SHUFFLER   CHKSHF

;ROUTINE TO CHECK JOBS TO SEE IF ANY JOB CAN BE SHUFFLED
;CALLED FROM THE SWAPPER WHEN THERE IS ENOUGH FREE CORE
;TO FIT A JOB, BUT THERE IS NO SINGLE HOLE BIG ENOUGH.
;
;A JOB MUST HAVE ALL DEVICES INACTIVE (SINCE SOME
;OF THEM USE ABSOLUTE ADDRESSES) BEFORE IT CAN BE MOVED.
;IF DEVICES ARE ACTIVE, JOB WILL BE STOPPED SO THAT IO WILL
;CEASE SOON SO JOB CAN BE SHUFFLED
;ALL DEVICES LOOK AT SHF BIT IN JBTSTS (ADVBFF OR ADVBFE)
;TO SEE IF MONITOR IS WAITING TO SHUFFLE JOB

;THIS VERSION OF THE CORE SHUFFLER WORKS AS FOLLOWS:
;EVERY CLOCK TICK FOR WHICH ALL JOBS ARE SHUFFLEABLE (NOT COUNTING ACTIVE
;IO DEVICES), THE JOB IMMEDIATELY ABOVE THE LOWEST HOLE
;(IF ANY) WILL BE MOVED DOWN INTO HOLE.  THE HOLEF IS SET NON-ZERO
;TO THE ADDRESS OF JOB IMMEDIATELY ABOVE THE LOWEST
;HOLE (0 IF NONE), EVERY TIME CORE IS REASSIGNED.

↑CHKSHF:
	HGMAC	(26)
	SKIPE	J,SHFWAT	;DID WE STOP A JOB TO WAIT FOR IO INACTIVE?
	JRST	SHFLOP		;YES, SEE IF IO HAS STOPPED YET
	SKIPN	TAC,HOLEF	;NO, DOES CORE HAVE A HOLE IN IT?
	JRST	CHKSHX
CHKSHZ:	CAML	TAC,MEMSIZ
	JRST	CHKERR
	PUSHJ	P,CORGB1	;MAKE A BYTE POINTER FROM HOLEF
	ILDB	J,TAC		;GET A USE BYTE
	CAIGE	J,JOBN		;VALIDITY CHECK-SKIP IF ILLEGAL
	JUMPG	J,SHFLOA	;FOUND ONE?
SHFLOB:	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/HOLEF = /
	MOVE	TAC,HOLEF
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/  BUT NO HOLE PRESENT. CORTAB = /
	MOVE	LOC,HOLEF
	PUSHJ	P,CORGBP	;GET A BYTE POINTER.
	ILDB	J,TAC		;GET THE BYTE.
	CAIL	J,JOBN
	JRST	HOLHLP
	PUSH	P,J
	PUSHJ	P,DISJOB	;PRINT JOB NAME & NUMBER.
	PUSHJ	P,DISCRLF
	POP	P,TAC
	HRRZ	TAC1,JBTADR(TAC)	;TAC1←BOTTOM OF JOB
	HLRZ	TAC,JBTADR(TAC)
	ADDI	TAC,(TAC1)		;TAC← TOP OF JOB.
	CAMG	TAC1,HOLEF	;SKIP IF HOLEF BELOW THE BOTTOM
	CAMG	TAC,HOLEF	;SKIP IF HOLEF INSIDE THIS IMAGE.
	JRST	.+2		;WE CAN FIX THIS?
	JRST	HOLHLP		;WE NEED HELP.
	MOVE	LOC,HOLEF
	PUSHJ	P,CORGBP
	MOVEI	TAC1,0
	IDPB	TAC1,TAC
	JRST	HOLFIX

HOLHLP:	PUSHJ	P,DISMES
	ASCIZ	/I CAN'T FIX IT.
/
	PUSHJ	P,DISFLU
	PUSHJ	P,DDTCAL
HOLFIX:	POPACS
	JRST	CHKSHX

CHKERR:	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/ππHOLEF OUT OF BOUNDS
/
	POPACS
	SETZM	HOLEF
CHKSHX:	SOS	(P)		;SET UP SWAPPER'S PARAMETERS AGAIN
	PSYNC	CORCSC
	JRST	DIDLE4

SHFLOA:	HRRZ	TAC,JBTADR(J)
	CAME	TAC,HOLEF
	JRST	SHFLOB		;LOSER!

;THIS CODE DECIDES WHETHER TO SWAP INSTEAD OF SHUFFLE
	SKIPN	JBTST2(J)	;IS THERE SPACEWAR ACTIVE FOR THIS JOB?
	SKIPG	TAC,FIT		;NO.  AND SOMEONE BEING FITTED IN?
	JRST	SHFLOP		;SPACEWAR ACTIVE OR NO ONE BEING FITTED
	MOVE	TAC,JBTPRI(TAC)	;PRIORITY OF JOB BEING FITTED.
	CAMG	TAC,JBTPRI(J)	;SKIP IF SHUFFLED JOB HAS LOW PRIORITY.
	JRST	SHFLOP		;SHUFFLED JOB HAS HIGH PRIORITY, DON'T FORCE IT
	MOVE	TAC,SEGWAIT
	LDB	TAC,[POINT 6,JBTSTS(TAC),35]
	CAIN	TAC,(J)		;IS THIS THE SEGMENT THAT SOMEONE IS WAITING FOR?
	JRST	SHFLOP		;YES. DON'T SHOVE IT OUT!
	SKIPE	FORCE		;IF FORCE IS SET THEN WE CAN'T MAKE US SWAP
	JRST	SHFLOZ		;TELL PEOPLE THAT WE HAVE LOST.
SHFLOX:	JRST	SHFLOP		;CLOBBER THIS TO JFCL TO MAKE IT SWAP INSTEAD

	MOVSI	TAC,SWP
	IORM	TAC,JBTSTS(J)	;ANNOUNCE THAT WE ARE SWAPPING THIS GUY.
	MOVEM	J,FORCE
	POPJ	P,		;TELL THEM WE WANT TO SWAP THIS USER

SHFLOZ:	PUSH	P,J		;THIS MESSAGE IS FOR INFORMATION ONLY!
	PUSHJ	P,DISMES
	ASCIZ	/[FORCE SET AT SHFLOZ]
/
	POP	P,J

SHFLOP:	JUMPL	J,CPOPJ		;JUMP IF A JOB IS ALREADY MOVING.
	SKIPN	PROG,JBTADR(J)	;SETUP PROG FOR CALL
	JRST	NOTSH1		;NO CORE. HE CAN'T BE SHUFFLED, SO CLEAR SHFWAT
IFN JDMPRG,<
	MOVE	JDAT,JBTDAT(J)	;JOB DATA AREA
>
	HLRZ	TAC,PROG	;REASSIGN SAME AMOUNT OF CORE.
	PUSHJ	P,SHFCOR	;IN A LOWER POSITION IN CORE
	JRST	NOTSHF		;CANNOT ONLY IF IO IS ACTIVE

IFN FTSHF1K,<
	SKIPE	SHFJOB		;IF FINISHED, CLEAN UP SHF BIT AND OTHER CELLS
	POPJ	P,		;OTHERWISE, RETURN, LETTING CLOCK DO THE MOVING
>
	JRST	NOTSH1		;FINISHED SHUFFLING, CLEAN UP

NOTSHF:	SKIPN	HOLEF		;JOB CAN'T BE MOVED.  STILL ACTIVE IO.
	JRST	NOTSH1		;HOLE ISN'T THERE ANYMORE?
IFN FTSWAP,<
	MOVM	TAC,FORCE
	CAME	J,FIT
	CAMN	J,TAC
	JRST	NOTSH1		;IF THIS JOB IS BEING SWAPPED, DON'T SHUFFLE
>
	MOVEM	J,SHFWAT	;SET SHUFFLE WAIT FLAG WITH JOB NO.
	MOVSI	TAC,SHF		;SET SHF WAIT BIT IN JOB STATUS WORD
	SKIPN	JBTST2(J)	;IF SPW RUNNING, LET HIM RUN TOO
	IORM	TAC,JBTSTS(J)	;SO JOB WILL NOT BE RUN
	POPJ	P,		;AND IO WILL STOP SOON

↑NOTSH1:			;HERE WHEN JOB FINISHES MOVING
	PSYNC	CORCSC
	SETZM	SHFWAT		;JOB SHUFFLED, CLEAR FLAG
IFN FTSHF1K,<
	SETZM	SHFTAC		;CLEAR SHUFFLE FLAGS WHEN DONE
	SETZM	SHFEND
	SETZM	SHFJOB
>
	MOVSI	TAC,SHF		;CLEAR SHUFFLE WAIT BIT IN CASE IT WAS ON
	ANDCAB	TAC,JBTSTS(J)
	SKIPN	JBTADR(J)
	JRST	NOTSH4		;IF WE DON'T HAVE CORE, DON'T CONTINUE SPACEWAR
	TLNE	TAC,JSEG
	JRST	NOTSH6		;YES.
	PUSHJ	P,SPWCNT	;THIS IS A LOWER, CONTINUE SPACEWAR FOR HIM
	JRST	NOTSH4
 
NOTSH9:	MOVEI	TAC1,(J)	;THIS IS AN UPPER, FIND OUR LOWERS.
				;(CALLED FROM CORE2 UUO, AND FROM NOTSH6)
	MOVEI	J,JOBN-1	;AND CONTINUE THEIR SPACEWAR.
NOTSH3:	MOVE	TAC,JBTSTS(J)
	ANDI	TAC,77		;PSEGN BETTER POINT TO BITS 30-35.
	CAIN	TAC,(TAC1)	;IS THIS ONE OF MY LOWERS?
	PUSHJ	P,SPWCNT	;YES. CONTINUE HIS SPACEWAR.
	SOJG	J,NOTSH3	;LOOP LOOKING FOR ALL LOWER USERS OF THIS SEG.
	MOVEI	J,(TAC1)	;RESTORE J.
	POPJ	P,

NOTSH6:	PUSHJ	P,NOTSH9	;CONTINUE SPACEWAR FOR LOWERS OF THIS UPPER.
NOTSH4:

IFN FTSHF1K,<
	SKIPN	SHFBLK		;ANY CORE TO RETURN?
	JRST	NOTSH2		;NO.
	HRRZ	LOC,SHFBLK
	HLRZ	BLK,SHFBLK
	SETZB	UCHN,SHFBLK
	PUSHJ	P,CORSTG	;YES. RETURN IT.
>

NOTSH2:	SOS	(P)		;DIDLE SKIP RETURNS
	JRST	DIDLE4		;RE-FORM CORE AVAIL PARAMS.

↑SPWCNT:			;CONTINUE A SPW JOB
	SKIPN	JBTST2(J)	;IS THERE A SPW JOB HERE??
	POPJ	P,		;NO.
	PSYNC	SPWCSC
	MOVSI	TAC,SPWST1!SPWST2
	ANDCAM	TAC,JBTST2(J)
	XSYNC	SPWCSC
	POPJ	P,
SUBTTL	ANYACT	ROUTINE TO TEST FOR ANY ACTIVE DEVICES
COMMENT  $
CALLING
	MOVE	J,JOB NUMBER
	MOVE	JDAT,ADDRESS OF JOB DATA AREA
	PUSHJ	P,ANYACT
	<HERE IF DEVICES ACTIVE>
	<HERE IF NO DEVICE IS ACTIVE, EXCEPT POSSIBLY TTY>
$

↑ANYACT:
	MOVE	UCHN,JBTSTS(J)		;GET JOB STATUS
	TLNN	UCHN,JSEG		;SKIP IF THIS IS AN UPPER
	JRST	ANYAC3			;THIS IS A LOWER
	PUSH	P,PROG			;SAVE VITAL DATA.
	PUSH	P,J			;SAVE THIS JOB NUMBER.
	MOVEI	J,JOBN-1		;SEARCH THRU ALL JOBS.
ANYAC1:	LDB	UCHN,PSEGN		;LOOKING FOR LOWERS THAT POINT HERE
	CAME	UCHN,(P)		;DOES THIS POINT TO ME.
ANYA1A:	SOJG	J,ANYAC1		;NO. DECREMENT J AND LOOP
	JUMPLE	J,ANYAC2		;JUMP IF WE HAVE EXHAUSTED THE LOOP
	MOVE	PROG,JBTADR(J)		;YES. GET HIS ADDRESS
	PUSHJ	P,ANYAC3		;CALL ROUTINE FOR A LOWER SEGMENT
	CAIA				;LOSE. CANT MOVE THIS LOWER
	JRST	ANYA1A			;THIS LOWER DOESN'T CARE IF WE MOVE
	POP	P,J
	POP	P,PROG
	POPJ	P,			;FAILURE RETURN

ANYAC2:	POP	P,J			;RESTORE JOB NUMBER
	POP	P,PROG
	JRST	CPOPJ1			;SUCCESS RETURN.

ANYAC3:	SKIPN	JBTADR(J)		;ANY CORE THERE?
	JRST	CPOPJ1			;NO CORE MEANS NO IO ACTIVE.
	SKIPE	JBTGLU(J)		;IS SOMEONE GLUEING HIM?
	POPJ	P,			;YES. FAKE ACTIVE DEVICE.
	MOVEI	UCHN,JOBJDA(JDAT)	;ASSUME JOB IS NOT CURRENT JOB
	CAMN	J,JOB(PID)		;IS IT CURRENT JOB?
	MOVEI	UCHN,USRJDA(PID)	;YES. GET DATA FROM MONITOR.
	MOVEI	IOS,IOACT		;IO DEVICE ACTIVE BIT
	SKIPL	AC2,JOBJMH(UCHN)	;GET NO. OF USER IO CHANNELS IN USE
	CAILE	AC2,17			;IS HIGHEST CHANNEL LEGAL?
	JRST	ANY3			;SAVEGET IO ACTIVE  OR ILLEGAL CHANNEL.
	TLO	UCHN,AC2		;SET TO ADD UCHN TO AC2
	MOVSI	TAC1,DVTTY		;DEVICE IS A TTY BIT
ANY:	HRRZ	DDB,@UCHN		;IS A DEVICE ASSIGNED TO THIS CHANNEL?
	JUMPE	DDB,ANY2		;NO.
	CAIL	DDB,CHKBEG		;CHECK ADDRESS. SKIP IF LOW CORE
	CAML	DDB,MEMSIZ		;SKIP IF BELOW F.S. (NO NO)
	CAML	DDB,RMEMSIZ		;BELOW REAL MEM? (REDUNDANT FOR LOW CORE)
	JRST	ANY7			;LOSING ADDRESS
	TDNN	IOS,DEVIOS(DDB)		;YES, IS IT ACTIVE?
ANY2:	SOJGE	AC2,ANY			;NOT ACTIVE KEEP LOOKING
	JUMPL	AC2,ANY4A		;JUMP IF FINISHED LOOKING
	TDNN	TAC1,DEVMOD(DDB)	;NOT FINISHED, IS DEVICE TTY?
	POPJ	P,			;NOT TTY DEVICE ACTIVE. CANT MOVE THIS JOB
	JRST	ANY2			;DEVICE IS TTY.  LOOK AT OTHER DEVICES

ANY4A:	SKIPL UCHN,JBTIOP(J)
	JRST ANY4
ANY4BA:	SKIPN DDB,(UCHN)		;GET DDB POINTER (SKIP FLUSHED ONES)
	JRST ANY4C
	TDNE IOS,DEVIOS(DDB)		;IOACT ON?
	TDNE TAC1,DEVMOD(DDB)		;YES, TTY?
	CAIA				;YES (TTY) OR NO (IOACT)
	POPJ P,				;ACTIVE IO
ANY4C:	ADD UCHN,[1,,1]			;ADVANCE TO CHANNEL NUM
	AOBJN UCHN,ANY4BA		;ADVANCE TO NEXT DDB AND TEST
	JRST ANY4

ANY7:	PUSHACS				;DDB ADDRESS IS OUT OF BOUNDS.
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/ANY7: ILLEGAL DDB ADDRESS = /
	HRRZ	TAC,DDB-17(P)		;PICK UP ADDRESS
	PUSHJ	P,DISLOC		;TYPE ADDRESS IN OCTAL
	PUSHJ	P,DISTAB
	MOVE	J,J-17(P)
	PUSHJ	P,DISJOB
	PUSHJ	P,DISMES
	ASCIZ	/ USER IO CHANNEL /
	MOVE	TAC,AC2-17(P)
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	MOVE	J,J-17(P)
;	PUSHJ	P,DATERR		;FIX JOB DATA AREA.
	POPACS
	SETZM	@UCHN			;BLAST ILLEGAL DDB POINTER
	JRST	ANY2

ANYHCC:	PUSHACS	
	PUSHJ	P,DISDAT
	PUSHJ	P,DISMES
	ASCIZ	/JOBHCU CLOBBERED AT ANYACT. /
	MOVE	J,J-17(P)
	PUSHJ	P,DISJOB
	PUSHJ	P,DISMES
	ASCIZ	/  JOBHCU = /
	MOVE	TAC,AC2-17(P)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
	MOVE	J,J-17(P)
;	PUSHJ	P,DATERR		;FIX JOB DATA AREA
	POPACS
	SETZM	JOBJMH(UCHN)		;SET ONLY USER CHANNEL 0 IN USE.
	SETZM	(UCHN)			;CLEAR USER CHANNEL 0.
	JRST	CPOPJ1			;FAKE SUCCESS RETURN.

ANY3:	JUMPG	AC2,ANYHCC		;JOBHCU IS CLOBBERED.
	HRRZ	AC2,AC2			;ADDRESS ONLY, PLEASE!
	CAIL	AC2,CHKBEG		;SKIP IF IN SYSTEM LOW CORE.
	CAML	AC2,MEMSIZ		;NO. MUST BE IN FREE STORAGE.
	CAML	AC2,RMEMSIZ		;IF IN F.S.  MUST BE IN REAL MEM.
	JRST	ANYILM			;WE LOSE.
ANY3A:	TDNN	IOS,DEVIOS(AC2)		;IS SAVEGET DEVICE STILL ACTIVE?
	AOS	(P)			;NO
	POPJ	P,			;YES

ANYILM:	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/ANYILM: SAVGET JOBCHU - ILLEGAL DDB ADDRESS.
/
	POPACS
	JRST CPOPJ1			; PRETEND SUCCESSFUL

ANY4:	SKIPE	JBTIIP(J)		; INTERRUPT IN PROGRESS
	POPJ	P,			;YES. CAN'T MOVE ME.
	SKIPN	SP2GO(J)		; IS A P2 SPACEWAR JOB RUNNING?
	SKIPE	SPWGO(J)		; OR IS A P1 SPACEWAR JOB RUNNING?
	AOSA	(P)			;SPACEWAR ACTIVE. ASSUME SKIP RETURN!
	JRST	CPOPJ1			;WE CAN BE MOVED.

	PSYNC	SPWCSC
	MOVE	IOS,JBTST2(J)
	TLC	IOS,SPWST1!SPWST2
	TLCN	IOS,SPWST1!SPWST2
	JRST	ANY4B			;SPW SUSPENDED. GIVE SKIP RETURN.
	MOVSI	IOS,SPWSUS		;NO. MARK IT FOR SUSPENSION
	TDNN	IOS,JBTST2(J)		;SKIP IF SUSPENSION REQUEST SET ALREADY.
	IORM	IOS,JBTST2(J)		;SET THE BIT THAT REQUESTS SPW SUSPENSION
	SOS	(P)			;NON-SKIP RETURN.
ANY4B:	XSYNC	SPWCSC
	POPJ	P,			;CANT MOVE HIM UNTIL HE'S SEEN SUSPENSION.
SUBTTL	CORE0
;CORE0 IS CALLED BY THE CORE MONITOR COMMAND AND THE CORE SHUFFLER
;AND RUN COMMAND
;CORE SHUFFLER AND RUN COMMAND

;CALL:	MOVE TAC,HIGHEST LEGAL ADDRESSABLE LOC. DESIRED
;	MOVE J,JOB NUMBER
;	MOVE PROG,[XWD PROT.,RELOC.]=JBTADR(J)
;	PUSHJ P,CORE0
;	ERROR	;EITHER JOB HAS ACTIVE IO
		;OR NOT ENOUGH CORE
;	OK RETURN
;JOB IS MOVED IF NECESSARY TO SATISFY REQUEST
;PROG AND JDAT ARE SET TO NEW CORE ASSIGNMENT ON EITHER RETURN
;0 MEANS NONE ASSIGNED

;ENTER HERE FROM CORE CONSOLE COMMAND OR INITIAL CORE
;ASSIGNMENT OF JUST A JOB DATA AREA FOR RUN COMMAND
;IE ENTER WHEN DEVICES MAY BE ACTIVE OR JOB MAY HAVE NO PREVIOUS CORE


↑CORE0:
IFE FTSWAP,<
	JUMPE	PROG,CORGET	;IS JOB WITHOUT CORE IN MEMORY?
>
IFN FTSWAP,<
	CAML	TAC,SWAPLIMIT	;IS HE BEING TOO GREEDY.
	POPJ	P,		;FLUSH THE GREEDY BASTARD!	;JS
	JUMPN	PROG,CORE0A	;DOES JOB HAVE CORE IN MEMORY?
	MOVSI	TAC1,SWP	;NO, DOES IT HAVE CORE ON DISK?
	CAMGE	TAC,CORMAX	;WILL REQUEST FIT IN PHYSICAL CORE.
	TDNN	TAC1,JBTSTS(J)	;YES, IS JOB ON DISK?
	JRST	CORGET		;NO, TRY TO ASSIGN MEMORY IN CORE OR DISK.
	JUMPE	TAC,CORE0B	;YES, IS HE REQUESTING ANY?
	LSH	TAC,-12		;YES, CONVERT TO 1K BLOCKS
	AOSA	TAC
CORE0B:	ANDCAM	TAC1,JBTSTS(J)	;NO, CLEAR CORE ON DISK BIT.
↑CORE0K:
	DPB	TAC,IMGIN	;STORE NEW CORE IMAGE BLOCK SIZE
IFN FTSTAT,<
	PUSH P,TAC
	LSH TAC,6
	ANDI TAC,37700
	TRO TAC,CSZSTA
	PUSHJ P,STAPUT
	POP P,TAC
>;FTSTAT
	PUSH	P,DAT
	LDB	DAT,IMGOUT	;SIZE ON DISC (1K BLOCKS)
	CAML	TAC,DAT		;NEW SIZE LESS THAN AMOUNT ON DISC?
	JRST	CORE0C		;NO, RETURN
	SETZM	SWPCNT		;WAKE UP SWAPPER NEXT TICK
	DPB	TAC,IMGOUT	;YES, REPLACE DISC SIZE
	SUB	DAT,TAC		;AMOUNT OF DISC TO FREE (1K BLOCKS)
	LSH	TAC,CONVMD	;CONVERT NEW SIZE TO DISC BLOCKS
	HLRZ	TAC1,JBTSWP(J)	;COMPUTE DISC BLOCK NUMBER FOR
	ADD	TAC,TAC1	;FIRST BLOCK TO FREE.
	PUSHJ	P,FXSAT		;FREE THE DISC BLOCKS.
CORE0C:	POP	P,DAT		;RESTORE TTY OUTPUT BYTE POINTER
	JRST	CPOPJ1		;AND SKIP RETURN

CORE0A:
>
	PUSHJ	P,ANYACT	;NO,ANY ACTIVE DEVICE?
	POPJ	P,		;YES, CANNOT ASSIGN CORE
				;NO, FALL INTO CORE1
;ENTER HERE FROM CORE UUO OR RUN COMMAND WHEN IT REASSIGNS
;PROPER AMOUNT OF CORE AFTER READING DIRECTORY
;JOB MUST ALREADY HAVE CORE AND NO ACTIVE DEVICES
;FIRST OLD CORE IS RETURNED TO SYSTEM
;THEN NEW REQUEST IS ATTEMPTED TO BE SATISFIED IN LOWEST
;POSITION POSSIBLE.  THUS CORE TENDS TO BE PACKED
;IF NEW REQUEST CANNOT BE GRANTED, OLD AMOUNT IS RETAINED

↑CORE1:	CAML	TAC,SWAPLIMIT	;CAN HE HAVE THIS MUCH?
	POPJ	P,		;NO
	NOSCHEDULE		;PREVENT SCHEDULING
	PSYNC	CORCSC
	MOVE	LOC,JBTSTS(J)
	TRNE	LOC,JLOCK
	PUSHJ	P,UNLOCK	;DRD. REG 2-14-73
	ANDI	TAC,-1		;RIGHT SIDE ONLY
	HRRZ	LOC,PROG	;ABS. LOC. OF OLD CORE
	HLRZ	BLK,PROG	;HIGHEST LEGAL REL. ADR.
	JUMPE	TAC,CORG2
	CAILE	TAC,(BLK)	; IS HE EXPANDING?
	JRST	CORG2		; YES, LET HIM
	CAIN	TAC,(BLK)	; NO, IS HE THE SAME?
	JRST	DIDLEA		; YES, LEAVE NOW
	ADDI	LOC,1(TAC)	; OTHERWISE, SHRINK HIM IN PLACE
	SUBI	BLK,1(TAC)
	HRL	PROG,TAC
	MOVEI	UCHN,0
	PUSHJ	P,CORSTG
	JRST	DIDLEA

SHFCOR:	PUSHJ	P,ANYACT
	POPJ	P,
	PSYNC	CORCSC
	ANDI	TAC,-1		;RIGHT SIDE ONLY
	HRRZ	LOC,PROG
	HLRZ	BLK,PROG
CORG2:	MOVEI	UCHN,0		;CLEAR FOR CORSTG CALL
	PUSHJ	P,CORSTG	;RETURN OLD CORE TO FREE STORAGE
	JRST	CORG1

;CORGET IS CALLED BY SWAPPER WHEN JOB IS ON DISC AND IS WANTED IN CORE.

↑CORGET:
	CAML	TAC,SWAPLIMIT	;CAN HE HAVE THIS MUCH?
	POPJ	P,
	PSYNC	CORCSC
CORG1:	SETZB	LOC,PROG	; SET NEW ASSIGNMENT TO 0 AND DIST. MOVED
	AOS	NCORCALLS
	JUMPE	TAC,DIDLE2	;IS ZERO CORE BEING REQUESTED?
	CAME	J,SHFWAT	;WAITING FOR CURRENT JOB?
	SKIPN	SHFWAT		;IF SHUFFLING, PRETEND NOT AVAIL.
	PUSHJ	P,HOLSRC	;NO, SEARCH FOR HOLE BIG ENOUGH
	JRST	BAKOLD		;NONE, GIVE BACK OLD AMOUNT
CORGT1:	MOVEM	LOC,PROG	;SETUP NEW RELOC
	HRLM	TAC,PROG	;AND NEW PROTECT.
	MOVEI	BLK,(TAC)	;HIGHEST REL ADR. BEING REQUESTED
	MOVE	UCHN,J		;SET USE BITS IN CORE TABLE
	PUSHJ	P,CORSTG
	MOVE	BLK,JBTADR(J)	;OLD CORE ASSIGNMENT
	JUMPN	BLK,MOVCOR	;WAS THERE OLD MEMORY ASSIGNED?
	PUSHJ	P,CLRJB1	;CLEAR JOB DATA AREA
	MOVE	UCHN,JBTSTS(J)
	TLNE	UCHN,SWP	;IS JOB COMING IN FROM DISK?
	JRST	DIDLEA
	MOVSI	UCHN,JERR	; SET ERROR BIT IN JOB STATUS WORD
	ORM	UCHN,JBTSTS(J)
	MOVNI	UCHN,STOPQ	; PUT JOB IN STOP QUEUE
	MOVEM	UCHN,JOBQUE(J)
	PUSHJ	P,REQUE
	JRST	DIDLEA
BAKOLD:
IFN FTSWAP,<;IN SWAPPING SYSTEM STORAGE LIMIT INSTEAD OF CORE
;LIMIT USED TO DETERMINE IF REQUEST IS GRANTED.

	MOVSI	UCHN,SWP
	TDNN	UCHN,JBTSTS(J)	;GETTING CORE FOR SWAPPER?
	JRST	CORGT3
	SOS	(P)		;YES, SET FAILURE RETURN
	JRST	DIDLE4

CORGT3:	JUMPL	TAC,CORGT2	; A NEGATIVE CORE AMOUNT IS AN ERROR?
	CAMGE	TAC,SWAPLIMIT	;GTR SWAP AREA?
	CAML	TAC,CORMAX	;WILL REQUEST FIT IN PHYSICAL CORE?
CORGT2:	SOSA	(P)		;NO - GIVE ERROR RETURN
	PUSHJ	P,XPAND		;YES - TELL SWAPPER TO SWAP OUT
>
IFE FTSWAP,<	SOS	(P)	;SET FOR ERROR RETURN
>
	HLRZ	TAC,JBTADR(J)	;GIVE BACK OLD CORE.
	HRRZ	LOC,JBTADR(J)	;RETURN OLD CORE
	TRNN	LOC,-1		;ANY CORE TO RETURN?
	JRST	DIDLE4		;NO.  JUST EXIT.
	JRST	CORGT1
;MOVE OLD CORE TO NEW AREA

MOVCOR:	CAIN	LOC,(BLK)	;IS NEW CORE IN SAME PLACE AS OLD?
	JRST	DIDLE		;YES, DO NOT MOVE IT
	MOVSI	TAC1,INTSHW	; DO WE INTERRUPT THIS GUY FIRST?
	TDNN	TAC1,JBTIEN(J)
	JRST	MOVCO1		; NO
	IORM	TAC1,JBTIRQ(J)	; YES
	PUSH	P,J
	PUSH	P,BLK
	PUSH	P,LOC
	PUSH	P,TAC
	PUSH	P,PROG
	PUSHJ	P,INTRUN	;MAKE INTERRUPT HAPPEN
	POP	P,PROG
	POP	P,TAC
	POP	P,LOC
	POP	P,BLK
	POP	P,J
MOVCO1:	
IFN FTSHF1K,<
	SKIPN	SPWACT		; IS THERE A SPACEWAR JOB ACTIVE?
	JRST	ISET2		; NO, DO IT ALL IN ONE BIG BLT
;;; THE FOLLOWING J. SAUTER CODE (+ OTHER BITS AND PIECES AROUND
;;; AT NOTSH1 AND CLKSER) IS DE-ACTIVATED FOR EFFECIENCY'S SAKE

;CALC AMT TO GIVE BACK AFTER MOVING
;BLK = XWD LENGTH OF OLD CORE,BOTTOM OF OLD CORE
;TAC = LENGTH OF NEW CORE
;LOC = BOTTOM OF NEW CORE

	MOVEM	BLK,SHFBLK
	HLRZ	TAC1,BLK	;LENGTH OF OLD
	ADDI	TAC1,(BLK)	;TOP OF OLD
	CAIL	LOC,(TAC1)	;BOTTOM OF NEW ABOVE TOP OF OLD
	JRST	ISET		;YES. AREAS ARE DISJOINT
	MOVE	TAC1,TAC	;LENGTH OF NEW CORE
	ADD	TAC1,LOC	;TOP OF NEW CORE
	CAIG	TAC1,(BLK)	;ABOVE BOTTOM OF OLD?
	JRST	ISET		;NO. AREAS ARE DISJOINT
	HRRZM	TAC1,SHFBLK
	HLRZ	TAC1,BLK	;AREAS OVERLAP.
	ADDI	TAC1,(BLK)
	SUB	TAC1,SHFBLK
	JUMPLE	TAC1,ISET1	;AMOUNT LEQ 0.  RETURN NONE.
	SUBI	TAC1,1
	HRLM	TAC1,SHFBLK
	AOS	SHFBLK
ISET:	PUSH	P,BLK		;GRAB THE OLD CORE UNTIL DONE
	PUSH	P,LOC
	HRRZ	LOC,SHFBLK
	HLRZ	BLK,SHFBLK
	MOVE	UCHN,J		;I HOPE J IS SET UP HERE
	PUSHJ	P,CORSTG	;GET BACK OLD CORE
	POP	P,LOC
	POP	P,BLK
	JRST	ISET2

ISET1:	SETZM	SHFBLK		;DONT GIVE ANYTHING BACK.
>;END OF IFN FTSHF1K

ISET2:	HLRZ	TAC1,BLK	;LENGTH OF OLD CORE
	CAILE	TAC1,(TAC)	;IS OLD CORE LESS THAN NEW?
	HRRZ	TAC1,TAC	;NO, MOVE THE SHORTENED NEW CORE
	ADDM	TAC1,SHFWRD	;INCREMENT TOTAL NO. WORDS SHUFFLED
	ADD	TAC1,LOC	;ADD IN NEW RELOC.
	MOVE	TAC,LOC		;DEST.=NEW RELOC.
	HRL	TAC,BLK		;SOURCE=OLD RELOC.
	MOVEM	BLK,PARBLK	;SAVE THIS FOR PARSER.
	SETZM	JBTADR(J)	;FLAG THAT CORE IS IN TRANSIT(TTY ROUTINES)

IFN FTSHF1K,<
	SKIPN	SPWACT		; IS THERE A SPACEWAR JOB ACTIVE?
	JRST	MOVC1		; NO, DO IT ALL IN ONE BLT
	ADDI	TAC1,1
	MOVEM	TAC1,SHFEND	;RECORD THE END OF THE BLT
	MOVE	TAC1,[XWD 2000,2000]
	ADD	TAC1,TAC	;BLT THE FIRST 1K NOW.
	MOVEM	TAC1,SHFTAC	;WHERE TO START NEXT TIME
	BLT	TAC,-1(TAC1)	;MOVE JOB DATA AREA.
	SETOM	SHFWAT		;NOTE THAT A JOB IS MOVING.
	MOVSI	TAC,SHF		;DONT RUN HIM UNTIL STOPPED
	IORM	TAC,JBTSTS(J)
	MOVEM	J,SHFJOB
	JRST	DIDLE
>;END OF IFN FTSHF1K

MOVC1:

IFN FTSHF1K,<
	SETZM	SHFTAC		; ZERO OUT CLKINT COMMUNICATION CELLS
	SETZM	SHFEND
	SETZM	SHFJOB		; MAKE SURE NOTSH1 IS CALLED!
>;IFN FTSHF1K

IFN FTHG,<PUSH	P,HGCODE
	HGMAC	(30)	>
	MOVEM	J,PARSJB	;FOR PARSER, THE JOB BEING SHUFFLED
↑SHFBLT:
	BLT	TAC,(TAC1)	;LABEL THIS FOR PARSER.
IFN FTHG,<POP	P,HGCODE>
	PUSHJ	P,DIDLE		; REFORM CORE PARAMETERS NOW
	JFCL
	AOS	(P)		;SET UP FOR SKIP RETURN
↑SHFDONE:
	MOVSI	TAC1,INTSHD
	TDNN	TAC1,JBTIEN(J)
	POPJ	P,
	IORM	TAC1,JBTIRQ(J)
	PUSH	P,J
	PUSH	P,BLK
	PUSH	P,LOC
	PUSH	P,PROG
	PUSHJ	P,INTRUN	;RUN USER I-LEVEL FOR END OF SHUFFLE
	POP	P,PROG
	POP	P,LOC
	POP	P,BLK
	POP	P,J
	POPJ	P,
SUBTTL	DIDDLE
;IF THE SHUFFLED JOB IS IN EXEC MODE, ITS DUMP ACS
;(P,PROG,JDAT SAVED IN JOB DATA AREA) MUST BE
;ALTERED BY DISTANCE CORE WAS MOVED

;IF THE SHUFFLED JOB IS CURRENT JOB, THE SOFTWARE STATE OF
;THE MONITOR(IE SOFTWARE OF JOB) NUST BE ALTERED BY AMOUNT
;CORE WAS MOVED

DIDLEA:	MOVE	TAC,JBTSTS(J)
	TLNE	TAC,JSEG	;UPPER SEGMENTS TAKE 2 GIANT STEPS!
	JRST	DIDLE3
	JRST	DIDLE1


DIDLE:	SUBI	LOC,(BLK)	;DISTANCE JOB WAS MOVED(DEST.-SOURCE)
	MOVE	TAC,JBTSTS(J)	; IS THIS A HIGH SEGMENT?
	TLNN	TAC,JSEG
	JRST	DIDLE6
	PUSH	P,J		;YES, RECALCULATE PROT-RELOC OF LOWER SEGMENT
	MOVE	J,JOB
	LDB	TAC,PSEGN
	CAME	TAC,(P)
	JRST	DIDLE5
	PUSHJ	P,GETPR
	DATAO	APR,TAC
DIDLE5:	POP	P,J
	JRST	DIDLE3

DIDLE6:	CAME	J,JOB(PID)	;IS THIS CURRENT JOB?
	SKIPA	TAC,JOBPC(JDAT)	;NO, GET PC IN JOB DATA AREA
	MOVE	TAC,USRPC(PID)	;YES, PC IN PROTECTED SYSTEM AREA
	TLNE	TAC,USRMOD	;IS JOB IN USER MODE?
	JRST	DIDLE1		;YES, DO NOT ALTER DUMP ACS
				;BECAUSE THEY ARE THE USERS
	HRRZ	TAC,JOBDAC+P(JDAT)
	CAMLE	TAC,SYSSIZ	; IS THIS PDL IN USER'S AREA?
	CAML	TAC,MEMSIZ
	JRST	.+2		; NO
	ADDM	LOC,JOBDAC+P(JDAT)
				; YES, RELOCATE PDL WITH JOB
	ADDM	LOC,JOBDPG(JDAT)	;AND ALTER PROG BY DIST. MOVED
DIDLE1:	HLRZM	PROG,JOBREL(JDAT)	;ALWAYS SET JOB DATA AREA W/PROTECTION
DIDLE2:	CAME	J,JOB(PID)	;IS THIS CURRENT JOB?
	JRST	DIDLE3		;NO, DO NOT ALTER STATE OF MONITOR
	HRRZI	TAC,(P)		; SEE IF THIS PDL IS IN USER'S AREA
	CAMLE	TAC,SYSSIZ	; IS IT ABOVE TOP OF SYSTEM
	CAML	TAC,MEMSIZ		; AND BELOW FREE STORAGE AREA?
	JRST	.+2		; NO
	ADDM	LOC,P		; YES, RELOCATE PDL
	MOVEM	PROG,JOBADR(PID)	;SET NEW JOB ADR. FOR CURRENT JOB
IFN FTSTAT,<
	CAME PROG,JBTADR(J)
	PUSHJ P,CSTAT
>
	MOVEM	PROG,JBTADR(J)
	HLRZM	PROG,USRREL(PID)	;SET NEW PROTECTION FOR CURRETN JOB
	PUSHJ	P,GETPR		; GET JOB'S PROT-RELOC IN TAC
	DATAO	APR,TAC		; AND PUT THAT OUT
DIDLE3:
IFN FTSTAT,<
	CAME PROG,JBTADR(J)
	PUSHJ P,CSTAT
>
	MOVEM	PROG,JBTADR(J)	;STORE NEW CORE ASSIGNMENT
DIDLE4:	SETZB	TAC,HOLEF	;CLEAR HOLE FLAG
	PUSHJ	P,HOLSRC	;IS THERE A NON-ZERO HOLE?
	JRST	COROK		;NO
	ADDI	LOC,1(BLK)	;YES, FORM ADR. OF JOB JUST ABOVE HOLE
	CAMGE	LOC,MEMSIZ	;IS HOLE AT TOP OF MEMORY?
	MOVEM	LOC,HOLEF	;NO, FLAG WITH ADDRESS OF JOB ABOVE HOLE
COROK:
IFN FTSWAP,<
	MOVEI	TAC,-1		;FIND BIGGEST HOLE
	PUSHJ	P,HOLE		;ALWAYS GET ERROR RETURN
	ASH	AC2,-=10	;CONVERT TO 1K BLOCKS
	MOVEM	AC2,BIGHOLE
>
	SCHEDULE
	XSYNC	CORCSC
IFN FTCORBUG,<	PUSHJ	P,CORTCK >	;CHECK FOR CORTAB - JBTADR CONSISTENCY
	JRST	CPOPJ1		;SKIP RETURN(UNLESS ERROR)

;CSTAT, STAPUT, STAPTT		STATISTICS SERVICE
IFN FTSTAT,<
CSTAT:	MOVE TAC,JBTSTS(J)
	TLNE TAC,SWP		;IF SWAPPER,
	JRST CSTAT0		;THEN IS ONLY POSITION CHANGE
	MOVE TAC,PROG
	XOR TAC,JBTADR(J)
	TLNN TAC,776000		;CHANGE IN PROT?
	JRST CSTAT1
	HLRZ TAC,PROG
	LSH TAC,-4
	TRZ TAC,77
	MOVEI TAC,CSZSTA+100(TAC);ADD CODE AND MAKE INTO K
	PUSHJ P,STAPUT
CSTAT1:	JUMPE PROG,CPOPJ	;REPORT ONLY PROT IF CORE 0
	MOVE TAC,PROG
	XOR TAC,JBTADR(J)
	TRNN TAC,776000
	POPJ P,
CSTAT0:	HRRZ TAC,PROG
	LSH TAC,-4
	TRO TAC,CPSSTA
↑STAPUT:IORI TAC,(J)
STAPTT:	CONSO PI,77000	;ARE WE ON CHAN HIGHER THAN 7?
	JRST STAPOK	;NO, OK
	HRLI TAC,STACLK	;YES, SEND THIS DATA UP TO CH7
	CONO PI,PIOFF
	IDPB TAC,CLKQ
	CONO PI,PION
	POPJ P,

STACLK:	HRRZ TAC,DAT
STAPOK:	IDPB TAC,STATPTR
	MOVE TAC,STATPTR
	CAME TAC,[POINT 18,STATS+STATLEN-1,35]
	POPJ P,
	MOVE TAC,[POINT 18,STATS]
	MOVEM TAC,STATPTR
	AOS STATNUM
	POPJ P,

↑GLUSTT:PUSH P,TAC
	MOVE TAC,JBTGLU(J)
	ANDI TAC,77
	LSH TAC,6
	TRO TAC,GLUSTA
	PUSHJ P,STAPUT
	POP P,TAC
	POPJ P,

↑NAMSTT:PUSH P,TAC
	MOVEI TAC,NAMSTA(J)
;I HOPE WE DON'T GET INTERRUPTED BY SOMEONE ELSE STORING IN STATUS TABLE
	PUSHJ P,STAPTT
	HLRZ TAC,JOBNAM(J)
	PUSHJ P,STAPTT
	HRRZ TAC,JOBNAM(J)
	PUSHJ P,STAPTT
	POP P,TAC
	POPJ P,

↑SEGSTT:PUSH P,TAC
	LDB TAC,PSEGN
	LSH TAC,6
	TRO TAC,SEGSTA
	PUSHJ P,STAPUT
	POP P,TAC
	POPJ P,
>;FTSTAT
SUBTTL	HOLSRC	
;ROUTINE TO FIND HOLE BIG ENOUGH FOR REQUEST
;CALL:	MOVE TAC,HIGHEST REL. ADR. ASKING FOR
;	PUSHJ P,HOLSRC
;	RETURN1	;NO HOLES BIG ENOUGH
;	RETURN2	;UCHN BYTE SET TO LAST BLOCK+1 IN HOLE
;		;BLK SET TO HIGHEST REL. LOC. IN THAT HOLE
;		;LOC SET TO ADDRESS OF FIRST BLOCK IN HOLE
;		;AC2=LARGEST HOLE SEEN
;USES TAC1

HOLSRC:
IFN FTSWAP,<
	CAML	TAC,CORMAX	; IS IT A REASONABLE SIZE REQUEST?
>
IFE FTSWAP,<
	CAML	TAC,MEMSIZ
>
	POPJ	P,		; NO, GIVE UP NOW
HOLE:	MOVE	UCHN,CORE2P	; BYTE POINTER TO FIRST BIT-1
	SETZ	AC2,		;LARGEST HOLE SIZE = 0
	MOVE	LOC,LOKTOP	;HOLE LOCATION = BOTTOM OF USER SPACE.
CORHOL:	TDZA	BLK,BLK		;START BLK AT 0 AND SKIP

CORHO0:	ADDI	BLK,2000	;INCREMENT HIGHEST REL LOC.
CORHO1:	CAMN	UCHN,CORLST	;BYTE POINTER TO 1ST NON-EXISTANT BLOCK
	POPJ	P,		;NO MORE CORE TO SEARCH
	ILDB	TAC1,UCHN	;GET NEXT CORE USE BIT
	ADDI	LOC,2000	;INCREMENT ADDRESS OF BLOCK
	JUMPE	TAC1,CORHO0	;IS THIS BLOCK IN USE?
	JUMPE	BLK,CORHO1	;YES, HAVE ANY FREE BLOCKS BEEN SEEN YET?
IFN FTSWAP,<
	CAMLE	BLK,AC2		;YES, BIGGEST SO FAR?
	MOVEM	BLK,AC2		;YES, SAVE IN T1.
>
	CAMG	BLK,TAC
				;YES, IS THIS HOLE EQUAL TO OR GREATER
				;THAN THE REQUEST?
	JRST	CORHOL		;NO, KEEP LOOKING FOR HOLES
	SUBI	LOC,2000(BLK)	;YES, SET LOC TO FIRST BLOCK IN HOLE
	SUBI	BLK,1		;SET BLK TO HIGHEST REL. LOC.	;JS
IFN FTSWAP,<
	CAMGE	TAC,SWAPLIMIT	;DOES HE WANT MORE THAN 76K?
>
	AOS	(P)		;NO. GIVE IT TO HIM.	;JS
	POPJ	P,		;RETURN			;JS
				;AND RETURN
;CORCHK AND CORTCK  -- CHECK CORTAL AGAINST CORTAB AND CHECK CORTAB AGAINST WORLD
IFN FTCORBUG,<
CORCHK:	PUSH	P,TAC		;MAKE SURE CORTAB AND CORTAL ARE CONSISTENT
	PUSH	P,AC2
	PUSH	P,AC1
	MOVE	AC1,CORE2P	;BYTE POINTER INTO CORE TABLE
	MOVEI	AC2,0		;COUNT OF FREE BLOCKS ABOVE LOKTOP
CORCH1:	ILDB	TAC,AC1		;GET CORE TABLE ENTRY
	JUMPN	TAC,CORCH9	;IF IN USE FORGET IT
	ADDI	AC2,1		;YES.  FREE BLOCK!
CORCH9:	CAME	AC1,CORLST	;OUT OF MEMORY RANGE YET?
	JRST	CORCH1		;NO. GO ON
	CAMN	AC2,CORTAL	;GET RIGHT ANSWER?
	JRST	CORCH8		;YES

	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/CORTAL = /
	MOVE	TAC,CORTAL
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/,ππππ SHOULD BE = /
	MOVE	TAC,AC2-17(P)
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/;     CALLER'S ADDRESS = /
	HRRZ	TAC,-24(P)
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/
GET A WIZARD!!  IF YOU CAN'T FIND ONE, TYPE POPJ 3,$X
/
	PUSHJ	P,DISFLU
	PUSHJ	P,DDTCALL
	POPACS
	MOVEM	AC2,CORTAL

CORCH8:	POP	P,AC1
	POP	P,AC2
	POP	P,TAC
	POPJ	P,

CORTCK:	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	PUSH P,LOC
	PUSH P,J
	PUSH P,TAC
	PUSH P,TAC1
	MOVSI AC1,JNA
	MOVE J,JOBNM1
CORCKL:	TDNE AC1,JBTSTS(J)
	SKIPN AC2,JBTADR(J)
	JRST CORCKN		;NO JOB OR ZERO JBTADR
	HRRZ LOC,AC2		;ADDRESS OF HIS FIRST BLOCK
	HLRZ AC2,AC2		;PROT
	ADDI AC2,1
	LSH AC2,-=10		;NUMBER OF 1K BLOCKS
	PUSHJ P,CORGBP		;SET UP TAC AS ILDB POINTER TO CORTAB
CORCK1:	ILDB AC3,TAC
	CAIE AC3,(J)
	JRST CORCKC		;CORTAB AND JBTADR DISAGREE
	SOJG AC2,CORCK1
CORCKN:	SOJG J,CORCKL

	MOVE LOC,SYSTOP
CORCK0:	PUSHJ P,CORGBP		;NOW LOOK AT ALL USER STG CORTAB ENTRIES
CORCK2:	ILDB J,TAC
	JUMPE J,CORCK3
	CAILE J,77
	JRST CORCK4		;SYS, NXM, OR FREE STG
	CAMLE J,JOBNM1
	JRST CORCKD		;JOB NUMBER OUT OF RANGE
	MOVE AC1,JBTADR(J)
	CAIE LOC,(AC1)
	JRST CORCKE		;NOT FIRST BLOCK OF THIS JOB!
	HLRZ AC2,AC1
	IORI AC2,1777
	ADDI LOC,1(AC2)
	JRST CORCK0

CORCK3:	ADDI LOC,2000
	CAME TAC,CORLST
	JRST CORCK2
CORCKZ:	POP P,TAC1
	POP P,TAC
	POP P,J
	POP P,LOC
	POP P,AC3
	POP P,AC2
	POP P,AC1
	JRST CORCHK		;NOW CHECK CORTAL

CORCK4:	CAIN J,101		;SKIP IF NOT SYS BLOCK
	JRST CORCKF
CORCK5:	CAIE J,105		;SKIP IF FS BLOCK
	JRST CORCK3
	CAMGE LOC,MEMSIZ
	JRST CORCKF		;NOT IN SYS AREA OR FS
	JRST CORCK3

CORCKC:	JSP TAC1,CORCKX
CORCKD:	JSP TAC1,CORCKX
CORCKE:	JSP TAC1,CORCKX
CORCKF:	JSP TAC1,CORCKX

CORCKX:	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /LOSSAGE AT CORCHK -- GET A WIZARD.  THE WINNING ENTRY IS /
	HRRZ TAC,TAC1-17(P)
	SUBI TAC,CORCKC+1
	PUSHJ P,DISOCT
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLU
	PUSHJ P,DDTCAL
	POPACS
	JRST CORCKZ
>;IFN FTCORBUG
SUBTTL	CORSTG		;ROUTINE TO SET AND CLEAR CORE USE TABLE
;CALL:	MOVE UCHN,<JOB NUMBER, OR OTHER CODE>	;TO SET TABLE
;	MOVEI UCHN,0	;TO CLEAR TABLE
;	MOVE BLK,HIGHEST REL. LOC. IN USER AREA
;	MOVE LOC,ADDRESS OF FIRST BLOCK TO SET OR CLEAR



↑CORSTG:			;THE EXTERNAL CALL IS FROM REMAP IN UUOCON
	PUSH	P,TAC		;SAVE HIGHEST LOC. BEING REQUESTED
	ASH	BLK,-12		;CONVERT TO NO. OF BLOCKS-1
	ADDI	BLK,1		;NO. OF BLOCKS
	JUMPE	UCHN,.+2	;UPDATE NO OF FREE BLOCKS
	MOVNI	BLK,(BLK)	;DECREASE IF SETTING BITS
	CAML	LOC,LOKTOP	;IF THIS IS A CALL IN LOCKED CORE, LOCK AND
				;UNLOCK ARE RESPONSIBLE FOR DIDDLING CORTAL - REG
	ADDM	BLK,CORTAL	;INCREASE IF CLEARING,DECREASE IF SETTING BITS
	PUSHJ	P,CORGBP	;MAKE A BYTE POINTER
	MOVM	BLK,BLK		;GET MAG. OF NO. OF BLOCKS INVOLVED
CORST1:	ILDB	TAC1,TAC	;GET OLD BIT.
	JUMPE	UCHN,CORST9	;LOOK FOR CONFLICTS
	JUMPN	TAC1,CORST2
	JRST	CORSTD
CORST9:	JUMPN	TAC1,CORSTD
CORST2:	PUSHACS			;LOSER.
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/CORTAB LOSES AT CORSTG. OLD CLAIM= /
	MOVE	TAC,TAC1-17(P)	;GET THE ARGUMENT
	PUSHJ	P,DISDCP	;TYPE DECIMAL WITH PERIOD
	PUSHJ	P,DISMES
	ASCIZ	/  NEW CLAIM = /
	MOVE	TAC,UCHN-17(P)	;GET NEW CLAIM
	PUSHJ	P,DISDCP	;TYPE DECIMAL W/PERIOD
	PUSHJ	P,DISCRLF
	POPACS
CORSTD:	DPB	UCHN,TAC	;STORE NEW CORE USE BITS.
	SOJG	BLK,CORST1
IFN FTCORBUG,<	PUSHJ	P,CORCHK  >	;MAKE SURE CORTAB AND CORTAL ARE RIGHT
	JRST	TPOPJ		;RESTORE TAC, AND POPJ


↑CORGBP:			;(ALSO CALLED FROM PARSER)
				;MAKE A BYTE POINTER TO CORTAB
	MOVE	TAC,LOC		;ADDRESS OF FIRST BLOCK
CORGB1:	MOVEI	TAC1,0		;ENTER HERE WITH TAC SET UP.
	LSHC	TAC,-14		;FORM BYTE POINTER TO BIT-1
	ROT	TAC1,2
	ADD	TAC,COREP(TAC1)	;FORM BYTE POINTER
	POPJ	P,
SUBTTL	CLRJOB
;ROUTINE TO CLEAR PART OF JOB DAT AREA(PART PROTECTED FROM USER IO)
;CALLED WHEN NEW CORE ASSIGNED AND AT SYSTEM RESTART(140)
;	MOVE J,JOB NO.
;CALL:	MOVE JDAT,ADR. OF JOB DATA AREA
;	PUSHJ	P,CLRJOB


↑CLRJB1:
	MOVE	UCHN,JBTSTS(J)	; CAN'T DO THIS IF NO JOB DATA AREA
	TLNE	UCHN,JSEG	; IS THIS AN UPPER SEGMENT
	POPJ	P,		; YES, JUST FORGET IT
	SETZM	JOBPRT(JDAT)	;FIRST LOC. PROTECTED FROM USER
	MOVSI	TAC,JOBPRT(JDAT)
	HRRI	TAC,JOBPR1(JDAT)
	BLT	TAC,JOBPFI(JDAT)
	SETZM	JOBENB(JDAT)	;ALSO CLEAR APR ENABLE WORD
	SETZM JOBINT(JDAT)	;AND MOORER RELOCATER
	MOVE	TAC,JBTSTS(J)
	TLNN	TAC,SWP!SHF	; FORGET THIS IF SWAPPING REQUEST
	HRRZS	UUOPC(J)	; AND UUO PC FLAGS
	POPJ	P,		;RETURN

↑CLRJOB:
	PUSHJ	P,CLRJB1	; CLEAR JOB DATA AREA
	JRST	ESTOP2		; GO SET JOB STATUS, SO CONT WILL
				;NOT WORK

↑CLRINI:
	PUSH	P,JOBDDT(JDAT)	; ON 200 RESTARTS, SAVE JOBDDT
	PUSHJ	P,CLRJB1
	POP	P,JOBDDT(JDAT)
	JRST	ESTOP2
SUBTTL	GETPR
; ROUTINE TO GET A JOB'S PROTECTION-RELOCATION

↑GETPR:
	PUSH	P,DAT		; SAVE SOME ACCUMULATORS
	PUSH	P,TAC1
	MOVE	TAC,JBTADR(J)	; START WITH THE MAIN PART
	ANDCM	TAC,[XWD 1777,1777]
	LDB	DAT,PSEGN
	JUMPE	DAT,GETPR4	; IF NO UPPER SEGMENT, WE ARE DONE
	MOVE	TAC1,JBTSTS(DAT)	; HE HAS AN UPPER, IS IT WRITE-PROTECTED?
	TLNE	TAC1,JWP
	TLO	TAC,1		; YES, SET WRITE-PROTECT BIT
	SKIPN	TAC1,JBTADR(DAT)
	JRST	GETPR1
GETPR5:	HLRZ	DAT,JBTADR(J)
	CAIGE	DAT,400000
	JRST	GETPR3
	SUBI	TAC1,(DAT)	; FUDGE RELOCATION BY RIGHT AMOUNT
	HRLZ	DAT,DAT
	ADD	TAC1,DAT	; AND PROTECTION
	JRST	GETPR2
GETPR3:	TRC	TAC1,400000
GETPR2:	TLO	TAC1,400000
	LSH	TAC1,-11
	AND	TAC1,[XWD 776,776]
	OR	TAC,TAC1	; MERGE TWO RELOCATIONS
GETPR1:	MOVEM	TAC,LASTPR(PID)	; SAVE THIS AS THE LAST PROT-RELOC ISSUED
	POP	P,TAC1
	POP	P,DAT
	POPJ	P,

GETPR4:	SKIPN	TAC1,JBTPR2(J)	;IS DOING PEEK-POKE STUFF?
	JRST	GETPR1		;NO
	TLNE	TAC1,1		;IS IT TO BE WRITE PROTECTED?
	TLO	TAC,1		;YES
	TRZN	TAC1,1		;IS IT TO BE RELATIVE TO HIS CORE IMAGE?
	JRST	GETPR5
	PUSH	P,TAC		;YES, CHECK TOP OF HIS CORE IMAGE
	HLRZ	TAC,TAC1	;PROTECTION HE IS REQUESTING
	IORI	TAC,1777	;MAKE IT HONEST
	HLRZ	DAT,JBTADR(J)	;HIS JOBS PROTECTION
	CAIG	DAT,(TAC1)	;IS RELOC BELOW LOWERS PROT?
	JRST	GETPR6
	IORI	DAT,1777	;JUST TO BE SAFE
	SUBI	DAT,(TAC1)	;HOW FAR FROM NEW RELOCATION TO TOP OF CORE IMAGE.
	CAML	DAT,TAC		;IS HE REQUESTING TO MUCH?
	MOVE	DAT,TAC		;NO, USE WHAT HE GAVE US
	POP	P,TAC		;GET BACK LOWERS PROT. RELOC.
	HRL	TAC1,DAT	;SET NEW PROT. FOR PR2
	ADDI	TAC1,(TAC)	;AND RELOCATE IT
	JRST	GETPR5		;AND NOW IT LOOKS LIKE AN UPPER
GETPR6:	POP	P,TAC
	TLZ	TAC,1
	JRST	GETPR1
SUBTTL	RELOCA
;THIS HERE IS A ROUTINE TO ADDRESS CHECK AND RELOCATE
;A USER ADDRESS. IT MAKES USE OF UPPER SEGMENTS AND
;THE PEEK-POKE FEATURE (JBTPR2).
;CALLING:
;	MOVE J,<NUMBER OF JOB IN QUESTION>
;	MOVE TAC1,<ADDRESS TO CHECK AND RELOCATE>
;	PUSHJ P,RELOCA
;	<ILLEGAL ADDRESS>
;	<LEGAL ADDRESS>
;UPON SUCCESS RETURN TAC1 CONTAINS THE ABSOLUTE ADDRESS
;THE SIGN BIT IS SET IF THIS ADDRESS IS WRITE PROTECTED
;FROM THE USER (THIS INCLUDES THE PROTECTED PART FROM 0-JOBPFI).
;AC1 IS NOW SET-UP FOR A CALL ON RELOCB.

↑↑RELOCA:
	TLZ TAC1,-1		;CLEAR CONFUSING BITS!
	CAIGE TAC1,JOBPFI	;BELOW PROTECTED PART?
	TLO TAC1,400000		;SET WRITE PROTECTED ACCESS
	PUSH P,TAC		;SAVE AN AC
	HLRZ TAC,JBTADR(J)	;GET PROT
	CAIGE TAC,(TAC1)	;IS IT OUTSIDE LOWER?
	JRST RELOC1		;YES, THIS IS HARDER
	MOVE AC1,JBTADR(J)	;SET-UP AC1 WITH PROT RELOC WE ARE USING
	ADDI TAC1,(AC1)		;DO RELOCATION THING
	JRST TPOPJ1		;PUT BACK TAC AND SKIP

RELOC1:	LDB AC1,PSEGN		;CHECK FOR UPPER SEGMENT
	JUMPE AC1,RELOC2	;NONE, CHECK PEEK-POKE
	MOVSI TAC,JWP		;CHECK WRITE PROTECT
	TDNE TAC,JBTSTS(AC1)
	TLO TAC1,400000		;WRITE PROTECTED
	MOVE AC1,JBTADR(AC1)	;GET PROT RELOC INTO AC1
	JRST RELOC3

RELOC2:	SKIPN AC1,JBTPR2(J)	;IS HE DOING PEEK-POKE
	JRST TPOPJ		;RESTORE TAC AND RETURN
	TLOE AC1,1		;IS HE WRITE PROTECTED(SET BIT FOR COMPARE)
	TLO TAC1,400000		;YES
	TRZN AC1,1		;IS THIS A RELATIVE MAPPING?
	JRST RELOC3		;NO, (WHEW)!
	PUSH P,DAT		;OH BOY, SAVE ANOTHER AC
	HLRZ TAC,AC1		;GET RELOC HE IS TRYING FOR
	IORI TAC,1777		;MAKE IT HONEST
	HLRZ DAT,JBTADR(J)	;GET PROT OF LOWER
	CAIG DAT,(AC1)		;IS THE RELATIVE RELOC HE WANTS TOO BIG?
	JRST RELOC4		;YES, LOSE
	SUBI DAT,(AC1)		;GET MAX PROT HE CAN HAVE
	CAML DAT,TAC		;IS HE ASKING FOR MORE THAN THAT?
	MOVE DAT,TAC		;NO, USE HIS
	ADD AC1,JBTADR(J)	;SET ABSOLUTE RELOCATION
	HRL AC1,DAT		;SET PROT.
	POP P,DAT		;GET BACK THE AC WE SAVED
RELOC3:	HLRZ TAC,JBTADR(J)	;NOW WE CHECK TO SEE
	CAIGE TAC,400000	;IF HIS LOWER IS BIGGER THAN 400000
	MOVEI TAC,400000	;IT ISN'T, USE 400000
	SUB TAC1,TAC		;ADJUST REFERENCE
	TLNE TAC1,377777	;UNDERFLOW?
	JRST TPOPJ		;YES, BETWEEN UPPER AND LOWER!
	HLRZ TAC,AC1		;GET PROT.
	CAIL TAC,(TAC1)		;TOO BIG?
	AOS -1(P)		;NO, SKIP
	JRST TPOPJ		;RESTORE TAC AND RETURN

RELOC4:	POP P,DAT
	JRST TPOPJ		;LOSE

;USE THIS ROUTINE AFTER CALLING RELOCA ONCE TO ASSURE
;THAT THE ADDRESS YOU ARE CHECKING IS IN THE SAME
;SEGMENT AS THE LAST ONE YOU CHECKED. DON'T CLOBBER
;AC1 BETWEEN CALLS ON RELOCA AND RELOCB
;CALLING:
;	MOVE J,<NUMBER OF JOB IN QUESTION>
;	MOVE TAC1,<ADDRESS YOU WISH CHECKED>
;	PUSHJ P,RELOCB
;	<ILLEGAL ADDRESS OR NOT IN SAME SEGMENT AS AC1>
;	<LEGAL ADDRESS AND IN RIGHT SEGMENT>

↑↑RELOCB:
	PUSH P,AC1		;SAVE PROT RELOC WE USED LAST!
	PUSHJ P,RELOCA		;DO THE RELOC THING
	JRST RELOC5
	POP P,(P)
	EXCH AC1,1(P)
	CAMN AC1,1(P)		;DID RELOCA USE PROT RELOC WE WANTED?
	AOS (P)			;YES, SUCCESS
	POPJ P,

RELOC5:	POP P,AC1
	POPJ P,			;LOSE
SUBTTL	LOCK AND UNLOCK UUOS.
↑UNLOKC:MOVEI	J,(DAT)			;CALLED FROM CLOCK RQ AT ESTOP4
↑UNLOCK:
	PUSH	P,TAC
	MOVEI	TAC,JLOCK
	TDNN	TAC,JBTSTS(J)		;IS JOB LOCKED IN AT ALL?
	JRST	TPOPJ			;NO. THIS IS EASY.
	PUSH	P,PROG
	ANDCAM	TAC,JBTSTS(J)		;UNLOCK HIM.
IFN FTSTAT,<
	MOVEI TAC,LOKSTA
	PUSHJ P,STAPUT
>;FTSTAT
	MOVE	PROG,JBTADR(J)		;GET THE ADDRESS OF THIS JOB.
	HLRZ	TAC,PROG
	IORI	TAC,1777		;DEPT REDUNDANCY DEPT.
	ADDI	TAC,1(PROG)		;COMPUTE ADDRESS ABOVE THIS JOB.
	CAME	TAC,LOKTOP		;SAME AS LOKTOP?
	JRST	UNLOK4

UNLOK0:	PUSH	P,TAC1
	MOVEI	PROG,(PROG)		;BOTTOM OF NEW UNLOCKED AREA.
UNLOK1:	MOVEI	TAC,-2000(PROG)		;LOOK 1K FURTHER DOWN.
	PUSHJ	P,CORGB1		;GET A BYTE POINTER
	ILDB	TAC1,TAC		;LOAD CORE CODE.
	JUMPE	TAC1,UNLOK2		;CORE IS FREE. (GIVE BACK TO CORTAL)
	MOVEI	TAC,JLOCK
	CAIGE	TAC1,101		;CORE IN SYSTEM?
	TDNE	TAC,JBTSTS(TAC1)	;NO. CORE BELONGS TO UNLOCKED USER?
	JRST	UNLOK3			;SYSTEM CORE OR LOCKED USER.
	JRST	.+2
UNLOK2:	AOS	CORTAL			;UNCLAIMED BLOCK: INCREMENT CORTAL
	SUBI	PROG,2000
	JRST	UNLOK1

UNLOK3:	MOVEI	TAC,(PROG)
	PUSHJ	P,CORGB1
	MOVEM	TAC,CORE2P		;SET FOR HOLSRC.
	MOVEM	PROG,LOKTOP
IFN FTCORBUG,<	PUSHJ	P,CORCHK  >	;MAKE SURE CORTAB AND CORTAL ARE CONSISTENT
	POP	P,TAC1			;RESTORE AC'S
UNLOK4:	POP	P,PROG
	JRST	TPOPJ

LOCK0:	JSP	TAC,UUOMES
	ASCIZ	/CAN'T LOCK WITH SEGMENT
/

↑LOCK:	LDB	TAC1,PSEGN
	JUMPN	TAC1,LOCK0
	SKIPE	LOCKNO
	CAMN	J,LOCKNO
	JRST	LOCK1
	MOVEI	TAC,JIFSEC/2		;CODE CAN'T BE REENTERED, SO
	PUSHJ	P,SLEEPT		;LET THIS GUY WAIT.
	JRST	LOCK
LOCK0A:	MOVEI	TAC,0
	PUSHJ	P,SLEEP
	JRST	LOCK

LOCK1:					
	PUSHJ	P,ANYACT		;WAIT UNTIL IO STOPS.
	JRST	LOCK0A
					;NOW WE DECIDE WHERE TO PUT THIS TURKEY.
	MOVEI	AC2,JLOCK
	TDNE	AC2,JBTSTS(J)		;ARE WE LOCKED ALREADY?
	PUSHJ	P,UNLOCK		;YES. UNLOCK FIRST. (SHUFFLES IF POSSIBLE)
LOCK2A:	MOVE	LOC,SYSTOP		;LOWEST POSSIBLE LOC OF HOLE.
	CAML	LOC,LOKTOP		;TOP OF LOCKED SPACE.
	JRST	LOCK2			;LOC CONTAINS ADDRESS.
	PUSHJ	P,CORGBP		;MAKE A BYTE POINTER
	MOVE	UCHN,TAC		;BYTE POINTER IN UCHN
	HLRZ	TAC,JBTADR(J)		;SIZE OF HOLE NEEDED.
LOCK1A:	TDZA	BLK,BLK			;SIZE OF THIS HOLE.
LOCK1B:	ADDI	BLK,2000		;INCREMENT SIZE OF THIS HOLE.
LOCK1C:	CAML	LOC,LOKTOP		;PASSED THE LOCKED PART?
	JRST	LOCK1D			;YES. SEE IF IT WAS IN A HOLE.
	ILDB	TAC1,UCHN		;PICKUP CORE USE BITS
	ADDI	LOC,2000
	JUMPE	TAC1,LOCK1B		;JUMP IF STILL IN HOLE.
	CAIGE	TAC1,101		;SKIP IF THIS IS NOT A JOB
	TDNE	AC2,JBTSTS(TAC1)	;SKIP IF JOB IS UNLOCKED
	JRST	.+2			;IN SYSTEM OR IN LOCKED JOB.
	JRST	LOCK1B			;UNLOCKED JOB IS A LOGICAL HOLE.
	JUMPE	BLK,LOCK1C		;NOT IN HOLE. JUMP IF THERE WAS NO HOLE.
	CAIG	BLK,(TAC)		;SKIP IF HOLE IS BIG ENOUGH.
	JRST	LOCK1A			;NOT BIG ENOUGH.
	SUBI	LOC,2000(BLK)		;COMPUTE FIRST LOCATION OF HOLE.
	JRST	LOCK2
LOCK1D:	SUBI	LOC,(BLK)		;DECREASE FOR HOLE AT TOP.
LOCK2:	HLL	LOC,JBTADR(J)		;LOC HAS REL. OF IDEAL HOLE.
	MOVEM	LOC,LOKPOS		;SAVE ADDRESS OF THE HOLE.
	CAMN	LOC,JBTADR(J)		;SAME AS WHERE WE ARE NOW?
	JRST	LOCK4			;WE'RE IN LUCK. (LOCK)
	PUSHJ	P,LOCK5			;SEE IF WE CAN SHUFFLE TO THE RIGHT PLACE.
	JRST	LOCK3			;NO. LET THE CLOCK SWAP JOBS OUT.
					;HERE WE HAVE TO MOVE OURSELVES IN.
	PSYNC	CORCSC
	MOVE	PROG,JBTADR(J)
	HLRZ	TAC,PROG
	HRRZ	LOC,PROG
	HLRZ	BLK,PROG
	MOVEI	UCHN,0
	PUSHJ	P,CORSTG		;FREE OLD CORE.
	HRRZ	LOC,LOKPOS
	PUSHJ	P,CORGT1		;MAKE IT SHUFFLE
	JFCL				;COULD SKIP.
LOCK4:
IFN FTSTAT,<
	MOVEI TAC,LOKSTA+100
	PUSHJ P,STAPUT
>;FTSTAT
	MOVEI	TAC,JLOCK
	IORM	TAC,JBTSTS(J)		;TELL THEM WE'RE LOCKED IN.
	MOVE	PROG,JBTADR(J)		;JOB IS NOW IN THE RIGHT PLACE.
	HLRZ	TAC,PROG		;GET PROT
	IORI	TAC,1777
	ADDI	TAC,1(PROG)		;FIRST ADDRESS ABOVE THIS JOB
	CAMG	TAC,LOKTOP		;IS THIS GREATER THAN OLD LOKTOP?
	JRST	LOCK99			;NO.  THEN THERE'S NOTHING SPECIAL.
	MOVEM	TAC,LOKTOP
;CORTAL SHOULD BE OK. JOB WAS MOVED TO CORE WHICH WASN'T LOCKED CORE AT THAT TIME.
	MOVE	LOC,LOKTOP
	PUSHJ	P,CORGBP
	MOVEM	TAC,CORE2P
LOCK99:	PUSHJ	P,SPWCNT		;CONTINUE HIS SPACEWARE JOB IF SUSPENDED
	SETZM	LOCKNO			;CLEAR THIS.
	MOVE	TAC,JBTADR(J)
	JRST	STOTAC

LOCK5:	HRRZ	LOC,LOKPOS		;GET BASE LOCATION
	HLRZ	AC3,LOKPOS		;AND THE PROTECTION.
	PUSHJ	P,CORGBP		;MAKE A BYTE POINTER IN TAC.
LOCK5A:	ILDB	TAC1,TAC		;GET CORE USE BITS
	CAIN	TAC1,(J)		;SAME AS OUR JOB
	JRST	CPOPJ1			;YES. THEN WE CAN MOVE IN.
	JUMPN	TAC1,CPOPJ		;SOME ONE IS THERE. WE HAVE TO WORK HARD.
	SUBI	AC3,2000
	JUMPG	AC3,LOCK5A		;LOOP.
	JRST	CPOPJ1			;WE'RE ALL FREE.


LOCK3:	MOVEM	J,LOCKNO		;TELL THE SWAPPER TO FOREGO SWAPIN.
	PUSHJ	P,LOCKPL		;PLANT CLKRQ FOR LOCK.
	MOVNI	TAC,IOWQ		;REQUE THIS JOB TO IOWQ
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,WSCHED		;WAIT FOR REACTIVATION
	CAME	J,LOCKNO		;AVOID ↑C CONTINUE HANGUP
	JRST	LOCK			;REENTER THE LOCK RESOURCE
	MOVE	LOC,LOKPOS
	JRST	LOCK2A			;SEE IF ALL GOOD THINGS HAVE HAPPENED.
	
LOCK3A:					;HERE AT CLOCK LEVEL.
	SKIPGE	FSCLKF			;FREE STORAGE DOING IT TOO?
	JRST	LOCKPL			;YES. WAIT FOR IT TOO.
	SKIPN	FINISH
	SKIPE	FORCE
	JRST	LOCKPL			;WAIT FOR SWAPPER TO BE IDLE.
	SKIPE	J,LOCKNO
	SKIPL	JBTSTS(J)
	JRST	LOCK3C			;FLUSH CLOCK RQ IF JOB NOT THERE.
	PUSHJ	P,LOCK5			;SEE IF THERE'S A HOLE YET.
	JRST	LOCK3B			;NOT YET.
	MOVNI	TAC,TQ
	MOVEM	TAC,JOBQUE(J)		;SET JOB TO RUN AGAIN
	JRST	REQUE			;REQUEUE AND DISMISS CLOCK LEVEL.

LOCK3B:	MOVEI	J,(TAC1)		;GET JOB NUMBER OF THE GUY WE'RE FORCING
	MOVE	TAC,JBTSTS(J)
	TLNE	TAC,SHF!SWP		;SKIP IF HE'S NOT IN MOTION ALREADY
	JRST	LOCKPL			;WE'LL HAVE TO WAIT FOR HIM TO STOP MOVING
	HLRZ	TAC,JBTADR(J)
	SKIPN	XJOB(J)			;IS HE ALREADY EXPANDING?
	PUSHJ	P,XPAND			;NO. LET'S GIVE HIM A SHOVE
LOCKPL:	MOVE	TAC,[LOCK3A,,1]		;PLANT A CLOCK REQUEST.
	CONO	PI,PIOFF
	IDPB	TAC,CLOCK
	CONO	PI,PION
	POPJ	P,

LOCK3C:	SETZM	LOCKNO
	POPJ	P,
SUBTTL	FREE STORAGE	;AND OTHER POLITICAL PRISONERS
; "AND WHO DESERVES THE CREDIT?  AND WHO DESERVES THE BLAME?
; NIKCOLI IVANOVITCH LOBACHEVSKY IS HIS NAME."

;		JAM - ORIGINAL FREE STORAGE SYSTEM
;		REG - REVISED SYSTEM MARCH 1972

;	ACCUMULATOR DEFINITIONS

SIZE←AC3		;INPUT PARAMETER TO FSGET
BLOCK←AC1		;BLOCK ADDRESS OF FS BLOCK (BLK)

PICMSK←←37		;MASK TO SELECT CHANNELS 3,4,5,6,7 IN CONO/I PI
PICHON←←2000		;BIT TO TURN ON SELECTED CHANNELS: CONO PI
PICHOF←←1000		;BIT TO TURN OFF SELECTED CHANNELS

;THE FREE STORAGE SYSTEM ASSUMES THAT CHANNELS 1 AND 2 NEVER REQUEST
;FREE STORAGE.
COMMENT $	INITIALIZE FREE STORAGE

MEMSIZ:			<LOWEST WORD OF FREE STORAGE AREA>
RMEMSIZ:		<LOWEST NON-EX ADDRESS IN ALL CORE>

FREE STORAGE LOOKS LIKE:

BLOCK IN USE:			BLOCK THAT IS FREE

	(LOW ADDRESS)

---------------			---------------
| RS   |  *---|→→→*		|  U   |  *---|→→→*
---------------   ↓		---------------   ↓
|             |   ↓		|             |   ↓
|             |   ↓		|             |   ↓
|             |   ↓		|             |   ↓
| DATA AREA   |   ↓		|             |   ↓
|             |	  ↓		---------------   ↓
|             |	  ↓		|   0  | BLINK|   ↓
---------------   ↓		---------------   ↓
|⊗ SIZE| RS   |←←←*		| SIZE | FLINK|←←←*
---------------			---------------

	(HIGH ADDRESS)


WHERE SIZE IS THE TOTAL SIZE OF THE BLOCK IN WORDS.
THE DATA AREA HAS SIZE-2 WORDS. ⊗SIZE IS SIZE + 400000.
RS IS RESERVED FOR FUTURE USE BY THE FS SYSTEM.
U IS UNDEFINED.
FLINK IS A FORWARD LINK IN A CHAIN OF FREE BLOCKS.
LINKS WILL EVENTUALLY POINT BACK TO THE BASE OF THE CHAIN!
BLINK IS A BACKWARD LINK IN A CHAIN OF FREE BLOCKS.

THERE ARE "NFSB" CHAINS OF FREE BLOCK WITH FORWARD AND
BACKWARD POINTERS IN FSAVB TABLE.


ALL FREE STORAGE BLOCKS ARE SOME MULTIPLE OF THE "TRIVIAL" SIZE.
ALL REQUESTS ARE ROUNDED UP TO SUCH A MULTIPLE.
CHAINS OF FREE BLOCKS OF EACH SIZE ARE KEPT WITH BASE POINTERS IN FSAVB.
$

↑FSINIT:
	SETZM	FSBEG
	MOVE	TAC,[XWD FSBEG,FSBEG+1]
	BLT	TAC,FSEND
	SYNINI	CORCSC			;INITIALIZE INTERLOCK CELLS
	SYNINI	FSCSC
	MOVE	LOC,MEMSIZ		;GET THE SIZE OF USER SPACE
	CAMN	LOC,RMEMSIZ		;SKIP IF WE HAVE SOME STORAGE CLAIMED
	JRST	FSINI2			;NO. WE HAVE NOTHING TO GIVE BACK
	PUSHJ	P,CORGBP		;GET A POINTER TO OUR LOWEST BLOCK
	MOVEM	TAC,CORLST		;SAVE AS POINTER TO THE END OF ALL CORE
	MOVEI	AC2,2000
FSINI1:	IDPB	AC2,CORLST		;CLEAR BLOCKS IN CORTAB
	ADDI	LOC,2000		;ADD TO BOTTOM OF FS.
	AOS	CORTAL			;INCREMENT CORE COUNT
IFN FTSWAP,<
	ADDM	AC2,CORMAX >		;INCREASE USER CORE
	CAME	LOC,RMEMSIZ		;AT THE TOP YET?
	JRST	FSINI1			;NO LOOP

FSINI2:	MOVEM	LOC,MEMSIZ		;SAVE RMEMSIZ AS MEMSIZ
	MOVNI	UCHN,FSNINIT		;NUMBER OF BLOCKS TO CLAIM NOW
	ADDM	UCHN,CORTAL		;DECREASE USER'S SPACE
	MOVNI	LOC,2000*FSNINIT	;GET - NUMBER OF WORDS CLAIMED
IFN FTSWAP,<
	ADDM	LOC,CORMAX>		;DECREASE USER SPACE
	ADDB	LOC,MEMSIZ		;SET LOWER BOUND OF FS
	PUSHJ	P,CORGBP	
	MOVEI	UCHN,105
	IDPB	UCHN,TAC		;CLAIM BLOCK FROM CORTAB
	MOVE	AC2,TAC	
FSINI3:	CAMN	AC2,CORLST		;ARE WE AT THE END YET?
	JRST	FSINI4	
	IDPB	UCHN,AC2
	JRST	FSINI3

FSINI4:	MOVEM	TAC,CORLST		;SET UP NEW TOP OF CORE POINTER
	IBP	CORLST			;MAKE POINT TO 2ND UNAVAIL BLK.
	MOVE	UCHN,[XWD 2000*FSNINIT,FSAVB+2*NFSB-1]	;SIZE,,FLINK
	MOVE	AC2,RMEMSIZ		;FIRST NONEX ADDRESS
	SUBI	AC2,1			;ADDRESS OF HI END OF FIRST BLOCK
	MOVEM	UCHN,(AC2)		;SET SIZE,,FLINK IN TOP OF BLOCK
	HRRZM	UCHN,-1(AC2)		;SET BLINK
	MOVEM	AC2,(LOC)		;ADDRESS OF TOP GOES INTO BOTTOM
	SETZ	UCHN,
FSINI5:	MOVEI	AC3,FSAVB+1(UCHN)	;GET ADDRESS OF SOMEONE
	MOVEM	AC3,FSAVB(UCHN)		;SAVE BACK POINTER
	MOVEM	AC3,FSAVB+1(UCHN)	;SAVE FORWARD POINTER
	ADDI	UCHN,2			;INCREMENT BY 2
	CAIGE	UCHN,2*NFSB-2		;ARE WE AT THE END YET?
	JRST	FSINI5			;NO KEEP LOOPING
	HRRZM	AC2,FSAVB+2*NFSB-2	;SAVE BACK POINTER TO ONLY BLOCK
	HRRZM	AC2,FSAVB+2*NFSB-1	;SAVE FORWARD POINTER TO ONLY BLOCK
	MOVEI	AC2,JIFSEC*=60		;NUMBER OF TICKS BETWEEN CHECKER CHECK
	MOVEM	AC2,FSCKCT		;SAVE
	MOVEI	UCHN,FSLIST		;GET THE START OF OUR Q SPACE
	MOVEM	UCHN,FSIPTR		;SAVE AS Q INPUT POINTER
	MOVEM	UCHN,FSOPTR		;AND Q OUTPUT POINTER
	JRST	SFSINI		;INITIALIZE FREE STORAGE SPARE LIST USERS


FSACSV:	EXCH	DAT,(P)		;PUSHJ P,FSACSV TO SAVE AC'S.
	PUSH	P,TAC
	PUSH	P,TAC1
	PUSH	P,AC2
	PUSH	P,SIZE
	PUSH	P,TEM
	JRST	(DAT)


FSACRS:	POP	P,TEM		;JSP DAT,FSACRS TO RESTORE AC'S
	POP	P,SIZE
	POP	P,AC2
	POP	P,TAC1
	POP	P,TAC
	EXCH	DAT,(P)
	POPJ	P,
COMMENT $	FSGET:	GET FREE STORAGE AT ANY LEVEL.
CALLING:
	MOVEI	SIZE,<BLOCK SIZE>
	PUSHJ	P,FSGET
	<NONE AVAILABLE>
	<OK - ADDRESS OF BLOCK IS IN BLOCK (AC1)>

	UUO LEVEL ALWAYS GETS SUCCESS EXIT

$

FSSBYP:	POINT	17,(BLOCK),17		;POINTER TO SIZE FIELD OF BLOCK
FSSBP1:	POINT	17,(AC2),17		;POINTER TO SIZE WHEN BLOCK TOP IN AC2

↑FSGET:	TDZA	BLOCK,BLOCK		;NORMAL CALL.
↑FSGETU:MOVNI	BLOCK,1			;CALL AT UUO LEVEL AND NEVER WAIT.
	CONSZ	PI,60000		;ARE WE BELOW CHANNEL 2?
	JRST	FSGLUZ			;NO. SOMEONE SHOULD KNOW BETTER.
	CONSO	PI,77400		;ANY PI'S IN PROGRESS?
	SKIPE	INTACT(PID)		;WE'RE AT UUO LEVEL? USER INTERRUPT?
	JRST	.+2			;EITHER PI IN PROGRESS OR USER I-LEVEL
	MOVEM	BLOCK,FSGTUF		;NORMAL UUO LEVEL. SET SPECIAL FLAG.
	AOS	NFSGETS			;COUNT FS GETS
	PUSHJ	P,FSACSV		;SAVE  DAT,TEM,SIZE,AC2,TAC,TAC1
	PSYNC	FSCSC			;SYNCHRONIZE WITH OTHER PROCESSOR
	MOVEI	SIZE,2(SIZE)		;GET SIZE OF REQUEST +2
	TRZE	SIZE,TRIVIAL-1		;IS THIS EXACT MULTIPLE OF TRIVIAL?
	ADDI	SIZE,TRIVIAL		;NO. ADD TRIVIAL
FSGETT:	MOVEI	TAC,(SIZE)		;GET SIZE INTO TAC
	LSH	TAC,1-TSHF		;SHIFT TO MAKE INDEX
	SUBI	TAC,2			;NORMALIZE TO ZERO INDEX
	CAILE	TAC,2*NFSB-2		;ARE WE AT THE END OF THE TABLE?
	JRST	FSGTBX			;YES. LOOK FOR A BIG BLOCK
	LSH	TAC,-1
	AOS	FSRPQ(TAC)
	LSH	TAC,1
FSGT0:	MOVE	TAC1,TAC		;INDEX TO FIRST BASE INSPECTED
	MOVE	BLOCK,MEMSIZ		;FIND BLOCK WITH A HIGHER ADDRESS
FSGT1:	CAMGE	BLOCK,FSAVB+1(TAC1)	;ADDRESS BIGGER THAN OUR BEST?
	MOVE	BLOCK,FSAVB+1(TAC1)	;YES. REMEBER BEST ADDRESS
	ADDI	TAC1,2			;GO ON TO NEXT LIST BASE
	AOS	NFSLP1			;COUNT A LOOP OF TYPE1
	CAIGE	TAC1,2*NFSB		;STILL IN TABLE?
	JRST	FSGT1			;YES. LOOP
	CAMG	BLOCK,MEMSIZ		;FOUND ANY?
	JRST	FSGTW			;NO WE'LL HAVE TO WAIT...
	PUSHJ	P,FSGCL			;CALL ROUTINE TO CLAIM AND DELINK
	JRST	FSGT0			;THE CLAIM FAILED. LOOK AGAIN.
	JRST	FSGTC			;CLAIM OK

FSGTBX:	AOS	FSRPQ+NFSB-1
FSGTB0:	HRRZ	BLOCK,FSAVB+2*NFSB-1	;GET THE FIRST LINK
FSGTB1:	AOS	NFSLP2			;COUNT A LOOP OF TYPE 2
	CAIG	BLOCK,FSAVB+2*NFSB-1	;FLINK > ADDRESS OF LIST BASE?
	JRST	FSGTW			;NO. WE'LL HAVE TO WAIT.
	SKIPG	AC2,(BLOCK)		;SKIP IF THIS BLOCK IS NOT CLAIMED
	JRST	FSGTB0			;HIGHER CHANNEL MUST HAVE GOT THIS ONE!
	HLRZ	TAC1,AC2		;GET THE SIZE FIELD
	CAIL	TAC1,(SIZE)		;SIZE BIG ENOUGH?
	JRST	FSGTB2			;YES. TRY TO CLAIM IT
	MOVEI	BLOCK,(AC2)		;LOAD NEXT FLINK
	JRST	FSGTB1			;LOOP

FSGTB2:	PUSHJ	P,FSGCL			;CLAIM THE BLOCK AND DELINK IT
	JRST	FSGTB0			;CLAIM FAILED.
	JRST	FSGTC			;GOT IT

FSGCL:	CONI	PI,AC2			;GET PI CHANNEL STATUS
	ANDI	AC2,PICMSK		;ONLY CHANNELS 3,4,5,6,7
	CONO	PI,PICHOF(AC2)		;TURN OFF CHANNELS 3-7
	SKIPG	TAC1,(BLOCK)		;FLINK INTO TAC1
	JRST	FSGCLX			;BLOCK IS ALREADY CLAIMED!
	HRRZ	TAC,-1(BLOCK)		;BLINK INTO TAC
	HRRM	TAC1,(TAC)		;GO BACK AND RESET FLINK
	HRRM	TAC,-1(TAC1)		;GO FORWARD AND RESET BLINK
	CONO	PI,PICHON(AC2)		;RESTORE CHANNELS THAT WERE ON
	MOVSI	AC2,400000
	IORM	AC2,(BLOCK)		;TURN ON THE SIGN BIT TO CLAIM BLOCK
	JRST	CPOPJ1			;GIVE THE SKIP RETURN

FSGCLX:	CONO	PI,PICHON(AC2)		;RESTORE PI.
	POPJ	P,

FSGTC:	LDB	AC2,FSSBYP		;GET THE SIZE OF THIS BLOCK
	SETZ	TEM,			;INITIALIZE EXCESS SIZE
	CAIGE	AC2,TRIVIAL(SIZE)	;IS BLOCK TOO BIG?
	JRST	FSGTC1			;NO
	MOVE	TEM,AC2			;GET THE SIZE
	SUBI	TEM,(SIZE)		;GET EXCESS SIZE
	MOVEI	AC2,(SIZE)		;GET THE SIZE TO USE
	DPB	AC2,FSSBYP		;SET SIZE
FSGTC1:	HLLZS	(BLOCK)			;CLEAR RIGHT SIDE OF TOP MARK
	SUBM	BLOCK,AC2		;AC2 GETS ADDRESS BELOW LOWEST
	HRROM	BLOCK,1(AC2)		;SET UP POINTER IN THE LOW ADDRESS
	JUMPE	TEM,FSGTCR		;ALL DONE IF NO SPLIT
	HRLZM	TEM,(AC2)		;SET SIZE IN SPLIT BLOCK
	SUBM	AC2,TEM			;GET LOWEST ADDRESS OF THIS, -1
	HRRZM	AC2,1(TEM)		;SET UP FORWARD LINK
	HLRZ	TEM,(AC2)		;GET THE SIZE BACK
	CAIGE	TEM,NFSB*TRIVIAL	;IS BLOCK VERY BIG?
	JRST	FSGTC4			;NO. RETURN THE SPLIT BY THE CLOCK
	JRST	FSGTC5
FSGTC2:	CONO	PI,PICHON(TEM)		;TURN CHANNELS ON AGAIN
FSGTC5:	SKIPG	(TAC1)			;LOOK AHEAD
	JRST	FSGTC6			;LOSE
	MOVE	DAT,-1(TAC1)		;GET BLINK AHEAD
	HRRM	DAT,-1(AC2)		;SET BLINK HERE
	HRRM	TAC1,(AC2)		;SET FLINK HERE
	CONI	PI,TEM			;GET PI STATUS
	ANDI	TEM,PICMSK
	CONO	PI,PICHOF(TEM)		;TURN OFF CHANNELS
	SKIPLE	(TAC1)			;GRABBED FROM UNDER US?
	CAME	DAT,-1(TAC1)		;BE SURE
	JRST	FSGTC2			;TRY AGAIN
	HRRM	AC2,-1(TAC1)		;SET BLINK AHEAD
	HRRM	AC2,(DAT)		;SET FLINK BEHIND
	CONO	PI,PICHON(TEM)		;TURN ON PI'S AGAIN
	JRST	FSGTCR			;RETURN FREE STORAGE.

FSGTC3:	CONO	PI,PICHON(TEM)
FSGTC6:	SKIPG	DAT,(TAC)
	JRST	FSGTC4			;LINK'S HAVE MOVED
	HRRM	DAT,(AC2)		;SET FLINK HERE
	HRRM	TAC,-1(AC2)		;SET BLINK HERE
	CONI	PI,TEM
	ANDI	TEM,PICMSK
	CONO	PI,PICHOF(TEM)
	CAME	DAT,(TAC)		;THESE GUYS STILL THE SAME?
	JRST	FSGTC3			;LINKS HAVE MOVED. TRY AGAIN
	HRRM	AC2,-1(DAT)		;SET BLINK AHEAD
	HRRM	AC2,(TAC)		;SET FLINK BEHIND
	CONO	PI,PICHON(TEM)
	JRST	FSGTCR			;RETURN BLOCK

FSGTC4:	MOVSI	TAC,400000
	IORM	TAC,(AC2)
	LDB	TAC,FSSBP1
	SUBM	AC2,TAC
	HRROM	AC2,1(TAC)
	PUSH	P,BLOCK
	MOVEI	BLOCK,2(TAC)
	PUSHJ	P,FSQUIK		;ADD BLOCK TO FSRTL.
	POP	P,BLOCK
FSGTCR:	LDB	TAC,FSSBYP		;GET THE SIZE
	ADDM	TAC,FSBUSY		;ADD TO CLAIMED AMOUNT.
	SUBI	BLOCK,-2(TAC)		;COMPUTE LOWEST USABLE ADDRESS
	CONSO	PI,77000		;SKIP IF AT HI PI CHANNEL
	SKIPN	FSRTL			;LOW CHANNEL. SKIP IF ANY COMING BACK
	JRST	FSGRT1			;NOTHING TO DO OR MUST RETURN QUICK
	PUSH	P,BLOCK
	PUSHJ	P,FSCKX			;GIVE IT BACK TO THE INDIANS
	POP	P,BLOCK
FSGRT1:	XSYNC	FSCSC
	JSP	DAT,FSACRS
	PUSH	P,[FSGET]		;IN CASE OF TROUBLE TRY AGAIN
	PUSHJ	P,FSECHK
	POP	P,(P)			;FLUSH STACK
	JRST	CPOPJ1			;AND GIVE SKIP RETURN

;HERE IF WE COULDN'T FIND ANY FREE STORAGE.
FSGTW:	PUSHJ	P,FSGETK		;WE NEED ANOTHER K, GET IT
	JRST	FSGTW5			;CAN'T GET ANOTHER K
	PUSHJ	P,FSWAKE		;WAKE SOMEONE WHO WAITS
	JRST	FSGETT			;FSGET RETRY THIS ONE

FSGTW5:	CONSO	PI,77400		;ARE WE AT I-LEVEL?
	SKIPE	FSGTUF			;NOT I-LEVEL, WANT TO RETURN QUICK?
	JRST	FSGFAI			;GIVE THE NON-SKIP RETURN
	SKIPE	INTACT(PID)		;IF YOU'RE AT USER I-LEVEL YOU'LL
	JRST	WSCHED			;BE KICKED OUT BY WSCHED....
	AOS	NFSWAITS		;COUNT A WAIT
	PUSH	P,J			;SAVE J ON THE STACK
	MOVE	J,JOB(PID)		;GET THE JOB NUMBER
	HRL	J,SIZE			;GET THE SIZE OF REQUEST
	MOVEM	J,@FSIPTR		;SAVE IN OUR QUEUE OF JOBS
	AOS	TAC,FSIPTR		;INCREMENT THE POINTER
	CAIL	TAC,FSLIST+JOBN
	MOVEI	TAC,FSLIST
	MOVEM	TAC,FSIPTR
	AOS	FSCNT
	XSYNC	FSCSC
	PUSHJ	P,WSCHED		;CALL CH7 TO RESCHEDULE JOB(PID)
	SETZM	FSGTUF			;ZERO THIS CELL SO IF WE FAIL AGAIN, WE WAIT
	PSYNC	FSCSC			;HERE EVENTUALLY AFTER FSWAKE
	PUSHJ	P,FSWAKE		;WAKE SOMEONE ELSE
	POP	P,J			;RESTORE J, FINALLY.
	JRST	FSGETT			;PLAY IT AGAIN, SAM.

FSGFAI:	XSYNC	FSCSC
	JSP	DAT,FSACRS		;RESTORE AC'S
	AOS	NFSGFA			;COUNT A FAILURE
	POPJ	P,			;CRY

FSGLUZ:	HRRZ	BLOCK,(P)		;GET RETURN ADDRESS
	PUSHACS
	PUSHJ	P,DISERR
	[ASCIZ/ FSGET CALLED ILLEGALLY FROM PI CHANNEL 1 OR 2
RETURN ADDRESS = /]
	DISARG ( LOC,<BLOCK-20(P)> )
	[ASCIZ/
/]
	-1
	POPACS
	JUMPE	PID,CPOPJ
	HALT	CPOPJ			;STOP THE PDP-6
;SWIPE 1K FROM AVAILABLE USER SPACE.
;THIS CAN BE DONE ONLY AT CLOCK OR UUO LEVEL.
;IT SETS THE FOLLOWING GLOBAL VALUES:
; CORLST		BYTE POINTER SET TO THE SECOND UNAVAILABLE 1K BLOCK.
; CORTAL		NUMBER OF 1K BLOCKS AVAILABLE TO USERS
; CORMAX		MAXIMUM NUMBER OF WORDS A JOB MAY HAVE.
; MEMSIZ		LOWEST LOCATION USED BY FREE STORAGE

FSGETK:	JUMPN	PID,CPOPJ		;THE PDP-6 CAN'T DO THIS
	CONSZ	PI,77000		;ARE WE AT A HIGH CHANNEL?
	POPJ	P,			;YES. WE CAN'T DO THIS!
	PUSH	P,LOC
	MOVE	LOC,MEMSIZ		;GET THE CURRENT MEMORY SIZE
	SUBI	LOC,2000		;GET LOWEST ADDRESS WE WANT
	PUSHJ	P,CORGBP		;MAKE A BYTE POINTER TO CORTAB
	POP	P,LOC
	ILDB	TAC1,TAC		;PICK UP MARK BIT FOR THIS BLOCK
	JUMPN	TAC1,FSSWAP		;JUMP IF CLAIMED AND FORCE USER OUT
	MOVEI	TAC1,105		;CLAIM THIS BLOCK!
	DPB	TAC1,TAC		;STUFF OUR CLAIM BIT IN
	IBP	TAC
	MOVEM	TAC,CORLST		;SECOND UNAVAILABLE BYTE IN CORTAB
	MOVNI	TAC,2000		;UPDATE 4 GLOBAL CELLS
IFN FTSWAP,<
	ADDM	TAC,CORMAX >		;MAXIMUM CORE SIZE IN WORDS
	ADDM	TAC,MEMSIZ		;BOTTOM OF FREE STORAGE
	SOS	CORTAL			;NUMBER OF 1K BLOCKS FOR USERS
IFN FTCORBUG,<	PUSHJ	P,CORCHK >	;CHECK VALIDITY OF CORE TABLES.
	PUSH	P,LOC
	PUSH	P,UCHN
	PSYNC	CORCSC
	PUSHJ	P,DIDLE4		;SET UP HOLEF, BIGHOL, AND SKIP RETURN
	JFCL				;ALWAYS SKIP RETURNS
	POP	P,UCHN
	POP	P,LOC
	MOVE	BLOCK,MEMSIZ		;GET THE LOW BOUND OF FS.
	ADDI	BLOCK,1777		;POINTER TO HIGH SIDE OF THIS 1K
	MOVSI	TAC,402000		;SET UP SIZE AND USE BIT
	MOVEM	TAC,(BLOCK)		;STUFF IN BLOCK HEADER
	HRROM	BLOCK,@MEMSIZ		;STUFF IN LOWER MARKER
	MOVE	BLOCK,MEMSIZ
	ADDI	BLOCK,1
	PUSH	P,SIZE
	PUSHJ	P,FSGIVX		;GIVE BACK A 1K BLOCK (MERGES)
	POP	P,SIZE
	SETZM	FSGVKF			;FLUSH WARNING ABOUT BOTTOM K.
	JRST	CPOPJ1			;GIVE A SKIP RETURN FROM FSGETK

;ROUTINE TO FORCE THE JOB AT TOP OF CORE OUT.

FSSWAP:
IFN FTSWAP,<
	SKIPN	FORCE			;CAN WE DIDDLE THE SWAPPER NOW?
	SKIPE	FINISH			;?
	JRST	FSSWP3			;NO CAN'T BOTHER HIM JUST YET.
	PUSH	P,LOC			;SAVE LOC FOR A WHILE
	MOVE	LOC,MEMSIZ		;REMOVE 4 INSTRUCTIONS STARTING HERE.
	SUBI	LOC,2000			;D.RED.D.
	PUSHJ	P,CORGBP
	POP	P,LOC
	PUSH	P,J			;DON'T CLOBBER J
	ILDB	J,TAC			;GET JOB NUMBER OF THE GUY TO FORCE
	MOVE	TAC,JBTSTS(J)
	TLNE	TAC,SWP!SHF		;IS HE IN MOTION?
	JRST	FSWP3A			;CAN'T DO HIM NOW.
	HLRZ	TAC,JBTADR(J)
	SKIPN	XJOB(J)
	PUSHJ	P,XPAND			;MAKE HIM GET SHOVED OUT
FSWP3A:	POP	P,J			;RESTORE J
>
FSSWP3:	SETOM	FSCLKF			;TELL FSCLK TO THINK ABOUT GOBBLING
	SETOM	FSNCLK			;TELL CLKSER TO RUN FSCLK
	POPJ	P,			;AND RETURN


; THIS ROUTINE REQUEUES A JOB WHEN CORE IS AVAILABLE FOR HIM.

FSWAKE:	CONO	PI,PIOFF
	SKIPLE	FSCNT			;ANYONE THERE?
	JRST	FSWAK1			;YES
	SETZM	FSCNT
	CONO	PI,PION
	POPJ	P,			;NO WORK FOR NO ONE

FSWAK1:	SOS	FSCNT			;DECREASE NUMBER OF WAITERS
	CONO	PI,PION
	HRRZ	J,@FSOPTR		;GET JOB NUMBER TO REQUEUE
	AOS	TAC,FSOPTR
	CAIL	TAC,FSLIST+JOBN
	MOVEI	TAC,FSLIST
	MOVEM	TAC,FSOPTR
	SKIPL	JBTSTS(J)		;IS THIS GUY STILL RUNABLE?
	JRST	FSWAKE			;NO. TRY ANOTHER ONE.
	MOVNI	TAC,RUNQ
	MOVEM	TAC,JOBQUE(J)		;SET QUEUE FOR THIS JOB
	JRST	REQUE			;REQUEUE THIS JOB
COMMENT $FSCLK:	CLOCK LEVEL (CHANNEL 7) ROUTINES TO KEEP FREE STORAGE HAPPY!
CALLED FROM CLKSER, NEAR CALL ON DPYCLK
$

↑FSCLK:	SETZM	FSNCLK			;WE HAVE GOTTEN SERVICE. SHUT OFF FLAG.
	PSYNC	FSCSC			;SYNCRONIZE
	PUSHJ	P,FSCKX			;RETURN CONTENTS OF FSRTL.
FSCKY:	SKIPN	FSCLKF			;ARE WE WAITING FOR THE SWAPPER?
	JRST	FSCLK1			;NO. SKIP THIS MESS
	SETZM	FSCLKF
	PUSHJ	P,FSGETK		;LOOK FOR THE 1K WE WANTED.
	JRST	FSCKZ			;THERE WASN'T ANY THERE FOR US
	PUSHJ	P,FSWAKE		;ATTEMPT TO WAKE A WAITER.
	JRST	FSCKZ			;AVOID ATTEMP TO GIVE BACK 1K

FSCLK1:	SKIPN	FSGVKF			;MAYBE THERE'S A 1K BLOCK TO GIVE BACK?
	JRST	FSCKZ			;NOPE.
	SETZM	FSGVKF
	HRRZ	BLOCK,@MEMSIZ		;POINTER TO TOP OF BOTTOM BLOCK
	LDB	SIZE,FSSBYP		;GET THE SIZE FIELD
	CAIGE	SIZE,2000		;SKIP IF BIG ENOUGH
	JRST	FSCKZ
	PUSHJ	P,FSGCL			;ATTEMPT TO CLAIM THIS BLOCK
	JRST	FSCKZ			;LOSE
	LDB	SIZE,FSSBYP		;GET THE SIZE
	MOVEI	TEM,(BLOCK)		;GET THE BLOCK ADDRESS
	SUBI	TEM,-1(SIZE)		;GET THE BOTTOM ADDRESS
	HRROM	BLOCK,(TEM)		;CLAIM THE BOTTOM
	CAIL	SIZE,2000		;SKIP IF SMALLER THAN A BREADBOX
	CAME	TEM,MEMSIZ		;BIG ENOUGH. AT BOTTOM?
	JRST	FSGVK3			;NO. GIVE IT ALL BACK.
	SUBI	SIZE,2000		;FIGURE SIZE OF NEW BLOCK
	JUMPE	SIZE,FSGVK1		;THERE'S NOTHING TO SPLIT
	DPB	SIZE,FSSBYP		;SET SIZE FIELD IN BLOCK
	SUBM	BLOCK,SIZE		;GET THE BOTTOM ADDRESS
	HRROM	BLOCK,1(SIZE)		;SET THE BOTTOM MARK
	MOVEI	BLOCK,2(SIZE)		;GET THE ADDRESS FOR FSGIVE
	SETOM	(SIZE)			;MAKE HI END OF K LOOK CLAIMED.
	PUSHJ	P,FSGIVX		;GIVE BACK THIS PART OF THE BLOCK
FSGVK1:	MOVEI	TAC,2000
	ADDM	TAC,MEMSIZ
IFN FTSWAP,<
	ADDM	TAC,CORMAX>
	AOS	CORTAL
	MOVE	LOC,MEMSIZ
	SUBI	LOC,2000
	PUSHJ	P,CORGBP
	SETZ	TAC1,
	IDPB	TAC1,TAC
	IBP	TAC
	MOVEM	TAC,CORLST
IFN FTCORBUG,<	PUSHJ	P,CORCHK  >	;MAKE SURE CORTAB AND CORTAL ARE CONSISTENT
	PSYNC	CORCSC
	PUSHJ	P,DIDLE4
	JFCL
	SETOM	FSGVKF			;FLAG FOR NEXT TICK JUST IN CASE 
	JRST	FSCKZ

FSGVK3:	MOVEI	BLOCK,1(TEM)		;GET THE BOTTOM DATA WORD ADDRESS
	PUSHJ	P,FSGIVX		;GIVE BACK THIS BLOCK!
FSCKZ:	SKIPLE	FSCKCT			;TIME TO DO CHECKERBOARD?
	JRST	FSCLK3			;NO.
	MOVE	BLOCK,RMEMSIZ
	SUB	BLOCK,MEMSIZ
	SUB	BLOCK,FSBUSY
	CAILE	BLOCK,5000		;SKIP IF LESS THAN 2.5 FREE
	JRST	FSCLK4			;TOO MUCH IS FREE.
	MOVEI	BLOCK,=30*JIFSEC	;LOOK AGAIN IN 30 SECONDS.
	MOVEM	BLOCK,FSCKCT
FSCLK3:	XSYNC	FSCSC
	POPJ	P,

FSCLK4:	XSYNC	FSCSC
	MOVEI	BLOCK,=10*JIFSEC
	MOVEM	BLOCK,FSCKCT
	JRST	RELEX			;RELEASE SPARES.


FSCKX:	SKIPN	FSRTL			;ANY ONE ON THE RETURN LIST?
	POPJ	P,			;NO. RETURN
	CONO	PI,PIOFF		;DON'T INTERRUPT
	HRRZ	BLOCK,FSRTL		;GET THE FORWARD LINK
	MOVE	TAC,(BLOCK)		;GET THE NEXT FLINK
	HRRZM	TAC,FSRTL		;SAVE IT HERE
	CONO	PI,PION			;TURN ON THE PI'S
	LDB	TAC,FSSBYP		;GET THE SIZE FIELD
	SUBI	BLOCK,-2(TAC)		;GET THE ADDRESS OF LOWEST DATA WORD
	PUSHJ	P,FSGIVX		;ALL SET TO GIVE THE BLOCK BACK AGAIN
	JRST	FSCKX			;LOOK FOR MORE
COMMENT $	FSGIVE:	RETURN FREE STORAGE TO SYSTEM.
CALLING:
	MOVE	BLOCK,<ADDRESS OF BLOCK>
	PUSHJ	P,FSGIVE
	<RETURN HERE ALWAYS>

FSGIVX IS ROUTINE FOR FSGIVE THAT DOESN'T SAVE AC'S 
USE THIS ONLY INSIDE OF FS ROUTINES!

$

FSECHK:	PUSH	P,BLOCK		;SAVE AC'S FOR A WHILE.
	PUSH	P,SIZE		;SAVE.
	CAMGE	BLOCK,RMEMSIZ
	CAMG	BLOCK,MEMSIZ
	JRST	FSECK1
	SUBI	BLOCK,1
	TRNE	BLOCK,TRIVIAL-1	;ALL THESE BITS MUST BE OFF!
	JRST	FSECK1
	HRRZ	BLOCK,(BLOCK)	;GET BOTTOM LINK
	CAMGE	BLOCK,RMEMSIZ
	CAMG	BLOCK,MEMSIZ
	JRST	FSECK1
	HLRZ	SIZE,(BLOCK)	;GET 400000+SIZE
	SUBI	BLOCK,-400002(SIZE)	;MAKE POINTER TO 1 ABOVE LOWEST ADR.
	CAME	BLOCK,-1(P)		;MAKE SURE THESE ARE THE SAME.
	JRST	FSECK1		;LOSE
	POP	P,SIZE
	POP	P,BLOCK
	POPJ	P,

FSECK1:	
	PUSHACS	
	PUSHJ	P,DISMES
	ASCIZ	/RELEASE OF NON-EX FREE STORAGE BLOCK. BLOCK = /
	MOVE	TAC,-21(P)	;REACH BACK AND PULL UP STINKING MESS.
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/
CALLERS ADDRESS = /
	MOVE	TAC,-23(P)
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/

/
	SKIPE	DEBMOD			;NO NEED TO DISFLUSH IF NOT DEBUGGING
	PUSHJ	P,DISFLUSH		;MAKE SURE WE CAN SEE MESSAGE.
	POPACS
	DEBCHECK
	POP	P,SIZE
	POP	P,BLOCK
	POP	P,(P)		;THROW OUT RETURN FROM FSCHEK
	POPJ	P,		;RETURN TO BASTARD WHO CALLED ME.

↑FSGIVE:MOVEI BLOCK,(BLOCK)		;SOME PEOPLE COME HERE WITH SHIT IN LEFT HALF
	PUSHJ	P,FSECHK		;CHECK FOR WINNING ADDRESSES
	AOS	NFSGIVES		;INCREMENT COUNT OF GIVES
	PUSH	P,BLOCK			;SAVE THIS FOR A WHILE.
	HRRZ	BLOCK,-1(BLOCK)		;GET THE TOP ADDRESS
	LDB	BLOCK,FSSBYP		;GET THE SIZE
	MOVN	BLOCK,BLOCK		;GET -SIZE
	ADDM	BLOCK,FSBUSY		;DECREASE BUSY COUNT
	POP	P,BLOCK			;RESTORE BLOCK.
	CONSZ	PI,77000		;SKIP IF WE'RE NOT IN CHANNELS 1-6
	JRST	FSQUK1			;DO THE QUICK STUFF!
	PUSHJ	P,FSACSV		;SAVE AC'S
	PUSHJ	P,FSGIVY		;NOW GO GIVE BACK FREE STORAGE
	JSP	DAT,FSACRS		;RESTORE AC'S
	POPJ	P,			;RETURN

FSGIVX:	PUSHJ	P,FSECHK		;CHECK FOR ERROR.
	CONSZ	PI,77000		;SKIP IF AT LOW LEVEL
	JRST	FSQUK1			;AT HI CHANNEL GIVE BACK QUICK
FSGIVY:	PUSH	P,BLOCK			;SAVE BLOCK
	PSYNC	FSCSC			;LOCK OUT OTHER PROCESSOR
	MOVEI	AC2,-2(BLOCK)		;AC2 ← HIGH ADDRESS OF LOWER BLOCK
	HRRZ	BLOCK,1(AC2)		;BLOCK SET TO TOP WORD OF THIS BLOCK
	CAMG	AC2,MEMSIZ		;NO MERGE IF WE'RE AT THE BOTTOM
	JRST	FSGV1			;NO. TRY A HIGH MERGE.
	PUSH	P,BLOCK			;SAVE BLOCK TOP!
	MOVE	BLOCK,AC2		;GET THE ADDRESS OF LOWER
	PUSHJ	P,FSGCL			;ATTEMPT TO CLAIM LOWER
	JRST	FSGV0			;POP BLOCK AND FORGET ABOUT LOW MERGE
	LDB	TEM,FSSBYP		;GET THE SIZE
	MOVEI	DAT,(BLOCK)
	SUBI	DAT,(TEM)		;GET THE BOTTOM ADDRESS - 1
	POP	P,BLOCK			;GET ADDRESS OF TOP OF BIG BLOCK
	LDB	TAC1,FSSBYP		;GET SIZE OF ORIGINAL
	ADD	TEM,TAC1		;SUM THEM
	DPB	TEM,FSSBYP		;STUFF THEM IN THE ORIGINAL
	HRROM	BLOCK,1(DAT)		;SAVE A BOUNDARY MARKER.
	JRST	FSGV1
FSGV0:	POP	P,BLOCK			;GET THE TOP OF THIS BLOCK BACK.
FSGV1:	MOVEI	TAC1,1(BLOCK)		;GET ADDRESS OF GUY ABOVE
	JUMPE	TAC1,FSGV2A		;MOVEI OVERFLOW IF BLOCK=777777.
	CAML	TAC1,RMEMSIZ		;SKIP IF NOT THE TOP OF ALL CORE
	JRST	FSGV2A			;THIS BLOCK IS AT THE VERY TOP!
	HRRZ	TAC1,1(BLOCK)		;GET BOTTOM POINTER OF GUY ABOVE
	CONI	PI,DAT
	ANDI	DAT,PICMSK
	CONO	PI,PICHOF(DAT)		;STOP CHANNELS 3-7
	HRRZ	AC2,1(BLOCK)		;GET THE BOTTOM POINTER
	SKIPG	TAC,(AC2)		;GET THE FLINK
	JRST	FSGV2			;ALL A BAD IDEA.
	MOVE	TAC1,-1(AC2)		;GET THE BLINK
	HRRM	TAC1,-1(TAC)		;GO FORWARD AND STUFF BLINK
	HRRM	TAC,(TAC1)		;GO BACK AND SET FLINK
	CONO	PI,PICHON(DAT)		;ALLOW INTERRUPTS AGAIN
	MOVSI	DAT,400000
	IORM	DAT,(AC2)		;CLAIM THIS BLOCK.
	LDB	TAC,FSSBP1		;GET THE SIZE OF THIS GUY
	LDB	SIZE,FSSBYP
	ADD	SIZE,TAC
	MOVE	DAT,AC2
	SUB	DAT,SIZE		;COMPUTE THE BOTTOM ADDRESS
	DPB	SIZE,FSSBP1
	HRROM	AC2,1(DAT)
	SKIPA	BLOCK,AC2
FSGV2:	CONO	PI,PICHON(DAT)
FSGV2A:	LDB	SIZE,FSSBYP
	LSH	SIZE,1-TSHF		;SHIFT SIZE TO MAKE INDEX.
	SUBI	SIZE,2			;FIX INDEX.
	CAIL	SIZE,NFSB*2		;REASONABLE INDEX?
	MOVEI	SIZE,NFSB*2-2		;NO. FIX INDEX.
	JRST	FSGV6
FSGV5:	CONO	PI,PICHON(TAC1)		;MAKE SURE PI'S GET RESTORED
FSGV6:	MOVEI	TAC,FSAVB+1(SIZE)	;GET THE LIST BASE
FSGV7:	SKIPG	DAT,(TAC)		;DOES THIS POINT FREE?
	JRST	FSGV6			;NO TRY THIS LIST ALL OVER AGAIN
	HRRZ	TEM,(TAC)		;GET THE FLINK
	CAIGE	TEM,(BLOCK)		;HAVE WE FOUND THE RIGHT PLACE?
	JRST	FSGV8			;YES. PREPARE TO LINK IT IN
	CAME	DAT,(TAC)		;IS THIS STILL THE SAME?
	JRST	FSGV6			;NO. TRY ALL OVER
	MOVEI	TAC,(TEM)		;GET THE NEXT FLINK
	JRST	FSGV7			;CHASE DOWN THIS LIST

FSGV8:	HRRZM	TAC,-1(BLOCK)		;SET THE BLINK
	HRRM	TEM,(BLOCK)		;SET THE FLINK
	LDB	AC2,FSSBYP		;GET THE SIZE OF BLOCK
	SUBM	BLOCK,AC2		;GET POINTER TO BOTTOM
	MOVSI	SIZE,400000
	ANDCAM	SIZE,(BLOCK)		;TURN OFF CLAIM BIT
	CONI	PI,TAC1
	ANDI	TAC1,PICMSK
	CONO	PI,PICHOF(TAC1)		;HOLD CHANNELS 3-7
	CAME	DAT,(TAC)		;STILL HERE?
	JRST	FSGV5			;WHAT A LOSS.
	HRRM	BLOCK,(TAC)		;STUFF IN NEW FLINK
	HRRM	BLOCK,-1(TEM)		;STUFF IN NEW BLINK
	HRRZM	BLOCK,1(AC2)		;AND TURN OFF BOTTOM MARK
	CONO	PI,PICHON(TAC1)		;ALLOW INTERRUPTS
	HRRZ	BLOCK,@MEMSIZ		;POINTER TO BOTTOM-MOST FS BLOCK
	LDB	SIZE,FSSBYP		;GET THE SIZE OF LOW BLOCK
	SKIPL	(BLOCK)			;SKIP IF BLOCK IS CLAIMED ALREADY
	CAIGE	SIZE,2000		;UNCLAIMED. SKIP IF BIGGER THAN 1K
	JRST	FSXPOP			;CLAIMED OR NOT BIG ENOUGH
	SKIPN	FSCNT			;SKIP IF ANYONE'S WAITING
	SETOM	FSGVKF			;SET FLAG TO LET CLOCK THINK ABOUT IT
	SETOM	FSNCLK			;MAKE CLKSER CALL FSCLK
FSXPOP:	PUSH	P,J			;SAVE J, CLOBBERED BY FSWAKE
	PUSHJ	P,FSWAKE		;WAKE SOMEONE WHO WAITS.
	POP	P,J			;RESTORE J
FSPOP:	POP	P,BLOCK
	XSYNC	FSCSC
	POPJ	P,


FSQUIK:	PUSHJ	P,FSECHK		;CHECK ADDRESSES
FSQUK1:	PUSH	P,BLOCK
	PUSH	P,TEM
	HRRZ	BLOCK,-1(BLOCK)		;LOAD TOP ADDRESS FROM BOTTOM
	PSYNC	FSCSC
	CONO	PI,PIOFF		;ADD THIS BLOCK TO THE FREE LIST
	HRRZ	TEM,FSRTL		;GET THE FLINK
	HRRM	TEM,(BLOCK)		;SAVE HERE
	HRRZM	BLOCK,FSRTL		;RESET LIST BASE
	CONO	PI,PION			;DONE
	SETOM	FSNCLK
	POP	P,TEM
	JRST	FSPOP
;GET FREE STORAGE AT UUO LEVEL.

↑UFSGET:
	PUSHJ	P,FSGET			;GET FREE STORAGE AT UUO LEVEL
	JRST	.+2			;FAILURE CANNOT HAPPEN (IT SAYS HERE)
	POPJ	P,			;EXPECTED RETURN
	PUSHACS				;STUFF EVERYTHING AWAY
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ/π
NO FREE STORAGE AT UFSGET. /
	CONSO	PI,77400		;ARE THERE ANY CHANNELS ACTIVE?
	JRST	UFSGT1			;NO.
	PUSHJ	P,DISMES
	ASCIZ	/NOT AT UUO LEVEL!  RETURN PC = /
	MOVE	TAC,P-17(P)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ	/ PI = /
	CONI	PI,TAC
	PUSHJ	P,DISLOC
UFSGT1:	PUSHJ	P,DISCRLF
	POPACS
	JSP	DAT,UERROR		;GIVE A UUO ERROR.
; ROUTINES TO GET AND RELEASE THE PDL AT UUO LEVEL ONLY. - GETPDL
; CALLING:
;	JSP TAC,GETPDL			;TO GET A PDL
;	PUSHJ P,RELPDL			;TO RELEASE A PDL
; NOTE FREE STORAGE BLOCK THAT THIS PDL USES WILL BE PLACED
; ON THE FREE STORAGE RETURN LIST. THE BLOCK WILL ACTUALLY
; BE RETURNED THE NEXT TIME CHANNEL 7 IS ACTIVATED BY THE CLOCK.
; YOU MUST FINISH USING THE PDL AT UUO LEVEL OR CHANNEL 7 LEVEL,
; WHICHEVER YOU'RE PRESENTLY IN.

; THE NUMBER IN J MUST BE THE CORRECT JOB NUMBER.
; AND PROG MUST POINT TO THE RIGHT JOB DATA AREA

;GETPDL SHOULD BE A NO-OP AFTER SYSTEM 6.09L

↑GETPDL:
	SKIPE	P,JBTPDL(J)
	JRST	(TAC)
	MOVEM	BLOCK,JOBTM1(JDAT)	;SAVE AC'S IN JOB DATA AREA
	MOVEM	SIZE,JOBTM2(JDAT)
	MOVEI	SIZE,JBTPLN		;GET ONE THIS SIZE
	MOVEI	P,JOBPDL-1(JDAT)	;MAKE A TEMPORARY PDL FOR FSGET
	HRLI	P,-JOBPLN		;THIS LONG
	PUSHJ	P,FSGET			;GET SOME FREE STORAGE
	JSP	DAT,ERROR		;IT CAN'T HAPPEN.
	PSYNC	PDLCSC			;SYNCHRONIZE
	SKIPN	P,JBTPDL(J)		;HAS HE GOT ONE SOME OTHER WAY?
	JRST	GETPD1			;NO. WE USE THE ONE WE JUST GOT
	XSYNC	PDLCSC			;DESYNCHRONIZE
	PUSHJ	P,FSGIVE		;RETURN THE PDL WE DON'T NEED IT.
	JRST	GETPD2			;AND RETURN IT.
GETPD1:	MOVEI	P,-1(BLOCK)		;GET THE PDL BASE-1
	HRLI	P,1-<JBTPLN+JOBPRT-JOBPFI>	;AND THE PDL LENGTH
	MOVEM	P,JBTPDL(J)		;SAVE PDL POINTER
	XSYNC	PDLCSC			;RELEASE INTERLOCK
	SETZM	1(P)			;ZERO A CELL
	MOVSI	BLOCK,1(P)		;MAKE A BLT POINTER
	HRRI	BLOCK,2(P)
	BLT	BLOCK,JBTPLN(P)		;ZERO THE ENTIRE PDL
GETPD2:	MOVE	BLOCK,JOBTM1(JDAT)	;RESTORE THE AC'S WE SAVED
	MOVE	SIZE,JOBTM2(JDAT)	
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/AT GETPDL WITHOUT A PDL /
	PUSHJ	P,DISJOB
	PUSHJ	P,DISCRLF
	POPACS
	SKIPE	DEBMOD
	PUSHJ	P,DDTCAL
	JRST	(TAC)			;RETURN TO CALLER.

↑RELPDL:
	HRRZ	BLOCK,JBTPDL(J)		;GET THE ADDRESS OF THE PDL
	JUMPE	BLOCK,CPOPJ		;NO PDL, CAN'T RELEASE
	HRRZ	TAC,JBTPDL(J)		;GET THE PDL ADDRESS
	ADDI	TAC,JBTPLN+JOBPRT-JOBPFI	;ADDRESS OF THE TOP IN TAC
	SKIPN	(TAC)			;LOOK FOR A NON-ZERO CELL
	SOJGE	TAC,.-1			;LOOP.
	SUB	TAC,BLOCK		;SUBTRACT THE BASE ADDRESS.
	CAMLE	TAC,NPUSHD		;BIGGER THAN OUR BIGGEST
	MOVEM	TAC,NPUSHD		;YES. SAVE THIS NUMBER
	SETZM	JBTPDL(J)		;CLEAR PDL CELL FOR NEXT JOB
	AOS	NFSGIVES		;COUNT THIS CELL HERE, SINCE FAKING IT
	MOVNI	TAC,JBTPLN+2		;GET THE SIZE OF THIS BLOCK
	ADDM	TAC,FSBUSY		;DECREASE BUSY COUNT TOO.
	AOJA	BLOCK,FSQUIK		;CHECK BLOCK, STUFF ON FSRTL, RETURN
;SPARE LIST HANDLER FOR DPYSER & TTYSER

;HERE WE SET UP THE INITIAL QUOTAS (QUOTAE?)
SFSINI:	HRRZ DDB,SFHEAD		;THE SPARE LIST LIST
SFSIOL:	LDB DAT,[331000,,SFSIZE(DDB)]	;HOW MANY DOES THIS ONE WANT?
	JUMPE DAT,SFSI2		;NONE?
	HRRZ AC3,SFSIZE(DDB)
	MOVEI AC2,(DDB)		;INIT PNTR FOR LINKING
SFSIIL:	PUSHJ P,FSGETU
	JRST .+4		;LOSE - SET TO TRY LATER (SHOULDN'T HAPPEN)
	MOVEM AC1,(AC2)		;LINK IT IN
	MOVEI AC2,(AC1)
	SOJG DAT,SFSIIL
	SETZM (AC2)		;TERMINATE LIST
	MOVEM DAT,SPFSN(DDB)	;SET FROM DAT IN CASE WE LOST
	SKIPL SFSIZE(DDB)
	ADDM DAT,SPFSNT
SFSI2:	HRRZ DDB,SFLINK(DDB)
	JUMPN DDB,SFSIOL
	POPJ P,

;WE GET HERE AT CLOCK LEVEL WHEN SPFSNT>0 TO REPLENISH OUR SPARES
↑SFSCLK:HRRZ DDB,SFHEAD
SFSCL1:	SKIPLE SPFSN(DDB)	;IF THIS LIST DOESN'T NEED ANY
	SKIPGE SFSIZE(DDB)	;OR THIS ISN'T THE CLOCK-FILLED KIND
	JRST SFSCL2		;TRY NEXT LIST
SFSCLL:	HRRZ AC3,SFSIZE(DDB)
	PUSHJ P,FSGET		;TRY TO GET ONE
	JRST SFSCL2		;LOSE - DON'T BOTHER WITH THIS LIST ANY MORE
	CONO PI,PIOFF
	EXCH AC1,(DDB)		;PUT IT IN THE LIST
	MOVEM AC1,@(DDB)
	CONO PI,PION
	SOS AC1,SPFSNT		;DECREMENT TOTAL
	SOSLE SPFSN(DDB)	;& # THIS LIST
	JRST SFSCLL		;STILL NEED MORE
	JUMPLE AC1,CPOPJ	;THIS LIST ALL SET, ANY OTHERS TO DO?
SFSCL2:	HRRZ DDB,SFLINK(DDB)	;YES, TRY NEXT LIST
	JUMPN DDB,SFSCL1	;IF THERE IS ONE
	POPJ P,
;VERSION OF FSGET TO USE SPARE LIST
;LIKE FSGET EXCEPT AC3 HAS SPARE LIST HEADER POINTER INSTEAD OF SIZE
;SIGN BIT (AC3) MEANS NO SKIP (OR FAILURE) RETURN
;SFNWT BIT FORCES FAILURE RETURN EVEN AT UUO LEVEL
↑SFSGET:PUSH P,AC3
	SKIPGE SFSIZE(AC3)
	JRST SFGSF		;WANTS TO TRY SPARES FIRST
SFGFS:	HRRZ AC3,SFSIZE(AC3)
	PUSHJ P,FSGETU
	JRST SFSGTS		;NO FS, TRY SPARE
SFSXIT:	POP P,AC3
SFSWIN:	JUMPGE AC3,CPOPJ1	;HERE WE HAVE WON, AND GIVE THE REQUESTED SUCCESS RETURN
	POPJ P,

SFSGTS:	PUSHJ P,SFGTS		;TRY TO GET A SPARE
	JRST SFSLUZ		;OOPS - NO SPARE, EITHER
SFSGOK:	POP P,AC3
	AOS SPFSN(AC3)		;NOW WE NEED ANOTHER
	SKIPL SFSIZE(AC3)	;AND UNLESS WE'RE KEEPING SFSCLK OUT
	AOS SPFSNT		;WE SHOULD REQUEST SERVICE FROM IT
	JRST SFSWIN

SFGSF:	PUSHJ P,SFGTS		;HERE WE TRY THE SPARES FIRST
	SKIPA AC3,(P)		;LOSE - GET THE PNTR SO WE CAN GET THE SIZE FOR FSGET
	JRST SFSGOK		;WIN - UPDATE THINGS & EXIT
	JRST SFGFS		;NOW TRY FSGET

SFGTS:	MOVEI AC3,		;PREPARE TO FLUSH LINK
	CONO PI,PIOFF		;GET SPARE FROM LIST AT @(P)
	SKIPN AC1,@-1(P)
	JRST PIONJ		;NONE
	EXCH AC3,(AC1)		;THIS ZEROES LINK TO TELL RELEX SOMETHING CHANGED
	MOVEM AC3,@-1(P)	;DELINK IT FROM THE LIST
	CONO PI,PION
	JRST CPOPJ1

SFSLUZ:	POP P,AC3
	AOS SFLOSS(AC3)		;COUNT OUR TOTAL LOSSES
	CONSO PI,77400
	JRST SFULUZ		;UUO LEVEL - NOT TOO BAD
	JUMPL AC3,SFILUZ	;IF WE CAN'T GIVE A FAILURE RETURN WE ARE IN DEEP TROUBLE
	POPJ P,			;WHEW!

SFULUZ:	TLNE AC3,SFNWT		;IF THE CALLER DOESN'T WANT TO WAIT
	JUMPGE AC3,CPOPJ	;AND HE ALLOWS FAILURE, JUST RETURN
	PUSH P,AC3
	HRRZ AC3,SFSIZE(AC3)
	PUSHJ P,UFSGET		;OTHERWISE OFF TO FSGET TO WAIT FOR IT
	JRST SFSXIT
;ARRRGH! PI LEVEL AND NO FAILURE POSSIBLE! HERE WE CURL UP AND DIE
SFILUZ:	HLRZ AC2,SFLOSS(AC3)	;MAYBE THE CONDEMNED HAS A FEW LAST WORDS
	SKIPN AC2
	MOVEI AC2,[ASCIZ /SOMETHING/]	;NOPE
	PUSHACS
	PUSHJ P,DISDAT
	PUSHJ P,DISERR
	[ASCIZ /πππππππNO CORE FOR /]
	@AC2-20(P)
	[ASCIZ / AT SFSGET.

/]
	-1
	CONO PI,PIOFF
	SETOM DISFLAG
	PUSHJ P,DISFLUSH
	PUSHJ P,DDTCALL			;MAYBE SOMEONE WANTS TO KNOW WHY
	JRST AUTOLOAD		;AS THE SYSTEM SINKS SLOWLY INTO THE WEST
;VERSION OF FSGIVE TO THINK ABOUT PUTTING RETURNED BLOCK INTO SPARE LIST
;LIKE FSGIVE BUT CALL IS FOLLOWED BY LIST HEADER ADDRESS
↑SFSGIV:PUSH P,AC3
	AOS AC3,-1(P)		;SKIP OVER ARG
	MOVEI AC3,@-1(AC3)	;& GET IT
	SKIPGE SFSIZE(AC3)	;ONLY RETURN INTO LIST IF THIS BIT IS ON
	SKIPG SPFSN(AC3)	;AND WE NEED SOME
	JRST [POP P,AC3↔JRST FSGIVE]	;OTHERWISE GIVE IT BACK TO FS
	PUSH P,AC1
	ANDI AC1,-1
	CONO PI,PIOFF
	EXCH AC1,(AC3)		;LINK IT IN
	MOVEM AC1,@(AC3)
	CONO PI,PION
	POP P,AC1
	SOS SPFSN(AC3)		;ONE FEWER NEEDED
	POP P,AC3
	POPJ P,

;ROUTINE TO DYNAMICALLY SHRINK SIZE OF SPARE LIST
;CALL WITH -# TO DECREASE IN AC2, HEADER POINTER IN AC3 (CLOBBERS AC1 & AC2)
↑SFSREL:SKIPL SFSIZE(AC3)	;AS USUAL, THIS TYPE LEAVES SPFSNT ALONE
	ADDM AC2,SPFSNT
	ADDB AC2,SPFSN(AC3)
	JUMPGE AC2,CPOPJ	;LEAVE IF WE DON'T HAVE TO GIVE ANY AWAY
SFSRLL:	CONO PI,PIOFF
	SKIPN AC1,(AC3)		;GET ONE
	JRST PIONJ		;NONE
	HRRZ AC2,(AC1)
	MOVEM AC2,(AC3)		;LINK IT OUT
	CONO PI,PION
	PUSHJ P,FSGIVE		;AND GIVE IT BACK TO THE WORLD
	SKIPL SFSIZE(AC3)	;THE UBIQUITOUS TEST (SIGH)
	AOS SPFSNT
	AOSGE SPFSN(AC3)	;ONE MORE "NEEDED" (SHOULD BE GOING UP TO 0)
	JRST SFSRLL		;AND WE'LL KEEP AT IT UNTIL IT DOES
	POPJ P,
;YES FANS, IT'S THE INFAMOUS RELEX, FORMERLY SCATTERED THROUGH TTYSER & DPYSER
;THIS ONE TRIES TO SHUFFLE UP ALL THE SPARES IN THE BOTTOM 1K
;BY REPLACING THEM WITH NEW ONES FROM FREE STORAGE
;IT GIVES UP QUICKLY IF THE NEW ONES AREN'T ABOVE THE BOTTOM 1K
RELEX:	MOVE AC2,MEMSIZ
	ADDI AC2,2000		;THIS WILL BE OUR THRESHOLD
	CAML AC2,RMEMSIZ	;BUT LEAVE THE TOP 1K ALONE
	POPJ P,		;IF THIS INSTRUCTION GETS EXECUTED SOMEONE DESERVES OUR WARMEST CONGRATULATIONS
	HLRZ DDB,SFHEAD		;THERE WAS ONCE A REASON FOR GOING THROUGH BACKWARDS
RELX1:	MOVEI TAC,(DDB)		;START THE "PREVIOUS" POINTER HERE
RELX2:	HRRZ TEM,(TAC)		;CONSIDER A BLOCK
	JUMPE TEM,RELXO		;GEE, WASN'T THAT EASY
	CAIL TEM,(AC2)
	JRST RELXI		;HE'S NOT IN THE BOTTOM 1K, SO WE WON'T WORRY ABOUT HIM NOW
	MOVE TAC1,(TEM)		;PICK UP HIS LINK
	HRRZ AC3,SFSIZE(DDB)	;HE MUST BE THIS BIG
	PUSHJ P,FSGET		;GET A SHINY NEW PIECE
	JRST RELXO		;OH WELL, SO MUCH FOR THIS LIST
	CAIGE AC1,(AC2)		;SEE IF THE NEW ONE IS ABOVE THE BOTTOM 1K
	JRST RELXL		;TIME TO SEE THE COMPLAINT DEPARTMENT
	MOVEM TAC1,(AC1)	;COPY THE LINK
	CONO PI,PIOFF		;NOW CLOSE OUR EYES
	CAMN TAC1,(TEM)		;AND IF THESE 2 POINTERS
	CAME TEM,(TAC)		;STILL AGREE
	JRST [CONO PI,PION↔JRST RELXL]	;CURSES! FOILED AGAIN! GIVE BACK NEW BLOCK.
	MOVEM AC1,(TAC)		;QUICK! PULL THE SWITCH!
	CONO PI,PION		;DIDN'T SEE A THING
	EXCH AC1,TEM		;DON'T FORGET TO TELL FSGIVE ABOUT THE SWITCH
	PUSHJ P,FSGIVE		;NOW GET RID OF THE LOSER
RELXI:	MOVE TAC,TEM		;THIS IS NOW THE PREVIOUS BLOCK
	JRST RELX2

RELXL:	PUSHJ P,FSGIVE		;GIVE BACK THE NEW ONE
RELXO:	HLRZ DDB,SFLINK(DDB)	;AND TRY A NEW LIST
	JUMPN DDB,RELX1		;IF THERE'S ONE TO BE FOUND
	POPJ P,
BEND CORE
