COMMENT ⊗   VALID 00017 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	BEGIN	PTPSER ↔ SUBTTL	PTPSER - PAPER TAPE PUNCH SERVICE ROUTINES
C00006 00003	 PTP SERVICE DISPATCH TABLE
C00007 00004	 INITIALIZE CODE, RESET ALL REGISTERS
C00009 00005	 ARE YOU HUNG UP? AH, ER, ARE YOU HUNG UP? HUNG UP? HUNG UP? HUNG UP? HUNG UP?     HUNG UP?        HUNG UP?
C00011 00006	 2-PROCESSOR ROUTINES
C00012 00007	 ROUTINE TO SET BITS IN IOS AND START DEVICE
C00015 00008	 CLOCK INTERRUPT ROUTINES FOR PTP
C00017 00009	 OUTPUT ROUTINES ARE DIVIDED INTO PARTS AND KINDS, DEPENDING ON
C00019 00010	 IN THIS MODE, WE BRING 1 CHAR PER WORD IN AND PACK 4 TO A WORD
C00022 00011	 THIS IS FOR REAL BINARY MODE, WITH CHECKSUMS AND ALL
C00024 00012	 HERE, WE TRY TO FIT THE USER'S BUFFER INTO SYSTEM CORE
C00027 00013	 COME HERE IF WE HAVE TO DO 2 SEPARATE BLT'S
C00029 00014	 THIS ROUTINE SETS UP THE CRAZY DISPATCHES FOR EACH OF THE VARIOUS MODES OF OPERATION
C00033 00015	 INTERRUPT SERVICE ROUTINES - OBOYOBOYOBOY!
C00036 00016	 TYPE 2 - PUNCH PARITY AND DELETES AFTER CR, FF, VT AND  HT
C00038 00017	 LAST PAGE - PUNCH FEED HOLES, SHUT OFF PTP
C00042 ENDMK
C⊗;
BEGIN	PTPSER ↔ SUBTTL	PTPSER - PAPER TAPE PUNCH SERVICE ROUTINES
; ROUTINES DESIGNED TO SERVE DUAL-PROCESSOR PUNCH SYSTEM

; PARAMETER ASSIGNMENTS . . .

; ACCUMULATORS
	A←TAC
	B←TAC1
	C←AC1
	D←DAT
	COUNT←AC2
	POINTR←AC3

; IOS BITS
	PTPFT←←200		; FEED AFTER EVERY BUFFERLOAD IS PUNCHED
	PTPEN1←←2000		; LAST BUFFERLOAD, FEED WHEN DONE
	PTPPDN←←4000		; PUNCH DELETE CODE NEXT
	PTPERR←←10000		; DEVICE PTP HUNG BIT
	PTPBG1←←20000		; SPECIAL 2ND LEVEL IOBEG FLAG

; CONO BITS . . .
	PTPDON←←10		; DONE FLAG
	PTPNOT←←100		; 'OUT OF TAPE' FLAG

; PTP SERVICE DISPATCH TABLE

	JRST PTPINI		; INITIALIZE
	JRST PTPCLT		; HUNG TIME OUT, SET ERROR BIT
↑PTPDSP:
	JRST PTPREL
	JRST PTPCLS		; CLOSE
	JRST PTPOUT		; OUTPUT
	JRST ILLINP		; INPUT ?????

PTPREL:	MOVSI IOS,DEVSBB+PTPERR
	ANDCAM IOS,PTPIOS
	POPJ PDP,
; INITIALIZE CODE, RESET ALL REGISTERS

PTPINI:	MOVE A,[XWD PTPIBP,PTPIBP+1]
	SETZM PTPIBP		; SET UP BLT POINTER TO ZERO PTPDDB
	BLT A,PTPCSC		; FROM DEVOAD TO END OF PTPDDB
	SYNINI PTPCSC		; CLEAR CONTROL CELLS TOO
	SKIPE P2NUM		; DO WE HAVE A 2-PROCESSOR SYSTEM?
	SETOM PTPMOD		; SET THE MODE FLAG IF WE DO
	CONO PTP,0		; SETTLE PTP CONTROL REGISTER
	HLLZS	PTPCN1
	HLLZS	PTPCN2
	MOVEI	TAC,PTPCN1	;ASSUME P1
	SKIPE	PTPMOD		;P1?
	MOVEI	TAC,PTPCN2	;NO. USING P2
	MOVEM	TAC,PTPCON	;SET ADDRESS OF INTERRUPT CHAIN CONSZ
	POPJ	P,

; CLOSE CODE

PTPCLS:	SETZ A,			; SET THE 'LAST UUO' BIT IN IOS
	HRLZI IOS,IOEND		; THIS BIT
	PUSHJ PDP,PTPSOS	; THIS ROUTINE HANDLES THAT
	JRST OUT

; PTP OUTPUT CODE

PTPOUT:	TLNE IOS,IOBEG		; FIRST UUO?
	TLZ IOS,PTPERR		; YES, ZERO HUNG DEVICE BIT
	TLNE IOS,PTPERR		; CHECK FOR HUNG DEVICE
	JRST PTPHNG
PTPO2:	TLZE IOS,IOBEG		; FIRST OUTPUT?
	JRST PTPSUD		; YES, FIGURE OUT CONFIGURATION NOW
PTPO1:	JRST @PTPUDS		; EACH MODE HAS A DIFFERENT ROUTINE

; ARE YOU HUNG UP? AH, ER, ARE YOU HUNG UP? HUNG UP? HUNG UP? HUNG UP? HUNG UP?     HUNG UP?        HUNG UP?

PTPHNG:	PUSHJ PDP,HNGSTP	; PRINT 'DEVICE PTP OK?' AND HANG HIM UP
	SETZ IOS,		; DON'T SET ANYTHING
	HRLZI A,PTPERR+DEVSBB	; GOTTA CLEAR  ERROR FLAG NOW
	PUSHJ PDP,PTPSOD	; AFTER IT'S OVER, START UP AGAIN
	JRST PTPO2

; COME HERE IF THE CLOCK TICKS

PTPCLT:	MOVEI DEVDAT,PTPDDB	; SET UP THIS FOR SETIOD
	HRLZI IOS,PTPERR	; ERROR BIT WE WANT TO SET
	SKIPE P2NUM		; IS P2 ACTIVE?
	JRST PTPCL1		; YES, DO SOMETHING
	CONO PI,PTPOFF		; SHUT OFF PTP
	ORB IOS,PTPIOS		; OR IN ERROR BIT
	TLZE IOS,IOW		; ARE WE IN AN IO WAIT?
	PUSHJ PDP,STTIOD	; YES, GET US OUT!
	MOVEM IOS,PTPIOS	; RESTORE IOS
	CONO PI,PTPON		; SPEED UP PTP, EVEN THOUGH IT IS HUNG
	JRST CPOPJ1		; SKIP RETURN, DON'T EXCITE HNGCHK

PTPCL1:	MOVEI B,1		; WE ARE P1
	PSYNC PTPCSC		; GET CONTROL OF IOS
	ORB IOS,PTPIOS		; OR IN ERROR BIT
	TLZE IOS,IOW		; ARE WE IN IO WAIT?
	PUSHJ PDP,STTIOD	; YES, GET US OUT!!
	MOVEM IOS,PTPIOS	; RESTORE IOS
	AOS (PDP)		; SET TO SKIP RETURN
	MOVEI B,1		; RESTORE WHAT SETIOD CLOBBERED
	XSYNC PTPCSC		; RELEASE CONTROL OF IOS
	POPJ PDP,
; 2-PROCESSOR ROUTINES
; SET AND CLEAR BITS IN IOS
; PUT BITS YOU WANT SET IN IOS, BITS YOU WANT CLEARED IN A (IN TAC)

PTPSOS:	SKIPE PTPMOD		; ARE WE IN 1 OR 2 PROCESSOR MODE
	JRST PTPS1		; 2-PROCESSORS, HARDER
	CONO PI,PTPOFF		; SLOW DOWN PTP
	ANDCAM A,PTPIOS		; ZERO OUT BITS IN A
	ORB IOS,PTPIOS		; OR BITS BACK IN
	CONO PI,PTPON		; SPEED UP PTP
	POPJ PDP,

PTPS1:	MOVEM A,PTPPTR		; SAVE THIS ACCUMULATOR
	MOVEI B,1		; WE ARE P1
	PSYNC PTPCSC		; GET CONTROL OF IOS
	OR IOS,PTPIOS		; OR IN IOS BITS
	ANDCM IOS,PTPPTR	; TAKE OUT REQUESTED BITS
	MOVEM IOS,PTPIOS	; RESTORE IOS
	XSYNC PTPCSC
	POPJ PDP,
; ROUTINE TO SET BITS IN IOS AND START DEVICE

PTPSTD:	SETZB A,IOS		; START DEVICE, SET NO IOS BITS
PTPSOD:	OR IOS,[XWD IO,0]	; FIRST, OR IN OUTPUT BIT
	LDB C,PDVTIM		; AND SET HUNG COUNT
	DPB C,PDVCNT
	SKIPE PTPMOD		; ARE WE RUNNING 1 OR 2 PROCESSORS TODAY?
	JRST PTPSD1		; 2 PROCESSORS
	MOVEI B,PTPDON+PTPNOT	; ASK FOR INTERRUPTS UPON DONE OR OUT OF PAPER
	CONO PI,PTPOFF		; SHUT OF PTP IF IT IS RUNNING
	OR IOS,PTPIOS		; PUT BITS INTO IOS
	ANDCM IOS,A		; TAKE BITS OUT
	TLOE IOS,DEVSBB		; IS THE PTP ALREADY RUNNING?
	JRST PTPSD2		; YES, SKIP IT
	HRRM B,@PTPCON		; SET INTERRUPT LOCATION
	CONO PTP,PTPDON+PTPCHN	; ASK FOR A DONE INTERRUPT, SET PI CHANNEL
PTPSD2:	MOVEM IOS,PTPIOS	; RESTORE IOS
	CONO PI,PTPON		; SPEED UP PTP, WILL INTERRUPT NOW
	POPJ PDP,

PTPSD1:	MOVEM A,PTPPTR		; SAVE THE BITS WE ARE TO CLEAR
	PSYNC PTPCSC		; GET CONTROL OF IOS
	OR IOS,PTPIOS
	ANDCM IOS,PTPPTR	; CLEAR APPROPRIATE BITS
	TLON IOS,DEVSBB		; SET DEVICE RUNNING NOW BIT.
	SETOM PTPACT		; ASK P2 TO START PTP SINCE IT'S NOT ALREADY ON.
	MOVEM IOS,PTPIOS	; RESTORE IOS
	XSYNC PTPCSC		; RELEASE CONTROL OF IOS
	POPJ PDP,

; ROUTINE TO SET BITS IN IOS, START DEVICE, AND WAIT FOR
; DEVICE TO FINISH

PTPIOW:	SETZB A,IOS
PTPSOW:	PUSHJ PDP,PTPSOD	; STORE IOS BITS AND START DEVICE
	JRST WSYNC		; WAIT FOR DEVICE TO FINISH
; CLOCK INTERRUPT ROUTINES FOR PTP


;PDP-10 HERE WHEN PDP-6 HAS FINISHED BUFFER
↑PTPP1:	SETZM	PTPSID		;CLEAR REQUEST
	MOVEI DEVDAT,PTPDDB	; GET ADDRESS OF DEVICE DDP FOR SETIO
	JRST STTIOD		; SET IO WAIT SATISFIED BIT

;PDP-6 HERE WHEN PDP-10 HAS SET PTPACT
↑PTPP2:	MOVE TAC,PTPACT		; ARE WE TO START THE DEVICE FOR P1?
	JUMPE TAC,CPOPJ
	SETZM PTPACT		; YES, FLAG IT STARTED
	MOVEI DEVDAT,PTPDDB	; SET UP DEVDAT FOR PDVTIM
	CONO PI,PTPOFF		; SHUT OFF PTP
	HRLZI IOS,IO		; SET OUTPUT BIT IN IOS
	OR IOS,PTPIOS
	MOVEI C,PTPDON+PTPNOT	; ASK FOR INTERRUPTS UPON DONE OR OUT OF PAPER
;	TLOE IOS,DEVSBB		; IS PTP ALREADY RUNNING?
;	JRST PTPP2A		; YES, QUIT NOW
	MOVEM IOS,PTPIOS	; NO, STORE IOS
	CONO PTP,PTPDON+PTPCHN	; AND ASK FOR DONE INTERRUPT FROM PTP
	HRRM C,@PTPCON		; SET UP CONSO LOCATION
PTPP2A:	CONO PI,PTPON		; RESTORE PI CHANNEL
	LDB C,PDVTIM		; RESET HUNG COUNT
	DPB C,PDVCNT
	POPJ PDP,
; OUTPUT ROUTINES ARE DIVIDED INTO PARTS AND KINDS, DEPENDING ON
; MODE OF OPERATION AND OTHER SUCH STUFF

PTPK1:	MOVEI A,5		; SET UP CHARS PER WORD AS 5, ASCII MODE
	CAIA
PTPK3:	MOVEI A,6		; BINARY MODE, 6 PER WORD
	MOVEM A,PTPCPW		; CHARACTERS PER WORD
PTPK1F:	PUSHJ PDP,DEVSTU	; SET UP COUNT AND POINTR TO USER'S CORE
	JRST PTPK1A
	PUSHJ PDP,PTPBBI	; BLT BUFFER INTO SYSTEM CORE
	JRST PTPK1B		; NO ROOM IN THE INN . . .
	PUSHJ PDP,ADVBFE	; FIT AS MANY BUFFERS IN NOW AS IS POSSIBLE
	JRST PTPK1A
	JRST PTPK1F

PTPK1B:	PUSHJ PDP,PTPIOW	; ASK TO START DEVICE AND WAIT
	JRST PTPK1F

PTPK2A:
PTPK1A:	SKIPGE PTPBCN		; IS SYSTEM BUFFER EMPTY?
	JRST PTPK1C		; NO, START DEVICE AND LEAVE
	TLNN IOS,IOEND		; LAST UUO?
	POPJ PDP,		; NO, LET HIM GIVE ANOTHER ONE
PTPK1D:	SETZ A,			; SET THE 'PTP DISCONNECT' BIT IN IOS
	HRLZI IOS,PTPEN1	; TELLS INTERRUPT SERVICE TO FEED A LITTLE
	JRST PTPSOD		; START DEVICE AND LEAVE

PTPK1C:	TLNE IOS,IOEND		; LAST UUO?
	JRST PTPK1D		; YES, GO START DEVICE
	PUSHJ PDP,DEVCR		; DOES HE HAVE ANOTHER BUFFER TO FILL
	JRST PTPIOW		; NO, WAIT FIRST AND THEN LEAVE
	JRST PTPSTD		; START DEVICE AND LEAVE

; IN THIS MODE, WE BRING 1 CHAR PER WORD IN AND PACK 4 TO A WORD
; IN THE SYSTEM BUFFER

PTPK2:	PUSHJ PDP,DEVSTU	; SET UP POINTR TO USER BUFFER
	JRST PTPK2A		; NOTHING THERE, LEAVE
	CAILE COUNT,PTPBLN	; IF'N HE'S ASK'N MORE'N WE GOT . . .
	JRST BTLERR		; FUCK'M!
	MOVN A,PTPBCN		; IS THERE ROOM IN THE INN?
	ADD A,COUNT		; ADD IN NUMBER OF WORDS TO BE TRANSFERRED
	CAIL A,4*PTPBLN		; COMPARE WITH TOTAL CHAR COUNT
	JRST PTPK2B		; CAN'T DO IT, LEAVE
	MOVSI A,(<POINT =8,0>)	; SET UP POINTER TO SYSTEM BUFFER
	HLLZ B,PTPUBP		; GET POINTER THAT IS ALREADY THERE
	JUMPN B,.+2		; IF NOT ALREADY SET UP . . .
	HLLM A,PTPUBP		; SET IT UP!!
	MOVEI B,1
	PSYNC PTPCSC

	MOVE B,PTPUBP		; BRING UP TO AN ACCUMULATOR FOR SPEED
PTPK2C:	MOVE A,B		; CHECK FOR WRAP-AROUND
	IBP A
	HRRZS A			; GET THE NEXT POINTED TO ADDRESS
	CAIL A,PTPBUF+PTPBLN	; RUN OFF END OF BUFFER?
	MOVE B,[POINT =8,PTPBUF]

	MOVE A,(POINTR)		; PICK UP CHARACTER (WORD)
	IDPB A,B		; PACK INTO SYSTEM BUFFER
	SOS PTPBCN		; UPDATE CHARACTER COUNT
	AOJ POINTR,		; UPDATE USER CORE POINTER
	SOJG COUNT,PTPK2C	; LOOP AROUND

	MOVEM B,PTPUBP		; STORE THIS BACK FOR NEXT TIME
	MOVEI B,1
	XSYNC PTPCSC
	PUSHJ PDP,ADVBFE	; LOAD IN ANOTHER BUFFER IF POSSIBLE
	JRST PTPK2A		; NOT POSSIBLE, EXIT
	JRST PTPK2		; GO THROUGH THE ENTIRE BIT AGAIN

PTPK2B:	PUSHJ PDP,PTPIOW	; START DEVICE AND WAIT UNTIL IT IS FINISHED
	JRST PTPK2		; THEN TRY AGAIN!!

; THIS IS FOR REAL BINARY MODE, WITH CHECKSUMS AND ALL
; BLT IN A SINGLE BUFFER, PUNCH IT, THEN PUNCH CHECKSUM AND FEEDER
; AFTER EVERY SINGLE BUFFERLOAD!

PTPK4:	HRRZ TAC1,PTPADR	; SET UP ADDRESS
	PUSHJ PDP,CKS12		; CALCULATE CHECKSUM OF BUFFER
	ADDI TAC1,@PTPADR	; GET ADDRESS OF FIRST WORD OF DATA
	HLLM TAC,@TAC1		; PUT THE CHECKSUM NEXT TO THE WORD COUNT
	PUSHJ PDP,DEVSTU	; SET UP POINTR AND COUNT
	JRST PTPK4A		; NO BUFFERS TO EMPTY?
	AOJ COUNT,		; FUDGE BY ONE TO LEAVE ROOM FOR CHECKSUM AND WORD COUNT WORD
	SOJ POINTR,		; BACK POINTER UP BY ONE TOO
	MOVEI A,6		; BINARY MODE, 6 CHARS PER WORD
	MOVEM A,PTPCPW
	PUSHJ PDP,PTPBBI	; BRING IN A SINGLE BUFFER
	JSP DAT,UERROR		; THERE BETTER BE ROOM!!
	SKIPGE PTPBCN		; ANYTHING IN BUFFER?
	JRST PTPK4B		; YES, PUNCH IT
PTPK4C:	PUSHJ PDP,ADVBFE	; NO, IS THERE ANOTHER BUFFER?
	POPJ PDP,		; NO, LET HIM FILL ONE
	JRST PTPK4		; YES, BRING IT IN

PTPK4A:	TLNE IOS,IOEND		; LAST UUO?
	JRST PTPK1D		; YES, SHUDDER!
	POPJ PDP,		; NO, LET HIM FILL SOME BUFFERS

PTPK4B:	HRLZI IOS,PTPFT		; THIS IS A 'FEED-WHEN-TERMINATING' SITUATION
	SETZ A,			; SO TELL THE INTERRUPT SERVICE ABOUT IT
	PUSHJ PDP,PTPSOW	; START DEVICE AND WAIT FOR IT TO STOP
	JRST PTPK4C		; LOOP BACK AGAIN AND AGAIN

; HERE, WE TRY TO FIT THE USER'S BUFFER INTO SYSTEM CORE

PTPBBI:	JUMPE COUNT,CPOPJ1	; ZERO-LENGTH BUFFER IS AN AUTOMATIC SUCCESS
	CAILE COUNT,PTPBLN	; SEE IF HE WANTS MORE THAN WE CAN GIVE
	JRST BTLERR		; YES, SCREW HIM!
	MOVEI B,1
	SKIPE PTPMOD		; FAST OR SLOW MODE?
	JRST PTPZZ0
	CONO PI,PTPOFF	; FAST MODE, DO CONO DIRECTLY
	JRST PTPZZ1
PTPZZ0:	PSYNC PTPCSC
PTPZZ1:	MOVE A,PTPIBP		; PICK UP INTERRUPT LEVEL BYTE POINTER
	IBP A			; THIS IS TO GET THE DISTANCE, IN WORDS, BETWEEN THE TWO POINTERS
	HRRZS A			; WHICH IS THE NUMBER OF AVAILABLE WORDS IN THE BUFFER
	MOVEI B,PTPBUF+PTPBLN	; WE ALSO NEED THE DISTANCE TO THE END OF THE BUFFER
	SUB B,PTPUBP		; FOR WRAP-AROUND PURPOSES
	SUB A,PTPUBP		; DISTANCE BETWEEN POINTERS
	JUMPLE A,PTPBB6		; POINTER WRAP-AROUND, SPECIAL CASE
PTPBB5:	CAMGE A,COUNT		; SEE IF THERE IS ULTIMATLY ROOM
	JRST PTPBB7		; NO, FAILURE
	JUMPE B,PTPBB2		; IF ZERO, IT IS A SPECIAL CASE
	HRLZ C,POINTR		; SET UP BLT WORD. SOURCE IS USER CORE
	HRR C,PTPUBP		; DESTINATION IS SYSTEM CORE
	CAMLE COUNT,B		; NOW WE DECIDE WHETHER WE MUST WRAP AROUND
	JRST PTPBB1		; YES, GO WRAP IT UP
	HRRZ B,PTPUBP		; NO, GET LAST WORD TO BE TRANSFERRED
	ADD B,COUNT		; BY ADDING THE SOURCE AND THE COUNT
	BLT C,-1(B)		; AND SUBTRACTING ONE AT INDEX TIME
	ADDM COUNT,PTPUBP	; UPDATE BUFFER CHARACTER POINTER
PTPBB3:	IMUL COUNT,PTPCPW	; UPDATE BUFFER CHARACTER COUNT TOO
	SUB COUNT,PTPBCN	; SUBTRACT OFF CURRENT COUNT
	MOVNM COUNT,PTPBCN	; CORRECT SIGN AND STORE
	AOS (PDP)		; SET TO SKIP, SUCCESS
PTPBB7:	SKIPE PTPMOD
	JRST PTPZZ3
	CONO PI,PTPON
	POPJ PDP,
PTPZZ3:	XSYNC PTPCSC
	POPJ PDP,
; COME HERE IF WE HAVE TO DO 2 SEPARATE BLT'S

PTPBB1:	BLT C,PTPBUF+PTPBLN-1	; FIRST BLT, TO END OF SYSTEM BUFFER
PTPBB2:	MOVE C,COUNT		; PICK UP WORD COUNT
	SUB C,B			; THIS IS NUMBER OF WORDS LEFT TO TRANSFER
	ADDI B,(POINTR)		; THIS IS PLACE TO START TRANSFERRING FROM
	HRLZS B			; SWAP IT
	HRRI B,PTPBUF		; DESTINATION IS START OF BUFFER
	BLT B,PTPBUF-1(C)	; TRANSFER REMAINDER OF BUFFER
	HRROI C,-PTPBLN(COUNT)	; WORD COUNT, WRAPPED AROUND
	ADDM C,PTPUBP		; UPDATE POINTER
	JRST PTPBB3

; COME HERE IF THE DIFFERENCE OF THE TWO POINTERS IS NEGATIVE

PTPBB6:	JUMPN A,.+2		; IF NON-ZERO, NOTHING TO WORRY ABOUT
	SKIPN PTPBCN		; ZERO. HMMM. IF COUNT IS NOT ZERO, THEN THERE IS NO ROOM IN THE INN!!
	ADDI A,PTPBLN		; ADD IN TOTAL BUFFER LENGTH
	JRST PTPBB5
; THIS ROUTINE SETS UP THE CRAZY DISPATCHES FOR EACH OF THE VARIOUS MODES OF OPERATION

PTPSUD:	PUSHJ PDP,PTPINI	; INITIALIZE TABLES
	ANDI IOS,117		; LEAVE ONLY THE MODE BITS IN IOS
	TLO IOS,IO+PTPBG1	; SET OUTPUT BIT AND FEED BIT
	MOVEM IOS,DEVIOS(DEVDAT)
	LDB A,PIOMOD		; PICK UP MODE BITS, BOTTOM 4 BITS IN IOS
	JUMPE A,PTPSKA		; MODES 0 AND 1 ARE IDENTICAL
	CAIN A,1
	JRST PTPSKA
	CAIN A,10		; MODE 10 - IMAGE MODE, 1 BYTE PER WORD
	JRST PTPSKB
	CAIN A,13		; MODE 13 - BINARY, NO CHECKSUMMING
	JRST PTPSKC
	CAIN A,14		; MODE 14 - BINARY WITH CHECKSUMMING
	JRST PTPSKD
	JSP DAT,UERROR		; IT REALLY CAN'T GET HERE.  - CAN IT?

PTPSKA:	MOVEI A,PTPK1		; UUO LEVEL KIND 1
	MOVE C,[POINT 7,PTPBUF]	; 7-BIT BYTES AT INTERRUPT LEVEL
	MOVEI B,PTPT2		; INTERRUPT LEVEL TYPE 2
	TRNE IOS,100		; CHECK FOR ALTERNATE MODES
	MOVEI B,PTPT1		; INT. LEVEL TYPE 1 - NON-PARITY 8TH HOLE, NO DELETES AFTER TABS
PTPSKE:	MOVEM A,PTPUDS		; UUO-LEVEL DISPATCH ADDRESS
	MOVEM B,PTPIDS		; INTERRUPT-LEVEL DISPATCH ADDRESS
	MOVEM C,PTPIBP		; INTERRUPD-LEVEL BYTE POINTER
	MOVEI A,PTPBUF		; SET UP UUO-LEVEL BUFFER POINTER
	MOVEM A,PTPUBP		; NOT A BYTE POINTER, JUST AN ADDRESS
	SETZM PTPBCN		; BUFFER IS EMPTY, CLEAR COUNT
	JRST PTPO1		; RETURN TO OUTPUT ROUTINE

PTPSKB:	MOVEI A,PTPK2		; UUO LEVEL KIND 2, PACK USER BUFFER INTO SYSTEM BUFFER
	MOVEI B,PTPT3		; INT LEVEL TYPE 3, 8-BIT BYTES
	MOVE C,[POINT =8,PTPBUF]
	JRST PTPSKE

PTPSKC:	MOVEI A,PTPK3		; UUO LEVEL KIND 3, BINARY MODES
	MOVEI B,PTPT1		; INT. LEVEL TYPE 1, PUNCH 8TH HOLE
	MOVE C,[POINT 6,PTPBUF]	; 6-BIT BYTES, 6 TO A WORD
	TRNE IOS,100		; THIS EFFECTS THE ANAL-CRANIAL INVERSION
	MOVEI B,PTPT3		; THIS MEANS DON'T PUNCH 7TH OR 8TH HOLE AT ALL
	JRST PTPSKE

PTPSKD:	TRNE IOS,100
	JRST PTPSKC		; 100 BIT HERE MEANS SOMETHING ENTIRELY DIFFERENT
	MOVEI A,PTPK4		; UUO LEVEL KIND 4, CHECKSUMM A LOT
	MOVEI B,PTPT1		; INT. LEVEL TYPE 1, PUT IN 8TH HOLE ALWAYS
	MOVE C,[POINT 6,PTPBUF]	; SET FOR 6-BIT BYTES
	JRST PTPSKE

; INTERRUPT SERVICE ROUTINES - OBOYOBOYOBOY!

↑PTPINT:
	JSR @PTPSAV		; SAVE ACCUMULATORS FIRST
	MOVEI DEVDAT,PTPDDB	; SET UP DEVDAT FOR EVERYBODY'S BENEFIT
	SKIPE PTPFCN		; ANY FEED COUNT LEFT?
	JRST PTPFED		; GO PUNCH A FEED HOLE OR TWO
	MOVEI B,2		; WE ARE P2
	SKIPN PTPMOD		; MUST WE SYNCHRONIZE?
	JRST PTPZZ2		; NO, SKIP IT
	PSYNC PTPCSC
PTPZZ2:	MOVE IOS,PTPIOS		; WE HAVE TO INSPECT THIS FIRST
	TLZE IOS,PTPBG1		; IS THIS THE FIRST BUFFERLOAD?
	JRST PTPF1		; YES, WE SHOULD PUNCH FEED FIRST
	TLZE IOS,PTPPDN		; DO WE HAVE A DANGLING DELETE?
	JRST PTPIDN		; YES, GO PUNCH IT
	SKIPN PTPBCN		; IS THERE ANYTHING IN THE SYSTEM BUFFER?
	JRST PTPOF		; NO, QUIT AND GO HOME
	AOS PTPBCN		; DECREMENT CHAR COUNT
	MOVE D,PTPIBP		; PICK UP BYTE POINTER
	IBP D			; INCREMENT POINTER TO CHECK FOR WRAP-AROUND
	HRRZ C,D		; GET ADDRESS PORTION
	CAIL C,PTPBUF+PTPBLN	; IS BYTE POINTER OUT OF RANGE?
	HRRI D,PTPBUF		; YES, RESET ADDRESS TO START OF BUFFER
	LDB C,D			; PICK UP CHARACTER
	MOVEM D,PTPIBP		; REPLACE BYTE POINTER
	JRST @PTPIDS		; AND PUNCH IT CORRECTLY

PTPT1:	ORI C,200		; TYPE 1 - ALWAYS PUNCH 8TH HOLE
PTPT3:	DATAO PTP,C		; TYPE 3 - NO MODIFICATION AT ALL
	LDB C,PDVTIM		; SET HUNG COUNT
	DPB C,PDVCNT
PTPXIT:	MOVEM IOS,PTPIOS	; THIS PROCESSOR OWNS IOS
	SKIPN PTPMOD
	POPJ PDP,
	XSYNC PTPCSC
	POPJ PDP,
; TYPE 2 - PUNCH PARITY AND DELETES AFTER CR, FF, VT AND  HT

PTPT2:	JUMPE C,PTPT3		; TYPE 2 - PARITY AND DELETES AFTER THESE CHARACTERS
	CAIE C,15		; C.R. RATES A DELETE
	CAIN C,11		; V.T. RATES A DELETE FOR THE LOSING ASR35
	TLO IOS,PTPPDN		; PUNCH DELETE NEXT TIME AROUND
	CAIN C,13		; V.T.
	TLO IOS,PTPPDN
	CAIN C,14		; F.F. MEANS PUNCH A LOT OF FEED
	JRST PTP2A
PTP2B:	MOVE D,C		; NOW COMPUTE PARITY ON THE CHARACTER
	IMULI D,200401		; MAKE 3 COPIES OF THE NUMBER
	AND D,[11111111]	; MAKES ONE COPY OF EACH BIT, EVERY 3RD BIT. NUMBER IS NOW SPREAD OUT
	IMUL D,[11111111]	; ADD UP BITS IN LH
	TLNE D,10		; NOW, DO WE NEED PARITY?
	IORI C,200		; YES, INSERT IT
	JRST PTPT3		; AND PUNCH CHAR

PTP2A:	MOVNI D,30		; PUNCH 30 FEED HOLES
	MOVEM D,PTPFCN		; SET THIS IN OUR REGISTER
	JRST PTP2B		; AND RETURN TO CALCULATE PARITY

; LAST PAGE - PUNCH FEED HOLES, SHUT OFF PTP

PTPF2:	MOVNI C,30		; PUNCH 30 HOLES FOR MODE 14
	CAIA
PTPF1:	MOVNI C,100		; STANDARD INITIAL AND FINAL FEED
	MOVEM C,PTPFCN		; INTO FEED COUNT REGISTER
	MOVEM IOS,PTPIOS	; STORE IOS
	SKIPN PTPMOD
	JRST PTPFED
	XSYNC PTPCSC		; SLOW MODE, RELEAS CONTROL OF IOS
PTPFED:	AOS PTPFCN		; DECREMENT FEED COUNT
	DATAO PTP,[0]		; GIVE IT A FEED WORD
	LDB C,PDVTIM		; SET HUNG COUNT
	DPB C,PDVCNT
	POPJ PDP,		; AND LEAVE

PTPIDN:	MOVEI C,377		; PUNCH A DELETE, FLAG HAS BEEN CLEARED
	JRST PTPT3

PTPOF:	TLZE IOS,PTPEN1		; OH MAMA, CAN THIS REALLY BE THE END?
	JRST PTPF1		; IT IS, FEED BEFORE LEAVING
	TLZE IOS,PTPFT		; IS THIS THE 'FEED WHEN TERMINATING' BIT?
	JRST PTPF2		; YES, DO IT
	CONO PTP,0		; CLEAR PTP REGISTERS
	HLLZS @PTPCON		; DON'T CONFUSE INTERRUPT SERVICE DISPATCHES
	SKIPE PTPMOD		; ARE WE IN FAST OR SLOW MODE?
	JRST PTPOF1		; SLOW MODE, SET A FLAG FOR P1 TO SEE
	TLZE IOS,IOW		; ARE WE IN AN IO WAIT?
	PUSHJ PDP,STTIOD	; YES, SET IO DONE
PTPOF2:	TLZ IOS,DEVSBB		; CLEAR BUSY FLAG, ALTHOUGH NOONE LOOKS AT IT
	SETZM PTPBCN		; BUFFER IS NOW EMPTY, MARK IT AS SUCH!
	JRST PTPXIT

PTPOF1:	TLZE IOS,IOW		; ARE WE IN AN IO WAIT?
	SETOM PTPSID		; YES, ASK TO CALL SETIOD FOR US
	JRST PTPOF2

BEND PTPSER
