COMMENT ⊗   VALID 00043 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00006 00002	SUBTTL IMP SERVICE - REGULAR MESSAGE HANDLING
C00007 00003	 REGULAR MESSAGE ON NON-ZERO LINK. HERE WE HAVE FOUND THE LINK TABLE ENTRY.
C00010 00004	 ALLOCATION UNDERFLOW ERROR
C00011 00005	 CONTROL MESSAGE
C00014 00006	 ERROR MESSAGES FOR LINK ZERO MESSAGES
C00016 00007	 NCP SECOND LEVEL PROTOCALL OPCODE DISPATCH TABLE
C00017 00008	 ALLOCATE. BUMP COUNTERS - RETURN, DECREMENT HIS COUNTERS
C00019 00009	 NOP - NO OPERATION AND COMDDS ERROR RETURNS
C00020 00010	 GVB COMMAND. THEY WANT US TO RETURN SOME STORAGE.
C00022 00011	 GVB COMMAND. HERE WE FORMAT A RET BLOCK
C00023 00012	 INTERRUPTS
C00024 00013	 REQUEST FOR CONNECTION
C00026 00014	 ROUTINE TO SET HOST NUMBER AND EITHER LINK OR BYTE SIZE
C00028 00015	 RFC PENDING. CLOCK REQUEST COMES BACK HERE
C00030 00016	 RFC CONTINUED. HERE THERE EXISTS A SOCKET.
C00033 00017	 RFC CONTINUED. HERE WE ARE GOING TO ESTABLISH A CONNECTION AND RETURN THE RFC
C00035 00018	 CLS COMMAND
C00038 00019	 CLS CONTINUED. HERE WE GOT A RECEIVE-SIDE CLS AND THERE IS A LINK TABLE ENTRY.
C00040 00020	 ECHO COMMAND
C00041 00021	 ERROR - INCOMMING!
C00042 00022	 RESET REPLY
C00043 00023	 RESET - PURGE OUR TABLES
C00046 00024	 RESET - SCAN DOWN THE QUEUED RFC LIST FOR ENTRIES BY THIS GUY
C00048 00025	 ERROR RECOVERY SYSTEM. POOT OUT MESSAGES TO EVERYONE WHO THINKS
C00050 00026	 ERROR RECOVERY FOR LINK ZERO
C00052 00027	 UTILITY ROUTINES FOR THE PRECEEDING ROUTINES - ERROR ROUTINE
C00054 00028	 ROUTINE TO DELETE A LINK IN THE LINK TABLE.
C00056 00029	 ROUTINE TO POLL ALL THE OTHER SITES FOR SIGNS OF LIFE
C00058 00030	 ROUTINE TO PERIODICALLY CHECK AND MAKE SURE ALL IS OK
C00060 00031	 ROUTINE TO SEND THE IMP SOME NOPS
C00062 00032
C00064 00033	 ROUTINE TO DUMP AN INCOMMING COMMAND INTO THE DATA PORTION OF AN ERROR MESSAGE
C00065 00034	 ROUTINE TO WAIT AT CLOCK LEVEL FOR A STANDARD FREE STORAGE BLOCK
C00066 00035	 ROUTINE TO RELEASE THE STORAGE IN A LIST
C00067 00036	 ROUTINE TO PLANT AN INTERRUPT REQUEST
C00068 00037	 ROUTINE TO UNLINK THE TOP MESSAGE ON THE INPUT LIST
C00070 00038	 ROUTINE TO SEND OUT A MESSAGE FROM CLOCK LEVEL ON LINK 0.
C00072 00039	 ROUTINE TO FIND A DDB FROM LINK NUMBER IN A SECOND LEVEL
C00074 00040	 ROUTINES TO PICK UP SOCKET NUMBERS AND STORE THEM FOR CLS, RTS, AND STR
C00075 00041	 ROUTINE TO RETURN A CLS TO THE HOST WHOSE MESSAGE IS IN AC1
C00076 00042	 ROUTINE TO MAKE UP A CLS BLOCK WITH EMPTY SOCKETS
C00077 00043	 SEND CLOSE TO FOREIGN HOST
C00078 ENDMK
C⊗;
SUBTTL IMP SERVICE - REGULAR MESSAGE HANDLING
; REGULAR MESSAGE

REGULAR:
	LDB AC2,ELINKP		; PICK UP HOST-LINK NUMBER
	TRNN AC2,377		; CONTROL MESSAGE?
	JRST L0REG		; YES, GO PICK UP NCP PROTOCAL OP-CODE
	SKIPN AC3,FFLNK
	JRST RMUNL
	SETZ DAT,
REGFRL:	CAMN AC2,LNKTAB-1(AC3)
	JRST REGCRS		; LINK NUMBER MATCHES, CHECK FOR RECEIVE-SIDE
REGINC:	SOJG AC3,REGFRL
	JUMPE DAT,UNL
RMUNL:	TELCTR(RWNOSS,<INPUT WITH NO RECEIVE SIDE>)
	JRST PSCAN

IWCNO:	TELCTR(NIWCNO,<INPUT WITH CONNECTION NOT ENTIRELY OPEN>)
	JRST PSCAN
; REGULAR MESSAGE ON NON-ZERO LINK. HERE WE HAVE FOUND THE LINK TABLE ENTRY.

REGCRS:	MOVE TEM,IMPLS-1(AC3)
	MOVEI DAT,(AC3)		; NOTE THAT WE FOUND A SOCKET OF SOME KIND
	TRNE TEM,1
	JRST REGINC		; SEND SIDE, SKIP THIS ONE.
	MOVE AC2,IMPSTB-1(AC3)	; PICK UP STATUS BITS
	TLC AC2,RFCR!RFCS
	TLNE AC2,RFCR!RFCS	; IS THE SOCKET ALL THE WAY OPEN?
	JRST IWCNO		; NO, MUST BE COMPLETELY OPEN TO RECEIVE MESSAGES
	SKIPN DDB,IMPDDB-1(AC3)	; PICK UP DDB ADDRESS IF ANY
	JRST NODDB
	MOVE IOS,DEVIOS(DDB)	; PICK UP IO STATUS WORD
	TLZE IOS,INPW		; IS HE WAITING FOR INPUT?
	PUSHJ P,QRUN		; YES, WAKE HIM UP
	MOVEM IOS,DEVIOS(DDB)
	MOVSI AC2,INTINP	; GIVE HIM AN INPUT INTERRUPT
	PUSHJ P,INTCOM
	LDB AC2,SIZEP		; PICK UP BYTE SIZE OF TRANSFER
	LDB AC3,COUNTP		; AND LENGTH OF TRANSFER
	IMULI AC2,(AC3)		; GET TOTAL NUMBER OF BITS IN TRANSFER
	ADDM AC2,BIIL(DDB)	; NOTE THIS MANY MORE BITS IN THE INPUT LIST
	MOVNS AC2
	ADDM AC2,HBA(DDB)	; DECREMENT BIT ALLOCATION
	AOS MIIL(DDB)		; AND THIS MANY MORE MESSAGES IN THE INPUT LIST
	SOSL HMA(DDB)		; DECREMENT MESSAGE ALLOCATION
	SKIPGE HBA(DDB)		; DID BIT ALLOCATION UNDERFLOW?
	JRST CTROVF		; YES, ERROR
	PUSHJ P,UNLNS		; POP MESSAGE OFF INPUT LIST
	SKIPN AC2,INL(DDB)	; DOES HE HAVE AN INPUT LIST?
	JRST REG1		; NO, START ONE
	MOVSS AC2		; GET POINTER TO LAST BLOCK IN RH
	HRLM AC1,TLINK(AC2)	; LINK US ONTO HIS TAIL
REG2:	HRLM AC1,INL(DDB)	; PUT US IN AS NEW LAST ELEMENT
	HRRZS TLINK(AC1)	; NOTE THAT NOONE FOLLOWS US
	JRST IMPCLK

REG1:	HRRM AC1,INL(DDB)	; PUT US IN AS FIRST ELEMENT
	JRST REG2
; ALLOCATION UNDERFLOW ERROR

CTROVF:	ORI IOS,CTROV!IODERR
	MOVEM IOS,DEVIOS(DDB)
	PUSH P,AC1		; SEND ERROR MESSAGE TO HOST
	PUSHJ P,MAKERB		; MAKE UP AN ERROR BLOCK
	PUSHJ P,CLKWAIT
	PUSHJ P,OFILL		; TAG ON HIS MESSAGE
	MOVEI AC3,CTO
	DPB AC3,BYTE3P
	PUSHJ P,CLKOUT		; SEND IT OUT
	POP P,AC1
	JRST PSCAN

; UNKNOWN LINK ERROR

SLUNL:	TELCTR(SLUNLK,<UNKNOWN LINK IN REGULAR MESSAGE>)
	PUSHJ P,UNLMER
	JRST L0XIT
; CONTROL MESSAGE

L0REG:	LDB AC3,SIZEP		; YES, CHECK BYTE SIZE
	CAIE AC3,10		; BETTER BE 8
	JRST ILLBS		; ILLEGAL, GIVE ERROR
	MOVEI AC3,(AC1)		; SEPARATE OUT INPUT BLOCK ADDRESS
	HRLI AC3,441000		; MAKE UP AN 8-BIT BYTE POINTER FOR IT
	ADDI AC3,TDATA+2	; MAKE IT POINT AT THE FIRST OPCODE
	MOVEM AC3,TBP(AC1)	; SAVE IT IN INPUT BLOCK
L0MORE:	ILDB DSER,TBP(AC1)	; PICK UP OPCODE
	CAIL DSER,OPMAX		; IS IT A LEGAL OPCODE?
	JRST RILLO		; NO, GIVE ERROR
	LDB AC3,COUNTP		; PICK UP LENGTH OF MESSAGE
	LDB TAC,[POINT 9,OPTAB(DSER),8]
	CAIL AC3,(TAC)		; IS COMMAND AS LONG AS IT SHOULD BE?
	JRST L0CDSP		; YES, DISPATCH
	TELCTR(BCMM,<SHORT CONTROL COMMAND>)
	PUSH P,AC1		; SAVE INPUT MESSAGE
	PUSHJ P,MAKERB		; MAKE UP AN ERROR BLOCK
	PUSHJ P,CLKWAIT
	PUSHJ P,EFILL		; TAG ON HIS LEADER
	MOVEI AC3,SPS		; GIVE HIM SHORT PARAMETER ERROR
RERR1:	DPB AC3,BYTE2P
RERR2:	PUSHJ P,CLKOUT
	POP P,AC1
	JRST PSCAN

L0CDSP:	SUBI AC3,(TAC)		; SHORTEN TOTAL MESSAGE BY THIS MUCH
	DPB AC3,COUNTP		; AND THIS IS THE NEW MESSAGE LENGTH
	JRST @OPTAB(DSER)

L0XIT:	HRRZ AC1,ILIST		; PICK UP POINTER TO MESSAGE
	LDB AC2,COUNTP		; SEE IF THERE IS ANYTHING LEFT IN THIS MESSAGE
	JUMPE AC2,PSCAN
	JRST L0MORE
; ERROR MESSAGES FOR LINK ZERO MESSAGES

RILLO:	SKIPE RECOVER
	JRST PSCAN		; IF ERROR RECOVERY IN PROGRESS, TOLERATE A BIT OF FOOLISHNESS
	SETOM RECOVER		; OTHERWISE INITIATE RECOVERY SEQUENCE
	TELCTR(NILLOP,<ILLEGAL OPCODE>)
	PUSH P,AC1
	PUSHJ P,MAKERB
	PUSHJ P,CLKWAIT
	PUSHJ P,EFILL
	MOVEI AC3,ILO
	JRST RERR1

ILLBS:	SKIPE RECOVER
	JRST PSCAN		; IF ERROR RECOVERY IN PROGRESS, TOLERATE A BIT OF FOOLISHNESS
	SETOM RECOVER		; OTHERWISE INITIATE RECOVERY SEQUENCE
	TELCTR(BSILL,<ILLEGAL BYTE SIZE ON CONTROL COMMAND>)
	PUSH P,AC1
	PUSHJ P,MAKERB
	PUSHJ P,CLKWAIT
	PUSHJ P,OFILL
	MOVEI AC3,ILB
	DPB AC3,BYTE3P
	JRST RERR2
; NCP SECOND LEVEL PROTOCALL OPCODE DISPATCH TABLE

DEFINE Z (LENGTH,DSP) <XWD LENGTH*1000,DSP>

OPTAB:	Z(1,SNOPCN)	; NO OPERATION
	Z(12,IRTS)	; REQUEST FOR CONNECTION, RECEIVER TO SENDER
	Z(12,ISTR)	; REQUEST FOR CONNECTION, SENDER TO RECEIVER
	Z(11,ICLS)	; CLOSE
	Z(10,IALL)	; ALLOCATE
	Z(4,IGVB)	; GIVE BACK STORAGE
	Z(10,IRET)	; STORAGE RETURNED
	Z(2,IINR)	; INTERRUPT BY RECEIVER
	Z(2,IINS)	; INTERRUPT BY SENDER
	Z(2,IECO)	; ECHO REQUEST
	Z(2,IERP)	; ECHO REPLY
	Z(14,IERR)	; ERROR
	Z(1,IRST)	; RESET
	Z(1,IRRP)	; RESET REPLY

OPMAX←←.-OPTAB
; ALLOCATE. BUMP COUNTERS - RETURN, DECREMENT HIS COUNTERS

IALL:	PUSHJ P,COMDDS		; PICK UP DDB OF CONNECTION
	JRST SLUNL		; NON-EX CONNECTION
	JRST RD6NSE		; NO SEND SOCKET
	JRST RD6CC		; CONNECTION CLOSED OR NO DDB
	PUSHJ P,RD2B		; GET 16 CONSECUTIVE BITS INTO AC2
	ADDM AC2,MAL(DDB)	; BUMP HIS MESSAGE ALLOCATION
	PUSHJ P,RD4B		; GET 32 BIT DATUM
	ADDM AC2,BAL(DDB)	; BUMP BIT COUNTER
	MOVE IOS,DEVIOS(DDB)
	TLZE IOS,ALLW		; WAITING FOR ALLOCATION
	PUSHJ P,QRUN		; YES, WAKE HIM UP
	MOVEM IOS,DEVIOS(DDB)
	JRST L0XIT

; RTN COMMAND.

IRET:	PUSHJ P,COMDDR		; PICK UP DDB OF A RECEIVE-SIDE CONNECTION
	JRST SLUNL		; NON-EX CONNECTION
	JRST RD6NSE		; NO RECEIVE SIDE CONNECTION
	JRST RD6CC		; CONNECTION CLOSED
	PUSHJ P,RD2B		; PICK UP MESSAGE ALLOCATION
	MOVNS AC2
	ADDM AC2,HMA(DDB)	; HE NOW HAS THAT MUCH LESS ALLOCATION
	PUSHJ P,RD4B		; GET BIT ALLOCATION
	MOVNS AC2
	ADDM AC2,HBA(DDB)
	JRST L0XIT		; END OF OPERATION
; NOP - NO OPERATION AND COMDDS ERROR RETURNS

SNOPCN:	AOS SLNOPS		; BUMP COUNT OF SECOND LEVEL NO-OPERATIONS
	JRST L0XIT

; ERROR RETURNS FOR COMDDS CALLERS

RD6NSE:	PUSHJ P,RD4B		; PUSH BYTE POINTER ALONG
RD2NSE:	PUSHJ P,RD2B
RCCANS:	TELCTR(NSSC,<NO SEND-SIDE CONNECTION>)
	JRST L0XIT

RD6CC:	PUSHJ P,RD4B
RD2CC:	PUSHJ P,RD2B
	AOS NALWNC
	JRST L0XIT
; GVB COMMAND. THEY WANT US TO RETURN SOME STORAGE.

IGVB:	PUSHJ P,COMDDS
	JRST RD2NSE
	JRST RD2CC
	JRST SLUNL
	ILDB AC2,TBP(AC1)	; PICK UP FIRST FRACTION BYTE
	CAILE AC2,200		; FRACTION GREATER THAN ONE?
	MOVEI AC2,200		; YES, GIVE IT ALL BACK
	IMUL AC2,MAL(DDB)	; SEE HOW MUCH HE WANTS
	TRNE AC2,177		; ROUND UP ALWAYS
	ADDI AC2,200
	LSH AC2,-7		; AND THIS IS NUMBER OF BITS HE WANTS
	PUSH P,AC2
	MOVNS AC2
	ADDM AC2,MAL(DDB)

	ILDB AC2,TBP(AC1)	; GET NEXT BYTE
	CAILE AC2,200		; FRACTION GREATER THAN ONE?
	MOVEI AC2,200		; YES, GIVE IT ALL BACK
	IMUL AC2,BAL(DDB)	; SEE HOW MUCH HE WANTS
	TRNE AC2,177		; ROUND UP ALWAYS
	ADDI AC2,200
	LSH AC2,-7		; AND THIS IS NUMBER OF BITS HE WANTS
	PUSH P,AC2
	MOVNS AC2
	ADDM AC2,BAL(DDB)
; GVB COMMAND. HERE WE FORMAT A RET BLOCK

	PUSH P,AC1
	PUSHJ P,IMPGET		; GET SOME STORAGE FOR A RET COMMAND
	PUSHJ P,CLKWAIT
	POP P,AC2
	MOVE AC2,TDATA(AC2)
	MOVEM AC2,TDATA(AC1)
	SETZM TDATA+1(AC1)
	SETZM TDATA+2(AC1)
	MOVEI AC3,10
	DPB AC3,SIZEP		; BOTH SIZE AND COUNT ARE 8 BYTES
	DPB AC3,COUNTP
	MOVEI AC3,RET
	DPB AC3,OPCDP
	LDB AC3,[POINT 8,TDATA+2(AC2),15]
	DPB AC3,OLINKP		; PUT IN LINK
	POP P,AC3
	LSH AC3,4
	MOVEM AC3,TDATA+3(AC1)
	POP P,AC3		; PUT ALLOCATIONS BEING RETURNED IN FIRST 32 BITS
	DPB AC3,[POINT 16,TDATA+2(AC2),31]
	MOVEI AC3,4
	MOVEM AC3,TWC(AC1)
	PUSHJ P,CLKOUT
	JRST L0XIT
; INTERRUPTS

IINR:	PUSHJ P,COMDDS
	JRST SLUNL
	JRST RCCANS
	JRST L0XIT
	MOVSI AC2,INTINR	; INTERRUPT BY RECEIVER
	ORM AC2,IMPSTB-1(AC3)	; PUT IN STATUS BITS TOO
	PUSHJ P,INTCOM
	JRST L0XIT

IINS:	PUSHJ P,COMDDR
	JRST SLUNL
	JRST RCCANS
	JRST L0XIT
;	JRST SLUNL		; ?? comddr only has 4 returns, not 5
	MOVSI AC2,INTINS	; INTERRUPT BY SENDER
	ORM AC2,IMPSTB-1(AC3)
	PUSHJ P,INTCOM
	JRST L0XIT
; REQUEST FOR CONNECTION

XTTIME←←TDATA
SOCK1←←TDATA+1		; BLOCK LOCATIONS FOR PENDING MESSAGES
SOCK2←←TDATA+2

IRTS:
ISTR:	PUSHJ P,RD4B		; GET FIRST SOCKET NUMBER (FOREIGN SOCKET)
	MOVE UUO,AC2		; SAVE FOREIGN SOCKET IN UUO
	PUSHJ P,RD4B
	MOVE JDAT,AC2		; SAVE LOCAL SOCKET NUMBER IN JDAT
	SKIPN AC3,FFLNK		; SCAN LINK TABLE FOR IT
	JRST MAKPND
ISTRL:	CAMN AC2,IMPLS-1(AC3)
	JRST ISTRFS
	SOJG AC3,ISTRL
MAKPND:	AOS AC3,FFLNK		; MAKE UP NEW INDEX NUMBER
	CAILE AC3,MAXNLK	; OVERFLOWED TABLES?
	JRST NOLNK		; YES, CANNOT ACCEPT RFC
	SETZM IMPDDB-1(AC3)
	MOVEM AC2,IMPLS-1(AC3)
	MOVEM UUO,IMPFS-1(AC3)
	SETZM IMPRFQ-1(AC3)	; CLEAR OUT OLD GARBAGE
	PUSHJ P,SETHLB		; SET HOST NUMBER AND EITHER BYTE SIZE OR LINK NUMBER
MAKPN:	PUSHJ P,IMPGET		; GET A BLOCK FOR PENDING MESSAGE
	PUSHJ P,CLKWAIT
	MOVEM JDAT,SOCK2(AC1)	; SAVE SOCKET NUMBER
	MOVEM UUO,SOCK1(AC1)
	HRLI AC1,PNDG		; MAKE IT PEND IN A CLOCK QUEUE REQUEST
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
	MOVEI AC2,4*=60*JIFSEC
	MOVEM AC2,XTTIME(AC1)	; WE WILL PEND FOR 4 MINUTES
	MOVSI AC2,RFCR!ANYC
	MOVEM AC2,IMPSTB-1(AC3)	; NOTE THAT A STR HAS BEEN RECEIVED
	JRST L0XIT
; ROUTINE TO SET HOST NUMBER AND EITHER LINK OR BYTE SIZE

SETHLB:	LDB AC2,SRCP		; SET HOST NUMBER IF NOT ALREADY SET
	DPB AC2,[POINT 8,LNKTAB-1(AC3),27]
	ILDB AC2,TBP(AC1)	; PICK UP SIZE FIELD
SETHB:	CAIN DSER,STR		; IF SENDER TO RECEIVER,
	MOVEM AC2,IMPBS-1(AC3)	; THEN LET HIM SET THE BYTE SIZE
	CAIN DSER,RTS		; OTHERWISE, LET HIM SET LINK NUMBER
	DPB AC2,[POINT 8,LNKTAB-1(AC3),35]
	POPJ P,

; GET HERE IF THERE IS NO MORE ROOM IN THE LINK TABLE

NOLNK:	IBP TBP(AC1)		; SKIP OVER SIZE-LINK FIELD
	PUSHJ P,RTNCLS		; SEND HIM BACK A CLOSE
	SOS FFLNK		; UNDO THE DAMAGE
	TELCTR(NNOLNK,<RFC RECEIVED BUT NOT LINK AVAILABLE>)
	JRST L0XIT		; INCOMMING MESSAGE HAS BEEN USED FOR THE CLOSE
; RFC PENDING. CLOCK REQUEST COMES BACK HERE

PNDG:	MOVEI AC1,(DAT)
	SKIPN AC3,FFLNK		; FIND INDEX OF PARTIAL CONNECTION
	JRST RELLST		; IF NONE, FORGET IT
	MOVE AC2,SOCK2(AC1)	; PICK UP LOCAL SOCKET NUMBER
	MOVE UUO,SOCK1(AC1)
PNDGL:	CAMN AC2,IMPLS-1(AC3)
	CAME UUO,IMPFS-1(AC3)
	JRST PNDGI
	MOVE TEM,IMPSTB-1(AC3)	; PICK UP STATUS BITS
	TLNE TEM,RFCS!CLSR!CLSS
	JRST RELLST		; IF ANYTHING HAS HAPPENED ON THE LINE, LEAVE
PNDGN:	SOSLE XTTIME(AC1)	; OTHERWISE, COUNT DOWN
	JRST DPYTIM
	PUSH P,AC1
	PUSHJ P,IMPGET		; SEND HIM A CLS
	JRST [	POP P,AC1
		JRST DPYTIM]
	PUSHJ P,SNCLS		; SEND A CLOSE
	POP P,AC1
	JRST RELLST

PNDGI:	SOJG AC3,PNDGL
	JRST RELLST
; RFC CONTINUED. HERE THERE EXISTS A SOCKET.

ISTRFS:	MOVE DAT,IMPSTB-1(AC3)	; PICK UP STATUS BITS
	TLNE DAT,RFCS		; HAS AN RFC BEEN SENT TO IT?
	JRST CLRFCW		; YES, CONNECTION HAS BEEN MADE
	SKIPN LNKTAB-1(AC3)	; IS HOST NUMBER INITIALIZED?
	JRST CHKFSK		; NO, OURS WILL WORK THEN
	LDB DAT,ELINKP		; PICK UP HOST NUMBER
	XOR DAT,LNKTAB-1(AC3)
	TRNN DAT,177400		; TWO RFC'S?
	JRST ISTRMP		; YES, CHECK FOR UNOPENED SIDE OF CONNECTION
ISTRF3:	MOVEI TEM,(AC1)
	PUSHJ P,IMPGET
	PUSHJ P,CLKWAIT
	DPB DSER,OPCDP		; MAKE UP NEW INPUT MESSAGE BLOCK
	MOVE AC2,UUO		; WITH JUST THIS RFC IN IT
	PUSHJ P,PSOCK1
	MOVE AC2,JDAT
	PUSHJ P,PSOCK2
	ILDB AC2,TBP(TEM)	; PICK UP SIZE-LINK FIELD
	DPB AC2,SZLKP
	MOVE AC2,TDATA(TEM)	; GET LEADER
	MOVEM AC2,TDATA(AC1)
	SETZM TDATA+1(AC1)
	MOVEI AC2,10
	DPB AC2,SIZEP
	MOVEI AC2,12
	DPB AC2,COUNTP
	SKIPN AC2,IMPRFQ-1(AC3)	; SEE IF THERE IS A WAITING RFC LIST
	JRST ISTRF2		; NO, WE ARE ONLY ELEMENT
	MOVSS AC2		; POINT US TO TAIL OF LIST
	HRLM AC1,TLINK(AC2)
ISTRF1:	HRLM AC1,IMPRFQ-1(AC3)
	HRRZS TLINK(AC1)
	JRST L0XIT

ISTRF2:	HRRM AC1,IMPRFQ-1(AC3)
	JRST ISTRF1

CLRFCW:	LDB AC2,ELINKP		; PICK UP HOST #
	XOR AC2,LNKTAB-1(AC3)
	TRNE AC2,177400		; SAME HOST NUMBER?
	JRST ISTRF3		; NO, QUEUE RFC
ISTRMP:	TLNN DAT,RFCR		; HAS THIS SIDE OF THE CONNECTION BEEN ESTABLISHED?
	JRST CHKFSK		; NO, PUT US IN THERE
	CAME UUO,IMPFS-1(AC3)	; DOES THE FOREIGN SOCKET MATCH?
	JRST ISTRF3		; NO, QUEUE US UP
TWORFC:	AOS N2RFCS
	IBP TBP(AC1)
	JRST L0XIT
; RFC CONTINUED. HERE WE ARE GOING TO ESTABLISH A CONNECTION AND RETURN THE RFC

CHKFSK:	SKIPL IMPFS-1(AC3)	; HAS SOCKET BEEN INITIALIZED
	CAMN UUO,IMPFS-1(AC3)	; YES, DOES IT MATCH
	JRST CLRFC1		; YES, COMPLETE CONNECTION
	JRST ISTRF3		; NO, QUEUE US UP

CLRFC1:	MOVEM UUO,IMPFS-1(AC3)
	PUSHJ P,SETHLB		; SET HOST NUMBER AND LINK (OR BYTE SIZE)
	MOVSI AC2,RFCR
	PUSHJ P,CSTAT		; CHANGE STATUS BITS
	SKIPN DDB,IMPDDB-1(AC3)
	JRST MAKPN
	MOVSI AC2,RFCS
	TDNE AC2,IMPSTB-1(AC3)	; HAVE WE ALREADY SENT HIM AN RFC?
	JRST CLRFC2		; YES, SKIP OVER THIS PART
	PUSHJ P,IMPGET		; GET US SOME F.S.
	PUSHJ P,CLKWAIT		; WAIT FOR IT IF NECESSARY
	PUSHJ P,CLRBLK
	CAIN DSER,RTS		; SEND HIM THE OPPOSITE FLAVOR RFC
	MOVEI TEM,STR
	CAIN DSER,STR
	MOVEI TEM,RTS
	DPB TEM,OPCDP
	PUSHJ P,MAKRF		; SET THE REST OF THE MESSAGE, SOCKETS, BYTE SIZE OR LINK, ETC.
	PUSHJ P,CLKOUT
CLRFC2:	MOVE IOS,DEVIOS(DDB)
	TLZE IOS,RFCW
	PUSHJ P,QRUN
	MOVEM IOS,DEVIOS(DDB)
	JRST L0XIT
; CLS COMMAND

ICLS:	PUSHJ P,RD4B		; PICK UP FOREIGN SOCKET
	MOVE UUO,AC2
	PUSHJ P,RD4B
	MOVE JDAT,AC2
	SKIPN AC3,FFLNK
	JRST RTCL		; NOBODY HOME.
ICLSL:	CAMN JDAT,IMPLS-1(AC3)
	JRST RCLSRC		; RECEIVE SIDE SOCKET FOUND
	SOJG AC3,ICLSL
RTCL:	AOS NSCLSS		; BUMP NUMBER OF STRANGE CLSS
	JRST L0XIT

RCLSRC:	LDB AC2,ELINKP		; PICK UP HOST-LINK NUMBER
	XOR AC2,LNKTAB-1(AC3)
	CAMN UUO,IMPFS-1(AC3)	; FOREIGN SOCKET MUST MATCH TOO
	TRNE AC2,177400
	JRST CLSRFQ		; MISMATCH SOMEWHERE, CHECK RFQ LIST
	JRST SRCLSR		; SAME HOST, 

; HERE, WE HAVE RECEIVED A CLS FROM A HOST THAT IS NOT ACTIVE.
; SEE IF HE IS IN THE RFC QUEUE FOR THIS SOCKET. IF NOT, IGNORE IT.
; SHOULD CHECK FOR MATCHING FOREIGN SOCKET

CLSRFQ:	LDB DAT,SRCP		; PICK UP HOST NUMBER
	PUSHJ P,RTNCLS		; SEND RETURN CLOSE
	SETZ TAC1,		; CLEAR LAST ITEM POINTER
	SKIPN AC1,IMPRFQ-1(AC3)
	JRST QLEAVE
QL1:	LDB DSER,SRCP		; PICK UP HOST NUMBER
	CAIE DAT,(DSER)		; SAME HOST?
	JRST QLOOP		; NO, GET ANOTHER ONE
	PUSHJ P,GSOCK1
	CAME AC2,UUO		; IS THIS THE SAME ONE?
	JRST QLOOP
	PUSHJ P,UNLRFQ		; YES, UNLINK QUEUED RFC FROM LIST
	PUSHJ P,RELLST		; FLUSH IT
QLEAVE:	JRST L0XIT

QLOOP:	MOVE TAC1,AC1
	HLRZ AC1,TLINK(AC1)
	JUMPN AC1,QL1
	JRST QLEAVE
; CLS CONTINUED. HERE WE GOT A RECEIVE-SIDE CLS AND THERE IS A LINK TABLE ENTRY.

SRCLSR:	MOVSI AC2,CLSR		; HERE WE ARE THE HOST IN QUESTION
	PUSHJ P,CSTAT		; CHANGE THE CONNECTION STATUS
	SKIPN DDB,IMPDDB-1(AC3)	; ANYBODY HOME?
	JRST CHCLSS		; NO
	MOVE IOS,DEVIOS(DDB)	; YES, DOES HE THINK HE WILL GET SOME MORE INPUT?
	TLZE IOS,ANYW
	PUSHJ P,QRUN		; YES, BRING HIM OUT OF WAIT
	MOVEM IOS,DEVIOS(DDB)	; SO HE WILL GET EOF
CHCLSS:	MOVE AC2,IMPSTB-1(AC3)
	TLNE AC2,CLSS		; RECEIVE-SIDE CLS SENT?
	JRST SRCLWK		; YES, SEE IF HE IS WAITING FOR US
	PUSHJ P,IMPGET		; GET SOME STORAGE
	PUSHJ P,CLKWAIT
	PUSHJ P,SNCLS		; RETURN A CLS TO HIM
SRCLWK:	SKIPN DDB,IMPDDB-1(AC3)
CALLZL:	PUSHJ P,ZEROLK		; NO, CLEAR THE LINK IF WE CAN
	JRST L0XIT
; ECHO COMMAND

IECO:	PUSH P,AC1
	PUSHJ P,IMPGET
	PUSHJ P,CLKWAIT
	MOVE AC2,(P)		; PICK UP ADDRESS OF INCOMING MESSAGE
	MOVE AC3,TDATA(AC2)	; TURN MESSAGE RIGHT AROUND
	MOVEM AC3,TDATA(AC1)
	SETZM TDATA+1(AC1)
	MOVEI AC3,10
	DPB AC3,SIZEP		; PUT IN BYTE SIZE
	MOVEI AC3,2
	DPB AC3,COUNTP		; AND MESSAGE LENGTH
	ILDB AC3,TBP(AC2)	; PICK UP ECHO BYTE
	DPB AC3,BYTE2P		; AND GIVE IT BACK TO HIM
	MOVEI AC3,ERP		; PUT ECHO REPLY OPCODE IN WITH DATA BYTE INPUTTED
	DPB AC3,OPCDP
	PUSHJ P,CLKOUT
	POP P,AC1
	JRST L0XIT

; ECHO REPLY

IERP:	JRST RILLO		; WE DON'T SEND ECOS
; ERROR - INCOMMING!

IERR:	AOS RERRM
	PUSH P,AC1
	PUSHJ P,DISDATE
	PUSH P,TDATA(AC1)
	PUSHJ P,DISERR
	[ASCIZ /IMP - WE GOT AN ERROR MESSAGE, #/]
	DISARG DEC,RERRM
	[ASCIZ /
/]
	DISARG OCT,<-1(P)>
	[ASCIZ /
/]
	-1
	SUB P,[XWD 1,1]
	POP P,AC1
	MOVEI TAC1,13
	PUSH P,TAC1
	PUSH P,AC1
IEPLOP:	ILDB TAC,TBP(AC1)
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ / /
	MOVE AC1,(P)
	SOSLE -1(P)
	JRST IEPLOP
	PUSHJ P,DISMES
	ASCIZ /
/
	POP P,AC1
	SUB P,[XWD 1,1]
	JRST L0XIT
; RESET REPLY

IRRP:	JRST L0XIT
; RESET - PURGE OUR TABLES

IRST:	AOS NRSETS
	PUSHJ P,FLCWL0		; FLUSH ALL PENDING MESSAGES TO THIS HOST
	PUSH P,AC1
	PUSHJ P,IMPGET		; GET FREE STORAGE FOR A RESET REPLY
	PUSHJ P,CLKWAIT
	PUSHJ P,CLRBLK
	MOVE AC2,(P)
	MOVE AC3,TDATA(AC2)	; STEAL THE LEADER FROM THE INCOMMING MESSAGE
	MOVEM AC3,TDATA(AC1)
	SETZM TDATA+1(AC1)
	MOVEI AC3,10
	DPB AC3,SIZEP
	MOVEI AC3,1
	DPB AC3,COUNTP
	MOVEI AC3,3
	MOVEM AC3,TWC(AC1)	; WE WILL SEND OUT THE LEADER AND ONE EXTRA WORD
	MOVEI AC3,RRP		; SET RESET REPLY OPCODE
	DPB AC3,OPCDP
	PUSHJ P,CLKOUT
	POP P,AC1
	LDB AC2,ELINKP		; PICK UP HOST-LINK NUMBER (LINK=0)
	SKIPN AC3,FFLNK		; SCAN LINK TABLE FOR OPEN CONNECTIONS TO HIM
	JRST L0XIT
IRST2:	MOVEI TAC,(AC2)
	XOR TAC,LNKTAB-1(AC3)
	TRNN TAC,177400
	JRST IRST1
IRST3:	SKIPE AC1,IMPRFQ-1(AC3)	; DOES THIS ENTRY HAVE ANY QUEUED RFCS?
	JRST SCNIRF		; YES, SEE IF HE HAS SOME ENTRIES QUEUED
IRST5:	SOJG AC3,IRST2
	JRST L0XIT

IRST1:	SKIPE DDB,IMPDDB-1(AC3)	; DOES HE HAVE A DDB?
	JRST IRST4		; YES, SET ERROR BITS
	SKIPE AC1,IMPRFQ-1(AC3)
	PUSHJ P,APNLST		; APPEND ENTIRE RFC QUEUE ONTO ILIST FOR RE-INTERPRETATION
	PUSHJ P,KILLNK		; NO, DELETE THE LINK ENTIRELY
	JRST IRST3

IRST4:	MOVE IOS,DEVIOS(DDB)	; CLEAR ANY WAIT STATE
	TLZE IOS,ANYW
	PUSHJ P,QRUN
	ORI IOS,RSET!IODERR
	MOVEM IOS,DEVIOS(DDB)
	MOVSI AC2,CLSS!CLSR	; PRETEND CONNECTION IS CLOSED
	PUSHJ P,CSTAT		; GIVE HIM THE INTERRUPT
	MOVE AC2,IMPLS-1(AC3)	; PICK UP LOCAL SOCKET NUMBER
	TRNN AC2,1		; IS OUR SIDE THE SEND SIDE?
	JRST IRST3		; NO
	SETZM BAL(DDB)		; YES, NO MORE MESSAGES, PLEASE
	SETZM MAL(DDB)
	JRST IRST3
; RESET - SCAN DOWN THE QUEUED RFC LIST FOR ENTRIES BY THIS GUY

SCNIRF:	SETZ TAC1,		; SET PREDECESSOR TO ZERO
SCNNXR:	PUSHJ P,LEGAL		; BLESS THIS BLOCK
	JRST [	SETZM IMPRFQ-1(AC3)
		JRST IRST5]
	LDB TAC,ELINKP
	CAIE TAC,(AC2)
	JRST SCNGNX
	PUSH P,AC2
	PUSH P,TLINK(AC1)	; SAVE POINTER TO SUCCESSOR
	PUSHJ P,UNLRFQ		; UNLINK RFC FROM LIST
	PUSHJ P,RELLST		; RELEASE THE STORAGE
	POP P,AC1		; GET BACK SUCCESSOR
	HLRZS AC1		; GET POINTER INTO RIGHT HALF
	POP P,AC2		; GET BACK SOURCE NUMBER
	JRST SCNCZ

SCNGNX:	MOVEI TAC1,(AC1)	; SET PREDECESSOR TO CURRENT
	HLRZ AC1,TLINK(AC1)	; MOVE DOWN THE LIST
SCNCZ:	JUMPN AC1,SCNNXR
	JRST IRST5
; ERROR RECOVERY SYSTEM. POOT OUT MESSAGES TO EVERYONE WHO THINKS
; HIS LINK IS BLOCKED. WE WILL THEN GET BACK EITHER A BLOCKED LINK
; OR A RFNM, BUT  IN ANY CASE THE LINK WILL BE CLEARED.

ERRREC:	SKIPL RECOVER
	JRST ERRCNT
	SKIPN AC3,FFLNK
	JRST ERRL0
ERRNXD:	SKIPN DDB,IMPDDB-1(AC3)
	JRST ERRLIN
	MOVE IOS,DEVIOS(DDB)
	TRNN IOS,BLOK
	JRST ERRLIN
	PUSHJ P,IMPGET
	PUSHJ P,CLKWAIT
	SETZM TDATA(AC1)
	SETZM TDATA+1(AC1)
	SKIPN AC2,IMPBS-1(AC3)
	MOVEI AC2,10
	DPB AC2,SIZEP
	MOVE AC2,LNKTAB-1(AC3)
	DPB AC2,ELINKP
	MOVEI AC2,2
	MOVEM AC2,TWC(AC1)
	PUSHJ P,CLKOUT		; OUTPUT A ZERO LENGTH MESSAGE
ERRLIN:	SOJG AC3,ERRNXD
; ERROR RECOVERY FOR LINK ZERO

ERRL0:	MOVEI AC3,7		;INDEX OF LAST WORD IN L0BLOK TABLE
ERRL0L:	SKIPN TEM,L0BLOK(AC3)
	JRST ERRL0I
	MOVEI DAT,1
	SETZ TAC,
ERRL0T:	TDNN DAT,TEM
	JRST ERRL0R
	PUSHJ P,IMPGET
	PUSHJ P,CLKWAIT
	SETZM TDATA(AC1)
	SETZM TDATA+1(AC1)
	SETZM TDATA+2(AC1)
	MOVEI TAC1,3
	MOVEM TAC1,TWC(AC1)
	MOVEI TAC1,10
	DPB TAC1,SIZEP
	MOVEI TAC1,1
	DPB TAC1,COUNTP
	MOVEI TAC1,(AC3)
	LSH TAC1,5
	ORI TAC1,(TAC)
	DPB TAC1,SRCP
	PUSHJ P,QOUT		; BYPASS LINK BLOKAGE
ERRL0R:	ADDI TAC,1
	LSH DAT,1
	CAIGE TAC,40
	JRST ERRL0T
ERRL0I:	SOJGE AC3,ERRL0L
	MOVEI AC1,4*=60*=60
	MOVEM AC1,RECOVER
	POPJ P,

ERRCNT:	SOSGE RECOVER
	SETZM RECOVER
	POPJ P,
; UTILITY ROUTINES FOR THE PRECEEDING ROUTINES - ERROR ROUTINE
; MAKES UP ERROR MESSAGE TO HOST WHOSE INCOMING MESSAGE
; ADDRESS HAS BEEN PUSHED ON THE STACK. SKIPS ON SUCCESS, NON-SKIP
; MEANS NO FREE STORAGE AVAILABLE.

MAKERB:	PUSHJ P,IMPGET		; GET A FREE STORAGE BLOCK
	POPJ P,			; NONE AVAILABLE
	PUSHJ P,CLRBLK		; ZERO THE FREE STORAGE BLOCK
	MOVE AC2,-1(P)		; PICK UP ADDRESS OF INPUT MESSAGE
	LDB AC3,[POINT 16,TDATA(AC2),23]
	ANDCMI AC3,377		; ZERO OUT LINK NUMBER
	DPB AC3,ELINKP		; SET HOST TO THE SAME, LINK TO CONTROL LINK
	MOVEI AC3,10
	DPB AC3,SIZEP		; BYTE SIZE FOR CONTROL MESSAGES IS 8
	MOVEI AC3,ERR		; PUT IN ERROR OPCODE
	DPB AC3,OPCDP
	MOVEI AC3,14		; ALL ERROR CODES ARE 12 BYTES LONG
	DPB AC3,COUNTP
	MOVEI AC3,7		; PICK UP A WORDCOUNT
	MOVEM AC3,TWC(AC1)
	JRST CPOPJ1

; ROUTINE TO CLEAR A FREE STORAGE BLOCK.
; ENTER WITH BLOCK ADDRESS IN AC1
; ONLY CLEARS DATA PORTION

CLRBLK:	PUSH P,AC2
	PUSH P,AC3
	SETZM TDATA(AC1)
	HRLI AC2,TDATA(AC1)	; MAKE UP BLT POINTER
	HRRI AC2,TDATA+1(AC1)
	HRRI AC3,TDATA-1(AC1)
	ADD AC3,TLEN(AC1)
	BLT AC2,(AC3)
	POP P,AC3
	POP P,AC2
	POPJ P,
; ROUTINE TO DELETE A LINK IN THE LINK TABLE.
; ENTER WITH THE LINK TABLE INDEX (PLUS ONE) IN AC3

KILLNK:	SKIPE AC1,IMPRFQ-1(AC3)	; ANY QUEUED RFCS HERE?
	PUSHJ P,APNLST		; YES, RECYCLE THEM
	MOVEI AC2,-1(AC3)	; CORRECT INDEX
	PUSH P,DAT
	SOSE DAT,FFLNK		; DECREMENT FIRST FREE LINK NUMBER
	CAIN DAT,(AC2)		; IS THIS LINK THE TOP ONE?
	JRST KILLN1		; YES, RESTORE ACS AND LEAVE
	PUSH P,AC2
	PUSH P,AC3
	MOVE AC3,LNKTAB(DAT)
	MOVEM AC3,LNKTAB(AC2)
	MOVE AC3,IMPDDB(DAT)
	MOVEM AC3,IMPDDB(AC2)
	MOVE AC3,IMPLS(DAT)
	MOVEM AC3,IMPLS(AC2)
	MOVE AC3,IMPFS(DAT)
	MOVEM AC3,IMPFS(AC2)
	MOVE AC3,IMPRFQ(DAT)
	MOVEM AC3,IMPRFQ(AC2)
	MOVE AC3,IMPBS(DAT)
	MOVEM AC3,IMPBS(AC2)
	MOVE AC3,IMPSTB(DAT)
	MOVEM AC3,IMPSTB(AC2)
	POP P,AC3
	POP P,AC2
KILLN1:	POP P,DAT
	POPJ P,
; ROUTINE TO POLL ALL THE OTHER SITES FOR SIGNS OF LIFE

POLL:	MOVEI AC1,POLTIM
	MOVEM AC1,POLCNT
	SKIPE IMPDEAD
	POPJ P,
	SOSG HCLSCT		; TIME TO CHECK HALF-DEAD SOCKETS YET?
	PUSHJ P,HCLSS		; YES, DO IT NOW
	SKIPE IMPECT		; ANY ERROR BITS?
	JRST IERBD
; ROUTINE TO PERIODICALLY CHECK AND MAKE SURE ALL IS OK
; IT DELETES HALF-CLOSED SOCKETS PERIODICALLY

HCLSS:	MOVEI AC1,HCLSTM
	MOVEM AC1,HCLSCT
HCLSR:	SKIPN AC3,FFLNK
	POPJ P,
HCLSL:	SKIPE IMPDDB-1(AC3)
HCLSI:	SOJG AC3,HCLSL
	JUMPE AC3,CPOPJ
	MOVE AC1,IMPSTB-1(AC3)
	TLNE AC1,CLSS
	TLNE AC1,CLSR
	JRST HCLSI
	TLNE AC1,LONCE
	JRST HCLSZ
	MOVSI AC1,LONCE
	ORM AC1,IMPSTB-1(AC3)
	JRST HCLSI

HCLSZ:	SKIPE AC1,IMPRFQ-1(AC3)	; GIVE BACK ANY QUEUED RFCS WHAT MAY BE
	PUSHJ P,APNLST
	PUSHJ P,KILLNK
	JRST HCLSR		; GO BACK AND TRY AGAIN

; TYPE OUT ERROR MESSAGE ON IMP ERROR BIT DETECTED
; WE OUGHT TO SOMEHOW CLEAR THE INTERFACE TOO

IERBD:	SKIPE IMPDEAD
	POPJ P,
	SETZM IMPECT		; START COUNTING AGAIN
	SKIPN RECOVER		; INITIATE ERROR RECOVERY SEQUENCE
	SETOM RECOVER
	TELCTR(IERBIT,<IMP ERROR BIT CAME UP,>)
	POPJ P,
; ROUTINE TO SEND THE IMP SOME NOPS

SNDNOP:	MOVEI AC3,4
	MOVEM AC3,NOPCNT
	SETOM IMPOACT
	MOVEI AC3,MAXCNT
	MOVEM AC3,IMPOCT
	CONO PI,IMPOFF
	CONO IMP,STROUT!ODPIEN!IMPCHN
	DATAO IMP,[BYTE (8) 4]	;NOP
	CONO PI,IMPON
	POPJ P,
; ROUTINE TO DUMP AN INCOMMING COMMAND INTO THE DATA PORTION OF AN ERROR MESSAGE
; ENTER WITH ERROR MESSAGE IN AC1
; OFFENDING INCOMMING MESSAGE AT -1(P)

EFILL:	MOVEI DAT,12
	HRRZI AC2,TDATA+2(AC1)
	HRLI AC2,(<POINT 8,0,15>)
EFILL1:	HRRZ AC3,-1(P)
	ADD AC3,[POINT 8,TDATA+2]
EFILL2:	ILDB DSER,AC3
	IDPB DSER,AC2
	SOJG DAT,EFILL2
	POPJ P,

; SAME THING EXCEPT FOR STANFORD IDIOSYNCRATIC ERROR MESSAGES.
; DUMPS ONE LESS BYTE ONE BYTE FURTHER DOWN

OFILL:	MOVEI DAT,11
	HRRZI AC2,TDATA+2(AC1)
	HRLI AC2,(<POINT 8,0,23>)
	JRST EFILL1
; ROUTINE TO WAIT AT CLOCK LEVEL FOR A STANDARD FREE STORAGE BLOCK

CLKWAIT:
	SETOM IMPCLW		; NOTE THAT WE ARE WAITING
	PUSHACS			; SAVE OUR STATE
	MOVEM P,IMPPDP
	MOVE AC1,[XWD CLKPDL,IMPSAV]
	BLT AC1,IMPSAV+CLKPLN-1	; SAVE THE STACK
	MOVE P,IMPFP
	POPJ P,			; RETURN TO CLKSER

CLKWT:	PUSHJ P,IMPGET
	POPJ P,
	MOVE AC3,[XWD IMPSAV,CLKPDL]
	BLT AC3,CLKPDL+CLKPLN-1
	MOVE P,IMPPDP
	PUSHJ P,IMPREL		;GIVE BLOCK BACK (PROBABLY TO SPARE LIST)
	POPACS
	SETZM IMPCLW
	SOS (P)
	SOS (P)			; BACK UP TO TRY OFFENDING ROUTINE OVER AGAIN
	POPJ P,
; ROUTINE TO RELEASE THE STORAGE IN A LIST
; CALL WITH LIST IN AC1

RELLST:	HRRZS AC1
	PUSHJ P,LEGAL		; IS THIS A LEGAL BLOCK?
	POPJ P,			; NO, LEAVE NOW
	PUSH P,TLINK(AC1)	; SAVE POINTER TO NEXT BLOCK
	PUSHJ P,IMPREL		; RELEASE STORAGE
	POP P,AC1		; GET PTR TO NEXT BLOCK
	TRNE AC1,-1
	JRST RELLST
	POPJ P,

; ROUTINE TO RELEASE LIST OF LISTS
; ENTER WITH LIST LIST IN AC1

RELBLS:	PUSHJ P,LEGAL
	POPJ P,
	PUSH P,TLINK(AC1)
	PUSHJ P,RELLST
	POP P,AC1
	HLRZS AC1
	JUMPN AC1,RELBLS
	POPJ P,
; ROUTINE TO PLANT AN INTERRUPT REQUEST
; MUST HAVE DDB SET UP
; ENTER WITH INTERRUPT BIT IN AC2

INTCOM:	LDB J,PJOBN
	TDNN AC2,JBTIEN(J)
	POPJ P,
	IORM AC2,JBTIRQ(J)
	SETOM INTREQ(PID)
	POPJ P,
; ROUTINE TO UNLINK THE TOP MESSAGE ON THE INPUT LIST
; SKIPS IF THERE ACTUALLY WAS ONE AND PUTS ITS ADDRESS IN AC1

UNLMES:	CONO PI,IMPOFF
	SKIPN AC1,ILIST		; PICK UP INPUT LIST
	JRST UNLME1
	HLRZ AC2,TLINK(AC1)	; GET POINTER TO NEXT LIST
	HRRM AC2,ILIST
	SKIPN AC2
	SETZM ILIST
	CONO PI,IMPON
	HRRZS TLINK(AC1)	; CLEAR OUT POINTER TO NEXT BLOCK
	JRST CPOPJ1

UNLME1:	CONO PI,IMPON
	POPJ P,

; SAME THING BUT IS ERROR IF NO LIST THERE

UNLNS:	PUSHJ P,UNLMES
	JRST UNLERR
	POPJ P,

UNLERR:	PUSHJ P,DISMES
	[ASCIZ /NO INPUT LIST AT UNLNS
/]
	-1
	SETOM DISFLAG
	PUSHJ P,DISFLUSH
	JRST AUTOLOAD

; ROUTINE TO POP THE FIRST TRANSFER OFF THE INPUT LIST AND DELETE IT

POPMESS:
	PUSHJ P,UNLMES
	POPJ P,
	JRST RELLST
; ROUTINE TO SEND OUT A MESSAGE FROM CLOCK LEVEL ON LINK 0.
; IF LINK IS BLOCKED, PUTS MESSAGE ON A LIST (L0CWTL)
; ENTER WITH MESSAGE TO BE SENT IN AC1
; PRESERVEC AC3, BUT DEFINITELY CLOBBERS AC2

CLKOUT:	SKIPE IMPDEAD
	JRST RELLST		; IF IMP DEAD, FLUSH OUTPUT
CLKOUD:	LDB AC2,TYPEP		; PICK UP MESSAGE TYPE
	JUMPE AC2,CLKOU4	; IF A REGULAR MESSAGE, BLOCK LINK FIRST
	CAIN AC2,5		; IF REGULAR MESSAGE FOR DISCARD, BLOCK LINK ALSO
	JRST CLKOU4
	JRST QOUT		; OTHERWISE, DON'T WORRY ABOUT TRYING TO BLOCK IT

CLKOU4:	PUSH P,AC3
	PUSHJ P,L0PTR
	TDNN AC3,L0BLOK(AC2)	; IS THIS LINK BLOCKED?
	JRST CLKOU3		; NO, SEND AWAY
	SKIPN AC2,L0CWTL	; YES, PUT IT ON END OF LIST
	JRST CLKOU1		; NO LIST, PUT IT ON BOTH ENDS
	MOVSS AC2
	HRLM AC1,TLINK(AC2)	; LINK US ON TO END OF LAST GUY
CLKOU2:	HRLM AC1,L0CWTL
	HRRZS TLINK(AC1)
	POP P,AC3
	POPJ P,

CLKOU1:	HRRM AC1,L0CWTL
	JRST CLKOU2

CLKOU3:	ORM AC3,L0BLOK(AC2)	; BLOCK LINK
	POP P,AC3
	JRST QOUT		; OUTPUT MESSAGE
; ROUTINE TO FIND A DDB FROM LINK NUMBER IN A SECOND LEVEL
; NCP COMMAND. GETS SEND OR RECEIVE SIDE AS SPECIFIED.
; RETURNS:
; +1 FOR NO SUCH LINK NUMBER
; +2 FOR WRONG SIDE ONLY
; +3 FOR SOCKET THERE BUT NO DDB

COMDDR:	SKIPA DDB,[TRNE TEM,1]	; GET RECEIVE SIDE SOCKET NUMBER TEST
COMDDS:	MOVE DDB,[TRNN TEM,1]	; PICK SEND SIDE TEST
	LDB AC2,SRCP		; PICK UP HOST NUMBER
	LSH AC2,=8
	ILDB AC3,TBP(AC1)
	ORI AC2,(AC3)		; MAKE UP HOST-LINK NUMBER
	SETZ DAT,
	SKIPN AC3,FFLNK		; PICK UP POINTER TO FIRST FREE LINK
	POPJ P,
COMDS2:	CAMN AC2,LNKTAB-1(AC3)	; HOST-LINK NUMBER MATCH?
	JRST COMDS1
COMDS3:	SOJG AC3,COMDS2
	SKIPE AC3,DAT		; DID WE FIND ANYTHING AT ALL?
	AOS (P)			; YES, GIVE +2 RETURN
	POPJ P,

COMDS1:	MOVEI DAT,(AC3)		; SAVE INDEX FOR FUTURE REFERENCE
	MOVE TEM,IMPLS-1(AC3)
	XCT DDB
	JRST COMDS3
	AOS (P)
	AOS (P)
	SKIPE DDB,IMPDDB-1(AC3)
	AOS (P)
	POPJ P,
; ROUTINES TO PICK UP SOCKET NUMBERS AND STORE THEM FOR CLS, RTS, AND STR

RD2B:	ILDB AC2,TBP(AC1)
	LSH AC2,10
	ILDB TEM,TBP(AC1)
	ORI AC2,(TEM)
	POPJ P,

RD4B:	ILDB AC2,TBP(AC1)
REPEAT 3,<
	LSH AC2,10
	ILDB TEM,TBP(AC1)
	ORI AC2,(TEM)
>
	POPJ P,

PSOCK1:	DPB AC2,SOK1BP
	LSH AC2,-10
	DPB AC2,SOK1AP
	POPJ P,

PSOCK2:	DPB AC2,SOK2BP
	LSH AC2,-10
	DPB AC2,SOK2AP
	POPJ P,

GSOCK1:	LDB AC2,SOK1AP
	LDB TEM,SOK1BP
	LSH AC2,10
	ORI AC2,(TEM)
	POPJ P,

GSOCK2:	LDB AC2,SOK2AP
	LDB TEM,SOK2BP
	LSH AC2,10
	ORI AC2,(TEM)
	POPJ P,
; ROUTINE TO RETURN A CLS TO THE HOST WHOSE MESSAGE IS IN AC1
; RETURNS MESSAGE TO FREE STORAGE.

RTNCLS:	MOVE AC2,TDATA(AC1)
	PUSH P,AC1
	PUSHJ P,IMPGET
	PUSHJ P,CLKWAIT
	PUSHJ P,MCLSB		; MAKE UP A CLS LOCK
	MOVE AC2,JDAT
	PUSHJ P,PSOCK1
	MOVE AC2,UUO
	PUSHJ P,PSOCK2
	PUSHJ P,CLKOUT
	POP P,AC1
	POPJ P,
; ROUTINE TO MAKE UP A CLS BLOCK WITH EMPTY SOCKETS
; CALL WITH IMP HEADER IN AC2
; MUST ALREADY HAVE FREE STORAGE IN AC1

MCLSB:	MOVEM AC2,TDATA(AC1)
	SETZM TDATA+1(AC1)
	SETZM TDATA+2(AC1)
	SETZM TDATA+3(AC1)
	SETZM TDATA+4(AC1)
	MOVEI AC2,5		; FIVE WORD TRANSFER
	MOVEM AC2,TWC(AC1)
	MOVEI AC2,10
	DPB AC2,SIZEP
	MOVEI AC2,11
	DPB AC2,COUNTP
	MOVEI AC2,CLS
	DPB AC2,OPCDP
	POPJ P,
; SEND CLOSE TO FOREIGN HOST
; CALL WITH FREE STORAGE IN AC1
; CONNECTION INDEX MUST BE IN AC3

SNCLS:	MOVE AC2,LNKTAB-1(AC3)
	ANDI AC2,177400
	LSH AC2,14
	PUSHJ P,MCLSB
	MOVE AC2,IMPLS-1(AC3)
	SKIPE DDB,IMPDDB-1(AC3)	; MAKE SURE THERE IS A DDB THERE
	TRNN AC2,1		; IS OUR SIDE THE SEND SIDE?
	JRST SNCLS1		; NO
	SETZM BAL(DDB)		; YES, DON'T EMIT ANY MORE MESSAGES
	SETZM MAL(DDB)
SNCLS1:	PUSHJ P,PSOCK1
	MOVE AC2,IMPFS-1(AC3)
	PUSHJ P,PSOCK2
	PUSHJ P,CLKOUT
	MOVSI AC2,CLSS
	PUSHJ P,CSTAT
	POPJ P,
