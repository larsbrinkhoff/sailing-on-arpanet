COMMENT ⊗   VALID 00113 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00012 00002	BEGIN APRSER ↔ SUBTTL	SAVGET	4 AUG 67
C00014 00003	ROUTINE TO SCAN COMMAND STRING ARGUMENTS FOR SAVE,GET,RUN AND R
C00019 00004	THIS JOB SAVES A JOB AREA ON RETRIEVABLE STORAGE
C00021 00005	THIS JOB GETS A JOB AREA FROM A RETRIEVABLE DEVICE
C00023 00006	JOB HAS JUST A JOB DATA AREA ASSIGNED WHEN CONTROL GETS HERE
C00025 00007	ROUTINE TO SETUP ACS,RESET IO,ASSIGN DEVICE, AND DO LOOKUP
C00027 00008	 COMMON SAVEGET ROUTINE, OPEN FILE, DO LOOKUP (ENTER?)
C00029 00009	 COME HERE ON SAVE DEVICE NOT AVAILABLE
C00030 00010	ROUTINE TO SET DUMP MODE COMMAND LIST IN USER AREA
C00033 00011	ROUTINE TO RELEASE DEVICE AND FIND TTY
C00034 00012	ROUTINE TO GET FILE FROM DEVICE
C00037 00013	HERE WE DISCOVER IF WE HAVE A HIGH SEGMENT TO SET-UP
C00039 00014	END OF GET, REMAP ERROR, SETPR2 KLUDGE
C00042 00015	 ROUTINE TO STUFF A FILE ON A DEVICE
C00045 00016	 SAVE ROUTINE
C00047 00017	BEGIN SEGCSS ↔ SUBTTL	SEGCSS	8 SEPT 69	JAM
C00049 00018	 ROUTINE TO INVENT AN UPPER SEGMENT
C00051 00019	 THIS ROUTINE DEFINES A SEGMENT. IT SEARCHES FOR AN EXISTING
C00055 00020	 ROUTINE TO KILL A HIGH SEGMENT
C00058 00021	 ROUTINE TO ERASE A SEGMENT ENTIRELY
C00060 00022	 ROUTINE TO FLUSH A JOB'S HIGH SEGMENT AND ALL THE SEGMENTS HE MAY HAVE
C00064 00023	 UAPPLY - APPLY A ROUTINE TO ALL LOWERS OF AN UPPER.
C00066 00024	SUBTTL	COMCSS	4 AUG 67
C00067 00025	CTEX0:	PUSHJ PDP,GETLCCHR
C00069 00026	ROUTINE TO IGNORE LEADING SPACES, TABS, AND NULLS
C00071 00027	ROUTINE TO APPEND A "?" TO INPUT STRING AND SET AS OUTPUT
C00074 00028	ROUTINE TO PRINT A COMMAND ERROR MESSAGE
C00076 00029	ROUTINE TO PRINT INLINE ASCIZ MESSAGE - INLMES, PRCRCC, PRCNCC
C00078 00030	ROUTINE TO DEASSIGN A DEVICE
C00080 00031	ROUTINE TO READ CONSOLE AND CONVERT ANY RADIX NUMBER
C00083 00032	GET PROJECT-PROGRAMMER NUMBERS
C00085 00033	ROUTINE TO PRINT TIME AS HOURS,MINUTES,SECONDS, AND HUNDRETHS
C00087 00034	SUBTTL	ERRCON	4 AUG 67
C00089 00035	APRNXM:	TRNN TAC,NXM		NON-EX MEM?
C00090 00036	 ROUTINE TO PRINT ERROR MESSAGE FOR SPW MODULES
C00092 00037	ADDRESS CHECK ERROR AT ANY LEVEL
C00093 00038	CALL:	JSP DAT,ERROR
C00094 00039	 UERROR IS FOR UUO LEVEL, BLAMES CURRENT JOB
C00095 00040	 USER TRIED TO GIVE LPT OR PTP A BUFFER LARGER THAN
C00097 00041	UUOERR: ILLEGAL UUO 
C00100 00042	ILLEGAL INSTRUCTION  -  ILLINS, HALT
C00102 00043	ROUTINE FOR HUNG IO DEVICE
C00104 00044	ROUTINE TO HALT A JOB WHEN A DEVICE IS NOT READY FOR I/O
C00105 00045	 ROUTINE TO PRINT A MESSAGE AND STOP A JOB IN A WAY
C00106 00046	COMMON ERROR MESSAGE SETUP ROUTINES - ERRPTU
C00109 00047	ROUTINE TO PRINT UUO PC AND STOP JOB - UUOMES, UUOPCP, PCPNT
C00111 00048	ROUTINE TO PRINT EITHER: - PCSTOP, PCP
C00113 00049	ROUTINE TO PRINT 36 BIT OCTAL NO
C00114 00050	ROUTINE TO PRINT "DEVICE XXX"
C00115 00051	DISASTER TYPEOUT		DISOUT
C00117 00052	 DISFLUSH - CALL WITH PIS OFF TO FINISH FLUSHING
C00119 00053	 DISTYO - TYPES ONE CHARACTER IN TEM THROUGH
C00121 00054	DISMES, DISCRLF, DISTAB, DISJOB
C00123 00055	CALLING SEQUENCE
C00124 00056	 HERE ARE THE VARIOUS PRINTOUT ROUTINES FOR DISERR
C00125 00057	DISLOC PRINTS OUT 6 DIGIT OCTAL LOCATION WITHOUT LEADING ZEROES
C00128 00058	 SIXBIT PRINT ROUTINE FOR DISASTER MESSAGES
C00129 00059	 INITIALIZE ROUTINE FOR DISASTER MESSAGES . . .
C00130 00060	 ROUTINE TO TYPE ON THE CTY WITH PIS OFF
C00132 00061	DISDATE - SHOVE THE TIME AND DATE INTO THE BUFFER
C00134 00062	IOCSS	4 AUG 67	ADVBFE ADVBE1
C00137 00063	PRSET  ROUTINE TO PUSH CURRENT PR ON STACK AND SET UP NEW PR
C00138 00064	ADRCK ROUTINE TO ADDRESS CHECK SOMETHING
C00140 00065	ADVBFF ROUTINE TO ADVANCE INPUT BUFFER AT INTERRUPT LEVEL
C00143 00066	ROUTINE TO ADDRESS CHECK AT UUO LEVEL ONLY
C00144 00067	UADRCK ROUTINE TO ADDRESS CHECK AT UUO LEVEL ONLY
C00146 00068	ROUTINE TO ADDRESS CHECK AT ANY LEVEL
C00147 00069	ROUTINE TO CHECK VALIDITY OF A DUMP MODE COMMAND LIST
C00149 00070	COMCK1:	SOJLE ITEM,COMCKE	EXCEEDED 100 YET?
C00151 00071	ASSASG	ASSIGN DEVICE IF UNASSIGNED
C00154 00072	ROUTINE TO SEARCH FOR A DEVICE
C00156 00073	SEARCH PHYSICAL NAMES
C00158 00074	ROUTINE TO SETUP N-RING IO BUFFER IN USER AREA
C00161 00075	 HERE, WE WANT TO EXPAND CORE TO FIT IN A RING OF BUFFERS
C00163 00076	 END OF LOOP FOR SETTING UP AN N-RING BUFFER
C00165 00077	ROUTINE TO CLEAR IO BUFFER IN USER AREA
C00167 00078	ROUTINE TO COMPUTE 12 BIT FOLDED CHECKSUM
C00169 00079	ROUTINE TO CLEAR RESIDUE OF WORD POINTED TO BY A BYTE POINTER
C00170 00080	IOALL, IOALLR, IORELS,IOWAIT
C00175 00081	IOKILL, CLRUSR
C00177 00082	ROUTINE TO FLAG DEVICE ACTIVE  - ORACT, SETACT, CLRACT, STOIOS
C00179 00083	DEVCHK  - THIS ROUTINE UPDATES EACH DEVICE'S HUNG COUNT AND DISPATCHES
C00181 00084	 OTHER USEFUL ROUTINES FOR SETING UP USER BUFFER POINTERS
C00182 00085	 SET UP WORD COUNT IN AC2
C00183 00086	ROUTINE TO SETUP PROG AND ITEM FOR INTERRUPT SERVICE ROUTINE
C00184 00087	CALLING SEQUENCE
C00186 00088	ROUTINE TO RETURN NO. OF ITEMS IN BUFFER
C00187 00089	ROUTINE TO SET DEVICE STATUS WORD FROM UUO
C00188 00090	SETUP BYTE POINTER AND ITEM COUNT
C00189 00091	ROUTINE TO SETUP BYTE POINTER ACCORDING TO DATA MODE
C00190 00092	 ROUTINE TO STORE DATA IN IOBUFFER FOR INPUT DEVICES THAT
C00192 00093	↑STODAT:
C00194 00094	↑STOSQD:
C00196 00095	RUNCSS	4 AUG 67 - KSTOP
C00199 00096	ROUTINE TO STOP JOB, SET ERROR BIT AND PRINT MESSAGE - HOLD, PHOLD
C00200 00097	ROUTINE TO STOP USER AND FLAG AS ERROR STOP - ESTOP, MSTOP
C00205 00098	ROUTINE TO STOP ANY JOB FROM BEING SCHEDULED - STOP1, SETSTP
C00208 00099	DLYCOM     ROUTINE TO REQUE JOB WHICH HAS HAD A COMMAND TYPED
C00209 00100	ROUTINE TO PUT JOB IN NO CORE QUEUE
C00210 00101	ROUTINE TO SETUP MONITOR JOB TO RUN LATER AT UUO LEVEL - MONJOB
C00211 00102	MONSTR ROUTINE TO SETUP ACS FOR MONITOR JOB STARTING AT UUO LEVEL
C00213 00103	ROUTINE TO SET JOB STATE TO BE SCHEDULED TO RUN - USTART, MSTART
C00217 00104	ROUTINE TO SET JOB STATUS RUN BIT(RUN)
C00219 00105	ROUTINE TO PUT A JOB TO SLEEP AND WAKE UP AGAIN LATER
C00221 00106	ROUTINE TO GET DATA CONTROL AND ANOTHER SHARABLE DEVICE
C00223 00107	ROUTINE TO WAIT FOR A SHARABLE DEVICE
C00225 00108	SETIOD - ROUTINE TO SET JOB TO RUN AFTER IT HAS BEEN STOPPED
C00227 00109	ROUTINE TO CAUSE CLK ROUTINE TO RESCHEDULE - WSCHED
C00229 00110	ROUTINE TO WAIT TILL DEVICE CATCHES UP WITH USER AND BECOMES INACTIVE
C00231 00111	WSYNC IS CALLED TO WAIT UNTIL 
C00233 00112	 WE GET HERE IF THIS DEVICE HAS CONTROL CELLS
C00235 00113	REPEAT 0,<
C00236 ENDMK
C⊗;
BEGIN APRSER ↔ SUBTTL	SAVGET	4 AUG 67

;SPECIAL LOCATION IN USER JOB DATA AREA FOR STORING ARGUMENTS
;USED IN UUO CALLS TO THE MONITOR

;FOR LOOKUP UUO
FILNAM←←0		;FILE NAME
FILEXT←←FILNAM+1	;FILE EXTENSION
FILDAT←←FILNAM+2	;DATE WRITTEN
FILLEN←←FILNAM+3	;LH=-LENGTH,RH=FIRST LOC-1 DUMPED ON ENTER
			;PROJECT PROGRAMMER ON LOOKUP

DMPEND←←FILLEN+1	;LAST WORD OF DUMP COMMAND LIST=0

;FOR OPEN UUO
MODWRD←←5		;IOS MODE WORD FOR OPEN UUO
DEVWRD←←MODWRD+1	;DEVICE NAME
HEDWRD←←MODWRD+2	;INPUT AND OUTPUT BUFFER HEADER ADDRESSES


DMPWRD←←11	;DUMP WORD FOR SAVE COMMAND
NEWCOR←←12	;NEW CORE ASSIGNMENT FOR RUN AS SPECIFIED BY THIRD
		;ARGUMENT TO PREVIOUS SAVE.
↑INCWRD←←13	;STARTING INCREMENT STORAGE FOR MONITOR JOB.

COMWRD←←17	;TO PASS COMMAND TO PROG
CHRWRD←←16	;DITTO DELIMITER
;ROUTINE TO SCAN COMMAND STRING ARGUMENTS FOR SAVE,GET,RUN AND R
;COMMANDS AND STORE THEM IN JOB DATA AREA WHICH MUST BE IN CORE
;WHEN SGSET IS CALLED FROM COMMAND DECODER
;CALL:	MOVE TAC,INPUT BYTE POINTER
;	MOVE TAC1,SIXBIT DEVICE NAME
;	MOVE DAT,OUTPUT BYTE POINTER
;	MOVE IOS,ADR. OF MONITOR JOB(SAVJOB,GETJOB,RUNJOB)
;	MOVE PROG, ADR. OF JOB AREA
;	PUSHJ P,SGSET

;SET AC2 TO EXPLICIT PPN OF FILE AND ENTER BY:  PUSHJ P,SGSET0

C←←BUFPNT

SGDVOK:	PUSH	P,TAC			;CHECK TO SEE IF ARG IS LEGAL SAVEGET DEV
	PUSH	P,IOS
	PUSH	P,DAT
	PUSH	P,DDB
	MOVE	TAC,TAC1
	PUSHJ	P,DEVSRC		;IS THERE SUCH A DEVICE
	JRST	SGSETB			;NOT A LEGAL DEVICE. ASSUME IT WAS FILENAME
	MOVE	TAC,DEVMOD(DDB)
	TLNE	TAC,DVDSK!DVDTA!DVMTA	;ONLY LEGAL DEVICES FOR SAVE GET
	AOS	-4(P)
SGSETB:	POP	P,DDB
	POP	P,DAT
	POP	P,IOS
	JRST	TPOPJ

SGSET:	MOVEI	AC2,0			;NORMAL ENTRY - DISABLE PPN KLUDGE
SGSET0:					;THIS IS THE RUN FROM ANOTHER AREA KLUDGE
IFN FTLOGIN,<	MOVEM	AC2,JOBPPN(J)>
	MOVEM	TAC1,DEVWRD(PROG)	;STORE FIRST ARG. MAY BE DEVICE, OR FILE
	JUMPE	TAC1,SGSETC		;ASSUME DSK IF NO ARG
	PUSHJ	P,SGDVOK		;SEE IF IT'S A VALID DEVICE NAME
	JRST	SGSETC			;WASN'T A DEVICE NAME
	SKIPN	TAC1,JOBNAM(J)		;WAS DEVICE.   AUTOMATIC FILENAME?
	JRST	SGSET3			;NO. READ ONE FROM THE COMMAND STRING
SGSETA:	MOVEM	TAC1,FILNAM(PROG)	;OK. SET FILE NAME
	MOVSI	TAC1,'DMP'
	MOVEM	TAC1,FILEXT(PROG)	;DEFAULT EXTENSION
IFN FTLOGIN,<	SETZM	FILLEN(PROG)
		XCT	SGPPN	>	;LOAD AC1 WITH DEFAULT PPN
	JRST	SGSET1

SGSETC:	MOVSI	TAC1,'DSK'		;NO TRY TO ASSUME DISK
	EXCH	TAC1,DEVWRD(PROG)	;USE THIS FOR FILENAME
	JUMPN	TAC1,SGSETD
	SKIPN	TAC1,JOBNAM(J)
	JRST	NOTENF
	JRST	SGSETA

SGSET3:	PUSHJ	P, CTEXT1		;GET FILE NAME FROM COMMAND STRING
	JUMPE	TAC1,NOTENF		;THERE MUST BE A FILE NAME
SGSETD:	MOVEM	TAC1,FILNAM(PROG)	;STORE FILE NAME
	MOVEM	TAC1,JOBNAM(J)		;STORE ALSO FOR SYSTAT
IFN FTSTAT,<	PUSHJ	P,NAMSTT>
	MOVSI	TAC1,'DMP'		;ASSUME EXTENSION
	CAIN	TEM,"."			;EXTENSION EXPECTED?
	PUSHJ	P,CTEXT1		;YES. GET EXTENSION, OTHERWISE USE DEFAULT
	HLLZM	TAC1,FILEXT(PROG)	;STORE IT FOR LOOKUP

IFN FTLOGIN,<
	SETZM	FILLEN(PROG)
	PUSHJ	P,PJPGNO		;GET PROJ. PROG. NO.
SGPPN:					;THIS IS A SUBROUTINE CALLED BY XCT SGPPN
IFE FTDSKPPN,<	MOVE	AC2,PRJPRG(J)>
IFN FTDSKPPN,<	JSP	AC1,[SKIPN AC2,DSKPPN(J)
			MOVE AC2,PRJPRG(J)
			JRST (AC1)]	>;FTDSKPPN
>;FTLOGIN

	PUSHJ	P,DECIN1	;AMOUNT OF CORE (OPTIONAL THIRD ARG.)
	JRST	SGSET1		;DOES NOT RETURN IF ERROR, RETURN HERE IF NO ARG.
	JRST	COMERA		;ILLEGAL CHARACTER
	LSH	TAC1,12		;CONVERT TO HIGHEST REL. LOC.
	SUBI	TAC1,1
SGSET1:	HRRZM	TAC1,JOBCOR(PROG)	;STORE FOR RUN COMMAND AND SAVE
IFN FTLOGIN,<	SKIPN	JOBPPN(J)	;SKIP IF EXPLICIT PPN KLUDGE.
		MOVEM	AC2,JOBPPN(J)>	;SAVE PPN
	MOVE	TAC1,IOS		;SCHEDULE MONITOR JOB
	JRST	MSTART			;START JOB WITH PC IN MONITOR MODE
;THIS JOB SAVES A JOB AREA ON RETRIEVABLE STORAGE
;THIS JOB RUNS IN EXEC. MODE AND CALLS IO ROUTINES DIRECTLY
;NO ATTEMPT IS MADE TO SAVE STATUS OF IO DEVICES, JOBPDP, OR AC'S
;IN FACT THE ONLY USEFUL THING WHICH MAY BE DONE WITH A JOB AREA
;AFTER IT HAS BEEN SAVED IS TO START EXECUTION OVER AT THE STARTING
;ADDRESS


↑SSAVJB:
	JSP TAC1,SG1		;SET UP FOR SAVE
	JFCL
	PUSHJ P,SSAVJA		;NON-FLUSH SEGMENT ENTRANCE
	JRST SAVJB1

↑SAVJOB:
	JSP TAC1,SG1		; SET UP ACS AND ASSIGN DEVICE AND LOOKUP
	JFCL			;FILE DOES NOT ALREADY EXIST RETURN
	PUSHJ PDP,SAVJB		; THIS ROUTINE ACTUALLY DOES THE WORK
SAVJB1:	PUSHJ P,INLMES
	ASCIZ/JOB SAVED IN /
	HLRO TAC,FILLEN(PROG)
	MOVNS TAC
	ADDI TAC,JOBSAV
	LSH TAC,-12
	ADDI TAC,1
	PUSHJ P,RADX10		;TELL HIM HOW MUCH WE SAVED IT IN
	SKIPE NEWCOR(JDAT)
	JRST SAVEUP		;AND UPPER
	LDB TAC,PSEGN
	JUMPE TAC,SAVNUP	;ANY UPPER AT ALL?
	JSP TAC,PHOLD		;YES, TELL HIM NOT SAVED
	ASCIZ/K
UPPER NOT SAVED!
/

SAVEUP:	PUSHJ P,INLMES
	ASCIZ/K
UPPER SAVED IN /
	HLRO TAC,NEWCOR(JDAT)
	MOVNS TAC
	ADDI TAC,1777
	LSH TAC,-12
	PUSHJ P,RADX10
SAVNUP:	JSP TAC,PHOLD
	ASCIZ/K
/
;THIS JOB GETS A JOB AREA FROM A RETRIEVABLE DEVICE
;THIS JOB RUNS IN EXEC. MODE AND CALLS IO ROUTINES DIRECTLY
;NO ATTEMPT IS MADE TO RESTORE STATUS OF IO DEVICES, PC, OR AC'S
;JOBPC IS SET TO STARTING ADDRESS OF JOB
;CORE MUST ALREADY HAVE BEEN ASSIGNED AND THE FOLLOWING LOC. SETUP IN
;JOB DATA AREA:
;JOBPDP, JOBREL


↑GETJOB:
	JSP TAC1,SG1		; SET UP ACS AND ASSIGN DEVICE AND DO LOOKUP
	JRST NOFILE		;FILE NOT FOUND RETURN
	PUSHJ PDP,GETJB		;GET THE JOB
GETJ1:	PUSHJ P,INLMES		;RETURN ONLY IF EVERYTING OK
	ASCIZ /JOB SETUP IN /
	HLRZ TAC,JBTADR(J)
	LSH TAC,-12
	ADDI TAC,1
	PUSHJ P,RADX10
	LDB AC3,PSEGN
	JUMPE AC3,GETNUP
	PUSH P,AC3
	PUSHJ P,INLMES
	ASCIZ/K
YOUR UPPER IS /
	POP P,AC3
	HLRZ TAC,JBTADR(AC3)
	ADDI TAC,1777
	LSH TAC,-12
	PUSHJ P,RADX10
GETNUP:	JSP TAC,PHOLD
	ASCIZ/K
/
NOFILE:	PUSHJ P,CLRTPV		;NOT FOUND--CLEAR TEMPORARY PRIVILEGES
	PUSHJ PDP,SGREL		;RELEASE DEVICE, FIND TTY
	PUSHJ PDP,PRQM
	PUSHJ PDP,CRLF
	MOVE TAC1,FILNAM(PROG)	;PRINT FILE NAME
	PUSHJ PDP,PRNAME
	PUSHJ PDP,PRPER		;PRINT PERIOD
	HLLZ TAC1,FILEXT(PROG)
	PUSHJ PDP,PRNAME	;PRINT EXTENSION
	JSP TAC,PHOLD		;PRINT MESS. AND STOP JOB
	ASCIZ / NOT FOUND/
;JOB HAS JUST A JOB DATA AREA ASSIGNED WHEN CONTROL GETS HERE
;THIS MONITOR JOB GETS A JOB AREA FROM A RETRIEVABLE DEVICE
;ASSIGNS CORE AND START


↑RUNJOB:
	JSP TAC1,SG1		; SETUP ACS, ASSIGN DEVICE, AND DO LOOKUP
	JRST NOFILE		;NO FILE FOUND RETURN
	PUSHJ P,GETJB		;GET THE FILE
	HRRZ TAC,JOBSA(JDAT)	;GET STARTING ADDRESS
	TRNN TAC,-1
	JRST NOSTRT
	ADD TAC,SAVSAI(J)	;ADD STARTING ADDRESS INCREMENT
	HRLI TAC,USRMOD		;SET USER MODE BIT
	MOVEM TAC,UUOPC(J)	;MAKE IT LOOK LIKE UUO RETURN
	MOVE TAC,JOBPPN(J)	;GET PRJPRG OF FILE
	MOVEM TAC,DMPEND(PROG)	;GIVE IT TO THE USER
	JRST USRXIT		;AND GO START USER

NOSTRT:	PUSHJ P,INLMES
	ASCIZ /NO STARTING ADDRESS.
/
	JRST GETJ1
;ROUTINE TO SETUP ACS,RESET IO,ASSIGN DEVICE, AND DO LOOKUP
;CALL:	JSP TAC1,SG1
;	FILE NOT FOUND RETURN
;	FILE FOUND RETURN
;	IOWD FOR THIS SIZE CORE RETURNED IN AC TAC
;	DEVMOD IN TAC1



SG1:	JSP TAC,MONSTR		;SETUP PROG,PDP,RESET DEVICES
				;PUT TAC1 ON END OF PD LIST
	PUSHJ PDP,RESETUUO	;RELEASE ALL DEVICES
	MOVEI TAC,2		;SAVE MODE
	MOVEM TAC,MODWRD(PROG)	;STORE FOR OPEN UUO
	SETZM HEDWRD(PROG)	;CLEAR BUFFER HEADER ARG.
	SKIPN TAC,JOBCOR(PROG)	;WAS CORE SIZE SPECIFIED
	JRST SGCOR		;NO
	CAMG TAC,USRREL(PID)	;YES, MUST WE GET SOME MORE
	JRST SGCOR1		;NO
	PUSHJ P,RUNCOR		;TRY FOR ENOUGH
	JRST SG2		;CAN'T GET IT, GIVE HIM UP TO USRREL
SGCOR1:	MOVN TAC,JOBCOR(PROG)
	JRST SGCOR2

SGCOR:	HRRZ TAC,JOBFF(JDAT)	; PICK UP FIRST FREE LOCATION
	CAMLE TAC,USRREL(PID)	; IS IT IN BOUNDS?
	JRST SG2		; NO, USE HIGHEST RELOCATABLE ADDRESS
	JUMPE TAC,SG2		; ZERO IS PRETTY SILLY TOO
	MOVNS TAC		; NEGATE TO FORM HALF OF IOWD
	SKIPE USRDDT(PID)	; IF DDT IS IN, SAVE UP TO JOBREL
SG2:	MOVN TAC,USRREL(PID)	;YES, DUMP ALL OF CORE INSTEAD
SGCOR2:	ADDI TAC,JOBSAV		;LOWER CORE NOT DUMPED
	HRLI TAC,JOBSAV
	MOVSM TAC,DMPWRD(PROG)	;STORE IOWD WORD OF THIS SIZE CORE
; COMMON SAVEGET ROUTINE, OPEN FILE, DO LOOKUP (ENTER?)

	OPEN 0,MODWRD		;TRY TO ASSIGN DEVICE
	JRST SGERRA		;NOT AVAILABLE
	MOVE TAC1,DEVNAM(DEVDAT)
	MOVEM TAC1,JOBDEV(ITEM)
	MOVE TAC1,DEVLOG(DEVDAT)
	MOVEM TAC1,JOBLOG(ITEM)
	MOVE TAC1,DEVMOD(DEVDAT)
	HLRZ TAC,FILEXT(PROG)	;CHECK FOR DMP
	CAIN TAC,'DMP'
	TLNN TAC1,DVDTA		;IS IT ON DTA?
	JRST .+2
	MOVEI TAC,SAVDMP	;YES. CHANGE TO "SAV" IF WE HAVE
	HRLM TAC,FILEXT(PROG)	;"RECLAIMING FORMAT" DECTAPES
	MOVE AC1,JOBPPN(ITEM)	; GET PROJECT-PROGRAMMER NUMBER
	MOVEM AC1,FILLEN(PROG)	; SET IT INTO PLACE
	TLNN TAC1,DVDSK		; IS THIS A DISK?
	MOVEM TAC,FILLEN(PROG)	; NO, STORE WORD COUNT
	LOOKUP 0,FILNAM		;LOOKUP FILE NAME
	SOS (PDP)		;NOT FOUND
	MOVE TAC,DMPWRD(PROG)	;FOUND, RETURN IOWD FOR THIS SIZE CORE
	MOVE TAC1,DEVMOD(DEVDAT)
	MOVE ITEM,JOB(PID)	; RESTORE JOB NUMBER FOR THOSE WHO NEED IT
	TLNE TAC1,DVDSK
	JRST SG3
	SETZM JOBPPN(ITEM)
	JRST CPOPJ1
SG3:	MOVE AC1,FILPPN(DEVDAT)
	EXCH AC1,JOBPPN(ITEM)
	JRST CPOPJ1		;SKIP RETURN, UNLESS FILE NOT FOUND
; COME HERE ON SAVE DEVICE NOT AVAILABLE
; PRINT ERROR MESSAGE AND STOP JOB

SGERRA:	JUMPE DEVDAT,SGERR1
	MOVEM DEVDAT,(PDP)	; PRINT DEVICE XXX
	PUSHJ PDP,TTYFNU	; FIND TTY
	PUSHJ PDP,PRQM
	PUSHJ PDP,CRLF
	PUSHJ PDP,ERNAM	
	JSP TAC,PHOLD		;PRINT AND STOP JOB
	ASCIZ / NOT AVAILABLE/

SGERR1:	PUSHJ PDP,TTYFNU
	JSP	TAC,PHOLD
	ASCIZ	/?
NO SUCH DEVICE/
;ROUTINE TO SET DUMP MODE COMMAND LIST IN USER AREA
;AND CHECK TO SEE IF ROOM IN CORE
;THEN EXECUTE INPUT OR OUTPUT UUO,RELEASE DEVICE AND CHECK FOR
;ERRORS
;CALL:	PUSHJ PDP,SGDO
;	INPUT 0,FILLEN OR OUTPUT 0,FILLEN
;	OK RETURN(NO ERRORS)



SGDO:	SETZM DMPEND(PROG)		;SET 2ND WORD OF DUMP LIST TO 0
	HLRO TAC,FILLEN(PROG)		;GET - NO. WORDS TO READ OR WRITE
	SUBI TAC,JOBSAV			;NO. OF LOWER CORE LOC. NOT DUMPED
	ADD TAC,USRREL(PID)		;HIGHEST LOC. IN USER AREA
	JUMPL TAC,NOROOM		;WILL IT FIT?
	MOVEM DEVDAT,USRHCU(PID)	;SET HIGHEST IO CHAN IN USE NEGATIVE
					;ALSO ADDRESS OF SAVE GET DEVICE.
	XCT @(PDP)			;EXECUTE INPUT OR OUTPUT UUO
					;READ INTO PROTECTED PART OF JOB DATA AREA
	PUSHJ PDP,CLRUSR		;CLEAR OUT POSSIBLE GARBAGE
					;AND SET USRHCU BACK TO 0
	MOVEM DEVDAT,USRJDA(PID)	;RESTORE CHANNEL 0 ASSIGNMENT
	PUSH P,IOS			;SAVE POSSIBLE ERROR BITS
	PUSHJ PDP,SGREL			;RELEASE DEVICE,FIND TTY
	MOVE TAC,JOBS41(JDAT)		;RESTORE USER UUO JSR LOC.
	MOVEM TAC,JOB41(JDAT)		;IN CASE THIS IS GET OR RUN
	POP P,TAC			;GET BACK BITS
	TRNN TAC,IOBKTL+IODERR+IODTER+IOIMPM		;ANY ERRORS ON SAVE-GET DEVICE?
	JRST CPOPJ1			;NO, GIVE OK RETURN
SGTERR:	JSP TAC,PHOLD			;YES, PRINT MESS. AND STOP JOB
	ASCIZ \?
SAVE/GET IO ERROR\

NOROOM:	PUSHJ PDP,SGREL			;RELEASE DEVICE, FIND TTY
	PUSHJ PDP,PRQM
	PUSHJ PDP,CRLF
	SKIPLE TAC,JOBCOR(JDAT)		;GET MIN. HIGHEST REL.LOC. FOR JOB TO RUN
	JRST NOROM1			;USE IT IF SPECIFIED.
	HLRO TAC1,FILLEN(PROG)		;-LENGTH OF FILE
	MOVNS TAC1			;+LENGTH
	HRRZ TAC,FILLEN(PROG)		;FIRST LOC-1 DUMPED
	ADD TAC,TAC1			;LAST LOC DUMPED
NOROM1:	LSH TAC,-12			;CONVERT TO NO. OF 1K BLOCKS-1
	ADDI TAC, 1
	PUSHJ PDP,RADX10
	JSP TAC,PHOLD			;GO START TTY, AND STOP JOB
	ASCIZ /K OF CORE NEEDED/
;ROUTINE TO RELEASE DEVICE AND FIND TTY



SGREL:	SKIPN USRJDA(PID)	;HAS CHANNEL BEEN RELEASED ALREADY?
	JRST TTYFUW		;YES. FIND TTY AND WAIT FOR OUTPUT TO FINSIH
	MOVE TAC,DEVMOD(DEVDAT)
	TLNE TAC,DVMTA		;MAGTAPE?
	TLNN DEVDAT,INPB	;YES. WAS AN INPUT DONE?
	JRST SGREL1		;NO
	CLOSE 0,CLSOUT		;YES. CLOSE INPUT.
	STATO 0,IOTEND		;AT END OF TAPE?
	MTAPE 0,6		;NO. SKIPTO EOF
SGREL1:	RELEASE 0,		;NO, RELEASE DEVICE
	JRST TTYFUW		;FIND TTY AND WAIT FOR OUTPUT TO FINISH
;ROUTINE TO GET FILE FROM DEVICE


GETJB:	PUSHJ P,RESETSEG	; FLUSH HIS UPPER SEGMENT IF ANY
	SETZM JOBINT(JDAT)	; THIS WON'T GET CLEARED BY DMP FILE--RPH 1-6-74
	MOVE TAC,FILDAT(PROG)
	MOVEM TAC,JOBCRD(J)	;COPY CREATION DATE FOR SEGMENT ACCESS
	MOVE TAC,DMPWRD(PROG)
	TLNE TAC1,DVDSK		;DISK?
	HRRM TAC,FILLEN(PROG)	;YES.
	HRRZ TAC,JOBCOR(PROG)	;HIGHEST REL.LOC. REQUESTED
	MOVEM TAC,NEWCOR(PROG)	;SAVE IT
	SETZM JOBCOR(PROG)	;CLEAR JOBCOR SO NOROOM MESSAGE ALWAYS WORKS
	JUMPG TAC,GETJB1	;WAS CORE SPECIFIED IN COMMAND STRING?
	TLNE TAC1,DVMTA		;MAGTAPE?
	JRST GETJB3
	HLRO TAC1,FILLEN(PROG)	;NO, USE AMOUNT SPECIFIED IN DIRECTORY
	JUMPGE TAC1,GETERR	;DUMP FILE?
	HRRZ TAC,FILLEN(PROG)	;FIRST LOC.-1
	SUB TAC,TAC1		;TOTAL NO. OF WORDS NEEDED - 1=
				;HIGHEST LOCATION DUMPED.
	IORI TAC,1777		;HIGHEST LOC. IN 1K BLOCKS
GETJB1:	MOVE ITEM,JOB(PID)	;SETUP JOB NUMBER
	PUSHJ PDP,RUNCOR	;TRY TO ASSIGN CORE
	JRST NOROOM		;PRINT NO. OF BLOCKS NEEDED
	MOVE TAC1,DEVMOD(DEVDAT)
	TLNN TAC1,DVMTA		;MAGTAPE?
	JRST GETJB2		;YES
GETJB3:	HLRZ TAC1,PROG		;NO. SET FILLEN TO CURRENT CORE SIZE.
	SUBI TAC1,JOBSAV
	MOVNS TAC1
	HRLI TAC1,JOBSAV
	MOVSM TAC1,FILLEN(PROG)
GETJB2:	PUSHJ PDP,SGDO		;DO INPUT, RELEASE, FIND TTY
	 INPUT 0,FILLEN		;EXECUTED FROM SGDO
	MOVE TAC,JOBPPN(J)
	MOVEM TAC,FILLEN(PROG)	;RESTORE PPN FOR PROG TO SEE
	HLRZ TAC,HILOC(JDAT)	;SEGMENT PROTECTION SAVED HERE
				;IF NO SEGMENT WAS SAVED, PROT WILL BE 0.
	ANDI TAC,377		;FLUSH UNUSED BITS
	DPB TAC,[POINT 9,JOBCRD(J),8]
;HERE WE DISCOVER IF WE HAVE A HIGH SEGMENT TO SET-UP
;FIRST TRY TO ATTACH TO THE SAVED NAME (IF ANY)
;MAKE SURE IT IS WRITE PROTECTED, AND THAT IS WHAT WE WANT
;IF ALL THIS FAILS, TRY A REMAP ON OUR SEGMENT.

	SKIPN TAC,HILOC(JDAT)	; DOES THIS JOB HAVE A HIGH SEGMENT?
	JRST GETDN1		; NO, FIX UP CORE SIZE AND LEAVE
	TLZ TAC,777777		;ONLY INTERESTED IN RIGHT HALF
	IORI TAC,1777		;WHERE IT WILL BE MOVED TO
	CAML TAC,USRREL(PID)	;ADDRESS ABOVE TOP
	JRST GETERA		;YES, EVIL EVIL(NOT A DUMP FILE)
	PUSH P,DDB		;DDB CLOBBERED BY SEGMENT UUOS
	SKIPN TAC,HINAME(JDAT)	;GET SAVED HIGH SEGMENT NAME!
	JRST GETJ5
	MOVEM TAC,FILLEN(PROG)
	ATTSEG FILLEN,		;ATTACH TO IT?
	JRST GETJ5
	LDB TAC,PSEGN		;GET ITS JOB NUMBER
	MOVE TAC,JBTSTS(TAC)
	SKIPL HILOC(JDAT)	;DO WE WANT WRITE PROT?
	JRST GETJ7
	TLNE TAC,JWP		;YES, IS HE WRITE PROTECTED
	JRST GETDON		;PROT MATCHES
	JRST GETJ8
GETJ7:	TLNN TAC,JWP		;IS HE UNPROTECTED?
	JRST GETDON		;THAT'S IT!
GETJ8:	DETSEG			;DETACH THIS ONE
GETJ5:	HRRZ TAC,HILOC(JDAT)	;CURRENT BOTTEM OF SEGMENT
	SUBI TAC,1
	PUSHJ P,BLTUP		;MOVE UPPER TO NEXT 1K BOUNDARY
	MOVE TAC,HILOC(PROG)
	SUBI TAC,1
	IORI TAC,1777
	MOVEM TAC,FILLEN(PROG)
	REMAP FILLEN,		; REMAP US
	CAIA
	JRST GETDN2
;END OF GET, REMAP ERROR, SETPR2 KLUDGE

	POP P,DDB		;GET BACK TTY DDB
	MOVEI DAT,TTOBUF(DDB)	;AND SET UP THIS GUY
	PUSHJ P,INLMES
	ASCIZ /
COULDN'T GET YOU A SEGMENT.  WILL TRY TO LET YOU WIN WITH SETPR2.
/
	HLRZ TAC,PROG
	MOVEM TAC,JOBCOR(PROG)	;DON'T LET HIM CORE DOWN BELOW UPPER
	ADDI TAC,1
	MOVEM TAC,JOBFF(PROG)	;AND TELL HIM NOT TO WRITE OVER IT
	HRLM TAC,JOBSA(PROG)	;IN BOTH WAYS
	SUB TAC,FILLEN(PROG)	;LENGTH OF UPPER+1
	MOVSI TAC,-2(TAC)
	SKIPL HILOC(PROG)
	TLZ TAC,1		;SET UP W.P. BIT
	HRR TAC,FILLEN(PROG)
	ADDI TAC,1+3		;REMOVE OFFSET AND SET "RELATIVE" & "PSEUDO-UPPER" BITS
	PUSHJ P,STPR2
	JRST GETDN1

GETERR:	PUSHJ PDP,SGREL		;RELEASE DEVICE AND FIND TTY
GETERA:	JSP TAC,PHOLD
	ASCIZ /?
NOT A DUMP FILE/

GETDN2:	SKIPN TAC,HINAME(JDAT)
	JRST GETDON
	LDB TAC1,PSEGN
	MOVE DDB,NJOBS(TAC1)
IFE FTSTAT,<CAIG DDB,1		;MORE THAN ONE JOBS MEANS WE'RE NOT THE FIRST
	MOVEM TAC,JOBNAM(TAC1)
>;IFE FTSTAT
IFN FTSTAT,<
	CAILE DDB,1
	JRST GETDON
	MOVEM TAC,JOBNAM(TAC1)
	PUSH P,J
	MOVE J,TAC1
	PUSHJ P,NAMSTT
	POP P,J
>;FTSTAT
GETDON:	POP P,DDB		;GET BACK TTY DDB
	MOVEI DAT,TTOBUF(DDB)
GETDN1:	SKIPE TAC,NEWCOR(PROG)	;DID USER TYPE 3RD ARGUMENT?
	CAMG TAC,JOBCOR(JDAT)	;YES, IS 3RD ARG GREATER THAN
				;MIN SIZE SPECIFIED BY THIRD
				;ARG TO SAVE (IF ANY)?
	MOVE TAC,JOBCOR(JDAT)	;NO, ASSIGN NEW BIGGER AMOUNT OF CORE
	JUMPLE TAC,CPOPJ	; IF 0 OR NEG, DOESN'T MAKE SENSE.
	IORI TAC,1777
	HLRZ TAC1,PROG		; HOW MUCH DOES HE HAVE NOW
	CAMN TAC1,TAC		; DIFFERENT?
	POPJ P,			;NO
	PUSHJ PDP,RUNCOR
	JFCL			;IGNORE IF CAN'T
	POPJ P,
; ROUTINE TO STUFF A FILE ON A DEVICE

SAVJB:	SETZM NEWCOR(PROG)	;SIGNAL NO SAVE OF UPPER SEGMENT
	CAIA
				; RESTORE PROJECT-PROGRAMMER NUMBER
SSAVJA:	SETOM NEWCOR(PROG)	;FLAG TO SAVE UPPER(IF ANY)
	MOVEM AC1,FILLEN(PROG)	; TO THE LAST WORD OF THE LOOKUP BLOCK
				; PLEASE NOTE THAT THIS MEANS THAT YOU CAN'T CLOBBER TAC OR AC1 BETWEEN CALLS ON SG1 AND SAVJB
	TLNN TAC1,DVDSK		;DISK?
	MOVEM TAC,FILLEN(PROG)	;NO. SET FILE LENGTH IN DIRECT. HEADER
	SETZM FILDAT(PROG)	;MAKE SURE WE GET TODAY'S DATE
	TLNE TAC1,DVDSK		;DISC?
	CLOSE 0,CLSOUT		;YES, CLOSE INPUT
	ENTER 0,FILNAM		;ENTER FILE NAME IN DIRECTORY
	JRST SAV4		;DIRECTORY FULL
	MOVE TAC,DMPWRD(PROG)	;RESTORE FILLEN AFTER DISC ENTER
	MOVEM TAC,FILLEN(PROG)
	MOVE TAC,JOB41(JDAT)	;SAVE USER UUO HANDLING JSR
	MOVEM TAC,JOBS41(JDAT)	;IN UPPER PART OF JOB DATA AREA
	SKIPN NEWCOR(PROG)	;SHALL WE SAVE UPPER?
	JRST SAVJ1		;NO
	LDB TAC,PSEGN
	JUMPE TAC,SAVJ1
	HLRZ TAC1,JBTADR(TAC)
	ADDI TAC1,1
	MOVNS TAC1
	MOVSS TAC1
	HRRI TAC1,377777
	MOVEM TAC1,NEWCOR(PROG)
	HLRO TAC1,FILLEN(PROG)
	SETCM TAC1,TAC1		;COMPUTE +(LENGTH OF FIRST PART)-1
	IORI TAC1,177		;MAKE IT A DISK BLOCK BOUNDARY-1
	ADDI TAC1,JOBSAV+1+1	;ROUNDING UP AND MAKING INTO CORE LOC
	LDB TAC,PSEGN
	LDB TAC,[POINT 9,JOBCRD(TAC),8]
	HRL TAC1,TAC		;SET SEGMENT PROT BITS IN LEFT HALF OF JOBRL2 TO GET SAVED
	LDB TAC,PSEGN		;GET THIS BACK
	MOVE TAC,JBTSTS(TAC)
	TLNE TAC,JWP
	TLO TAC1,(1B0)
	MOVEM TAC1,JOBRL2(PROG)	;MAKE COMPATIBLE
	MOVEM TAC1,HILOC(PROG)
; SAVE ROUTINE

	LDB TAC,PSEGN		;AND AGAIN
	MOVE TAC,JOBNAM(TAC)
	CAMN TAC,JOBNAM(J)	;SAME NAMED UPPER AS LOWER
	SETZ TAC,		;YES, FLAG AS SUCH
	MOVEM TAC,HINAME(JDAT)	;SAVE IN THIS NEW PLACE!
	JRST SAVJ3

SAVJ1:	SETZM HILOC(JDAT)
	SETZM JOBRL2(PROG)
	SETZM HINAME(JDAT)
	SETZM NEWCOR(JDAT)	;MAKE SURE NO SAVE HAPPENS!
SAVJ3:	SETZM DMPEND(PROG)
	HLRO TAC,FILLEN(PROG)
	SUBI TAC,JOBSAV
	ADD TAC,USRREL(PID)
	JUMPL TAC,NOROOM
	HLRO TAC,FILLEN(PROG)
	MOVNS TAC
	ADDI TAC,JOBSAV
	MOVEM TAC,JOBCOR(PROG)	;MAKE SURE HE GETS TO BE RIGHT SIZE WHEN HE COMES BACK IN
	OUTPUT 0,FILLEN
	TRNE IOS,IOBKTL!IODERR!IODTER!IOIMPM
	JRST SGTERA
	SKIPN NEWCOR(PROG)
	JRST SGREL
	SETZM NEWCOR+1(PROG)
	OUTPUT 0,NEWCOR
	LDB TAC,PSEGN
	JUMPE TAC,SAVJ2
	HLRZ TAC1,JBTADR(TAC)
	TRO TAC1,400000
	MOVEM TAC1,HILOC(PROG)
	MOVEM TAC1,JOBRL2(PROG)
SAVJ2:	TRNN IOS,IOBKTL!IODERR!IODTER!IOIMPM
	JRST SGREL
SGTERA:	PUSHJ P,SGREL
	JRST SGTERR

SAV4:	PUSHJ PDP,SGREL		;RELEASE,DEVICE, FIND TTY
	JSP TAC,PHOLD		;PRINT MESSAGE AND STOP JOB
	ASCIZ /?
ENTER FAILED!/
BEGIN SEGCSS ↔ SUBTTL	SEGCSS	8 SEPT 69	JAM
; SEGMENT ACCESS CONTROL
; PUT JOB NUMBER OF MASTER ON STACK AND NUMBER OF SEGMENT IN J
; CALLING . . .
;	PUSH PDP,ITEM
;	MOVE ITEM,<SEGMENT NUMBER>
;	PUSHJ PDP,ACCESS
;	<NO ACCESS POSSIBLE>
;	<READ ACCESS ONLY>
;	<ALL ACCESS LEGAL>

↑ACCESS:MOVE TAC,-1(P)		; PICK UP MASTER JOB NUMBER
	MOVE TAC1,JBTPRV(TAC)	; GET PRIV BITS OF MASTER
	TLNE TAC1,SEGPRV	; DO WE HAVE THE PRIVILEGE?
	JRST CPOPJ2		; YES, AUTOMATIC SUCCESS
	MOVE TAC1,PRJPRG(TAC)
	LDB TAC,[POINT =9,JOBCRD(J),8]
	TRZE TAC,400		;UNPURIFIED?
	JRST ACCES2		;YES - DIFFERENT TEST (TAC IS NOW JOB # OF DEFILER)
	CAMN TAC1,JOBPPN(J)	; IS THIS THE SAME JOB?
	JRST ACCES1		; YES, USE OWNER'S PROTECTION
	XOR TAC1,JOBPPN(J)
	TRNE TAC1,-1		;SAME PROGRAMMER?
	LSH TAC,3		; NO, MOVE OVER TO GENERAL PROTECTION
	LSH TAC,3		; MOVE OVER TO PROGRAMMER PROTECTION
ACCES1:	TRNN TAC,300		; NOW, IS THERE ANY PROTECTION?
	JRST CPOPJ2		; NO, EVERYTHING GOES
	TRNN TAC,200		; IS IT READ PROTECTED?
	AOS (P)			; NO, IT CAN BE READ
	POPJ P,			; OTHERWISE INACCESSABLE

ACCES2:	CAMN TAC,-1(P)		;ONLY ORIGINAL OWNER WINS HERE
	JRST CPOPJ2
	POPJ P,
; ROUTINE TO INVENT AN UPPER SEGMENT
; SKIP RETURNS WITH JOB NUMBER OF SEGMENT IN J; NON SKIP IF JOB CAPACITY EXCEEDED
; SETS CORE SIZE TO ZERO, SETS PPN TO *SEG*, SETS AS DETATCHED

↑ESTSEG:
	MOVEI	J,1
	MOVSI	TAC,JNA!JLOG!JACCT!CMWB		;JNA IS PROBABLY ENOUGH
ESTSE1:	TDNN	TAC,JBTSTS(J)			;SKIP IF JOB SLOT IN USE.
	JRST	ESTSE2				;WE HAVE A SLOT TO USE.
	CAMGE	J,JOBNM1			;HAVE WE SEEN ALL SLOTS?
	AOJA	J,ESTSE1			;NOT YET.
	MOVEI	J,0				;RETURN A ZERO
	POPJ	P,				;FAILURE.

ESTSE2:
		SKIPE	JBTADR(J)	;BUG TRAP
		PUSHJ	P,INIJXX	;MAKE LOSE MESSAGE
	SETZM	JBTADR(J)			;NO CORE ANYWHERE.
	MOVSI	TAC,JSEG!JNA!JLOG		;SET SEGMENT, SLOT USED, LOGGED IN
	IORM	TAC,JBTSTS(J)			;IN JOB STATUS FOR SEGMENT
	SETZM	NJOBS(J)			;NO ONE USING THIS UPPER YET
	SETOM	JBTLIN(J)			;DETACHED
	SETZM	TTIME(J)			;NO RUN TIME FOR THIS UPPER
	SETZM	XTIME(J)			;NO XTIME
	SETZM	DSKOPS(J)			;NO DISK OPS
	MOVE	TAC,TIMDAT
	MOVEM	TAC,FTIME(J)			;SET UP JOB LAST RUN TIME.
	MOVE	TAC,[SIXBIT /*SEG*/]		;PPN = *SEG*
	MOVEM	TAC,PRJPRG(J)
	MOVEI	TAC,STOPQ			;QUEUE US INTO THE STOPQ
	MOVNM	TAC,JOBQUE(J)
	AOS	(P)				;SETUP SKIP RETURN
	JRST	REQUE
; THIS ROUTINE DEFINES A SEGMENT. IT SEARCHES FOR AN EXISTING
; SEGMENT FIRST WITH THE PROPER CREDENTIALS AND GIVES YOU ITS NUMBER FIRST.
; OTHERWISE, IT MAKES ONE UP AND PUTS YOUR ID IN ITS CREDENTIALS. RETURNS
; THE NUMBER OF THE SEGMENT IN JBTSTS, 0 FOR FAILURE.

↑LINKSEG:
	PUSHJ	P,KILSEG	;GET RID OF EXISTING UPPER.
	PUSH	P,J
	MOVE	AC1,J		; SAVE NUMBER OF MASTER JOB
	MOVE	J,JOBNM1
DEFSE1:	MOVE	TAC,JBTSTS(J)	;LOOK FOR AN UPPER.
	TLNN	TAC,JSEG
	JRST	DEFSE2		;NOT AN UPPER. SKIP IT.
	MOVE	TAC,JOBNAM(J)
	MOVE	TAC1,JOBPPN(J)
	CAMN	TAC,JOBNAM(AC1)	;DOES THE JOB NAME MATCH?
	CAME	TAC1,JOBPPN(AC1);AND DOES THE PROJ-PROG NAME MATCH?
	JRST	DEFSE2		; NO
	MOVE	TAC,JOBCRD(J)
	MOVE	TAC1,JOBDEV(J)
	CAMN	TAC,JOBCRD(AC1)	;DOES THE CREATION DATE AND PROTECTION MATCH?
	CAME	TAC1,JOBDEV(AC1);AND DOES THE DEVICE MATCH?
	JRST	DEFSE2		;NO
	MOVE	TAC,JOBLOG(J)	;CHECK LOGICAL NAME TOO
	CAMN	TAC,JOBLOG(AC1)
	PUSHJ	P,ACCESS	;NOW, CAN WE LEGALLY ACCESS THIS SEGMENT?
	JRST	DEFSE2		;NO
	JFCL
DEFSE3:	MOVE	TAC,J
	POP	P,J
	DPB	TAC,PSEGN
IFN FTSTAT, <PUSHJ P,SEGSTT
	LDB TAC,PSEGN
>
	AOS	NJOBS(TAC)	;BUMP COUNT OF NUMBER OF PEOPLE POINTING TO HIM
	SKIPE	TAC
	AOS	(P)
SEGXIT:	CAME J,JOB(PID)
	JRST SEGXT1
	PUSHJ P,GETPR
	DATAO APR,TAC
SEGXT1:	POPJ P,

DEFSE2:	SOJG J,DEFSE1
	POP P,J
	POPJ P,

↑MAKESEG:
	PUSHJ	P,KILSEG
	PUSH	P,J
	PUSHJ	P,ESTSEG	; IF NO EXISTING ONE, MAKE ONE UP
	JRST	DEFSE3		; IF NOT AVAILABLE, JUST LEAVE
	MOVE	TAC,J		;SAVE SEGMENT NUMBER
	POP	P,J
	DPB TAC,PSEGN
IFN FTSTAT,<
	PUSHJ P,SEGSTT
	LDB TAC,PSEGN
>;FTSTAT
↑MAKSE2:AOS NJOBS(TAC)		; BUMP COUNT OF PEOPLE POINTING TO HIM
	MOVE TAC1,JOBNAM(J)	; NOW ESTABLISH ITS CREDENTIALS
	MOVEM TAC1,JOBNAM(TAC)
IFN FTSTAT,<
	PUSH P,J
	MOVE J,TAC
	PUSHJ P,NAMSTT
	POP P,J
>;FTSTAT
	MOVE TAC1,JOBPPN(J)
	MOVEM TAC1,JOBPPN(TAC)
	MOVE TAC1,JOBCRD(J)
	MOVEM TAC1,JOBCRD(TAC)
	MOVE TAC1,JOBDEV(J)
	MOVEM TAC1,JOBDEV(TAC)
	MOVE TAC1,JOBLOG(J)
	MOVEM TAC1,JOBLOG(TAC)
	POPJ P,
; ROUTINE TO KILL A HIGH SEGMENT
; ENTER WITH JOB NUMBER OF OWNER IN J
; IF OTHER PEOPLE POINT TO IT, IT WILL REMAIN
; IF NO-ONE ELSE POINTS TO IT, IT WILL GO AWAY

↑↑KILSEG:
	SKIPE	JBTPR2(J)		;IS HE DOING PEEK-POKE?
	JRST	[SETZM	JBTPR2(J)	;YES, MUST KILL IT HERE
		JRST	SEGXIT]
	PUSH	P,J			;SAVE JOB NUMBER.
	LDB	J,PSEGN			;GET OUR SEGMENT NUMBER
	JUMPN	J,KILSE6		;JUMP IF THERE IS A SEGMENT
	POP	P,J			;THERE'S NO SEGMENT. FORGET IT
	POPJ	P,

KILSE6:	PUSH	P,J			;SAVE SEGMENT NUMBER.
	SKIPA	J,JOBNM1		;SEARCH FOR ANY OTHERS POINTING HERE
KILSE3:	SOJLE	J,KILSE1		;DECREMENT J. JUMP IF JOB LIST EXHAUSTED
	CAMN	J,-1(P)			;IS THIS THE CURRENT JOB?
	JRST	KILSE3			;YES. WE KNOW ABOUT HIM, SO SKIP IT.
	LDB	TAC,PSEGN
	CAMN	TAC,(P)			;DOES HE POINT TO OUR SEGMENT?
	JRST	KILSE4			;YES. - DON'T KILL SEGMENT.
KILSE7:	SKIPN	AC1,JBTDTS(J)		;DOES THIS GUY HAVE A DETACHED SEGMENT LIST?
	JRST	KILSE3			;NO.
KILSE5:	LDB	TAC,PDSEGN		;LOOK THRU DET SEG LIST
	JUMPE	TAC,KILSE3		;JUMP WHEN DET SEG LIST IS EMPTY
	CAME	TAC,(P)			;SAME AS THIS SEGMENT?
	AOJA	AC1,KILSE5		;NO. KEEP LOOKING.
KILSE4:	POP	P,J			;SOMEONE ELSE POINTS TO THIS SEGMENT
KILSE2:	SOSGE	NJOBS(J)
	PUSHJ	P,[
		PUSHACS
		PUSHJ	P,DISMES
		ASCIZ	/NJOBS<0 AT KILSE2
/
		POPACS
		SETZM	NJOBS(J)
		POPJ	P,]
	POP	P,J			;POP CURRENT JOB NUMBER
	MOVEI	TAC,0
	DPB	TAC,PSEGN		;ZERO SEGMENT FIELD
IFN FTSTAT,<
	PUSHJ P,SEGSTT
	LDB TAC,PSEGN
>;FTSTAT
	JRST	SEGXIT

;HERE  IF THERE ARE NO FURTHER REFERENCES TO THIS SEGMENT.
KILSE1:	POP	P,J			;GET THE SEGMENT NUMBER
	PUSHJ	P,ZEROSEG		;EXPUNGE SEGMENT
	MOVE	TAC,NJOBS(J)
	CAIE	TAC,1			;THERE SHOULD BE ONLY 1 POINTER TO THIS
	PUSHJ	P,NZERR
	JRST	KILSE2

NZERR:	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/NJOBS NOT 0 AT KILSEG
/
	POPACS
	POPJ	P,
; ROUTINE TO ERASE A SEGMENT ENTIRELY

ZEROSEG:PUSH	P,JDAT
ZERO1:	MOVE	JDAT,JBTADR(J)
	SETZM	TAC
	PUSHJ	P,CORE0			;GIVE BACK THIS SEGMENT'S CORE
	JRST	ZERO5
	MOVE	TAC,JOBNM1		;LOOK FOR FATHER JOB.
ZERO3:	LDB	TAC1,[POINT 6,JBTSTS(TAC),35]
	CAME	TAC1,J
ZERO4:	SOJG	TAC,ZERO3
	JUMPE	TAC,ZERO2
	SKIPN	JBTST2(TAC)		; WAS THERE A SPW MODULE HERE
	JRST	ZERO4			; NO.
	MOVSI	TAC1,SPWST1!SPWST2	; YES, CLEAR THE SPACEWAR STOPPED BITS
	PSYNC	SPWCSC
	ANDCAM	TAC1,JBTST2(TAC)
	XSYNC	SPWCSC
	JRST	ZERO4			;THERE AREN'T SUPPOSED TO BE ANY MORE ...

ZERO2:	MOVSI	TAC,JSEG!JWP!JNA!JLOG!JACCT!RUN
	ANDCAM	TAC,JBTSTS(J)
	SETZM	JOBNAM(J)
	SETZM	PRJPRG(J)
	MOVEI	TAC,NULQ
	MOVNM	TAC,JOBQUE(J)
	PUSHJ	P,REQUE
	PUSHJ	P,FBFLUSH
	POP	P,JDAT
	POPJ	P,

ZERO5:	PUSHJ	P,WSCHED		; WAIT FOR SPW TO STOP.
	JRST	ZERO1
; ROUTINE TO FLUSH A JOB'S HIGH SEGMENT AND ALL THE SEGMENTS HE MAY HAVE
; PREVIOUSLY DETACHED, IF AND ONLY IF NO ONE ELSE IS POINTING AT THEM.
; CALL FROM UUO OR CLOCK LEVEL ONLY!!!!!!

↑↑FLUSHSEG:
	PUSHJ	P,KILSEG		;KILL HIS IMMEDIATE UPPER
	SKIPN	AC1,JBTDTS(J)		;IS THERE A DET SEG LIST?
	POPJ	P,			;NO. THIS IS EASY.
	PUSH	P,J			;SAVE CALLING JOB'S NUMBER
FLUSH1:	MOVE	J,(AC1)			;GET THE NUMBER OF THE DETACHED SEGMENT
	JUMPE	J,FLUSH2		;JUMP IF THERE ARE NO MORE.
	JUMPL	J,FLUSH6		;JUMP IF THIS IS SPECIAL DETACHED.
	MOVE	TAC1,JOBNM1
	ANDI	J,77			;SEGMENT NUMBER ONLY.
FLUSH3:	LDB	TEM,[POINT 6,JBTSTS(TAC1),35]		;DO OTHERS POINT HERE?
	CAMN	TEM,J			;DIRECT MATCH?
FLUSH6:	AOJA	AC1,FLUSH1		;YES. CAN'T BE FLUSHED.
	CAME	TAC1,(P)		;DON'T MATCH AGAINST OUR OWN JOB
	SKIPN	DAT,JBTDTS(TAC1)	;DOES THIS JOB HAVE A DETACH LIST?
	JRST	FLUSH5			;NO, GO TO NEXT JOB
FLUSH4:	LDB	TEM,[POINT 6,(DAT),35]	;YES, PICK UP ITS SEGMENT NUMBER
	JUMPE	TEM,FLUSH5		;JUMP IF END OF LIST
	CAMN	TEM,J			;DOES HE POINT TO US?
	AOJA	AC1,FLUSH1		;YES, CAN'T ZERO THIS SEGMENT
	AOJA	DAT,FLUSH4		;NO, TRY NEXT DETACHED SEGMENT

FLUSH5:	SOJG	TAC1,FLUSH3		;LOOP AROUND FOR NEXT JOB
	MOVE	TAC,JBTSTS(J)		;NOW, DOES THIS SEGMENT STILL EXIST?
	TLNN	TAC,JNA
	AOJA	AC1,FLUSH1		;NO, DON'T BOTHER
	PUSH	P,AC1
	PUSHJ	P,ZEROSEG		;WIPE OUT THAT SEGMENT, NO OTHER REFERENCES TO IT
	SKIPE	NJOBS(J)
	PUSHJ	P,NZERR
	POP	P,AC1
	AOJA	AC1,FLUSH1

FLUSH2:	POP	P,J
	MOVE	AC1,JBTDTS(J)		;SEARCH FOR SPECIAL DET SEG.
	MOVEI	AC2,(AC1)		;AC1 POINTS AT HOLE. AC2 POINTS AT DATUM
FLUSH7:	SKIPLE	TAC,(AC2)		;SKIP IF SPECIAL OR EMPTY
FLUSH8:	AOJA	AC2,FLUSH7		;NORMAL DET SEG. GET NEW DATUM
	MOVEM	TAC,(AC1)		;DATUM IS BUBBLED DOWN.
	JUMPE	TAC,FLUSH9		;JUMP IF DONE.
	AOJA	AC1,FLUSH8		;ADVANCE HOLE, ADVANCE DATUM.

FLUSH9:	CAME	AC1,JBTDTS(J)		;IS HOLE IS STILL IN THE SAME PLACE?
	POPJ	P,			;NO. WE STILL HAVE A DET SEG LIST.
	PUSHJ	P,FSGIVE
	SETZM	JBTDTS(J)
	POPJ	P,

↑↑DSFLUSH:				;MAKE SPECIAL DET SEG INTO ORDINARY.
	SKIPN	AC1,JBTDTS(J)
	POPJ	P,
DSFL1:	MOVSI	TAC,400000
	ANDCAB	TAC,(AC1)
	JUMPE	TAC,CPOPJ
	AOJA	AC1,DSFL1


; UAPPLY - APPLY A ROUTINE TO ALL LOWERS OF AN UPPER.
;CALL:
;	MOVE	J,<UPPER'S NUMBER>
;	PUSHJ	P,UAPPLY
;	<INSTRUCTION TO XCT>	;J HAS LOWER'S NUMBER, DDB HAS UPPER'S NUMBER
;	RETURN HERE
;THE SUBJECT INSTRUCTION SHOULD NOT SKIP.  NO AC'S ARE CLOBBERED EXCEPT BY
;THE XCT'ED INSTRUCTION.  DDB AND J SHOULD NOT BE USED TO RETURN ARGUMENTS, ETC.

↑↑UAPPLY:	
	PUSH	P,DDB
	PUSH	P,J
	MOVEI	J,JOBN-1
UAPP1:	LDB	DDB,PJOBN	;GET NUMBER OF THIS LOWER'S UPPER
	CAMN	DDB,(P)
	JRST	UAPP3		;MATCHES.
UAPP2:	SOJG	J,UAPP1
	POP	P,J
	POP	P,DDB
	JRST	CPOPJ1

UAPP3:	PUSH	P,J
	XCT	@-3(P)		;J = JOB NUMBER OF LOWER, DDB = JOB NUMBER OF UPPER.
	POP	P,J
	JRST	UAPP2

BEND SEGCSS
SUBTTL	COMCSS	4 AUG 67

;ROUTINE TO RETURN NEXT ALPHANUMERIC STRING
; IN COMMAND LINE (SIXBIT)
;CALL:	MOVE TAC,BYTE POINTER TO PREVIOUS CHAR.
;	PUSHJ PDP, CTEXT
; SIXBIT STRING RETURN LEFT JUSTIFIED IN AC TAC1


↑CTEXT:	PUSHJ PDP,SKIPS		; SKIP LEADING SPACES, TABS, NULLS, AND CLEAR TAC1
	CAIA
↑CTEXT1:
	PUSHJ PDP,SKIPS1
				;DO NOT RETURN IF CR WAS PREVIOUS BREAK
	MOVE UCHN,[POINT 6,TAC1]
	LDB TEM,TAKR(DAT)
	ANDI TEM,177
	CAIG TEM,"Z"+40
	CAIGE TEM,"A"+40
	JRST CTEX1
	SUBI TEM,40
	JRST CTEX1
CTEX0:	PUSHJ PDP,GETLCCHR
CTEX1:	PUSHJ PDP, CTEX		;IS IT ALPHANUMERIC
	TRC TEM,40		;CONVERT TO SIXBIT
	TLNE UCHN,770000		; HAVE WE ACCUMULATED 6 CHARS?
	IDPB TEM,UCHN		;NO, STORE AWAY
	JRST CTEX0		; YES

;SCAN FOR ALPHANUMERIC CHAR IN TEM
CTEX:	CAIL TEM, "0"
	CAILE TEM, "Z"		;LETTERS ARE LARGER THAN NOS.
	JRST CTEXA		;NEITHER
	CAILE TEM, "9"
	CAIL TEM, "A"
	POPJ PDP,		;LETTER OR NUMBER RETURN
CTEXA:
	CAIN TEM,":"		; DEVICE NAME?
	PUSHJ PDP,GETLCCHR	; YES, SKIP COLON
	CAIE TEM,0		; ↑C?
	JRST TPOPJ		; NO, RETURN UP ONE LEVEL
CTXCNC:	MOVSI TAC1,'HAL'	; CUE UP A PHONY 'HALT'
	MOVEI TEM,12		; TERMINATE WITH LINE FEED
	DPB TEM,TAKR(DAT)	; STORE IN INPUT BUFFER DO ↑C NOT SEEN
	JRST TPOPJ		; AND RETURN UP A LEVEL


↑GETLCCHR:
	PUSHJ P,GETCHR
	CAIG TEM,"Z"+40
	CAIGE TEM,"A"+40
	POPJ P,
	SUBI TEM,40
	POPJ P,
;ROUTINE TO IGNORE LEADING SPACES, TABS, AND NULLS
;ALSO CLEARS TAC1
;DOES NOT RETURN IF PREVIOUS CHAR. OR NEXT NON-SPACING
;CHAR. IS CR(IE POPS SUBROUTINE LEVEL UP 1 ON RETURN)
;CALL:	MOVE TAC,BYTE POINTER TO PREVIOUS BREAK CHAR.
;	PUSHJ PDP, SKIPS1


SKIPSJ:	PUSHJ P,SKIPS1
	POPJ P,

SKIPS:	PUSHJ PDP,GETLCCHR	; GET FIRST CHAR ON LINE
SKIPS1:	MOVEI TAC1,0		; FOR CTEXT AND DECIN
	LDB TEM,TAKR(DAT)	; IN CASE TEM IS CLOBBERED
	ANDI TEM,177
	CAIE TEM,"."		; IF A PERIOD, GET NEXT CHARACTER
	CAIN TEM,15		; SKIP TO L.F. IF C.R.
SKIPSA:	PUSHJ PDP,GETLCCHR	; GET NEXT CHARACTER
SKIPSB:	JUMPE TEM,SKIPS3	; LEAVE IF NO MORE CHARS
	CAIN TEM,";"		; STOP HIM AT SEMI-COLON
	JRST SKIPS3		; MAKE IT LOOK LIKE END OF LINE
	PUSHJ PDP,SPCHEK	; IS THIS A SPECIAL CHAR?
	JRST SKIPS2		; NO
	TLNE TAC,BREAKB		; BREAK? END OF LINE?
	JRST SKIPS3		; YES, LEAVE
SKIPS2:	CAIG TEM,40		; SPACE OR CONTROL CHAR?
	JRST SKIPSA		; YES
	POPJ PDP,		; NO, RETURN

SKIPS3:	JUMPE TEM,CTXCNC	; ↑C?
	MOVEI TEM,12		; WE USE LINE FEEDS FOR BREAK CHARS
	JRST TPOPJ		; RETURN UP ONE LEVEL
;ROUTINE TO APPEND A "?" TO INPUT STRING AND SET AS OUTPUT
;CALLED FROM OCTIN, RETURNS TO SECOND LEVEL ON PDL
;CALL:	MOVE TAC, BYTE POINTER TO LAST CHAR. IN INPUT STRING
;	PUSHJ PDP, COMERA


↑COMEND:
	PUSHJ P,SKIPS1		; IF ANYTHING LEFT IN INPUT LINE, FALL INTO COMERA
↑COMERP:
	POP PDP,UCHN		; REMOVE SUBROUTINE RETURN BEFORE CALLING COMERA
↑COMERA:
	PUSHJ PDP,GETCHR


;ROUTINE TO REPLACE LAST CHARACTER IN INPUT STRING BY "?"
;AND SET AS OUTPUT
;CALL:	MOVE TAC, BYTE POINTER TO LAST CHAR. IN INPUT STRING
;	PUSHJ PDP, COMERR



↑COMERR:
	MOVE UCHN,TITCTR(DEVDAT)	; SAVE POSITION IN SCAN
	PUSHJ PDP,TRESCN	; BACK UP TO START OF COMMAND
COMERL:	PUSHJ PDP,GETCHR	; GET A CHARACTER FROM COMMAND LINE
	JUMPE TEM,COMER1	;QUIT ON NULL HERE!
	CAMN UCHN,TITCTR(DEVDAT)	; HAVE WE PASSED A BAD CHAR YET?
	JRST COMER1		; YES
	PUSHJ PDP,OUTCHS	; NO, TYPE CHARACTER
	JRST COMERL		; AND LOOP FOR ANOTHER

COMER1:	PUSHJ PDP,SETBFI	; CLEAR ANY MORE TYPE IN
	MOVEI TEM,"?"		; APPEND ? TO ERRONEOUS WORD
	PUSHJ PDP,OUTCHS	; AND PRINT IT
	MOVSI J,NOJOBN!NOINCK	;NOW WE PAINSTAKINGLY FAKE OUT COMRET
	IORM J,-1(P)		;*** IF YOU CALL COMERR FROM ANYPLACE THAT
	MOVSI J,NOPER!NOCRLF	;*** DOESN'T HAVE COMRET NEXT ON THE PDL
	ANDCAM J,-1(P)		;*** BOY ARE YOU IN BAD TROUBLE!
	TDZA ITEM,ITEM		; CLEAR JOB NUMBER AND SKIP INTO CRLF ROUTINE
;ROUTINE TO PRINT A COMMAND ERROR MESSAGE
;SAME CALL AS CONMES


				;COMERR SKIPS THIS ROUT.(SEE ABOVE)
↑ERRMES:
	TDZA ITEM,ITEM		; CLEAR JOB NUMBER TO INDICATE ERROR
				;SKIP INTO CONMES ROUTINE

;ROUTINE TO PRINT CARRIAGE RETURN-LINE-FEED
;CALL:	MOVE DAT,BYTE POINTER TO OUTPUT
;	PUSHJ PDP,CRLF


				;COMERR SKIPS TO HERE(SEE ABOVE)
↑CRLF:	MOVEI TAC,[BYTE (7) 15,12,0]

;ROUTINE TO MOVE ASCII CHAR. STRING TO CONSOLE OUTPUT BUFFER
; CALL:	MOVE DAT, BYTE POINTER TO LAST OUTPUT CHARACTER
;	MOVEI TAC,  ADDRESS OF ASCII MESSAGE
;	PUSHJ PDP, CONMES
; STRING TERMINATED BY NULL
; CONMES DOES NOT START TTY

				;ERRMES SKIPS TO HERE
↑CONMES:
	HRLI TAC,440700		; FORM ASCIZ BYTE POINTER
	PUSH PDP,TAC		;SAVE BYTE POINTER
CON0:	ILDB TEM,(PDP)		;GET NEXT CHAR.
	JUMPE TEM,TPOPJ		;IS IT NULL?(IF YES, DO POP P,TAC, POPJ)
↑TYO:
↑CONTYO:
	PUSHJ PDP,OUTCHS
	JRST CON0		;KEEP GOING
;ROUTINE TO PRINT INLINE ASCIZ MESSAGE - INLMES, PRCRCC, PRCNCC
;CALL:	PUSHJ PDP,INLMES
;	ASCIZ /THE MESSAGE/
;RETURN TO NEXT LOC AFTER MESSAGE


↑INLMES:
	POP PDP,TAC		; SETUP PRINT ADRESS FOR CONMES
	PUSHJ PDP,CONMES
	JRST 1(TAC)		;RETURN TO NEXT LOC AFTER MESSAGE

;ROUTINE TO APPEND ? TO ERROR MESSAGE
;CALL	PUSHJ PDP,PRQM
;	RETURN


↑PRQM:	MOVEI	TEM,"?"
	XCT	TYO
	POPJ	P,

PRSPC:	MOVEI TAC,[ASCIZ /    /]	;DEC 3.16
	JRST CONMES			;DEC 3.16

;ROUTINE TO PRINT "TOO FEW ARGUMENTS"
;CALL:	MOVE DAT,BYTE POINTER
;	PUSHJ PDP,NOTENF


↑NOTENF:
	JSP TAC,ERRMES

ASCIZ /TOO FEW ARGUMENTS
/

;ROUTINE TO PRINT A PERIOD
;CALL:	PUSHJ PDP,PRPER


↑PRCRCC:PUSHJ P,CRLF
↑PRCNTC:PUSHJ P,INLMES
	ASCIZ /↑C
/
↑PRPER:	MOVEI	TEM,"."
	JRST	OUTCHS

;ROUTINE TO DEASSIGN A DEVICE
;CALL:	MOVE DEVDAT, DEVICE DATA BLOCK
;	MOVE ITEM, JOB NUMBER
;	PUSHJ PDP, DEASG
;	ERROR NOT PREVIOUSLY ASSIGNED
;	OK RETURN WITH DEVICE DEASSIGNED



↑DEASG:	LDB UCHN, PJOBN		;WAS DEVICE ASSIGNED TO THIS JOB?
	CAME UCHN, ITEM
	POPJ PDP,		;NO, RETURN
	PUSH PDP,ITEM		;SAVE JOB NUMBER
	MOVSI UCHN,DVDIRIN		;CLEAR DIRECTORY IN CORE BIT
	ANDCAM UCHN,DEVMOD(DEVDAT)
	SETZM DEVLOG(DEVDAT)	;CLEAR LOGICAL NAME
	MOVEI TAC1,ASSCON	;IS DEVICE ASSIGNED BY CONSOLE?
	TDNE TAC1,DEVMOD(DEVDAT)
	AOS -1(PDP)		;YES, DO OK RETURN
	PUSHJ PDP,RELEA6	;CLEAR JOB NO. IN DDB IF DDB NOT NEEDED
	POP PDP,ITEM		;BY THIS JOB ANY MORE
	POPJ PDP,

;ROUTINE TO DEASSIGN ALL DEVICES EXCEPT LOGICAL TTY
;CALL:	MOVE ITEM, JOB NUMBER
;	MOVE DEVDAT,ADR. OF DEVICE NOT TO BE DEASSIGNED
;	PUSHJ PDP, DEASTY




↑DEASTY:
	HRRZS DDB		; CLEAN OUT THE LH SHIT
	PUSH PDP,DEVDAT		; SAVE TTY DDB ADDRESS
	HLRZ DEVDAT,DEVLST	;SEARCH ALL DDB'S
DEA1:	CAIE DEVDAT,@(PDP)	;IS THIS DEVICE NOT TO BE DEASSIGNED?
	PUSHJ PDP, DEASG	;NO, TRY TO DEASSIGN IT
	JFCL			;IGNORE IF CAN'T
	HLRZ DEVDAT, DEVSER(DEVDAT)
	JUMPN DEVDAT, DEA1
	POP PDP,DEVDAT		;RESTORE TTY DDB ADDRESS
	POPJ PDP,
;ROUTINE TO READ CONSOLE AND CONVERT ANY RADIX NUMBER
; CALL:	MOVE R,  DESIRED RADIX
;	PUSHJ PDP, ANYRIN
;	NO ARG. TYPED RETURN, TAC1=0
;	ILLEGAL CHARACTER RETURN
;	NORMAL EXIT	;AC TAC1 CONTAINS NUMBER
;SCAN STOPS ON FIRST CR,DASH,SPACE,OR TAB OR ILLEGAL CHAR.
;IF IT IS ILLEGAL CHAR.,SUBROUT. LEVEL IS POPED AND COMERA IS CALLED
;WHICH PRINTS MONITOR COMMAND ERROR. THUS CALLER NEVER SEES RETURN
;SKIPS LEADING SPACES AND TABS



C←BUFPNT			;CHARACTER AC
R←DSER				;RADIX AC

↑DECIN1:
↑DECIN:	MOVEI R,=10		;DECIMAL INPUT
	JRST ANYRIN

↑OCTINS:PUSHJ P,GETLCCHR	;SKIP PRECEEDING + OR -
↑OCTIN:	MOVEI R,10		;OCTAL INPUT
ANYRIN:	PUSHJ PDP,SKIPS1	;SKIP LEADING SPACES, TABS, NULLS
				;DO NOT RETURN IF CR WAS PREVIOUS BREAK
				;OR THIS BREAK
OCT0:	CAIL TEM,175		; ALT MODE?
	JRST CPOPJ2
	CAIE TEM,";"		;SEMICOLON?
	CAIN TEM," "		;SPACE?
	JRST CPOPJ2		;YES, SKIP RETURN
	CAIE TEM,"-"		;NO, DASH?
	CAIN TEM,15		;CR?
	JRST CPOPJ2		;YES, ONLY LEGAL TERMINATORS
	CAIE TEM,","		;COMMA?
	CAIN TEM,"["		;LEFT BRACKET?
	JRST CPOPJ2		;YES.
	SUBI TEM,60
	JUMPL TEM,CPOPJ1	;ERROR IF NEG.,REMOVE SUB. RETURN AND PRINT
	CAML TEM, R		;OR .GE. RADIX
	JRST CPOPJ1		;ERROR, GREATER OR EQUAL TO RADIX
	IMUL TAC1, R
	ADD TAC1,TEM
↑CONTYI:		;PATCHED BY ONCE.
XXTYI:
	PUSHJ PDP,GETCHR
	JRST OCT0
;GET PROJECT-PROGRAMMER NUMBERS
;CALL:	MOVE TAC,INPUT BYTE POINTER
;	PUSHJ PDP,PJPGNO
;	ERROR RETURN
;	OK RETURN
;
;(AC2)LH ← PROJECT NUMBER
;(AC2)RH ← PROGRAMMER NUMBER

IFN FTLOGIN,<
PJPGNO:	PUSHJ PDP,SKIPS1	;SKIP LEADING BLANKS.
	CAIE TEM,"["		;IS THERE A [?
	POPJ PDP,		;NO. NO PPN.
	PUSHJ PDP,PJPG1		;READ PROJ. "NUMBER".
	HLL AC2,TAC1
	CAIE TEM,","		;SHOULD BE FOLLOWED BY A COMMA.
	JRST PJPG2
	PUSHJ PDP,PJPG1		;NOW PROG. NO.
	HLR AC2,TAC1
	CAIN TEM,"]"		; ] IS OPTIONAL.
	PUSHJ PDP,GETLCCHR	;THROW IT AWAY IF PRESENT.
	JRST CPOPJ1

PJPG1:	PUSHJ PDP,CTEXT		;SCAN NEXT THING.
	JUMPE TAC1,TPOPJ	;RETURN UPLEVEL IF NOTHING.
	TLNN TAC1,7777
	LSH TAC1,-14		;JUSTIFY NOW IN CASE SKIPSB DOESN'T COME BACK
	TLNN TAC1,77
	LSH TAC1,-6
	PUSHJ PDP,SKIPSB	;MAKE SURE WE SEE TERMINATOR.
	POPJ P,			;PROGRAM BUMMERS BEWARE OF UPLEVEL RETURN!

PJPG2:	CAIE TEM,12
	POPJ P,
	SKIPN TAC1,DSKPPN(J)	;COPY PRG FROM APPROPRIATE PLACE
	MOVE TAC1,PRJPRG(J)
	HRR AC2,TAC1
	JRST CPOPJ1
>
;ROUTINE TO PRINT TIME AS HOURS,MINUTES,SECONDS, AND HUNDRETHS
;FORMAT IS HHMM:SS.HH
;CALL:	MOVE TAC,TIME IN JIFFIES(60THS,50THS OR MILLISECONDS)
;	MOVE DAT,OUTPUT TEXT BYTE POINTER
;	PUSHJ PDP,PRTIME

JIFMIN←←JIFSEC*=60		;NUMBER OF JIFFIES PER MINUTE.
JIFSC2←←JIFSEC/2		;NUMBER OF JIFFIES PER HALF SEC.

REPEAT 0,<	;THIS ROUTINE HAS BEEN REPLACED BY ONE OF THE SAME NAME IN CLKSER

PRTIME:	PUSHJ PDP,HHMM		;DEC 3.16
	JUMPE TAC,PR1		;DO NOT PRINT HOURS OR MINUTES IF 0
	PUSHJ PDP,RADX10	;PRINT BASE 10
	PUSHJ PDP,INLMES	;PRINT COLON
	ASCIZ /:/
PR1:	MOVE TAC,TAC1		;MOVE TAC,TAC1
	IDIVI TAC,JIFSEC	;JIFFIES PER SECOND
	PUSHJ PDP,RADX10	;PRINT SECONDS
	PUSHJ PDP,PRPER		;PRINT PERIOD
	MOVE TAC,TAC1		;NO OF JIFFIES(HUNDRETHS)
	IMULI TAC,=100		;CONVERT TO HUNDRETHS
	IDIVI TAC,JIFSEC
	CAIL TAC1,JIFSC2	;ROUND IF GREATER THAN HALF
	AOS TAC
	MOVEI TEM,"0"		;PRINT LEADING 0 IF NO.
	JRST PR2		;DEC 3.16

HHMM:	IDIVI TAC,JIFMIN	;DEC 3.16, REST OF PAGE.
	PUSH PDP,TAC1
	IDIVI TAC,=60
	IMULI TAC,=100
	ADD TAC,TAC1
	POP PDP,TAC1
	POPJ PDP,

PRTIM1:	PUSHJ PDP,HHMM
	MOVEI TEM,"0"
	CAIGE TAC,=1000
	XCT TYO
	CAIGE TAC,=100
	XCT TYO
PR2:	CAIGE TAC,=10
	XCT TYO
	JRST DECLF
>;END REPEAT 0
SUBTTL	ERRCON	4 AUG 67

;THESE ERROR ROUTINE PRINT "ERROR IN JOB N"
;FOLLOWED BY AN APPROPRIATE ERROR MESSAGE
;THEN THE JOB IS STOPPED AND CONSOLE IS RETURNED TO
;MONITOR COMMAND MODE

;APR DETECTED ERRORS
;PUSHDOWN OVERFLOW,ILLEGAL MEMORY, NONEXISTENT MEMORY
;FOR WHICH THE USER IS NOT ENABLED.
;SEE APRSER TO SEE HOW APR INTERRUPTS ARE HANDLED
;CALL:	SKIPE TAC,APRERR	;RESULT OF CONI APR,APRERR
;	PUSHJ PDP,APRILM	;FROM CLK SERVICE ROUT.(LOWEST PRIOTITY PI)
;	RETURN TO RESCHEDULE NEW USER

↑APRILM:
	SETZM APRERR(PID)	; ZERO ERROR FLAG
	MOVE ITEM,JOB(PID)	; BLAME CURRENT JOB, WHOMEVER IT MAY BE
	TRNN TAC,ILM		; ILLEGAL MEMORY REFERENCE?
	JRST APRNXM		;NO
	MOVE TAC,APRPC(PID)
	TLNE TAC,USRMOD
	JRST APRIL2
	PUSHJ P,KILSPW		; KILL HIS SPW JOB SO IT WON'T HAPPEN AGAIN
	JRST APRIL1
APRIL2:	HRRZS TAC
	CAMG TAC,USRREL(PID)	;IS IT IN BOUNDS?
	JRST APRIL1
	TRNN TAC,400000
	JRST APRJRS
	LDB TAC1,PSEGN
	JUMPE TAC1,APRJRS
	HLRZ TAC1,JBTADR(TAC1)
	CAILE TAC,400000(TAC1)
	JRST APRJRS
APRIL1:	JSP TAC,ERRPNT		;YES
	ASCIZ /ILL MEM REF/
	JRST APRSCD		;PRINT LOC, THEN STOP JOB

APRJRS:	JSP TAC,ERRPNT
	ASCIZ /PC EXCEEDS MEM BOUND/
	JRST APRSCD		;PRINT LOC, THEN STOP JOB
APRNXM:	TRNN TAC,NXM		;NON-EX MEM?
	JRST PDLAPR		;NO
	JSP TAC,ERRPNT		;YES
	ASCIZ /NON EX MEM/
	JRST APRSCD		;PRINT LOC, THEN STOP JOB

PDLAPR:	TRNN TAC,POV		;PUSHDOWN OVERFLOW?
	JRST APRCNS		;NO	;JS
	JSP TAC,ERRPNT		;YES
	ASCIZ /PDL OV/
APRSCD:	MOVE TAC1,APRPC(PID)	;PRINT APR PC 
	JRST PCPNT		;AS:
				;1)"AT USER LOC XXX" OR
				;2)"AT EXEC LOC XXX; EXEC CALLED FROM
				;   EXEC/USER LOC YYY

APRCNS:	TRNN TAC,CNS		;JS, REST OF PAGE.  CONS TRAP?
	JSP DAT,UERROR		;NO. HARDWARE PROBLEM.
	JSP TAC,ERRPNT
	ASCIZ /CONS TRAP/
	JRST APRSCD
;JS REST OF PAGE			;REG
; ROUTINE TO PRINT ERROR MESSAGE FOR SPW MODULES

↑SPWMES:
	JSP TAC,ERRPNT
	ASCIZ /SPACEWAR LOSSAGE/
	MOVE TAC,JBTST2(J)		;GET GOOD BITS
	TLNN TAC,ILMSPW			;ILL MEM REF?
	JRST SPWNXM			;NO
	HRRZS TAC
	HLRZ TAC1,JBTADR(J)
	CAMG TAC,TAC1
	JRST SPWILM
	TRNN TAC,400000
	JRST SPWIPC
	LDB TAC1,PSEGN
	JUMPE TAC1,SPWIPC
	HLRZ TAC1,JBTADR(TAC1)
	TRO TAC1,400000
	CAMLE TAC,TAC1
	JRST SPWIPC
SPWILM:	PUSHJ P,INLMES
	ASCIZ/ - ILL MEM REF/
	JRST SPWMS1
SPWIPC:	PUSHJ P,INLMES
	ASCIZ/ - PC EXCEEDS MEM BOUNDS/
	JRST SPWMS1
SPWNXM:	TLNN TAC,NXMSPW
	JRST SPWPDL
	PUSHJ P,INLMES
	ASCIZ/ - NON EX MEM/
	JRST SPWMS1
SPWPDL:	TLNN TAC,POVSPW
	JRST SPWCNS
	PUSHJ P,INLMES
	ASCIZ/ - PDL OV/
	JRST SPWMS1
SPWCNS:	TLNN TAC,CNSSPW
	JRST SPWTMX
	PUSHJ P,INLMES
	ASCIZ/ - CONS TRAP/
SPWTMX:	TLNN TAC,ILLTMO
	JRST SPWMS1
	PUSHJ P,INLMES
	ASCIZ/ - TIME OUT/
SPWMS1:
	HRRZ TAC1,JBTST2(ITEM)
	HRLI TAC1,USRMOD
	PUSHJ PDP,KILSPW
	JRST PCPNT
;ADDRESS CHECK ERROR AT ANY LEVEL
;DEVDAT MUST BE SET UP TO POINT TO OFFENDING DEVICE


↑ADRERR:
	JSP TAC,ERRDEV		; GET JOB NO. FROM DEVICE DATA BLOCK
UADER1:	ASCIZ /ADDRESS CHECK FOR /
	JRST DEVEXC		;PRINT "DEVICE XXX; EXEC CALLED FROM
				;   EXEC/USER LOC YYY"
				;THEN STOP JOB

↑UADRER:
	MOVEI TAC,UADER1	;ADDRESS CHECK AT UUO LEVEL.
	JRST ERRPTU		;WE WILL RETURN TO UADER1.

; ROUTINE TO PRINT OUT MESSAGE FOR NON-IO UUOS
; CALL BY <JRST UADERR>, DOES NOT RETURN

↑UADERR:
	JSP TAC,UUOMES
	ASCIZ /ADDRESS OUT OF BOUNDS, UUO /
;CALL:	JSP DAT,ERROR
;
;TYPES "ERROR IN MONITOR" FOLLOWED BY CONTENTS OF DAT
;THEN GOES TO AUTOLOAD



↑ERROR:
	MOVEM P,ERRPDL(PID)	;SAVE IT WHERE WE CAN FIND IT
	MOVE P,ERRPD(PID)
	AOBJN P,.+1
	PUSHACS
	PUSH P,DAT		;SAVE CALLING ADDR
	PUSHJ P,DISDATE
	PUSHJ P,DISMES
	ASCIZ /MONITOR ERROR AT /
	POP P,TAC
	SUBI TAC,1
	PUSHJ P,DISOCT
	PUSHJ P,DISCRLF
	SETOM DISFLAG
	PUSHJ P,DISFLUSH
	POPACS
	DEBCHECK
	JRST AUTOLOAD		;THIS IS A LOSE ALWAYS NOW
; UERROR IS FOR UUO LEVEL, BLAMES CURRENT JOB
; CERROR IS FOR CLOCK LEVEL AND LOSES

↑UERROR:
	MOVE ITEM,JOB(PID)	; PRINT FOR CURRENT JOB NUMBER
↑CERROR:
	JSP TAC,ERRPNT		; ITEM ALREADY SET UP
	ASCIZ /?
ERROR IN MONITOR/
	MOVE TAC1,-1(PDP)	;GET LOC OF JSP DAT,ERROR
	JRST PCPNT		;PRINT "AT EXEC LOC XXX;
				;  EXEC CALLED FROM EXEC/USER YYY"
				;THEN STOP JOB

;INPUT UUO FOR OUTPUT DEVICE
;CALLED AT UUO LEVEL ONLY


↑ILLINP:
	JSP TAC,ERRPTU
	ASCIZ /OUTPUT /
	PUSHJ PDP,ERNAM		;PRINT "DEVICE XXX"
	JSP TAC,UUOMES		;PRINT MESSAGE,UUOPC,STOP JOB
	ASCIZ / CANNOT DO INPUT/
; USER TRIED TO GIVE LPT OR PTP A BUFFER LARGER THAN
; THE INTERNAL SYSTEM BUFFER
; CALLED FROM UUO LEVEL ONLY

↑BTLERR:
	JSP TAC,ERRPTU		; SET UP TTY DEVDAT
	ASCIZ /?
/
	PUSHJ PDP,ERNAM		; "DEVICE XXX"
	JSP TAC,UUOMES
	ASCIZ / BUFFER TOO LARGE, UUO/

;OUTPUT UUO FOR INPUT DEVICE
;CALLED AT UUO LEVEL ONLY


↑ILLOUT:
	JSP TAC,ERRPTU
	ASCIZ /INPUT /
	PUSHJ PDP,ERNAM		;PRINT "DEVICE XXX"
	JSP TAC,UUOMES		;PRINT MESSAGE,UUOPC,STOP JOB
	ASCIZ / CANNOT DO OUTPUT/

;ILLEGAL DEVICE DATA MODE (INIT, OPEN, OR SETSTS UUOS)
;CALLED AT UUO LEVEL ONLY


↑ILLMOD:
	JSP TAC,ERRPTU
	ASCIZ /ILLEGAL DATA MODE FOR /
	JRST DEVEXC		;PRINT "DEVICE XXX",UUO PC

;IO UUO TO USER CHANNEL WITH NO PREVIOUS INIT OR OPEN
;CALLED AT UUO LEVEL ONLY


↑IOIERR:
	JSP TAC,ERRPTU
	ASCIZ /IO TO UNASSIGNED CHANNEL/
	JRST UUOPCP		;PRINT UUO PC
;UUOERR: ILLEGAL UUO 
;CALLED AT UUO LEVEL ONLY - liar!


↑UUOERR:
	SKIPE	SPWUUF(PID)	;DON'T GIVE MESSAGE IN SPACEWAR MODE
	CONSZ	PI,77000	;YES, CH7?
	CAIA			;NO TO EITHER
	JRST	SPWERR		;WE MIGHT BE ON THE PDP-6
	MOVEM	J,TSAVJ#	;I HATE VARIABLES, BUT SAVE J
	MOVE	J,JOB(PID)	;SOMETIMES NOT SET UP BY DPYSER
	MOVE	TAC1,UUOPC(J)
	JUMPE	J,UUOER3
	TLNE	TAC1,USRMOD
	JRST	UUOER1		;USER MODE CALL
UUOER3:	MOVEM	P,ERRPDL	;UUO CALLED FROM EXEC STORE LOSER'S P.
 	MOVE	P,ERRPD(PID)
	ADD	P,[1,,1]
UUOER1:	JSP	TAC,ERRPTU	;RETURNS WITH DAT AND DDB PUSHED
	ASCIZ	/ILLEGAL UUO/
	MOVE	TAC1,UUOPC(J)	;GET LAST UUO PC
	TLNE	TAC1,USRMOD	;USER ERROR?
	SOJA	TAC1,PCPNT
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/ILL UUO FROM EXEC AT UUO LEVEL
UUO AT /
	MOVE	TAC,UUOPC(J)
	MOVEI	TAC,-1(TAC)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISTAB
	PUSHJ	P,DISJOB
	PUSHJ	P,DISMES
	ASCIZ	/ UUOOPC = /
	MOVE	TAC,UUOOPC(J)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ	/  P= /
	MOVE	TAC,ERRPDL
	PUSHJ	P,DISOCT
	CAMN	J,TSAVJ
	JRST	UUOER2
	PUSHJ	P,DISMES
	ASCIZ	/J WAS: /
	MOVE	TAC,TSAVJ
	PUSHJ	P,DISOCT		;ONLY MAKES SENSE IN DECIMAL IF A JOB NUMBR
UUOER2:	PUSHJ	P,DISCRLF
	PUSHJ	P,SYSFIX
	JFCL			;NO ERRORS
	JFCL			;FOUND TROUBLE, BUT COULDN'T FIX IT!
	PUSHJ	P,DISFLUSH	;TELL THE WORLD
	POPACS
	PUSHJ	P,WDDTCALL
	MOVE	TAC1,UUOPC(J)
	SOJA	TAC1,PCPNT	;ALWAYS TRY JUST FLUSHING LOSER
;ILLEGAL INSTRUCTION  -  ILLINS, HALT
;HALT INSTRUCTION IS A SPECIAL CASE WHICH STOPS JOB BUT
;THE USER MAY CONTINUE FROM IT(EFFECTIVE ADR.)
;CALLED AT UUO LEVEL WITH A JRST


↑ILLINS:
	HLRZ TAC,UUO		; ILLEGAL OPCODE
	ANDI TAC,777600		;LOOK AT OPCODE AND HIGH 2 AC BITS
	CAIN TAC,(<JRST 4,>)	;IS IT A HALT?
	JRST HALT		;YES, PRINT DIFFERENT MESSAGE
	JSP TAC,ERRPTU
	ASCIZ /ILL INST./
	JRST UUOPCP		;PRINT UUO PC AND STOP JOB

↑HALT:	MOVE J,JOB(PID)		; PICK UP JOB NUMBER
	PUSHJ P,TTYERP		; SET TTY IN MONITOR MODE
	PUSHJ P,INLMES
	ASCIZ /HALT/
	SOS TAC1,UUOPC(J)	;UUOPC = LOCATION OF HALT PLUS ONE
	PUSHJ P,PCP		;PRINT "USER LOC XXX"
	PUSHJ P,PRCRCC		;PRINT MONITOR MODE RESPONSE
	HRRM UUO,UUOPC(J)	; SAVE EFFECTIVE ADDRESS OF HALT
	PUSHJ P,TTYSTC		;START TTY TYPING
	PUSHJ P,SETSTP		;STOP JOB, BUT FINISH THIS UUO
	SKIPN INTACT(PID)
	JRST USRXIT		;"RETURN" TO ADDRESS OF HALT (WILL NEVER GET THERE)
	JRST ESTOP
;ROUTINE FOR HUNG IO DEVICE
;CALL	MOVE DEVDAT,ADDRESS OF DEVICE DATA BLOCK
;	PUSHJ PDP,DEVHNG


↑DEVHNG:
	MOVEI TAC,IOACT		; TURN OFF IO DEVICE ACTIVE BIT IN
	ANDCAM TAC,DEVIOS(DEVDAT);MEMORY AND IOS
	TRZ IOS,IOACT
	JSP TAC,ERRDEV
	ASCIZ /HUNG /
	JRST DEVEXC

;BAD DECTAPE DIRECTORY
;CALLED AT INTERRUPT AND UUO LEVELS WITH DEVDAT AND ITEM SETUP


↑BADDIR:
	JSP TAC,ERRPNT
	ASCIZ /BAD DIRECTORY FOR /

;ROUTINE TO PRINT "DEVICE XXX; EXEC CALLED FOR EXEC/USER YYY"
;THEN STOP JOB
;TO BE USED BY DEVICE DEPENDENT ERROR MESSAGES AFTER JSP TAC,DEVERR


↑DEVEXC:
	PUSHJ PDP,ERNAM		; PRINT "DEVICE XXX"
	MOVE TAC,(P)		; GET DEVICE DDB
	MOVE TAC1,DEVMOD(TAC)	;RPH PATCH TO CLEAR GOBIT ON DISK ERRORS
	TLNN TAC1,DVDSK
	JRST EXCALP
	MOVSI IOS,GOBIT
	ANDCAB IOS,DEVIOS(TAC)	;CLEAR GO BIT IF STOPPING DISK
	JRST EXCALP		;PRINT "EXEC CALLED FROM EXEC/USER LOC YYY"
;ROUTINE TO HALT A JOB WHEN A DEVICE IS NOT READY FOR I/O
;CALLED FROM XXXSER AT UUO LEVEL
;CALL	MOVE DEVDAT,ADDR OF DEVICE DDB
;	MOVE ITEM,JOB NUMBER
;	PUSHJ PDP,HNGSTP


↑HNGSTP:
	PUSH PDP,IOS		; SAVE STUFF FOR DEVICE
	PUSH PDP,DEVDAT
	PUSHJ PDP,TTYFUW
	PUSHJ PDP,PRQM
	PUSHJ PDP,ERNAM		;PRINT "DEVICE XXX"
	PUSHJ PDP,INLMES	;AND MESSAGE
ASCIZ / OK?
/
	PUSHJ P,PRCRCC
	PUSHJ PDP,TTYSTC	;START TTY IN COMMAND MODE
	POP PDP,DEVDAT
	POP PDP,IOS
	PUSHJ PDP,STOP1		;STOP JOB
	JRST WSCHED		;AND RESCHEDULE
; ROUTINE TO PRINT A MESSAGE AND STOP A JOB IN A WAY
; THAT CAN BE CONTINUED FROM.
; CALLING . . .
;	MOVEI TAC,[ASCIZ /MESSAGE HERE/]
;	PUSHJ P,HNGMES

↑HNGMES:
	PUSH P,IOS
	PUSH P,DEVDAT
	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	PUSH P,DAT
	PUSH P,TEM
	PUSH P,TAC1
	PUSH P,TAC
	MOVE J,JOB(PID)
	PUSHJ P,TTYFUW
	POP P,TAC
	PUSHJ P,CONMES
	PUSHJ P,PRCRCC
	PUSHJ P,TTYSTC
	PUSHJ P,STOP1
	POP P,TAC1
	POP P,TEM
	POP P,DAT
	POP P,AC3
	POP P,AC2
	POP P,AC1
	POP P,DEVDAT
	POP P,IOS
	JRST WSCHED
;COMMON ERROR MESSAGE SETUP ROUTINES - ERRPTU
;CALL:	JSP TAC,ERRPTU, ERRDEV, OR ERRPNT
;	ASCIZ /MESSAGE/
;	RETURNS HERE WITH DEVDAT SAVED 0(PDP)
;	C(DEVDAT)=TTYDDB, DAT TO TTY OUTPUT BUFFER POINTER
;	ITEM=JOB NUMBER

;USE ERRPTU IF AT UUO LEVEL FOR SURE
;ERRDEV IF ERROR FOR AN ASSIGNED DEVICE AT ANY LEVEL
;ERRPNT WITH ITEM ALREADY SET TO OFFENDING JOB NUMBER
;THE JSP CALL IS USED IN CASE PUSHDOWN SPACE BECOMES CRITICAL
;AGAIN AND ERRPNT HAS TO WIPE EXISTING LIST OUT

↑ERRPTU:
	SKIPN J,JOB(PID)	; BLAME CURRENT JOB IF NOT 0
↑ERRDEV:
	LDB J,PJOBN		; JOB NUMBER FROM DEVICE DATA BLOCK
↑ERRPNT:
	JUMPN J,.+2
	SETOM NULBAD(PID)
	PUSH P,DAT		; SAVE CALL TO ERROR
	SKIPL J
	CAIL J,JOBN		;REASONABLE JOB NUMBER?
	CAIA
	JRST ERRZZ2
	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISMES
	ASCIZ/AT ERRPTU FOR JOB 0
/
	POPACS
	DEBCHECK
	SKIPN DISFLAG
	JRST ERRZZ2
	PUSHJ P,DISFLUSH
	JRST AUTOLOAD

ERRZZ2:	PUSH P,DDB		;SAVE ADR. OF DEV. DATA BLOCK
	PUSH P,TAC		;SAVE RETURN FROM ERRPNT
	MOVE JDAT,JBTDAT(J)	;EVEN NULL JOB HAS JOB DATA AREA
IFN JDMPRG,<
	MOVE PROG,JBTADR(J)	;JOB RELOCATION
>
	PUSHJ P,TTYERP		;FIND JOB'S TTY AND SET UP DDB.
	PUSHJ P,INLMES
	ASCIZ /?
ERROR IN JOB /
	PUSHJ P,PJOB		;PRINT JOB NO.
	JRST INLMES		;PRINT MESSAGE SPECIFIED BY CALLER
;ROUTINE TO PRINT UUO PC AND STOP JOB - UUOMES, UUOPCP, PCPNT
;IF IN USER MODE PC WILL PRINT AS "AT USER LOC XXX"
;IF IN EXEC MODE "AT EXEC LOC XXX; EXEC CALLED FORM EXEC/USER/ LOC YYY


↑UUOMES:
	MOVE J,JOB(PID)		;MAKE SURE J IS SET UP
	SKIPE SPWUUF(PID)
	CONSZ PI,77000
	CAIA
	JRST SPWERR		;MIGHT BE ON PDP-6
	PUSH P,TAC
	PUSHJ P,TTYERP
	POP P,TAC
	PUSHJ P,CONMES		; PRINT MESSAGE POINTED TO BY TAC
↑UUOPCP:
	MOVE TAC1,UUOPC(J)	; UUO PC STORED AT BOTTOM OF PDL
				;FIRST LOC ON PD LIST
	SOJA TAC1,PCPNT		;DECREMENT TO POINT TO UUO IN USER AREA

;ROUTINE TO PRINT ONE OF THREE MESSAGES AND STOP JOB
;1) "AT EXEC LOC XXX; EXEC CALLED FROM EXEC LOC YYY"
;2) "AT EXEC LOC XXX; EXEC CALLED FORM USER LOC YYY"
;3) "AT USER LOC YYY"

;CALL:	MOVE TAC1, XXX		;WITH PC FLAGS IN LH
;	PUSHJ PDP,PCPNT
;	NEVER RETURN IF AT UUO LEVEL


↑PCPNT:	PUSHJ P,PCP		;PRINT " AT EXEC XXX" OR " AT USER "
	TLNE TAC1,USRMOD	;WAS PC IN USER MODE?
	JRST PCSTOP		;YES, ENOUGH INFO.
;ROUTINE TO PRINT EITHER: - PCSTOP, PCP
;1) "; EXEC CALLED FROM EXEC LOC YYY"
;2) "; EXEC CALLED FROM USER LOC YYY"
;AND STOP JOB
;CALL:	PUSHJ PDP,EXCALP
;	NEVER RETURNS IF AT UUO LEVEL


↑EXCALP:
	PUSHJ P,INLMES
	ASCIZ /; UUO/
	MOVE TAC1,UUOPC(J)	; UUO PC ON PDL
	SUBI TAC1,1		;BACK IT UP TO POINT TO UUO
	PUSHJ P,PCP		;PRINT "EXEC LOC " OR USER LOC
↑PCSTOP:
	PUSHJ P,HOLD		; STOP JOB, START TTY AND SET JOB ERROR BIT
	POP P,DDB		;RETURN ONLY IF AT INTERRUPT LEVEL
	JRST TPOPJ		;REMOVE ERROR CALL AND RETURN

;ROUTINE TO PRINT PC AS:
;1) "EXEC LOC XXX" OR "USER LOC XXX"
;CALL:	MOVE TAC1,PC TO PRINT(LH=PC FLAGS)
;	PUSHJ PDP,PCP


XMODE:	ASCIZ / AT EXEC /
UMODE:	ASCIZ / AT USER /

PCP:	MOVEI TAC,XMODE		;ASSUME PC IN EXEC MODE
	TLNE TAC1,USRMOD	;IS IT?
	MOVEI TAC,UMODE		;NO, USER MODE
	PUSHJ PDP,CONMES	;PRINT ONE OR OTHER
	HRRZ TAC,TAC1		;PRINT RIGHT HALF IN OCTAL
				;FALL INTO OCTPNT
;ROUTINE TO PRINT 36 BIT OCTAL NO
;CALL:	MOVE DAT, TTY OUTPUT BYTE POINTER
;	MOVE TAC,OCTAL NO
;	PUSHJ PDP,OCTPNT


↑OCTPNT:
	PUSH	P,TAC1		; SAVE TAC1
	MOVEI	TAC1,10		;OCTAL BASE
ANYRDX:	PUSH	P,ITEM
	MOVEI	ITEM,(TAC1)
	PUSHJ	P,OCTP1
	POP	P,ITEM
	POP	P,TAC1
	POPJ	P,

OCTP1:	IDIV	TAC,ITEM
	HRLM	TAC1,(P)
	JUMPE	TAC,.+2
	PUSHJ	P,OCTP1
	HLRZ	TEM,(P)
	MOVEI	TEM,"0"(TEM)
	XCT	TYO
	POPJ	P,

;ROUTINE TO PRINT DECIMAL NO.
;CALL:	SAME AS OCTPNT
;TAC1 IS PRESERVED

↑RADX10:
	PUSH	P,TAC1		; OUTPUT DECIMAL
	MOVEI	TAC1,12
	JRST	ANYRDX
;ROUTINE TO PRINT "DEVICE XXX"
;CALL	MOVE DAT,ASCII OUTPUT BYTE POINTER
;	PUSH PDP,DEVDAT
;	PUSHJ PDP,ERNAM


↑ERNAM:	PUSHJ	P,INLMES
	ASCIZ	/DEVICE /
	SKIPE	TAC1,-1(P)		;IS DEVDAT = 0?
	MOVE	TAC1,DEVNAM(TAC1)	;NO, GET DEVICE NAME


;ROUTINE TO PRINT SIXBIT NAME
;CALL	MOVE DAT,ASCII OUTPUT BYTE POINTER
;	MOVE TAC1,NAME
;	PUSHJ PDP,PRNAME

↑PRNAME:
	JUMPE	TAC1,CPOPJ	;DONE IF NULL
	MOVEI	TAC,0
	LSHC	TAC,6		;SHIFT IN NEXT CHAR.
	MOVEI	TEM,40(TAC)
	XCT	TYO		;TYPE OUT IN ASCII.
	JRST	PRNAME
;DISASTER TYPEOUT		DISOUT
; ROUTINE TO TYPE OUT DISASTER BUFFER ON CTY AT CLOCK LEVEL
; RECCOMMENDED CALLING . . .
;	MOVE TAC,DISPTR
;	CAME TAC,DISOPT
;	PUSHJ P,DISOUT
; PUTS AS MUCH TEXT AS IT CAN INTO THE CTY OUTPUT BUFFER AND INITIATES
; CTYTYO.

↑DISOUT:
	SETZ J,
	PUSHJ P,TTYFND		; SET UP DDB AND DAT TO THE CTY
DISOU1:	MOVE TAC,FCTR(DAT)	; HOW FULL IS THE BUFFER?
	CAIG TAC,1
	JRST TYPGO		; FULL TO THE GILLS. INITIATE TYPEOUT
	ILDB TEM,DISOPT		; THERE IS ROOM. PICK UP A CHARACTER.
	AOS DISCTR
	XCT TYO
	MOVE TAC,DISOPT
	MOVE AC1,TAC
	IBP AC1
	HRRZS AC1
	CAIGE AC1,DISBUF+DISLEN
	JRST DISOU2
	MOVEI AC1,DISBUF-1	; WRAP POINTER AROUND
	HRRM AC1,DISOPT
DISOU2:	CAME TAC,DISPTR
	JRST DISOU1		; BUFFER NOT EMPTY. TRY TO STUFF ANOTHER CHARACTER IN.
	JRST TYPGO		; EMPTY. INITIATE TYPEOUT.
; DISFLUSH - CALL WITH PIS OFF TO FINISH FLUSHING
; DISASTER BUFFER. SERVOS CTY ALL BY ITSELF
; CALLING . . .
;	PUSHJ P,DISFLUSH

↑DISFLUSH:
	CONSO APR,MAOFF		;ARE WE THE PDP-6
	POPJ P,			;YES, NOTHING TO FLUSH.
	CONI CTY,AC1
	HRLM AC1,(P)		;SAVE PI CHANNEL
	CONO CTY,0		;AND SET TO 0 SO WE WON'T INT
	MOVEI AC1,100000	; WAIT FOR THE CTY TO COOL OFF
	SOJG AC1,.
	SKIPN DAT,TTYTAB+TCONLN	;IS THE CTY THERE AT ALL?
	JRST DISFL1		;NO, SKIP ALL THIS CRAP
	ADDI DAT,TTOBUF		;POINT TO OUTPUT BUFFER
DISFL3:	MOVE TAC,TAKR(DAT)
	CAMN TAC,PUTR(DAT)
	JRST DISFL1		; OUTPUT BUFFER EMPTY, EXIT
	PUSHJ P,GETCHO		; PICK UP A CHARACTER FROM THE OUTPUT BUFFER
	PUSHJ P,CTYTYO		; AND TYPE IT OUT
	JRST DISFL3

DISFL1:	MOVE TEM,DISOPT
	SKIPLE DISCTR		; MAY BE FULL
				; (BYTE POINTERS THE SAME WHEN FULL TOO)
	CAME TEM,DISPTR		; NOW IF THE SAME, THEN EMPTY
	CAIA
	JRST DISFLX		;SO LEAVE
	IBP TEM
	HRRZS TEM
	CAIGE TEM,DISBUF+DISLEN
	JRST DISFL4
	MOVEI TEM,DISBUF-1
	HRRM TEM,DISOPT
DISFL4:	ILDB TEM,DISOPT		; PICK UP A CHARACTER
	AOS DISCTR
	PUSHJ P,CTYTYO		; TYPE OUT ON CTY
	JRST DISFL1

DISFLX:	HLRZ AC1,(P)
	ANDI AC1,7	;GET BACK OLD PI CHAN
	CONO CTY,(AC1)
	POPJ P,
; DISTYO - TYPES ONE CHARACTER IN TEM THROUGH
; THE DISASTER BUFFER.
; CALLING . . .
;	MOVE TEM,<CHARACTER>
;	PUSHJ P,DISTYO

↑DISTYO:
	CONSO APR,MAOFF		;ARE WE THE PDP-10
	JRST CTYTYO		;NO, JRST HANG THINGS UP WHILE WE TYPE
	SKIPLE DISCTR		; ANY ROOM IN BUFFER?
	JRST DISTY1		; YES, JUST PLUNK THE CHARACTER IN
	SKIPN DISFLAG		; ARE PIS OFF YET?
	CONO PI,PIOFF		; NO, TURN THEM OFF
	PUSH P,TEM
	PUSHJ P,DISFLUSH	; EMPTY THE DISASTER BUFFER
	POP P,TEM
	SKIPN DISFLAG
	CONO PI,PION
	JRST DISTYO

DISTY1:	SOSL DISCTR
	JRST DISTY2
	AOS DISCTR
	JRST DISTYO

DISTY2:	CONO PI,PIOFF
	IDPB TEM,DISPTR
	CONO PI,PION
	MOVE AC1,DISPTR
	IBP AC1
	HRRZS AC1
	CAIGE AC1,DISBUF+DISLEN
	POPJ P,
	CONO PI,PIOFF
	MOVE AC1,DISPTR
	IBP AC1
	HRRZS AC1
	CAIGE AC1,DISBUF+DISLEN
	JRST DISTY3
	MOVEI AC1,DISBUF-1
	HRRM AC1,DISPTR
DISTY3:	CONO PI,PION
	POPJ P,
;DISMES, DISCRLF, DISTAB, DISJOB
; ROUTINE TO DO A DISASTER OUTPUT OF A STRING
; CALL BY:
;	PUSHJ P,DISMES
;	ASCIZ /<STRING>/

↑DISMES:
	MOVSI	AC1,(<POINT 7,0>)
	HLLM	AC1,(P)			;SET RETURN ADDRESS TO A BYTE POINTER
DISME1:	ILDB	TEM,(P)			;GET A BYTE
	JUMPE	TEM,CPOPJ1		;NONE THERE. INCREMENT SAVED PC AND RETURN
	PUSHJ	P,DISTYO
	JRST	DISME1

↑DISCRLF:			;CALL TO DO DISASTER OUTPUT OF CRLF ON THE CTY
	MOVEI	TEM,15
	PUSHJ	P,DISTYO
	SKIPA	TEM,[12]
↑DISTAB:MOVEI	TEM,11		;TYPE TAB THRU DISASTER SERVICE
	JRST	DISTYO

↑DISJOB:			;TYPE JOBNUMBER(JOBNAME). J IS SET WITH JOBNUMBER
				;J IS PRESERVED.
	PUSH	P,J		;SAVE JOB NUMBER
	MOVE	TAC1,JOBNAM(J)	;GET THE JOBNAME
	PUSHJ	P,DISSIX
	MOVEI	TEM,"("
	PUSHJ	P,DISTYO
	MOVE	TAC,(P)
	PUSHJ	P,DISDCP	;TYPE JOB NUMBER IN DECIMAL WITH DECIMAL POINT
	MOVEI	TEM,")"
	PUSHJ	P,DISTYO
	POP	P,J
	POPJ	P,
;CALLING SEQUENCE
;	PUSHJ P,DISERR
;	XWD CODE,ADDR
;	XWD CODE,ADDR
;	      .
;	      .
;	      .
;	      .
;	     -1
;

↑DISERR:
	SKIPGE	TEM,@(P)
	JRST	CPOPJ1			;SKIP RETURN
	ASH	TEM,-=23		;ONLY CODE BITS PLEASE
	MOVEI	AC1,@(P)		;GET EFFECTIVE ADDRESS
	MOVEI	AC1,@(AC1)		;NOW GET IT'S EFFECTIVE ADDRESS
	CAILE	TEM,ERRLEN-1
	PUSHJ	P,@ERRTAB(TEM)		;DISPATCH
	AOS	(P)			;NEXT ARG
	JRST	DISERR

DEFINE ERRMAC $ (I)
<	ERR$I
>
ERRTAB:	QQQNAM
ERRLEN←←.-ERRTAB
; HERE ARE THE VARIOUS PRINTOUT ROUTINES FOR DISERR

ERRSTR:	HRLI	AC1,(<POINT 7,0>)
	PUSH	P,AC1
ERRST1:	ILDB	TEM,(P)
	JUMPE	TEM,TPOPJ		;QUIT ON ZERO (ADJUST STACK AND RETURN)
	PUSHJ	P,DISTYO
	JRST	ERRST1

ERRCHR:	HRRZ	TEM,AC1
	JRST	DISTYO

ERROCT:	MOVE	TAC,(AC1)
	JRST	DISOCT

ERRLOC:	MOVE	TAC,(AC1)
	JRST	DISLOC

ERRDEC:	MOVE	TAC,(AC1)
	JRST	DISDEC

ERRSIX:	MOVE	TAC1,(AC1)
	JRST	DISSIX

ERRDCP:	MOVE	TAC,(AC1)
	JRST	DISDCP			;DECIMAL WITH PERIOD
;DISLOC PRINTS OUT 6 DIGIT OCTAL LOCATION WITHOUT LEADING ZEROES
;CALL	MOVE TAC,<LOCATION>
;	PUSHJ P,DISLOC

↑DISLOC:
	PUSH	P,[=6]
	HRLZ	TAC1,TAC
DISLC1:	TLNE	TAC1,700000	;DO WE HAVE A DIGIT YET?
	JRST	DSOCT2		;YES, PRINT ADDRESS
	LSH	TAC1,3		;SHIFT LEFT 3 BITS
	SOSLE	(P)
	JRST	DISLC1
	JRST	DSOCT2		;PRINT ONE ZERO.

; OCTAL PRINT ROUTINE FOR DISASTER MESSAGES
; CALLING . . .
;	MOVE TAC,<NUMBER>
;	PUSHJ P,DISOCT

↑DISOCT:
	PUSH	P,[=12]
	MOVE	TAC1,TAC
DSOCT2:	SETZ	TAC,
	LSHC	TAC,3
	MOVEI	TEM,"0"(TAC)
	PUSH	P,TAC1
	PUSHJ	P,DISTYO
	POP	P,TAC1
	SOSLE	(P)
	JRST	DSOCT2
	JRST	TPOPJ

;ANOTHER OCTAL PRINT ROUTINE. PRINTS  HALFWORD COMMA COMMA HALFWORD
↑DISOCH:
	PUSH	P,TAC		;SAVE THE ARGUMENT
	HLLZ	TAC1,TAC	;GET LEFT SIDE IN LEFT SIDE
	PUSH	P,[DSOCH1]	;"RETURN" ADDRESS
	PUSH	P,[6]		;6 CHARACTERS PLEASE
	JRST	DSOCT2		;DO IT.  RETURN TO DSOCH1

DSOCH1:	MOVEI	TEM,","
	PUSHJ	P,DISTYO
	MOVEI	TEM,","
	PUSHJ	P,DISTYO
	POP	P,TAC1		;GET RIGHT SIDE
	HRLZ	TAC1,TAC1
	PUSH	P,[6]
	JRST	DSOCT2		;WRITE IT AND RETURN

↑DISDCP:PUSHJ	P,DISDEC
	MOVEI	TEM,"."
	JRST	DISTYO		;APPEND . TO DECIMAL NUMBER

↑DISDEC:
	JUMPGE	TAC,DISDC1
	MOVEI	TEM,"-"
	PUSHJ	P,DISTYO
DISDC1:	MOVM	TAC,TAC

DISNUM:	IDIVI	TAC,=10
	HRLM	TAC1,(P)
	JUMPE	TAC,.+2
	PUSHJ	P,DISNUM
	HLRZ	TAC,(P)
	MOVEI	TEM,"0"(TAC)
	JRST	DISTYO
; SIXBIT PRINT ROUTINE FOR DISASTER MESSAGES
; CALLING . . .
;	MOVE TAC1,<WORD>
;	PUSHJ P,DISSIX

↑DISSIX:
	JUMPE	TAC1,CPOPJ
	MOVEI	TAC,0
	ROTC	TAC,6
	MOVEI	TEM," "(TAC)		;CONVERT TO ASCII
	PUSH	P,TAC1
	PUSHJ	P,DISTYO
	POP	P,TAC1
	JRST	DISSIX
; INITIALIZE ROUTINE FOR DISASTER MESSAGES . . .

↑DISINIT:
	MOVE	TAC,[POINT 7,DISBUF]
	MOVEM	TAC,DISPTR
	MOVEM	TAC,DISOPT
	SETZM	DISFLAG
	MOVEI	TAC,5*DISLEN
	MOVEM	TAC,DISCTR
	POPJ	P,
; ROUTINE TO TYPE ON THE CTY WITH PIS OFF
; CALLING . . .
;	MOVE TEM,<CHARACTER>
;	PUSHJ P,CTYTYO
; CLOBBERS TAC AND SOME OTHERS

↑CTYTYO:
	CONSZ CTY,40		;HAS SOMEONE TYPED SOMETHING?
	JRST CTYTY2
CTYTY3:
	MOVEI TAC,777777
	CONSZ CTY,20
	SOJG TAC,.-1
	DATAO CTY,TEM
	CAIE TEM,11			;WAS THAT A TAB?
	POPJ P,
	MOVEI TEM,4		;YES, SEND 3 IDLE CHARS.
TABWAT:
	MOVEI TAC,777777
	CONSZ CTY,20
	SOJG TAC,.-1
	DATAO CTY,[1]
	SOJG TEM,TABWAT
	POPJ P,

CTYTY2:	DATAI CTY,TAC	;YES, GET IT
	CAIE TAC,"O"-100	;IS IT ↑O?
	JRST CTYTY3		;NO, GO ON
	CONSO APR,MAOFF		;YES, ARE WE THE SIX?
	POPJ P,			;YES, IGNORE THIS CHAR.
	PUSH P,DAT		;SAVE THIS
	SKIPN DAT,TTYTAB+TCONLN	;IS THERE A CTY DDB
	JRST .+3
	ADDI DAT,TTOBUF
	PUSHJ P,SETBFO		;CLEAR OUTPUT BUFFER
	POP P,DAT
	JRST DISINI		;CLEAR DISASTER BUFFER AND POPJ
;DISDATE - SHOVE THE TIME AND DATE INTO THE BUFFER

↑DISDATE:
	MOVEI	TEM,1		;SHLUFF
	PUSHJ	P,DISTYO	;TO WARM UP THE CTY
	MOVE	TAC,THSDAT
	IDIVI	TAC,=31		;DAY-1 IN TAC1
	PUSH	P,TAC		;SAVE MONTH AND YEAR
	MOVEI	TAC,1(TAC1)	;GET DAY INTO TAC
	PUSHJ	P,DISDEC	;PRINT DECIMAL
	POP	P,TAC		;MONTH AND YEAR INTO TAC
	IDIVI	TAC,=12		;MONTH-1 IN TAC1, YEAR-64 IN TAC
	PUSH	P,TAC		;SAVE YEAR
	PUSH	P,DSER		;SAVE DSER = TEM+1
	LDB	DSER,[POINT 21,MONTAB(TAC1),35]	;GET MONTH NAME
	LSH	DSER,8				;SHIFT
	OR	DSER,[BYTE(7)40,0,0,0,40]	;SPACES ON EACH SIDE
DISDA1:	MOVEI	TEM,0
	LSHC	TEM,7
	PUSH	P,DSER
	PUSHJ	P,DISTYO
	POP	P,DSER
	JUMPN	DSER,DISDA1
	POP	P,DSER
	POP	P,TAC1		;YEAR-64
	MOVEI	TAC,=64(TAC1)
	PUSHJ	P,DISDEC
	MOVEI	TEM," "
	PUSHJ	P,DISTYO
	MOVE	TAC,TIME
	IDIVI	TAC,JIFMIN	;HOURS AND MINUTES IN TAC
	IDIVI	TAC,=60		;MINUTES IN TAC1
	IMULI	TAC,=100	;HOURS TIMES 100 TO MAKE IT PRINT RIGHT
	ADD	TAC,TAC1
	PUSHJ	P,DISDEC
	JRST	DISCRLF		;TYPE CRLF AND POPJ
SUBTTL	IOCSS	4 AUG 67	;ADVBFE ADVBE1

;ROUTINE TO ADVANCE OUTPUT BUFFER AT INTERRUPT LEVEL

;CALL:	PUSHJ PDP,ADVBFE
;	EXIT1		RETURN IF NEXT BUFFER IS EMPTY
;	EXIT2		RETURN IF NEXT BUFFER IS FULL
;CLEARS THE USE BIT (IOUSE:=0) OF THE BUFFER POINTED TO BY THE
;OUTPUT BUFFER ADDRESS (DEVOAD) OF THE CURRENT DEVICE DATA BLOCK
;AND ADVANCES THE BUFFER ADDRESS TO THE NEXT BUFFER IN THE RING.
;UPON RETURN, SKIPS IF THE NEXT BUFFER IS FULL.
;SECOND WORD OF NEXT BUFFER IS ADDRESS CHECKED TO
;MAKE SURE IT IS NOT IN JOB DATA AREA OR ABOVE USER AREA
;THE SECOND WORD OF CURRENT BUFFER WAS CHECKED AT UUO LEVEL
;OR PREVIOUS CALL TO ADVBFE



↑ADVBFE:
	AOS	NABFE			;COUNT BUFFER ADVANCE
	PUSH	P,AC3
	JSP	AC3,PRSET		;SET UP PROT-RELOC REGISTERS
	SKIPN	TAC1,DEVOAD(DDB)	;PICK UP BUFFER ADDRESS
	JRST	ADVXIT			;NONE THERE, EXIT
	JSP	AC3,ADRCK		;MAKE SURE THIS IS A LEGAL ADDRESS
	XCTR	XW,[MOVEM IOS,-1(TAC1)]
	MOVSI	TAC,IOUSE
	XCTR	XRW,[ANDCAB TAC,(TAC1)]
	TRNE	IOS,740000		;ANY ERRORS?
	JRST	ADVXIT			;YES, DO NOT FILL NEXT BUFFER
	MOVE	TAC1,TAC
	JSP	AC3,ADRCK		;ADDRESS CHECK NEXT BUFFER IN RING
	HRRM	TAC1,DEVOAD(DDB)	;OK. PUT IN LATEST FREE BUFFER ADDRESS
	JRST	ADVBE2

;ENTER HERE FROM SCNSER TO CHECK IF NEXT BUFFER FULL OF DATA YET

↑ADVBE1:
	PUSH	P,AC3
	JSP	AC3,PRSET
ADVBE2:	SKIPN	TAC1,DEVOAD(DDB)
	JRST	ADVXIT
	XCTR	XR,[SKIPL (TAC1)]
	JRST	ADVXIT
	JRST	ADVBF1
;PRSET  ROUTINE TO PUSH CURRENT PR ON STACK AND SET UP NEW PR
; CALLING . . .
;	JSP AC3,PRSET
; RETURNS WITH PR ON STACK.

PRSET:
IFN FTXCTR,<PUSH P,160
	    PUSH P,@161>	; MAKE XCTR SIMULATION RECURSIVE
	PUSH P,AC2
	PUSH P,AC1
	PUSH P,J
	PUSH P,TEM
	PUSH P,LASTPR(PID)
	LDB J,PJOBN
	PUSHJ P,GETPR
	MOVEM TAC,LASTPR(PID)
	DATAO APR,TAC
	MOVEI TEM,JOBPFI	; SET UP ADDRESS OF JOB DATA AREA
	HLRZ AC1,PROG		; SET UP BOUNDS OF JOB FOR ADDRESS CHECKING
	LDB AC2,PSEGN
	JUMPE AC2,(AC3)		; NO UPPER SEGMENT, LEAVE
	HLRZ AC2,JBTADR(AC2)	; PICK UP ITS SIZE
	ADDI AC2,400000
	JRST (AC3)
;ADRCK ROUTINE TO ADDRESS CHECK SOMETHING
; CALLING . . .
;	MOVE TAC1,<ADDRESS TO BE CHECKED>
;	MOVE AC1,<LOWER SEGMENT LENGTH>
;	MOVE AC2,<UPPER SEGMENT LENGTH>
;	JSP AC3,ADRCK
; GOES TO ADVXIT IF ERROR

ADRCK:	CAILE TEM,(TAC1)	; ABOVE JOB DATA AREA?
	JRST ADVXIT		; NO, ERROR
	CAIL AC1,(TAC1)		; INSIDE LOWER?
	JRST (AC3)		; YES
	TRNE TAC1,400000	; IS IT UPPER SEGMENT ADDRESS?
	CAIGE AC1,(TAC1)	; YES, IS IT THEN IN THE UPPER SEGMENT?
	JRST ADVXIT		; NO, ERROR
	JRST (AC3)		; YES, WIN

ADVXIT:	POP P,LASTPR(PID)	; POP PR OFF STACK
	DATAO APR,LASTPR(PID)	; RESTORE PR
	POP P,TEM
	POP P,J
	POP P,AC1
	POP P,AC2
IFN FTXCTR,<POP P,@161
	    POP P,160>		;XCTR SIMULATION
	POP P,AC3
	POPJ P,
;ADVBFF ROUTINE TO ADVANCE INPUT BUFFER AT INTERRUPT LEVEL

;CALL:	PUSHJ PDP,DEVBFF
;	EXIT1		RETURN IF NEXT BUFFER IS FULL
;	EXIT2		RETURN IF NEXT BUFFER IS EMPTY
;SETS THE USE BIT (IOUSE:=1) OF THE BUFFER POINTED TO BY THE
;INPUT BUFFER ADDRESS (DEVIAD) OF THE CURRENT DEVICE DATA BLOCK
;AND ADVANCES THE BUFFER ADDRESS TO THE NEXT BUFFER IN THE RING.
;UPON RETURN, SKIPS IF THE NEXT BUFFER IS EMPTY.
;SECOND WORD OF NEXT BUFFER IS ADDRESS CHECKED TO MAKE SURE
;IT IS NOT IN IO PROTECTED PART OF JOB DATA AREA OR ABOVE
;USER AREA
;ALSO END OF BUFFER IS CHECKED TO MAKE SURE NOT ABOVE JOB AREA



↑ADVBFF:
	AOS	NABFF
	PUSH	P,AC3
	JSP	AC3,PRSET
	SKIPN	TAC1,DEVIAD(DDB)	;IS THERE A BUFFER ADDRESS THERE?
	JRST	ADVXIT			;NO, ERROR EXIT
	JSP	AC3,ADRCK		;YES, IS IT LEGAL
	XCTR	XW,[MOVEM IOS,-1(TAC1)]
	MOVSI	TAC,IOUSE
	XCTR	XRW,[IORB TAC,(TAC1)]
	MOVE	TAC1,TAC
	JSP	AC3,ADRCK
	HRRM	TAC1,DEVIAD(DDB)
	XCTR	XR,[SKIPGE TAC1,(TAC1)]
	JRST	ADVXIT
	HLRZS	TAC1
	ADD	TAC1,TAC		;ADDRESS CHECK END OF BUFFER TOO
	JSP	AC3,ADRCK
ADVBF1:	SKIPGE	TAC,JBTSTS(J)		;IF JOB IS NOT RUNNING . . .
	TLNE	TAC,SHF!SWP!CMWB	;OR SWUFFLING OR SCHWAPPING . . .
	JRST	ADVXIT			;DO NOT ALLOW THE DEVICE TO GO ON.
	TRNN	IOS,IOCON+740000
IFE FTXCTR,<	AOS	-6(P)>		;NO ERRORS, GIVE SUCCESS RETURN 
IFN FTXCTR,<	AOS	-10(P)>		;2 MORE FOR 160 AND @161
	JRST	ADVXIT			;LASTPR, TEM, J, AC1, AC2, AND AC3 ARE ON STACK
;ROUTINE TO ADDRESS CHECK AT UUO LEVEL ONLY
;CALL	HRRZ AC1,REL ADR.
;	PUSHJ PDP,UADCK1
;	NEVER RETURNS IF ERROR,STOPS JOB AND PRINTS ERROR
;BAD ADR. IF IN LOC 20-JOBPFI IN JOB DATA AREA
;OR IF ABOVE PROTECTION(USRREL) FOR CURRENT JOB


↑UUOACK:HRRZ  AC1,UUO	;CHECK UUO.

↑UADCK1:
	TRNN AC1,777760		; IN USER ACS?
	POPJ PDP,		;YES, ADDRESS IS OK
;UADRCK ROUTINE TO ADDRESS CHECK AT UUO LEVEL ONLY
;USER ACS ARE ALSO ILLEGAL(ADR IS FOR IO USE LATER AT
;INTERRUPT LEVEL)
;CALL:	HRRZ AC1,REL.ADR.
;	PUSHJ PDP,UADRCK
;	NEVER RETURN IF ERROR


↑UADRCK: MOVE J,JOB(PID)
	CAILE AC1,JOBPFI 	;IS ADR. IN IO PROT. PART OF JOB DATA AREA?
	JRST UADCK2		;NO
	PUSH P,AC1	; SAVE OUR ACCUMULATOR
	MOVE AC1,UUOPC(ITEM)
	TLNE AC1,USRMOD
	JRST UADRER	; EXEC MODE IS GOD.
	POP P,AC1
	POPJ P,
UADCK2:	CAMG AC1,USRREL(PID)	;NO, IS IT ABOVE PROTECT.?
	POPJ PDP,		;NO
	TRNN AC1,400000		; IS IT IN UPPER SEGMENT?
	JRST UADRER		; NO, MUST BE ERROR
	PUSH P,AC2		; GET US AN ACCUMULATOR
	LDB AC2,PSEGN		; PICK UP SEGMENT NUMBER
	JUMPE AC2,UADRER	; NONE IS ERROR
	HLRZ AC2,JBTADR(AC2)	; PICK UP REL. ADR.
	CAILE AC1,400000(AC2)
	JRST UADRER
	POP P,AC2
	POPJ P,
;ROUTINE TO ADDRESS CHECK AT ANY LEVEL
;CALL:	MOVE PROG,[XWD PROT.,RELOC,]
;	HRRZ TAC,REL. ADR.
;	PUSHJ PDP,IADRCK
;	ERROR RETURN(ERROR MESSAGE NOT PRINTED,JOB NOT STOPPED)
;	OK RETURN


↑IADRCK:
	MOVS TAC1,PROG		; GET PROTECTION TO RH
	CAILE TAC,JOBPFI	;ADR. ABOVE PROT. PART OF JOB DATA AREA?
	CAILE TAC,(TAC1)	;YES, BELOW OR EQUAL TO PROTECT.?
	POPJ PDP,		;NO
	JRST CPOPJ1		;YES, SKIP RETURN
;ROUTINE TO CHECK VALIDITY OF A DUMP MODE COMMAND LIST
;WHICH IS:
;A LIST OF 0 OR MORE IOWD FORMAT WORDS
;   TERMINATED BY A GOTO WORD(LH=0)
;  WHICH POINTS TO ANOTHER LIST OF 0 OR MORE IOWD FORMAT WORDS ETC.
;   UNTIL A GOTO WORD IS ENTIRELY ZERO
;
;SINCE MONITOR DOES NOT RESCHEDULE WHEN IN EXEC MODE
;A MAXIMUM LIST OF 100 IS IMPOSED

;CALL:	MOVE UUO,[XWD PROG,REL. ADR. OF FIRST COMMAND]
;	PUSHJ PDP,COMCHK
;	ADDRESS CHECK RETURN(ERROR ROUTINE IS NOT CALLED)
;	OK RETURN, SUM OF LH OF IOWDS IN DAT
;		ADDRESS OF FIRST IOWD (LH NOT 0) IN UUO


↑COMCHK:
	PUSH PDP,UUO		;SAVE POINTER TO LIST
	PUSH PDP,AC2
	PUSH PDP,AC3		;JS
	MOVEI AC1,JOBPFI	;HIGHEST IO PROTECTED LOC. IN JOB DATA AREA
	MOVE AC2,UUOPC(ITEM)
	TLNN AC2,USRMOD		; IS THIS A MONITOR CALL
	MOVEI AC1,JOBSAV	;YES, HIGHEST LOC. NOT WRITTEN BY SAVE
	SETZB DAT,AC2		;CLEAR WORD COUNT AND ADDRESS OF FIRST IOWD
	MOVEI ITEM,100		;ONLY 100 LISTS
	JRST COMCK1
COMCK0:	HRR UUO,TAC1		;CHANGE COMMAND LIST POINTER ON GO TO WORD
	CAIE AC1,JOBPFI
	JRST COMCK1		;JS
	HRRZ TAC,UUO		;CHECK JUMP ADDRESS
	PUSHJ PDP,IADRCK
	JRST COMCKE		;ERROR.
COMCK1:	SOJLE ITEM,COMCKE	;EXCEEDED 100 YET?
	SKIPN TAC1,@UUO		;NO. GET NEXT IOWD. END OF LIST?
	JRST COMCK2		;YES
	TLNN TAC1,777777	;IS IT A GO TO WORD?
	JRST COMCK0		;YES
	HLRO AC3,TAC1		;NO. SAVE NEGATIVE WORD COUNT ;JS
	HRRZS TAC1		;GET LOWEST ADDRESS-1
	CAMGE TAC1,AC1		;IS IT GREATER THAN LOC. PROTECTED
				;FROM IO IN JOB DATA AREA?
	JRST COMCKE		;NO. ERROR RETURN
	SUB TAC1,AC3		;YES. COMPUTE LAST LOC.	;JS
	CAMLE TAC1,USRREL(PID)	;IS LAST LOC. IN BOUNDS?
	JRST COMCKE		;NO. ERROR RETURN
	SUB DAT,AC3		;YES. ACCUMULATE NEG. WORD COUNT ;JS
	SKIPN AC2		;IS THIS THE FIRST IOWD?
	MOVE AC2,UUO		;YES. SAVE ADDRESS IN AC2
	AOJA UUO,COMCK1		;GO GET NEXT IOWD

COMCK2:	SKIPE AC2		;ARE THERE ANY IOWDS WITH LH NOT 0?
	MOVE UUO,AC2		;YES, POINT UUO TO FIRST SUCH IOWD.
				;OTHERWISE, UUO POINTS TO A ZERO.
	POP PDP,AC3		;JS
	POP PDP,AC2
	JRST TPOPJ1		;REMOVE SAVED UUO AND SKIP RETURN
COMCKE:	POP PDP,AC3		;JS
	POP PDP,AC2
	POP PDP,UUO		;RESTORE ORIGINAL UUO
	POPJ PDP,		;ERROR RETURN
;ASSASG	ASSIGN DEVICE IF UNASSIGNED
;CALL:	MOVE	J, JOB NUMBER
;	MOVE	DDB, ADDRESS OF DDB
;	MOVEI	TAC1, EITHER ASSPRG OR ASSCON
;	PUSHJ	P, ASSASG
;	CAN'T	ASSIGN RETURN
;	DEVICE ASSIGNED RETURN


↑ASSASG:
	MOVE	TAC,JBTPRV(J)
	TLNE	TAC,LUPPRV		;LOCAL USER?
	JRST	ASSAS3			;YES. BYPASS TEST
	MOVE	TAC,DEVCMR(DDB)
	TLNE	TAC,DEVLUP		;REQUIRES LOCAL USER STATUS?
	POPJ	P,			;YES.  FAIL.
ASSAS3:	MOVE	TAC,DEVCMR(DDB)
	TLNN	TAC,DEVSHR		;SHARABLE DEV?
	JRST	ASSAS2			;NO
	HRRZ	TAC,DEVSER(DDB)
	PUSHJ	P,DGETDD(TAC)		;YES - MAKE A NEW DDB
	JRST	ASSAS0

ASSAS2:	LDB	TAC,PJOBN
	CAIE	TAC,(J)			;IS THIS DDB OURS?
	JRST	ASSAS1
;	MOVE TAC,TAC1
;	ANDI TAC,ASSPRG
;	TDNN TAC,DEVMOD(DDB)		;ARE WE INITING AN ALREADY INITED DEVICE?
	JRST	ASSAS0			;NO
	POPJ	P,			;YES, LOSE

ASSAS1:	MOVE	TAC,[TTYATC,,ASSCON!ASSPRG]
	CONO	PI,SCNOFF		;TURN SCANNER OFF
	TDNE	TAC,DEVMOD(DDB)		;ONE LAST CHECK
	JRST	SCNONJ			;OOPS - EATEN AWAY FROM UNDER US
ASSAS0:	DPB	J,PJOBN			;NO, STORE JOB NUMBER
	IORM	TAC1,DEVMOD(DDB)	;SET ONE OF ASSIGN BITS
	MOVSI TAC,DVTTY
	TDNE TAC,DEVMOD(DDB)
	JRST ASSAST			;JUMP IF ASSIGNING A TTY
ASSASZ:	CONO	PI,SCNON		;TURN SCANNER CHAN. BACK ON
	JRST	CPOPJ1

ASSAST:	PUSH P,AC1
	LDB TAC,PUNIT
	SKIPGE TTYTAB(TAC)		;SKIP IF COMBIT IS NOT SET
	SOS COMCNT
	MOVSI AC1,COMBIT+DLYBIT
	ANDCAM AC1,TTYTAB(TAC)
	POP P,AC1
	JRST ASSASZ
;ROUTINE TO SEARCH FOR A DEVICE
;CALL:	HRR ITEM,JOB NUMBER
;	MOVE TAC,[SIXBIT .DEVICE NAME.]
;	PUSHJ PDP, DEVSRC
;	NOT FOUND
;	FOUND

	
↑FNDDDB:TLNE TAC,770000		;IS IT NAME OR #?
	JRST DEVSRC
	CAMG TAC,USRHCU(PID)	;LEGAL CHANNEL?
	SKIPN DDB,USRJDA(TAC)	;GET DDB POINTER
	POPJ P,			;LOSE
	JRST CPOPJ1

↑DEVSRC:
	MOVSI DEVDAT,JLOG	;IS JOB LOGGED IN?
	TDNE DEVDAT,JBTSTS(J)
				;DO NOT SEARCH LOGICAL NAMES IF
				;FETCHING "LOGOUT" FROM "SYS".
	PUSHJ PDP, DEVLG	;SEARCH LOGICAL NAMES FIRST
	JRST DEVPHY		;NOT FOUND, SEARCH PHYSICAL NAMES
	JRST CPOPJ1		;FOUND

;SEARCH LOGICAL NAMES

↑DEVLG:	HLRZ DEVDAT,DEVLST	;BEGINNING OF DDB CHAIN
DEVLP0:	CAME TAC,DEVLOG(DEVDAT)	;COMAPRE WITH LOGICAL NAME
	JRST DEV0		;NO MATCH
	LDB TAC1,PJOBN		;DOES THE LOGICAL NAME BELONG TO THIS JOB?
	CAMN TAC1,ITEM
	JUMPN TAC,CPOPJ1	;YES, GIVE SUCCESSFUL RET. IF NAME NOT 0
DEV0:	HLRZ DEVDAT,DEVSER(DEVDAT)
				;NO, KEEP LOOKING
	JUMPN DEVDAT,DEVLP0
	POPJ PDP,		;FINISHED AND NOT FOUND
;SEARCH PHYSICAL NAMES

↑DEVPHY:
	CAMN TAC,[SIXBIT /OPR/]	; IS IT "OPR"?
	MOVE TAC,DEVOPR		;YES, CHANGE TO OPERATOR'S TTY
	CAMN TAC,[SIXBIT /SYS/]	;IS IT "SYS"?
	SKIPA TAC,SYSTAP	;YES, CHANGE TO SYSTEM TAPE DEVICE NAME
	TDZA TAC1,TAC1		;NO, CLEAR SYSTEM TAPE FLAG
	MOVEI TAC1,SYSDEV	;YES, SET SYSTEM TAPE FLAG
	HLRZ DEVDAT,DEVLST	;SEARCH DEVICE DATA BLOCKS
DEVLP1:
	TLO DEVDAT,(TAC1)	;SET SYSTEM TAPE BIT IF SEARCHING FOR SYS
	CAMN TAC,DEVNAM(DEVDAT)	;MATCH OF PHYSICAL NAME?
	JUMPN TAC,CPOPJ1	;YES, GIVE OK RET. IF NAME IS NOT 0
DEVLP2:	HLRZ DEVDAT,DEVSER(DEVDAT)
	JUMPN DEVDAT,DEVLP1
	CAME TAC,[SIXBIT /TTY/]	;IS THIS PUBLIC LOGICAL NAME TTY?
	JRST	DEVLP3		;SEE IF IT'S A TTY.
	PUSH PDP,DAT		;SAVE OUTPUT BYTE POINTER(TTY) OR INIT. ARG. ADR.
	PUSHJ PDP,TTYFND	;YES, FIND TTY JOB IS ATTACHED TO
	POP PDP,DAT		;RESTORE
	JRST CPOPJ1		;AND GIVE SUCCESSFUL RETURN
DEVLP3:	PUSH P,TAC		;SAVE DEVICE NAME IN CASE NOT FOUND
	PUSH P,DAT		;AND THIS IN CASE IT IS
	PUSHJ P,GETDDB		;SEE IF TTY DDB
	CAIA
	AOS -2(P)		;SKIP ON SUCCESS
	POP P,DAT
	POP P,TAC
	POPJ P,
;ROUTINE TO SETUP N-RING IO BUFFER IN USER AREA

;CALL:	PUSHJ PDP,BUFCLC
;	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED
; SETS UP AN N BUFFER RING FOLLOWING THE USER'S PROGRAM, WHERE N
; IS IN THE ADDRESS FIELD OF AC UUO.
; THE BUFFER RING FORMAT IS AS FOLLOWS:
;	LOCATION		LH   CONTENTS   RH
; C(JOBFF) + 1              BUFFER         C(JOBFF) +1
;    + 0(BUFFER SIZE+2)      SIZE               + 1(BUFFER SIZE+2)
; C(JOBFF) +1               BUFFER         C(JOBFF) +1
;     +1(BUFFER SIZE+2)      SIZE                + 2(BUFFER SIZE+2)
;         .		.		     .
;	.		.		     .
;	.		.		     .
; C(JOBFF) + 1	        BUFFER	   C(JOBFF) + 1
;    + (N-2)(BUFFER SIZE+2)  SIZE               +(N-1)(BUFFER SIZE+2)
; C(JOBFF) + 1	        BUFFER	   C(JOBFF) + 1
;    + (N-1)(BUFFER SIZE+2)  SIZE		   
;THEN SET 	BUFPNT:=IOUSE,C(JOBFF) + 1
; AND		JOBFF:=C(JOBFF) + N(BUFFER SIZE + 2)
; BUFWRD IS RESTORED.

BUFWRD←←AC3

↑BUFCLC:
	LDB TAC,PDVBLN
				; GET BUFFER SIZE IN TAC
BUFCLM:	PUSH PDP,BUFWRD		; SAVE BUFWRD ON STACK
	HRRZ BUFPNT,JOBFF(PROG)	; BUFPNT:= FIRST FREE USER LOC+1
	ADDI BUFPNT,1
	HRRZ BUFWRD,BUFPNT
	HRL BUFWRD,TAC		; PUT XWD BUFSIZ,JOBFF IN BUFWRD
	ADDI TAC,2		; ADD 2 TO BUFFER SIZE
	HRRZ TAC1,UUO		; GET NUMBER OF BUFFERS
	JUMPG	TAC1,.+2	;SKIP UNLESS NONE WERE REQUESTED. (ME 12-11-72)
	MOVEI	TAC1,2		;GIVE HIM TWO.
	HRRZ AC1,TAC
	IMUL AC1,TAC1
	ADD AC1,BUFWRD
	HRRZ AC1,AC1
	CAMG AC1,USRREL(PID)	; WILL THIS SPACE FIT IN USER CORE?
	JRST BUFC1		; YES, DO INBUF CODE
; HERE, WE WANT TO EXPAND CORE TO FIT IN A RING OF BUFFERS

	PUSH PDP,TAC		; NO.
	PUSH PDP,UUO		;  SO
	PUSH PDP,TAC1		;   WE
	PUSH PDP,BUFPNT		;    SAVE
	PUSH PDP,BUFWRD		;     A
	PUSH PDP,DEVDAT		;      FEW
	PUSH PDP,DSER		;       AC'S
	MOVE ITEM,JOB(PID)	;       AND DO A CORE UUO TO MAKE ROOM
	MOVE TAC,AC1		;       HOW HIGH TO TRY FOR
	MOVEI UUO,UUO		;       ..
	PUSHJ PDP,UCORE		;       TRY FOR ANOTHER K OF USER CORE
	JFCL			;       LET ADR CHECK HAPPEN IF CAN'T DO SO
	POP PDP,DSER		;       AND
	POP PDP,DEVDAT		;      WE
	POP PDP,BUFWRD		;     RESTORE
	POP PDP,BUFPNT		;    THE
	POP PDP,TAC1		;   FEW
	POP PDP,UUO		;  AC'S
	POP PDP,TAC		; DUE TO IOWAIT
				; FALL INTO BUFC1
; END OF LOOP FOR SETTING UP AN N-RING BUFFER

BUFC1:	ADD	BUFWRD,TAC	;ADD IN LENGTH OF BUFFER, ADDR OF NEXT BUFFER
	HRRZ	AC1,BUFPNT	;IS THIS ADDR IN BOUNDS?
	PUSHJ	P,UADRCK
	XCTR	XW,[MOVEM BUFWRD,(BUFPNT)]	;PUT THIS ADDRESS IN BUFFER HEADER
	HRR	BUFPNT,BUFWRD
	SOJG	TAC1,BUFC1		;LOOP AROUND AND MAKE N-1 MORE BUFFERS
	HRR	BUFWRD,JOBFF(PROG)	;UPDATE THE USER'S JOBFF
	ADDI	BUFWRD,1
	MOVEI	AC1,-2(BUFPNT)		;CHECK LAST ADDRESS OF HEADER
	PUSHJ	P,UADRCK
	SUB	BUFPNT,TAC
	XCTR	XW,[MOVEM BUFWRD,(BUFPNT)]	;LINK LAST BUFFER TO FIRST BUFFER
	ADDI	BUFPNT,-1(TAC)
	HRRM	BUFPNT,JOBFF(PROG)	;UPDATE USER'S JOBFF
	HRR	BUFPNT,BUFWRD		;LOAD IN USE BIT AND ADDRESS OF FIRST BUFFER
	HRLI	BUFPNT,IOUSE
	POP	P,BUFWRD		;RESTORE BUFWRD FROM STACK
	POPJ	P,			;EXIT
;ROUTINE TO CLEAR IO BUFFER IN USER AREA
;CALLED AT INTERRUPT AND UUO LEVEL

;CALL:	HRRZ TAC,REL. ADR. OF 2ND WORD OF USER BUFFER
;	PUSHJ PDP,BUFCLR
;	ERROR RETURN MEMORY EXCEEDED
;	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED
; CLEARS THE WORD COUNT AND DATA AREA OF THE BUFFER WHOSE ADDRESS
; IS IN TAC 18-35.

	

↑BUFCLR:
	PUSHJ PDP,IADRCK	; ADDRESS IN BOUNDS?
	POPJ PDP,		;NO. ERROR RETURN
	HRLI TAC,PROG		; SET TO RELOCATE BY PROG
	PUSH PDP,TAC		;SAVE FIRST BUFFER ADR.
	HLRZ TAC1,@TAC		;TAC1 18-35=SIZE
	TRZ TAC1,400000
	ADD TAC,TAC1		;LAST ADR=2ND ADR+SIZE
	TLZ TAC,-1		;CLEAR LEFT HALF
	PUSHJ PDP,IADRCK	;LAST ADDRESS IN BOUNDS?
	JRST TPOPJ		;NO. ERROR RETURN
	HRLI TAC,PROG		; SET LAST ADR. FOR RELOCATION
	POP PDP,TAC1		;RESTORE FIRST ADR.
	NOSHUFF			;NO SHUFFLING
	MOVEI TAC1,@TAC1	; GET ABS. ADDR OF 2ND WD. OF BUFFER
	HRL TAC1,TAC1
	AOBJN TAC1,.+1		;THIRD WORD IN BUFFER
	SETZM (TAC1)		;CLEAR THIRD WORD
	AOS TAC1		;SET DEST. ADR. TO 4TH WORD
	BLT TAC1,@TAC		;CLEAR BUFFER
	SHUFFLE			;SHUFFLING
	JRST CPOPJ1		;SUCESSFUL RETURN
;ROUTINE TO COMPUTE 12 BIT FOLDED CHECKSUM

;CALL:	PUSHJ PDP,CKS12
;	EXIT		ALWAYS RETURNS HERE
;CALCULATES FOLDED 12 BIT CHECKSUMS OF THE DATA WORDS IN THE
;BUFFER WHOSE ADDRESS IS IN AC TAC1.  TWO ALGORITHMS ARE USED.
;ON RETURN, THE LEFT HALF OF AC TAC CONTAINS A CHECKSUM OBTAINED
;BY ACCUMULATING, IN ONE'S COMPLEMENT, THE DATA WORDS AND FOLDING IT.
;THE LEFT HALF OF AC DAT CONTAINS A CHECKSUM OBTAINED BY ACCUMULATING,
;IN TWO'S COMPLEMENT, THE DATA WORDS AND FOLDING IT.  AC TAC1
;CONTAINS A 1.


↑CKS12:	ADD TAC1,PROG		;TAC1:=-WORD COUNT,ADDRESS OF FIRST DATA WORD
	AOS TAC1
	HRRZ TAC,0(TAC1)
	MOVNS TAC
	AOS TAC1
	HRL TAC1,TAC
	SETZM TAC		;INITIALIZE TWO'S COMPLEMENT SUM
CKS12A:	ADD TAC,0(TAC1)		;TWO'S COMPLEMENT ADD
	AOBJN TAC1,CKS12A	;DONE?
	LSHC TAC,-30
	LSH TAC1,-14
	ADD TAC,TAC1
	LSHC TAC,-14
	LSH TAC1,-30
	ADD TAC,TAC1
	TRZE TAC,770000
	AOS TAC
	HRLZS TAC
	MOVEI TAC1,1		;TAC1:=1
	POPJ PDP,
;ROUTINE TO CLEAR RESIDUE OF WORD POINTED TO BY A BYTE POINTER

;CALL:	PUSHJ PDP,CLRBYT
;	EXIT		ALWAYS RETURNS HERE
;CALLED WITH A BYTE POINTER IN AC TAC, IT CLEARS THE REST OF THE
;WORD POINTED TO BY THE BYTE POINTER.


↑CLRBYT:
	LDB TAC1,[POINT 6,TAC,5]	; SET UP POINTER
	DPB TAC1,[POINT 12,TAC,11]	;TAC 0-5:=0,TAC 6-12:=P
	SETZM TAC1
	DPB TAC1,TAC			;CLEAR BITS 36-P THROUGH 35
	POPJ PDP,			;RETURN
;IOALL, IOALLR, IORELS,IOWAIT

↑IOWAIT:	SKIPA TAC,[WAIT1]	;WAIT FOR ALL DEVICES TO BE INACTIVE
↑IORELS:	MOVEI TAC,RELEA3	;RELEASE ALL IO DEVICES. FALL INTO IOALL

;ROUTINE TO DO IO FOR ALL DEVICES ASSIGNED TO JOB
;CALL	MOVEI TAC,ADR. OF IO SUB.
;	PUSHJ PDP,IOALL

↑IOALL:	PUSH PDP,TAC			; SAVE SUBROUTINE CALL
	SETZB UCHN,UUO			;START WITH USER CHANNEL 0
	SKIPL DEVDAT,USRHCU(PID)	; IS THIS NEGATIVE?
	JRST IOALL1
	SETZM USRHCU(PID)		;SAVE-GET HAS BEEN HERE, RELEASE DEVICE ANYWAY!!!
	JRST IOALL2
IOALL1:	CAMLE UCHN,USRHCU(PID)		;IS IT GREATER THAN HIGHEST CHAN. USED?
	JRST IOALLP			;YES, POP PDP,TAC; POPJ PDP,
	SKIPN DEVDAT,USRJDA(UCHN)	;GET NEXT DDB ADR., IS IT IN USE?
	AOJA UCHN,IOALL1		;NO, KEEP GOING
IOALL2:	MOVE IOS,DEVIOS(DEVDAT)
	DPB UCHN,PUUOAC
	MOVE DSER,DEVSER(DEVDAT)	;SETUP ADR. OF DEV. DISP. TABLE
	LDB J,PJOBN			;DOES THIS DDB BELONG
	CAMN J,JOB(PID)			;TO THIS JOB?
	PUSHJ PDP,@(PDP)		;YES, CALL THE SUB.
	MOVE J,JOB(PID)			;KEEP THIS HONEST
	AOJA UCHN,IOALL1		;INCREMENT USER CHAN. NO.

IOALLP:	SKIPL UCHN,JBTIOP(J)		;GET IO PDL POINTER
	JRST TPOPJ			;NONE THERE. RETURN
	PUSH P,[-1]
IOALP1:	SKIPN DDB,(UCHN)		;SKIP FLUSHED CHANNELS
	JRST IOALP2
	EXCH DDB,USRJDA
	MOVEM DDB,(UCHN)		;EVERYONE MUST LIVE SOMEWHERE
	MOVE DDB,USRJDA
	PUSH P,UCHN
	SETZ UCHN,
	MOVE IOS,DEVIOS(DDB)
	DPB UCHN,PUUOAC
	MOVE DSER,DEVSER(DDB)		;SETUP ADR. OF DEV. DISP. TABLE
	LDB J,PJOBN			;DOES THIS DDB BELONG
	CAMN J,JOB(PID)			;TO THIS JOB?
	PUSHJ P,@-2(P)			;YES, CALL THE SUB.
	MOVE J,JOB(PID)			;KEEP THIS HONEST
	POP P,UCHN
	MOVE DDB,(UCHN)
	EXCH DDB,USRJDA
	MOVEM DDB,(UCHN)
	JUMPE DDB,IOALP2
	SETZM (P)			;FLAG TO NOT RETURN JBTIOP
IOALP2:	ADD UCHN,[1,,1]
	AOBJN UCHN,IOALP1
	POP P,TAC
	JUMPE TAC,TPOPJ
	PUSH P,AC1
	HRRZ AC1,JBTIOP(J)		;FLUSH IO STACK
	SETZM JBTIOP(J)
	PUSHJ P,FSGIVE
	POP P,AC1
	JRST	TPOPJ


;HERE TO CHASE THROUGH THE DDB LIST AND CALL RELEA5 FOR ANY DDB OF OURS
;CALLED FROM IOKILL
;THIS IS A KLUDGE TO RECTIFY THE PROBLEM OF DDBS GETTING LOST FROM JOBJDA

IOALLR:	PUSH	P,USRJDA
	MOVEI	DDB,DEVLST-DEVSER
IOALR1:	HLRZ	DDB,DEVSER(DDB)
	JUMPE	DDB,IOALR3
IOALR2:	LDB	J,PJOBN
	CAME	J,JOB(PID)
	JRST	IOALR1
	MOVE	UCHN,DEVMOD(DDB)
	TRNN	UCHN,ASSPRG		;ASSIGNED BY PROGRAM?
	JRST	IOALR1			;NO
	MOVEM	DDB,USRJDA
	MOVEI	UCHN,0
	DPB	UCHN,PUUOAC
	MOVE	IOS,DEVIOS(DDB)
	MOVE	DSER,DEVSER(DDB)	;SETUP ADR. OF DEV. DISP. TABLE
	PUSH	P,DSER			;SAVE DSER
	PUSHJ	P,RELEA5		;RELEASE THIS DDB
	POP	P,DDB
	HLRZ	DDB,DDB			;ADDRESS OF NEXT DDB
	JUMPN	DDB,IOALR2		;CONTINUE THROUGH THE DDB CHAIN.
IOALR3:	POP	P,USRJDA
	MOVE	J,JOB(PID)		;KEEP THIS HONEST
	POPJ	P,
;IOKILL, CLRUSR

;KILL ALL DEVICES(RELEASE WITHOUT WAITING FOR DEVICE INACTIVE)

↑IOKILL:
	MOVEI	TAC,RELEA5
	PUSHJ	P,IOALL		;RELEASE ALL DEVICES WITHOUT WAITING
	PUSHJ	P,IOALLR	;CHASE THRU DDB LIST AND RELEASE ANY OTHERS

;ROUTINE TO CLEAR PROTECTED JOB DATA AREA IN MONITOR
;AND RECLAIM FREE AREA ABOVE USER PROGRAM FOR IO BUFFERS

	HLRZ	TAC,JOBSA(JDAT)	;RESET FIRST FREE LOC. FOR THIS JOB
	MOVEM	TAC,JOBFF(JDAT)
↑CLRUSR:
	SETZM	JOBENB(JDAT)	;INITIALIZE USER FOR NO TRAPS ENABLED
	MOVEI	TAC,USRLO1(PID)	;FIRST LOC+1 TO CLEAR
	HRLI	TAC,USRLO(PID)	;FIRST LOC.
	SETZM	USRLO(PID)
	BLT	TAC,USRHI(PID)
	SETZM	USRHCU(PID)	;CLEAR HIGHEST USER IO CHAN. IN USE
	POPJ	P,

;ROUTINE TO FLAG DEVICE ACTIVE  - ORACT, SETACT, CLRACT, STOIOS
;CALL	MOVE IOS,IO STATUS BITS
;	MOVE DEVDAT,ADDRESS OF DEVICE DATA BLOCK
;	PUSHJ PDP,SETACT
;CALLED BY ALL IO SERVICE ROUTINES AT UUO AND INTERRUPT LEVELS



↑ORACT:	SKIPE SPWUUF(PID)
	CONSZ PI,77000
	CAIA
	JRST SPWERR
	TRO IOS,IOACT
	IORB IOS,DEVIOS(DDB)
	JRST ORACT1

↑SETACT:
	SKIPE SPWUUF(PID)
	CONSZ PI,77000
	CAIA
	JRST SPWERR
	TROE IOS,IOACT
	JRST STOIOS
	TLZA	IOS,IOW
↑CLRACT:
	TRZ IOS,IOACT
↑STOIOS:
	MOVEM IOS,DEVIOS(DDB)
ORACT1:	LDB TAC,PDVTIM		;GET NO. OF SECONDS
	DPB TAC,PDVCNT		;TO WAIT BEFORE
	POPJ P,		;DEVICE IS CONSIDERED HUNG
;DEVCHK  - THIS ROUTINE UPDATES EACH DEVICE'S HUNG COUNT AND DISPATCHES
; IF THE COUNT IS EXHAUSTED

↑DEVCHK:
	MOVEI TAC,JIFSEC	; RESET HUNG DEVICE CHECK TIME
	MOVEM TAC,HNGTIM	;TO CHECK ONCE A SECOND
;	HLRZ DEVDAT,DEVLST
	SOSN DSKHNG		;SEE IF DISK IS HUNG THIS WAY!
	PUSHJ P,DSKDSP+DHNG	;CALL DISK HUNG ROUTINE
	MOVEI DDB,PTRDDB	;SKIP DSK AND UDP
DEVCK0:	MOVE IOS,DEVIOS(DEVDAT)	;IS DEVICE ACTIVE?
	TRNN IOS,IOACT
	JRST DEVCK2		;NO
DEVCK3:	LDB TAC,PDVCNT		; YES, DECREMENT HUNG COUNT
	SOJL TAC,DEVCK1		;0 MEANS IGNORE DEVICE
	DPB TAC,PDVCNT		; NOW REPLACE IT IN THE DDB
	JUMPN TAC,DEVCK1	;HAS COUNT GONE TO 0?
	MOVE DSER,DEVSER(DEVDAT);YES, GET DISPATCH TABLE ENTRY
	PUSH	P,DDB
	PUSHJ	P,DHNG(DSER)	;DISPATCH TO SERVICE ROUTINES TO UNHANG DEVICE
	PUSHJ	P,DEVHNG	;PRINT ERROR MESSAGE AND STOP JOB
	POP	P,DDB		;DO NOT PRINT MESS. AND STOP JOB RETURN
DEVCK1:	HLRZ DEVDAT,DEVSER(DEVDAT)
	CAIE DEVDAT,TTYLST	;DON'T DO TTY'S
	JUMPN DEVDAT,DEVCK0
	POPJ PDP,

DEVCK2:	MOVE DAT,DEVCMR(DEVDAT)	; PULL IN EXTRA DEVCHR BITS
	TLNE DAT,DEVIBF		; DOES THIS DEVICE HAVE AN INTERNAL BUFFER?
	TLNN IOS,DEVSBB		; IF IT DOES, IS IT BUSY?
	JRST DEVCK1		; NOT BUSY, IGNORE DEVICE
	JRST DEVCK3		; BUSY, INCREMENT HUNG COUNT
; OTHER USEFUL ROUTINES FOR SETING UP USER BUFFER POINTERS
; CHECK RING USE BIT AND SEE IF USER HAS ANOTHER BUFFER TO FILL
; SET UP DEVDAT AND PROG
; DOES SCRATCH WORK IN TAC
; SKIPS IF HE HAS BUFFERS HE CAN BE FILLING

↑DEVCR:	HLR TAC,DEVBUF(DEVDAT)	; PICK UP RELATIVE ADDRESS OF HIS BUFFER HEADER
	HRLI TAC,PROG		; SET TO INDEX BY HIS RELOCATION CONSTANT
	HRR TAC,@TAC		; WE NOW HAVE THE ABSOLUTE ADDRESS OF THE FIRST BUFFER
	SKIPL @TAC		; CHECK THE RING USE BIT, AGAIN INDEXED BY PROG
	AOS (PDP)		; BUFFER IS FREE, LET HIM FILL IT
	POPJ PDP,
; SET UP WORD COUNT IN AC2
; SET UP 7-BIT BYTE POINTER TO ACTUAL DATA IN AC3
; DEVDAT AND PROG MUST BE SET UP
; ROUTINE SKIPS ON SUCCESS, DOESN'T SKIP IF BUFFER IS EMPTY

↑DEVSTU:
	SKIPL @DEVOAD(DEVDAT)	; FIRST, SEE IF THIS BUFFER HAS ALREADY BEEN EMPTIED
	POPJ PDP,		; YES IT HAS, EXIT NOW
	MOVEI AC3,@DEVOAD(DEVDAT)
	HRRZ AC2,1(AC3)		; WORD COUNT IS LOCATED 1 LOC AFTER HEADER ADDRESS
	ADD AC3,[POINT 7,2]	; MAKE ABSOLUTE ADDRESS INTO A BYTE POINTER TO THE WORD AFTER THE WORD COUNT
	AOS (PDP)		; SKIP UPON SUCCESS
	POPJ PDP,
;ROUTINE TO SETUP PROG AND ITEM FOR INTERRUPT SERVICE ROUTINE

;CALL	PUSHJ PDP,IOSET
;	EXIT	ALWAYS RETURNS HERE
;THIS PROGRAM IS CALLED FROM AN INTERRUPT SERVICE ROUTINE.
;IT PUTS THE ADDRESS OF THE DATA AREA OF THE JOB (C(JBTADR18-35))
;CONNECTED TO THE DEVICE SPECIFIED BY AC DEVDAT IN AC PROG AND
;PUTS THE ITEM POINTER (C(DEVCTR)) IN AC ITEM.

	

↑IOSET:	LDB PROG,PJOBN
	MOVE ITEM,DEVCTR(DEVDAT)	;ITEM:=ITEM POINTER=C(DEVCTR)
	MOVE PROG,JBTADR(PROG)		;PROG:=C(JBTADR 18-35)
	POPJ PDP,			;RETURN
;CALLING SEQUENCE
;	PUSHJ PDP,IOSETC
;	EXIT		ALWAYS RETURNS HERE

;SETS JBFPTR18-35:=C(TAC1 18-35)
;	JBFCTR:=C(ITEM)*[WORD LENGTH/BYTE SIZE]
;WHERE	WORD LENGTH:=36 DECIMAL
;	BYTE SIZE:=C(JBFPTR6-11)
;	[X]:= INTEGER PART OF X




↑IOSETC:
	ADDI	JBUF,1			;JBFPTR12-18 SET TO 0
	MOVSI	TAC,7777		;JBFPTR18-35:=C(TAC1 18-35)+1
	XCTR	XRW,[ANDM TAC,(JBUF)]
	XCTR	XRW,[HRRM TAC1,(JBUF)]
	XCTR	XRW,[AOS (JBUF)]
;NEXT 3 INST'S ADDED BY RPH TO AVOID INVALID WORD COUNTS 10-11-72
	XCTR	XLB,[LDB TAC1,[POINT 17,(TAC1),17]]	;GET BUFFER SIZE
	CAILE	ITEM,-1(TAC1)			;MORE DATA INDICATED THAN CAN BE IN BUFFER?
	MOVEI	ITEM,-1(TAC1)			; YES, SET TO MAX
	XCTR	XLB,[LDB TAC1,[POINT 6,(JBUF),11]]	;TAC1:=BYTE SIZE
	PUSHJ	P,ITMCT1			;JBFCTR:=C(ITEM)*[36/BYTE SIZE]
	ADDI	JBUF,1
	XCTR	XW,[MOVEM ITEM,(JBUF)]
	POPJ	P,				;EXIT
;ROUTINE TO RETURN NO. OF ITEMS IN BUFFER

;CALL:	PUSHJ PDP,ITMSET
;	EXIT		ALWAYS RETURNS HERE
;SETS AC ITEM:=(BUFFER SIZE-1)*[WORD LENGTH/BYTE SIZE]
;WHERE BUFFER SIZE:=BITS 1-17 OF THE BUFFER HEADER WORD POINTED TO
;		BY C(DEVADR)
;	WORD LENGTH:=36 DECIMAL
;	BYTE SIZE:=INTEGER PART OF X.

;CALLING SEQUENCE
;	PUSHJ PDP,ITMCNT
;	EXIT		ALWAYS RETURNS HERE
;SETS AC ITEM:=C(ITEM)*[WORD LENGHT/BYTE SIZE]

↑ITMSET:
	LDB ITEM,[POINT 17,@DEVADR(DEVDAT),17]
	SUBI ITEM,1
	LDB TAC1,[POINT 6,DEVPTR(DEVDAT),11]
↑ITMCT1:
	MOVEI TAC,44		; GET C(ITEM):=C(ITEM)*[WORD LENGTH/C(TAC1)]
	IDIV TAC,TAC1
	IMUL ITEM,TAC
	POPJ PDP,
;ROUTINE TO SET DEVICE STATUS WORD FROM UUO
;AND SETUP IOS


↑SETIOS:
	PUSHJ PDP,WAIT1
	PUSHJ	P,SETMOD
	JRST	ILLMOD
	POPJ	P,

↑SETMOD:
	LDB TAC1,[POINT 4,UUO,35]	;GET DEVICE DATA MODE
SETIO2:	MOVEI TAC,1		;AND CHECK FOR LEGALITY
	LSH TAC,(TAC1)
	TDNN TAC,DEVMOD(DEVDAT)
	JRST SETIO1
	TRZ UUO,IOACT		;LET USER SET ALL BITS EXCEPT IOACT
	HRRM UUO,DEVIOS(DEVDAT)
	JRST	CPOPJ1

SETIO1:	CAIE TAC1,2		;MODE 2?
	POPJ	P,		;NO. ILL MODE
	MOVEI TAC1,D		;YES. TRY MODE 17 INSTEND.
	ADDI UUO,D-2
	JRST SETIO2
;SETUP BYTE POINTER AND ITEM COUNT
;CALLED BY STODAT ONLY (AT INTERRUPT LEVEL)
;CALL	PUSHJ PDP,NEWBUF
;	ADDRESS CHECK WHEN SETTING UP BUFFER
;	OK RETURN





NEWBUF:	HRRZ TAC,DEVADR(DEVDAT)	;TAC:=INPUT BUFFER HEADER ADDRESS
	PUSHJ PDP,BUFCLR	;CLEAR INPUT BUFFER.
	POPJ PDP,		;ADDRESS CHECK
	HRR TAC,DEVADR(DEVDAT)
	HRLZI TAC,7737
	AND TAC,DEVPTR(DEVDAT)	;DEVPTR 0-5:=0, DEVPTR 12:=0
	HRR TAC,DEVADR(DEVDAT)	;DEVPTR 18-35:=C(DEVADR 18-35) + 1
	AOS TAC
	MOVEM TAC,DEVPTR(DEVDAT)
	PUSHJ PDP,ITMSET	;ITEM:=(BUFFER SIZE-1)*[36/BYTE SIZE]
	MOVEM ITEM,DEVCTR(DEVDAT)	;DEVCTR:=ITEM COUNT
	JRST CPOPJ1		;RETURN
;ROUTINE TO SETUP BYTE POINTER ACCORDING TO DATA MODE

;CALL:	PUSHJ PDP,SETBYT
;	EXIT		ALWAYS RETURNS HERE
;SETS	TAC 0-5:=0
;	TAC 6-11:=S
;	TAC 12-13:=0
;	TAC 14-17:=PROG
;WHERE S=36 IF DATA MODE (IOS 32-25) IS BINARY (B)
;	IMAGE (I), IMAGE BINARY (IB), OR DUMP (SD,D,DR)
;      S=7  IF DATA MODE IS 	ASCII PACKED (A)
;			ASCII LINE (AL)
;			ASCII SEQUENCED (AS)
;			ASCII SEQUENCED LINE (ASL)
;		OR	ALTERNATE MODE BREAK (AM)


↑SETBYT:
	TRNN IOS,14		; IS MODE LESS THAN 10?
	HRLI TAC,700+PROG	;YES,ASCII OR ASCII LINE
	TRNE IOS,14		;10 OR GREATER?
	HRLI TAC,4400+PROG	;YES, IMAGE,IMAGE BIN. OR BIN.
	POPJ PDP,
; ROUTINE TO STORE DATA IN IOBUFFER FOR INPUT DEVICES THAT
; OPERATE CHARACTER AT A TIME.

; CALLING SEQUENCE . . .
;       PUSHJ PDP,STODAT
;       EXIT1        CHECKSUM ERROR
;       EXIT2        BLOCK FULL OR BLOCK BOMPLETE
;       EXIT3        DATA STORED CORRECTLY
; CALLED FROM AN INPUT SERVICE ROUTINE WITH A DATA ITEM IN AC DAT.
; STORES THE DATA ITEM IN THE BUFFER, CHECKING TO SEE IF IT WERE
; THE FIRST ITEM ON THE BUFFER AND SETTING UP THE POINTER AND
; WORD COUNT APPROPRIATELY CHECKING THE MODE TO SEE IF ANY SPECIAL
; PROCESSING NEED BE DONE. FOR EXAMPLE, THE TERMINATION
; OF A BUFFER ON CERTAIN CHARACTERS IN OTHER MODES, OR IF THE BUFFER
; IS FULL. THERE ARE THREE RETURNS FROM THIS ROUTINE: THE FIRST
;RETURN OCCURS ON AN ERROR CONDITION, THE SECOND RETURN OCCURS
;ON A BLOCK FULL CONDITION OR BLOCK COMPLETE CONDITION, THE THIRD
;RETURN OCCURS ON THE DATA STORED CORRECTLY CONDITION.  THIS
;ROUTINE ALSO DOES SOME CHECKING ON INPUT OF BINARY RECORD,
;PAPER TAPE OR CARDS.
;CALLING SEQUENCE
;	PUSHJ PDP,STOSQD
;	XXXX		ALWAYS SKIPS 
;	EXIT		ALWAYS RETURNS HERE
;STORES THE WORD COUNT:=C(DEVPTR 18-35) -C(DEVIAD 18-35) - 1
;IN THE BUFFER.
↑STODAT:
	TLNN IOS,IOFST		; IS THIS FIRST ITEM OF BUFFER?
	JRST STO0		;NO
	PUSHJ PDP,NEWBUF	;SET UP A NEW BUFFER. ITEM:=(BUFFER 
				;SIZE - 1)*[36/BYTE SIZE]
	POPJ PDP,
STO0:	LDB TAC1,PIOMOD		;DATA MODE
	CAIN TAC1,B		;MODE=BINARY?
	JRST STOBIN
	TLZ IOS,IOFST
STO1:	IDPB DAT,DEVPTR(DEVDAT)	;STORE DATA IN BUFFER.
	CAIE TAC1,A		;MODE=ASCII, IMAGE, OR BINARY?
	CAIN TAC1,I
	JRST STOAIB
	CAIE TAC1,IB		;IMAGE BINARY?
	CAIN TAC1,B		;CHECKSUM BINARY?
	JRST STOAIB		;YES
	ANDI	DAT,177		;NO, MUST BE ASCII LINE MODE.
	CAIG	 DAT,14		;LINE FEED,FORM FEED, OR VERTICAL TAB?
	CAIGE	DAT,12
	JRST .+2		;NO
	JRST STOSQF		;YES
	SOJGE ITEM,CPOPJ2	;ITEM:=C(ITEM)-1. IS C(ITEM)>OR=0?
STOE1:	TRO IOS,IOBKTL	;IOBKTL:=1
	POPJ PDP,
STOAIB:	SOJG ITEM,CPOPJ2;	ITEM:=C(ITEM)-1. IS C(ITEM)>0?
	CAIN TAC1,A		;MODE=ASCII?
	JRST STOSQF		;YES
	CAIN TAC1,B		;MODE=BINARY?
	JRST STOBND		;YES, COMPUTE CHECKSUM AND CHECK.
	PUSHJ PDP,ITMSET	;ITEM:=(BUFFER SIZE-1)*[36/BYTE SIZE]
				; - C(DEVCTR)
	SUB ITEM,DEVCTR(DEVDAT)
	MOVE TAC1,DEVIAD(DEVDAT);STORE ITEM COUNT
	ADDI ITEM,1		;IN FIRST WORD OF BUFFER
	AOJA TAC1,STOSQE
↑STOSQD:
	TLZN IOS,IOFST		; FIRST CALL?
	JRST STOSQF		;NO
	PUSHJ PDP,NEWBUF	;YES, CLEAR BUFFER,SET ITEM COUNT
	POPJ PDP,		;ADDRESS CHECK
STOSQF:	MOVE TAC1,DEVIAD(DEVDAT)	;REL. ADR. OF BUFFER
	AOS TAC1
	HRRZ ITEM,DEVPTR(DEVDAT)	;ITEM:=C(DEVPTR 18-35) -
				;C(DEVIAD 18-35) -1
	SUBI ITEM,(TAC1)
STOSQE:	HRRM ITEM,@TAC1		;WORD COUNT TO FIRST WORD IN BUFFER
	JRST CPOPJ1		;EXIT2. BLOCK COMPLETE


STOBIN:	TLZN IOS,IOFST		;WILL THE NEXT ITEM BE THE FIRST ITEM
	JRST STO1		;OF A BUFFER?  IOFST:=0
	HRRZ TAC,DAT		;YES.
	CAMLE TAC,ITEM		;IS WORD COUNT <OR= (BUFFER SIZE-1)*
	JRST STOE1		;   [36/BYTE SIZE]?
	MOVE ITEM,TAC		;ITEM:=WORD COUNT
	MOVEM DAT,@DEVPTR(DEVDAT)	;STORE WORD COUNT IN BUFFER
	JRST CPOPJ2		;EXIT3.  DATA STORED CORRECTLY.

STOBND:	HRRZ TAC1,DEVIAD(DEVDAT)
	PUSHJ PDP,CKS12		;COMPUTE CHECKSUM
	ADD TAC1, DEVIAD(DEVDAT)
	HLLZ TAC1,@TAC1		;DATA CHECKSUM=COMPUTED CHECKSUM?
	CAMN TAC,TAC1
	JRST CPOPJ1		;EXIT2. BLOCK COMPLETE
	TRO IOS,IODTER		;IODTER:=1
	JRST CPOPJ		;EXIT1.  CHECKSUM ERROR


SUBTTL	RUNCSS	4 AUG 67 - KSTOP

;RUN CONTROL IS A COLLECTION OF ROUTINES WHICH
;SET AND CLEAR BITS IN THE JOB STATUS WORDS OF
;ALL JOBS SO THAT THE SCHEDULER WILL START AND STOP
;THEM ACCORDINGLY

;COMMON ERROR STOPPING ROUTINES
;CALLED AT ANY LEVEL(UUO,CLK, OR INTERRUPT)
;CALL:	MOVE ITEM,JOB CAUSING ERROR OR BEING STOPPED
;	MOVE DEVDAT,ADRRESS OF THAT JOB TTY DEVICE DATA BLOCK
;	MOVE DAT,BYTE POINTER TO LAST CHAR. ALREADY MOVED
;			;TO TTY OUTPUT BUFFER
;	PUSHJ PDP,KSTOP,PHOLD,HOLD,OR ESTOP
;	NEVER RETURN IF CALLED AT UUO LEVEL

;ROUTINE TO STOP JOB AFTER KJOB COMMAND
;CALLED AT UUO LEVEL IF JOB HAD CORE,CLK LEVEL IF NOT


↑KSTOP:	MOVSI	TAC,JNA!JLOG!JACCT	;CLEAR BITS 
	ANDCAM	TAC,JBTSTS(J)
	SKIPN	JBTADR(J)
	JRST	KSTOP1
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/JBTADR NOT 0 AT KSTOP.  /
	PUSHJ	P,DISJOB
	PUSHJ	P,DISCRLF
	PUSHJ	P,DISFLU
	PUSHJ	P,WDDTCALL		;GET A WIZARD
	POPACS
KSTOP1:


	MOVNI	TAC,NULQ		;PUT HIM IN NULL QUEUE
	MOVEM	TAC,JOBQUE(J)		;SO SWAPPER WILL FORGET ABOUT HIM
	PUSHJ	P,REQUE
	PUSHJ P,FLUSIN			;FLUSH FROM SWAP IN LIST
IFN FTLOGIN,<
	SETZM	PRJPRG(J)		;KEEP TABLE ACCURATE
>
	SETZM	JOBNAM(J)
	SETZM	TTIME(J)		;CLEAR RUN TIME FOR R. GORIN
	SETZM	JBTBTM(J)		;CLEAR LOGIN TIME FOR ACCOUNTING
	SETZM	JBTGSL(J)		;CLEAR GUARANTEED SERVICE WORDS
	SETOM	JBTWKM(J)		;WAKE ON ALL INTERRUPTS
	JRST	ESTOP2
;ROUTINE TO STOP JOB, SET ERROR BIT AND PRINT MESSAGE - HOLD, PHOLD
;THEN ADD ↑C<CRLF><CRLF><PERIOD>
;CALL:	MOVEI TAC,ADR. OF MESSAGE


↑PHOLD:	PUSHJ	P,CONMES	;MOVE MESSAGE TO TTY OUTPUT BUFFER
				;FALL INTO HOLD
;ROUTINE TO STOP JOB, SET ERROR BIT,
;AND ADD "↑C<CRLF><CRLF><PERIOD>



↑HOLD:	PUSHJ	P,PRCRCC
	PUSHJ	P,TTYSTC	;MAKE SURE TTY STAYS IN MONITOR MODE
				;AND START TTY TYPING OUT MESSAGE
				;FALL INTO ESTOP
;ROUTINE TO STOP USER AND FLAG AS ERROR STOP - ESTOP, MSTOP

MSTOP:
↑ESTOP:
	JUMPE	J,CPOPJ
	SKIPE	SPWUUF(PID)		;SPACEWAR LEVEL?
	CONSZ	PI,77000		;YES. ABOVE CH 7?
	CAIA				;NOT SPACEWAR (OR ABOVE CH 7)
	JRST	SPWERR			;ERROR AT SPACEWAR LEVEL
	MOVSI	TAC,JACCT
	ANDCAM	TAC,JBTSTS(J)		;NO LONGER AN ACCOUNTING PROGRAM
	MOVSI	TAC,JLOG
	TDNE	TAC,JBTSTS(J)		;IS THIS JOB REALLY LOGGED IN?
	JRST	ESTOP4			;YES, PROCEED NORMALLY
	SKIPN	PROG,JBTADR(J)
	JRST	ESTOP4			;NOT LOGGED IN AND NO CORE.
	CONSZ	PI,77400		;NOT LOGGED IN.  ARE WE AT UUO LEVEL
	JRST	ESTP3B			;NO, MUST START MONITOR JOB TO KILL JOB
	SKIPN INTACT(PID)
	JRST ESTP3A			;AT UUO LEVEL BUT NOT USER INT LEVEL
ESTP3C:	PUSHJ P,ESTOP3			;SET JLOG, SETUP MONJOB,
	SETOM ESTINT			;TELL CH7 WE'RE COMING FROM ESTOP
	JRST WSCHD2			;GET INTO CHANNEL 7

ESTP3B:	CAMN	J,JOB(PID)		;PI IN PROGRESS.  JLOG OFF
	SKIPN	INTACT(PID)
	JRST	ESTOP3
	JRST	ESTP3C			;CURRENT JOB IS AT USER-INT LEVEL

ESTP3A:	PUSHJ	P,JOBKL1		;AT UUO LEVEL, CAN KILL JOB FROM HERE
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/RETURNED FROM JOBKL1 AT ESTOP
/
	POPACS
	JRST	ESTOP4			;SET ERROR BIT

ESTOP3:	IORM	TAC,JBTSTS(J)	; FINISH LOGGING IN JOB SO WE WON'T GET HERE AGAIN
	MOVE	TAC,['-DIE!-']
	MOVEM	TAC,JOBNAM(J)	; (EVEN IF WE FAIL TO KILL THIS, WE GET NEW PHANTOM)
	PUSHJ	P,INTKIL	; MAKE SURE THE LOSER CAN'T GET ANY MORE ERRORS - RPH
	JSP	TAC1,MONJOB	; SET MONITOR JOB TO RUN AND KILL JOB
	JRST	JOBKL		; HERE AT UUO LEVEL

;GET HERE FROM KSTOP
↑ESTOP2:
	JUMPE	J,CPOPJ			;IS THIS ERROR IN JOB 0?
	SKIPE	SPWUUF(PID)		;JOB IN SPACEWAR MODE ?
	CONSZ	PI,77000
	CAIA
	JRST	SPWERR			;YES. GO TO SPWSER.
	MOVSI	TAC,JACCT		; ZERO OUT ACCT BIT
	ANDCAM	TAC,JBTSTS(J)		; SO IF LOGIN BLOWS, WE CAN KILL IT!!
ESTOP4:	MOVSI	TAC,JERR		; SET ERROR BIT
	IORB	TAC,JBTSTS(J)		;SO JOB CAN NOT CONTINUE(CONT COM.)
	TRNE	TAC,JLOCK
	JRST	[MOVSI TAC,UNLOKC
		HRR TAC,J
		CONO PI,PIOFF
		IDPB TAC,CLKQ		;USE DPYSLUR CLOCK QUEUE.
		CONO PI,PION
		JRST .+1]
	PUSHJ P,INTKILL			; CLEAR THE USER INTERRUPT SYSTEM
	CAME J,STUSER			;SYSTEM TAPE USER?
	JRST ESTOP6			;NO
	MOVSI TAC,'SYS'			;FIND SYS DDB
	PUSHJ P,DEVSRC			;SYSTEM ERROR IF NOT FOUND
	JRST ESTOP5			;BARF!
	PUSHJ P,RELEA9			;YES, RELEASE SYSTEM TAPE WITHOUT WAITING
	JRST ESTOP6

ESTOP5:	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/ππNO DEV SYS: AT ESTOP!
/
	POPACS
ESTOP6:	CAMN J,JOB(PID)	;IF NOT CURRENT JOB
	CONSZ PI,77400	;OR AT INTERRUPT LEVEL
	JRST STOP1	;JUST GO TO STOP1 AS ALWAYS
	SKIPE INTACT(PID)
	JRST STOP1	;ALSO IF FROM USER INT
	PUSHJ P,SETSTP	;OTHERWISE PUT HIM IN STOPQ, ETC.
	MOVE TAC,UUOPC(J)
	TLNN TAC,USRMOD
	TDZA TAC,TAC	;GIVE HIM 0 IF PC WAS EXEC
	HRRI TAC,-1(TAC);ELSE BACK IT UP TO LOSING UUO
	MOVEM TAC,UUOPC(J)
	JRST USRX4A	;NOW CATCH HIM ON HIS WAY "BACK"
;ROUTINE TO STOP ANY JOB FROM BEING SCHEDULED - STOP1, SETSTP
;CALL:
;	MOVE	J, JOB NUMBER
;	PUSHJ	P, STOP1
;	EXIT	;RETURN HERE IMMEDIATELY, IF CALLED FROM HIGHER
;PRIORITY PI CHANNEL THAN CLK(LOWEST), OTHERWISE WHEN JOB IS RUNABLE
;CALLED FROM COMMAND DECODER WHEN <CONTROL>C TYPED IN BY USER

↑STOP1:	PUSHJ	P,SETSTP	;SET IT TO STOPQ, ETC
	CAME	J,JOB(PID)	;IS THIS JOB CURRENT USER
	JRST	REQUE		;NO, SET REQUE JOB FLAG
	SKIPE INTACT(PID)
	SETOM ESTINT		;TELL CH7 WE'RE COMING FROM ESTOP
	JRST	WSCHD2		;YES, CALL WSCHED TO WAKE CH7

;THIS ROUTINE DOES ALL THE WORK OF STOPPING THE GUY WITHOUT ACTIVATING CH7
SETSTP:	MOVSI	TAC,RUN
	CONO	PI,PIOFF	;DONE AT INTERUPT LEVEL HIGHER THAN DT LEVEL
	CAME	J,STUSER	;IS THIS JOB CURRENTLY USING THE SYSTEM TAPE?
	TDNN	TAC,JBTSTS(J)	;NO, IS RUN BIT OFF IN JOB STATUS WORD
	JRST	STOP1A		;YES
	ANDCAM	TAC,JBTSTS(J)	;NO, SO CLEAR IT
	CONO	PI, PION
	MOVM	TAC,JOBQUE(J)	;GET JOB WAIT QUEUE CODE(IF ANY)
	CAIG	TAC,MAXQ	;DOES STATE HAVE Q ?
	SOSL	REQTAB(TAC)	;YES. REDUCE IT.
	JRST	STOP1A		;NO
	SOSGE	AVALTB(TAC)	;YES REDUCE  COUNT
	SETZM	AVALTB(TAC)	;CLEAR AVAL FLAG IF NO ONE WAITING
STOP1A:	CONO	PI,PION		;MAKE SURE PI ON
	MOVNI	TAC,STOPQ	; REQUE JOB TO STOP QUEUE
	MOVM	TAC1,JOBQUE(J)
	CAIE	TAC1,NULQ	; UNLESS HE IS IN THE NULL QUEUE
	MOVEM	TAC,JOBQUE(J)
	CAMN	J,LOCKNO	;WERE WE WAITING TO BE LOCKED IN?
	SETZM	LOCKNO		;YES. WELL, THERE'S NO ONE THERE ANYMORE.
	POPJ	P,		;↑C, CONTINUE WILL NOT UNLOCK A JOB!
;DLYCOM     ROUTINE TO REQUE JOB WHICH HAS HAD A COMMAND TYPED
;WHICH NEEDS CORE AND THE CORE IMAGE IS ON THE DISK.
;OR IS IN CORE AND HAS ACTIVE DEVICES.
;CALLED FROM COMMAND DECODER
;CALL:	MOVE ITEM,JOB NO.
;	PUSHJ PDP,DLYCOM


↑DLYCOM:MOVSI TAC,CMWB			; SET COMMAND WAIT BIT
	IORB TAC,JBTSTS(J)		;IN JOB STATUS WORD
	TLNN TAC,SWP			;DO WE NEED HIM IN??
	POPJ P,				;IN ALREADY
	MOVSI TAC,COMSNB
	JRST SETSIN
;ROUTINE TO PUT JOB IN NO CORE QUEUE

↑NOCORQ:PUSHJ P,FLUSIN			; FLUSH FROM SWAP IN LIST
	MOVEI	TAC,NULQ		; NO JOB NUMBER OR NO CORE QUEUE
	MOVNM	TAC,JOBQUE(J)
	JRST	REQUE
;ROUTINE TO SETUP MONITOR JOB TO RUN LATER AT UUO LEVEL - MONJOB
;CALLED BY COMMANDS WHICH MAY OR MAY NOT NEED TO
;RUN MONITOR JOB DEPENDING ON WHETHER JOB HAS CORE(KJOB,IJOB)
;TTY WILL REMAIN IN MONITOR MODE
;JOB MUST HAVE CORE ASSIGNED
;CALL:	MOVE ITEM, JOB NUMBER
;	MOVEI TAC1,ADDR. OF MONITOR JOB TO BE RUN
;	PUSHJ PDP,MONJOB
;WHEN SCHEDULED TO RUN, MONITOR JOB MUST SET UP ITS OWN ACS


↑MONJOB:
	PUSHJ	P,MSTART	; START WITH PC IN MONITOR
	JRST	SETRUN		;MCF(JBS);SET TTY TO START JOB WHEN COMMAND RESPONSE
				;IS FINISHED AND KEEP TTY IN MONITOR MODE
;MONSTR ROUTINE TO SETUP ACS FOR MONITOR JOB STARTING AT UUO LEVEL
;SETS UP J, WITH JOB NO.; PROG WITH RELOCATION, AND P
;WITH PUSH DOWN LIST ADR. IN JOB DATA AREA
;USED BY KJOB,CORE 0,SAVE,GET,RUN,R AND FINISH COMMANDS
;CALL:	MOVEI TAC1,MONITOR JOB STOP ADDRESS
;	JSP TAC,MONSTR
;	RETURN WITH ACS P, PROG AND J SETUP


↑MONSTR:
	MOVEI	PID,P1PID
	CONSO	APR,MAOFF
	MOVEI	PID,P2PID
	MOVE	J,JOB(PID)	; GET CURRENT JOB NUMBER
	MOVE	JDAT,JBTDAT(J)	;ADR. OF JOB DATA AREA
IFN JDMPRG,<
	MOVE	PROG,JBTADR(J)	;JOB RELOCATION
>
	EXCH	AC1,TAC
	JSP	TAC,GETPDL	; GET A PUSHDOWN LIST FOR US
	EXCH	AC1,TAC		; GET OUR RETURN ADDRESS BACK
	PUSH	P,TAC1		;SAVE STOP ADRRESS
	JRST	(TAC)		;RETURN AND DO MONITOR JOB
;ROUTINE TO SET JOB STATE TO BE SCHEDULED TO RUN - USTART, MSTART
;WITH SPECIFIED STARTING ADDRESS INCLUDING PC FLAGS
;CALLED ONLY WHEN JOB IN CORE AND AFTER JOB HAS BEEN
;SAFELY STOPPED IN ONE OF 2 STATES:
;1) PC IN USER MODE
;2) JOB IN A WAIT FOR SHARABLE DEVICE, OR IO WAIT
;CALL:	MOVE TAC1,STARTING PC
;	MOVE ITEM, JOB NUMBER
;	MOVE JDAT,ADR. OF JOB DATA AREA WHICH MUST BE IN CORE
;	PUSHJ PDP,USTART(PC TO USER MODE),MSTART(PC TO MONITOR MODE)
;	RETURN HERE IMMEDIATELY


↑USTART:
	MOVE TAC,JOBPC(JDAT)	; GET OLD PC
	TLNE TAC,USRMOD		;IS IT IN USER MODE TOO?
	JRST USTRT1		;YES, DUMP ACS AND PC FLAGS ARE ALREADY HIS
	MOVEI TAC,JOBDAC(JDAT)	;NO, MOVE USERS(UUO) ACS TO DUMP ACS
	HRL TAC,JDAT		;SOURCE=REL. 0,DEST.=JOBDAC IN JOB DATA AREA
	BLT TAC,JOBD17(JDAT)	;MOVE ALL ACS
	MOVE TAC,UUOPC(J)	; UUO PC HAS LAST KNOWN PC
	TLNN TAC,USRMOD		;IF NOT USEER MODE
	MOVE TAC,UUOOPC(J)	;TRY THIS
	TLNN TAC,USRMOD		;IS IT?
	TLZ TAC,-1		;NO, CLEAR ALL PC FLAGS
	HRRI TAC,-1(TAC)	;SUBTRACT 1 FROM RIGHT HALF AND
				;PRESERVE LH PC FLAGS.
				;(RH=0 ON HALT 0 OR FIRST START)
USTRT1:	HLL TAC1,TAC		;PRESERVE USER APR FLAGS
	TLO TAC1,USRMOD		;MAKE SURE NEW PC IN USER MODE
	TLZ TAC1,37		;MAKE SURE NO INDIRECT BITS OR INDEX FIELD
	JRST MSTAR1

↑MSTART:MOVE TAC,JOBPC(JDAT)	; PICK UP USER'S PC
	TLNE TAC,USRMOD		;IN USER MODE?
	JRST MSTAR1		;YES, THIS IS CORRECT JOBOPC
	MOVE TAC,UUOPC(J)	;HERE IS LAST USER PC (MAYBE)
	HRRI TAC,-1(TAC)	;JUST LIKE USTART
MSTAR1:	TLNE TAC,USRMOD		;IF IT STILL ISN'T USER PC LEAVE HIS OLD ONE
	MOVEM TAC,JOBOPC(JDAT)	; STORE IT FOR LATER USE
	MOVEM TAC1,JOBPC(JDAT)	; STORE NEW PC
	CAMN J,JOB(PID)		;IS THIS CURRENT JOB?
	MOVEM TAC1,USRPC(PID)	;YES.  STORE IN SYSTEM CORE AS WELL.
	SKIPE INTACT(PID)
	CAME J,SJOB		;MAKE SURE THAT USRPC IN THE INTERRUPT STACK
	JRST MSTAR2		;GETS UPDATED
	MOVE TAC,INTSP
	MOVEM TAC1,USRPC-USRJDA-20(TAC)
MSTAR2:	PUSHJ P,STXTM2		;UPDATE INTERACTION RUN TIME FOR THIS JOB
	MOVSI TAC,JERR+WTMASK
	ANDCAM TAC,JBTSTS(ITEM)	;CLEAR ERROR AND WAIT STATUS BITS
	MOVNI TAC,RUNQ		; REQUE JOB TO RUN QUEUE
	MOVEM TAC,JOBQUE(J)
IFN FTSWAP,<
	SETOM STIME(ITEM)	; TELL SWAPPER THIS CORE IMAGE HAS BEEN MODIFIED
>
	JRST TTYSET		;SET TTY STATE TO INITIAL COND.
				;TTYUSR OR TTYURC SHOULD BE CALLED
				;TO INDICATE WHETHER TTY TO USER OR EXEC MODE
				;AND THAT JOB IS TO RUN(RUN BIT =1) WHEN
				;MONITOR COMMAND RESPONSE FINISHES.
				;SET MONITOR MODE
;ROUTINE TO SET JOB STATUS RUN BIT(RUN)
;CALLED BY SCANNER SERVICE WHEN TTY MONITOR COMMAND
;RESPONSE FINISHES.  THIS ACTION IS ENABLED BY CALLING
;TTYUSR, OR TTYURC IN SCNSER
;CALL:	MOVE ITEM,JOB NUMBER
;	PUSHJ PDP,SETRUN



↑SETRUN:
	LDB TAC,[POINT JWSIZ,JBTSTS(J),JWPOS]	;GET OLD WAIT QUEUE CODE
	JUMPE TAC,SETR1		;NONE
	AOSE REQTAB(TAC)	;DEVICE AVAILABLE?
	MOVNM TAC,JOBQUE(J)	;NO - PUT US BACK INTO WAIT Q
SETR1:	MOVSI TAC,RUN		;SET RUN BIT IN JOB STATUS WORD
	IORM TAC,JBTSTS(ITEM)


↑REQUE:	PUSH P,TAC
	MOVEI TAC,QJOB(ITEM)
	CONO PI,PIOFF
	SKIPE (TAC)
	JRST .+3
	EXCH TAC,QJOB
	HRROM TAC,@QJOB
	CONO PI,PION
	JRST TPOPJ
;ROUTINE TO PUT A JOB TO SLEEP AND WAKE UP AGAIN LATER
;CALLED AFTER CLOCK QUEUE REQUEST PUT IN BY UUO ROUTINE



↑SETSLP:
	MOVSI TAC,CLKR		; FLAG THAT A CLOCK REQUEST
				;HAS BEEN PUT IN.
	IORM TAC,JBTSTS(ITEM)	;SO ONLY ONE PER JOB
	MOVEI AC1,IOWQ		;SLEEP STATE CODE
	JRST SETSTT		;SET STATUS AND RESCHEDULE

;HERE AT CLOCK LEVEL WHEN CLOCK REQUEST TIMES OUT FOR SLEEP
;JOB NO. IN AC TAC


↑WAKE:	MOVNI TAC1,RUNQ		;RUN QUEUE CODE
	MOVE ITEM,TAC		;JOB NO.
	MOVSI TAC,CLKR		;CLEAR CLOCK REQUEST BIT FOR THIS JOB
	ANDCAM TAC,JBTSTS(ITEM)	;SO IT CAN PUT ANOTHER ONE IN
	MOVM TAC,JOBQUE(J)	;GET QUEUE CODE
	CAIE TAC,IOWQ		;IS JOB STILL SLEEPING?
	POPJ P,			;NO
	MOVEM TAC1,JOBQUE(J)	;YES, STORE RUN QUEUE CODE
				;(CONTROL C, START CAN GET JOB OUT OF SLEEP)
	JRST REQUE
;ROUTINE TO GET DATA CONTROL AND ANOTHER SHARABLE DEVICE
;JOB NEVER GETS ONE DEVICE AND WAITS FOR SECOND, SINCE TYPING
;CONTROL C WOULD NEVER FINISH WITH FIRST DEVICE
;CALL	PUSHJ PDP,GETDCXX
;	AOSE XXREQ	;REQUEST COUNT FOR OTHER DEVICE
;	RETURN WHEN BOTH AVAILABLE


↑GETDCDT:↑GETDCMT:
	XCT @(PDP)		;INCREASE SHARABLE DEVICE REQ. COUNT
GETWT:	PUSHJ PDP,DVWAT1	;NOT AVAIL., GO WAIT FOR IT
	AOSN DCREQ		;IS DATA CONTROL AVAILABLE?
	JRST CPOPJ1		;YES, RETURN BOTH AVAILABLE
	MOVE AC1,@(PDP)		;DATA CONTROL NOT AVAILABLE
	SUBI AC1,REQTAB
	SOSL REQTAB(AC1)	;REDUCE REQ. COUNT FOR OTHER
				;SHARABLE DEVICE.
	SETOM AVALTB(AC1)	;SET AVAILABLE IF OTHER JOBS WAITING
	JFCL DCREQ		;ARGUMENT FOR DCWAIT
	PUSHJ PDP,DCWAIT	;WAIT FOR DATA CONTROL FREE
	MOVE AC1,@(PDP)		;INCREMENT REQ. COUNT
	AOSN @AC1		;NOW IS SHARABLE DEVICE FREE?
	JRST CPOPJ1		;YES
	SOSL DCREQ		;NO, REDUCE DATA CONTROL REQUEST
	SETOM DCAVAL		;SET AVAIL., SOME OTHER JOB WAITING FOR IT
	JRST GETWT		;TRY AGAIN
;ROUTINE TO WAIT FOR A SHARABLE DEVICE
;CALLED AT UUO LEVEL ONLY BY DEVICE SERVICE ROUTINES
;CALL:	AOSLE XXREQ		;ADD 1 TO SHARABLE DEVICE REQUEST COUNT
;				;IS DEVICE AVAILABLE?
;	PUSHJ PDP,XXWAIT	;NO, PUT JOB IN WAIT QUEUE
;	RETURN WHEN DEVICE AVAILABLE

;INITIALLY THE REQUEST COUNT IS -N, WHERE N IS THE
;NUMBER OF JOBS WHICH CAN USE THE SHARABLE DEVICE AT THE SAME TIME
;A REQUEST COUNT OF 0 MEANS THE MAXIMUM NO. OF JOBS ARE
;USING THE DEVICE, A POSITIVE NUMBER IS THE
;NUMBER OF JOBS WAITING IN THE SHARABLE DEVICE WAIT QUEUE



↑MTWAIT:↑DTWAIT:↑DCWAIT:↑STWAIT:
↑DVWAIT:
	MOVE AC1,(PDP)		; GET ADDRESS OF CALLER
	SKIPA AC1,-2(AC1)	;GET AOSLE XXREQ INSTRUCTION
DVWAT1:	MOVE AC1,@-1(PDP)	;GET ADR. OF CALLER OF THIS ROUTINE
	SUBI AC1,REQTAB		;COMPUTE WAIT-STATE QUEUE CODE
SETSTT:	MOVE AC3,JOB(PID)	;CURRENT JOB NO.
	HRRZS AC1		; CLEAN UP JOB QUEUE CODE
	MOVNM AC1,JOBQUE(AC3)	;STORE IN JOB STATUS WORD
	JRST WSCHED		;GO SCHEDULE ANOTHER AND RETURN TO CALLER
				;WHEN SHARABLE DEVICE BECOMES AVAILABLE
				;SEE CLOCK AND CLKCSS
				;WORD WAIT QUEUE CODE
;SETIOD - ROUTINE TO SET JOB TO RUN AFTER IT HAS BEEN STOPPED
;BECAUSE IT HAD TO WAIT FOR IO TO COMPLETE FOR SOME DEVICE
;EACH SERVICE ROUTINE AT INTERRUPT LEVEL
;CHECK EACH TIME IT FINISHED A TASK(BUFFERFUL)
;TO SEE IF THE JOB USING THE DEVICE HAS
;PREVIOUSLY CAUGHT UP WITH DEVICE AND HAS BEEN STOPPED
;CALL:	MOVE DEVDAT,ADR. OF DEVICE DATA BLOCK
;	MOVE IOS,DEVIOS(DEVDAT)	;GET DEVICE IO STATUS WORD FROM DDB
;	TLZE IOS,IOW	;IS JOB IN AN IO WAIT FOR THIS DEVICE?
;	PUSHJ PDP,SETIOD	;YES, GO FLAG JOB TO START UP AGAIN
;	RETURN
; REQUEUES JOB TO A RUN QUEUE
;THE SCHEDULER THEN SEES THAT THIS JOB HAS ITS
;IO WAIT SATISFIED AND IS WAITING TO BE RUN AGAIN


;!! No longer clobbers ac's !  	DWP.

↑STTIOD:PUSH P,[-TQ]	;HE'S A TTY.  PUT HIM IN SPECIAL HIGH-PRIORITY QUEUE
	CAIA
↑SETIOD:PUSH P,[-RUNQ]		; REQUE TO WAIT SATISFIED QUEUE
	EXCH J,(P)
	PUSH P,J
	LDB J,PJOBN		;Get job no.
	SKIPL JBTSTS(J)		; IS JOB STILL RUNNING?
	JRST [	POP P,J		;No.
		POP P,J
		POPJ P,]
	POP P,JOBQUE(J)
	PUSHJ	PDP,REQUE	;ARRANGE TO REQUE THIS JOB.
	POP P,J
NULTST:	SKIPE JOB(PID)		;IS NULL JOB RUNNING?
	POPJ PDP,		;NO LET OTHER JOB RUN
	CONO PI,PIOFF
	JRST STOP2
;ROUTINE TO CAUSE CLK ROUTINE TO RESCHEDULE - WSCHED
;CALLED AT ANY LEVEL
;CALL:	PUSHJ PDP,STOP2	
;	RETURN IMMEDIATELY EXCEPT IF AT UUO LEVEL
;	IF AT UUO LEVEL, RETURN WHEN JOB IS RUNABLE AGAIN


↑WSCHED: JUMPE PID,WSCHD1
	PUSHACS
	CONSZ APR,MAOFF
	JRST WSCHDA
	PUSHJ	P,DISMES
	ASCIZ	/PDP-6 AT WSCHED
/
	POPACS
	PUSHJ P,DISFLUSH
	JRST AUTOLOAD

WSCHDA:	PUSHJ	P,DISMES
	ASCIZ	/PID CLOBBERED AT WSCHED
/
	POPACS
WSCHD1:	SKIPE SPWUUF(PID)	;MAKE SURE WE'RE NOT IN A SPACEWAR JOB
	JRST SPWERR
WSCHD2:	AOS NWSCHEDS		; MARK ANOTHER ONE GONE
	CONO PI,PIOFF		;AVOID PREMATURE CLK INT
	SETOM SCHEDF(PID)	;THIS IS A SCHEDULING INTERRUPT
STOP2:	HLLOS CLKFLG(PID)	;SET FLAG TO INDICATE CLK INTERRUPT
				;EVEN THOUGH CLK INTERRUPT IS NOT A TIME INTERRUPT
	CONO PI,PION+1B24!1⊗(7-CLKCHN)
				;TURN PI BACK ON AND REQUEST INTERRUPT TO
				;CLK PI CHANNEL(LOWEST PRIORITY CHANNEL)
	POPJ P,			;INTERRUPT IMMEDIATELY IF AT UUO LEVEL
;ROUTINE TO WAIT TILL DEVICE CATCHES UP WITH USER AND BECOMES INACTIVE
;CALLING SEQUENCE
;     PUSHJ PDP, WAIT1
;     EXIT	  ALWAYS RETURNS HERE
 
;IF THE DEVICE IS INACTIVE (IOACT=0), RETURNS TO EXIT. OTHERWISE, SETS
;IOW:=1 AND ENTERS WAIT UNLESS IOACT BECOMES ZERO BEFORE THE
;JUMP IS MADE, IN WHICH CASE IT SETS IOW:=0 AND RETURNS TO EXIT.
;ON LEAVING THE WAIT STATE, RETURNS TO EXIT.
;THIS ROUTINE PREVENTS THE STATE IOACT=0 AND IOW=1 FROM OCCURING
;CALLING SEQUENCE
;     PUSHJ PDP, WSYNC
;     EXIT             ALWAYS RETURNS HERE
;SETS IOW:=1 AND ENTERS WAIT ROUTINE. RETURNS TO EXIT WHEN IOACT=0.


↑WAIT1:	MOVE IOS,DEVIOS(DEVDAT)
	MOVE AC1,DEVMOD(DDB)
	TLNE AC1,DVTTY		;TTY MAY ALWAYS PROCEED FROM HERE!!!!! RPH
	POPJ P,
	TRNN IOS, IOACT		;IS DEVICE ACTIVE? (IOACT=1?)
	JRST WAIT2
	PUSHJ PDP,WSYNC		;WAIT
	JRST WAIT1

WAIT2:	MOVSI AC1,DEVIBF	; SET TO CHECK IF THIS DEVICE IS INTERNALLY BUFFERD
	TDNE AC1,DEVCMR(DEVDAT)	; TEST THE BIT
	TLNN IOS,DEVSBB		; IT HAS A BUFFER, IS IT BUSY?
	POPJ PDP,		; NO, LEAVE
	PUSHJ PDP,WSYNC		; YES, WAIT FOR IT
	JRST WAIT1		; THEN MAKE SURE
;WSYNC IS CALLED TO WAIT UNTIL 
;SETIOD IS CALLED BY INTERRUPT SERVICE ROUTINE
;IE  UNTIL CURRENT BUFFER ACTIVITY IS COMPLETED
;CALLED ONLY FROM UUO LEVEL
;CALL:	MOVE DEVDAT,ADR. OF DEVICE DATA BLOCK
;	PUSHJ PDP,WSYNC
;	RETURN IMMEDIATELY IF DEVICE IS INACTIVE
;	RETURN WHEN DEVICE FINISHES NEXT BUFFER IF IT IS ACTIVE



↑WSYNC:	MOVSI IOS,IOW		;SETUP DEVICE IO WAIT BIT
	MOVEI AC1,DIOWQ		; DISK IO WAIT QUEUE
	MOVE AC3,DEVIOS(DEVDAT)	; SEE IF JOB IS LOCKED IN CORE
	MOVE AC2,DEVMOD(DEVDAT)	; WHICH FOR DEVICES OTHER THAN THE TTY MEANS IOACT IS ON
	TLNN AC2,DVTTY
	TRNN AC3,IOACT		; LOCKED IN?
	MOVEI AC1,IOWQ		; NO, STRAIGHT IO WAIT QUEUE CODE
	MOVE AC3,JOB(PID)	;CURRENT JOB NO.
	HRRZ AC2,DEVCMR(DEVDAT)	; FIRST, DOES HE HAVE CONTROL CELLS?
	SKIPE P2NUM		; IF P2 IS ACTIVE . . .
	JUMPN AC2,WSYNC1	; WE CHECK. IF YES, THIS IS A SPECIAL CASE
	MOVSI AC2,DEVIBF	; ALSO, IS THIS A SCREWEY DEVICE?
	TDNE AC2,DEVCMR(DEVDAT)	; LIKE LPT WITH THE INTERNAL BUFFER
	SKIPA AC2,[XWD DEVSBB,0]
	MOVEI AC2,IOACT
	CONO PI,PIOFF
	TDNN AC2,DEVIOS(DEVDAT)
	JRST WSYNC3
	IORM IOS,DEVIOS(DEVDAT)
	MOVNM AC1,JOBQUE(AC3)
	CONO PI,PION
	PUSHJ PDP,WSCHED
	ANDCAB IOS,DEVIOS(DEVDAT)
	POPJ PDP,

WSYNC3:	CONO PI,PION
	MOVE IOS,DEVIOS(DEVDAT)
	POPJ PDP,
; WE GET HERE IF THIS DEVICE HAS CONTROL CELLS
; WE MUST BOTH GET CONTROL OF THE CELLS AND SHUT OFF THE PI
; BECAUSE EVEN IF P2 IS ACTIVE, THE DEVICE MIGHT NOT BE RUNNING ON P2

WSYNC1:	MOVSI AC2,DEVIBF	; NOW SEE IF THIS IS A SCREWEY DEVICE
	TDNE AC2,DEVCMR(DEVDAT)
	SKIPA AC2,[XWD DEVSBB,0]
	MOVEI AC2,IOACT
	PSYNC1 <HRRZ TAC,DEVCMR(DDB)>	; GET CONTROL OF IOS
	TDNN AC2,DEVIOS(DEVDAT)	; IS THE DEVICE ACTIVE?
	JRST WSYNC2		; NO, FORGET IT
	CONO PI,PIOFF		; INTERLOCK OUR FOOLING AROUND
	IORM IOS,DEVIOS(DEVDAT)
	MOVNM AC1,JOBQUE(AC3)
	CONO PI,PION
	XSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	PUSHJ PDP,WSCHED	; DO THE IO WAITING
	PSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	ANDCAB IOS,DEVIOS(DEVDAT)
WSYNC4:	XSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	POPJ P,

WSYNC2:	MOVE IOS,DEVIOS(DEVDAT)	; RESTORE IOS
	JRST WSYNC4		; RELEASE CELLS, RESTORE ACS
REPEAT 0,<
; ROUTINE TO SWITCH YOUR JOB TO THE OTHER PROCESSOR TEMPORARILY
; CALLING . . .
;	PUSHJ P,PSWITCH
; CLOBBERS ACCUMULATOR AC1

PSWITCH:
	LDB AC1,PRUNB		; PICK UP THIS JOB'S PROCESSOR BITS
	PUSH P,AC1		; SAVE THEM
	MOVEI AC1,RUN1
	SKIPN PID
	MOVEI AC1,RUN2
	PSYNC JBTCSC
	DPB AC1,PRUNB
	XSYNC JBTCSC
	PUSHJ P,WSCHED
	MOVE PID,OTHERID(PID)	; PICK UP THE PROPER ID
	POP P,AC1
	PSYNC JBTCSC
	DPB AC1,PRUNB
	XSYNC JBTCSC		; RESTORE RUN BITS
	POPJ P,

GOTOP1:	JUMPE PID,CPOPJ
	JRST PSWITCH
>
