COMMENT ⊗   VALID 00061 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00007 00002	SUBTTL IMP UUO-LEVEL CODE - JAM, SEPT '71
C00010 00003	 MORE MTAPE UUO CODES
C00012 00004	 POSITIONS IN USER TABLE OF VARIOUS QUANTITIES
C00013 00005	 UUO DISPATCH TABLE
C00014 00006	 INITIALIZE ROUTINE
C00017 00007	 MTAPE DISPATCH
C00019 00008	 TERMINATE CONNECTION
C00021 00009	 REINITIALIZE THE IMP SYSTEM, BRING UP THE IMP
C00022 00010
C00024 00011	 TEST AND CLEAR INTERRUPT BITS - SET SYSTEM DEFAULT TIMEOUTS
C00026 00012	 LISTEN CODE
C00029 00013	 LISTEN CODE - HERE HE WANTS TO LISTEN TO AN EXTANT SOCKET
C00032 00014	 LISTEN - GET HERE WHEN THE SLOT IN THE TABLE IS OKED FOR CONNECTION
C00033 00015	 CONNECT CODE - FIRST CHECK FOR A PENDING SOCKET, THEN SEND OUT A RFC
C00036 00016	 CONNECT CODE. CHECK SOCKET FOR CLOSURE. IF CLOSED, WE MAY GO AHEAD AND USE IT
C00038 00017	 CONNECT CODE. ROUTINE TO SET UP THE INDEX AND TRY TO WAIT FOR CONNECTION.
C00039 00018	 DUMP. GIVE LOSER A DUMP OF THE MONITOR TABLES.
C00041 00019	 ROUTINE TO GIVE LOSER HIS SOCKET NUMBERS
C00042 00020	 ROUTINE TO WAIT FOR CONNECTION
C00044 00021	 MTAPE 13 - SET ALLOCATION
C00046 00022	 UUO TO SET ALLOCATION. HERE ALLOCATION HE WANTS IS IN AC2 & AC3
C00048 00023	 HERE WE DECREMENT HIS ALLOCATION AND ASK FOR SOME BACK IF NEED BE
C00050 00024	 MTAPE 14 - GIVE USER THE CURRENT ALLOCATIONS
C00051 00025	 ROUTINE TO SEND AN INTERRUPT
C00052 00026	 RELEAS CODE. SEND OUT CLSS IF NOT ALREADY.
C00054 00027	 BUFFERED OUTPUT . . .
C00056 00028	 ROUTINE TO ACTUALLY DO THE OUTPUT
C00059 00029	 FULL WORD MODE OUTPUT - BYTE AT A TIME
C00063 00030	 ROUTINE TO CORRECT WORD COUNT, ALLOCATION, AND SEND OFF MESSAGE
C00065 00031	 BUFFERED OUTPUT. GET HERE TO DO A BLT INTO THE MESSAGE BUFFERS.
C00068 00032	 HERE WE HAVE DECIDED TO SEND THE MESSAGE, WHETHER THERE IS MORE IN THE BUFFER OR NOT
C00069 00033	 IMP INPUT UUOS - BUFFERED MODE AND DUMP MODE
C00071 00034	 COMMON INPUT ROUTINE.
C00074 00035	 COMMON INPUT ROUTINE. READ DATA OUT OF INPUT LIST AND INTO USER CORE
C00077 00036	 HERE WE HAVE CORRECTED THE WORD COUNTS IN THE BUFFERS AND ARE READY TO DO THE INPUT
C00080 00037	 CLOSE CODE. DOESN'T REALLY DO MUCH EXCEPT FLUSH BUFFERS AND SEND OUT CLSS
C00082 00038	 UTILITY ROUTINES FOR UUO-LEVEL STUFF. ROUTINES TO SEND STR OR RTS
C00083 00039	 ROUTINE TO MAKE UP AN RFC BLOCK. MUST HAVE BLOCK IN AC1, CONNECTION INDEX IN AC3,
C00085 00040	 ERROR ROUTINE FOR NO CONNECTION
C00086 00041	 ROUTINE TO SEND OUT A MESSAGE AT UUO LEVEL. WAITS FOR
C00089 00042	 ROUTINE TO WAIT FOR THE LINK TO CLEAR
C00090 00043	 ROUTINE TO BLESS UUO LEVEL OUTPUTS BASED ON HOST STATUS.
C00091 00044	 ROUTINE TO CHECK FOR PROPER CONNECTION AND HOST DEAD.
C00094 00045	 ROUTINE TO INITIALIZE A CONNECTION
C00095 00046	 ROUTINE TO REQUEUE SOMEONE INTO THE RUN QUEUE
C00097 00047	 ROUTINE TO WAIT FOR ALLOCATION
C00099 00048	 ROUTINE TO GET LINK TABLE INDEX FROM A DDB POINTER - SEND SIDE
C00100 00049	 THIS IS CALLED AT CONNECT AND LISTEN TO DETERMINE
C00102 00050	 FREE STORAGE MANAGER FOR IMP SERVICE
C00104 00051	 HERE WE CAN'T GET FS FROM THE SYSTEM, SEE IF WE CAN SCROUNGE A BLOCK
C00105 00052	 ROUTINE TO RELEASE FREE STORAGE
C00107 00053	 ROUTINE TO ASSIGN A NEW LINK NUMBER
C00109 00054	 ROUTINE TO SEE IF A TABLE ENTRY MAY BE CLEARED.
C00110 00055	 ROUTINE TO SEARCH DOWN QUEUED RFC LIST FOR AN RFC THAT MATCHES OUR SOCKET
C00112 00056	 ROUTINE TO APPEND AN ENTIRE RFC QUEUE ONTO ILIST
C00114 00057	 ROUTINE TO GO INTO A WAIT STATE BUT START A COUNTDOWN TOO
C00116 00058	 ROUTINE TO WAIT FOR A MATCHING CLS
C00117 00059	 ROUTINE TO SEND AN ALLOCATION
C00119 00060	 ROUTINE TO CHECK AND SEND INITIAL ALLOCATION
C00121 00061	 ROUTINE TO SEND OUT A SEND-SIDE CLS FROM UUO LEVEL
C00123 ENDMK
C⊗;
SUBTTL IMP UUO-LEVEL CODE - JAM, SEPT '71

; THE NON-STANDARD UUOS WILL BE MTAPE UUOS
; THE ADDRESS OF THE MTAPE POINTS TO A BLOCK
; THE FIRST WORD OF THE BLOCK IS THE FUNCTION CODE
; THAT DETERMINES WHAT TO DO AND HOW TO INTERPRET ANY OTHER WORDS IN THE BLOCK
; FUNCTION=0		; CONNECT
;	1		; STATUS BITS ARE PLACED HERE UPON RETURN
;	2		; LOCAL SOCKET NUMBER. 32 BITS RIGHT-ADJUSTED
;	3		; WAIT FLAG. -1 FOR WAIT FOR CONNECTION.
;	4		; BYTE SIZE, OR IF SENDING, BYTE SIZE IS STORED HERE
;	5		; FOREIGN SOCKET NUMBER
;	6		; HOST NUMBER IS PLACED HERE
; FUNCTION=1		; LISTEN
;	1		; STATUS BITS ARE PLACED HERE
;	2		; LOCAL SOCKET NUMBER
;	3		; WAIT FLAG
;	4		; BYTE SIZE OF CONNECTION. STORED HERE IF SEND
; FUNCTION=2		; STATUS
;	1		; STATUS BITS ARE PLACED HERE FOR SEND SIDE
;	2		; RECEIVE SIDE STATUS BITS ARE PLACED HERE
; FUNCTION=3		; TERMINATE
;	1		; STATUS BITS ARE PLACED HERE
;	2		; LOCAL SOCKET NUMBER
;	3		; WAIT FLAG
; FUNCTION=4		; WAIT FOR CONNECTION COMPLETE
;	1		; STATUS IS RETURNED HERE
;	2		; NEEDS SOCKET NUMBER HERE
; FUNCTION=5		; DUMP. DUMPS MONITOR TABLES
;	1		; NUMBER OF WORDS OF TABLES DESIRED
;	2		; ADDRESS OF PLACE TO PUT TABLES
; FUNCTION=6		; WAKEUP. VALID ONLY IF AT I-LEVEL. USEFUL FOR
;			; WAKING UP PROCESS IN WAIT STATE DUE TO IMP.
; FUNCTION=7		; GET SOCKET NUMBERS AND HOST NUMBER
;	1		; HOST-LINK NUMBER, SEND SIDE
;	2		; LOCAL SEND SOCKET
;	3		; FOREIGN RECEIVE SOCKET
;	4		; HOST-LINK NUMBER FOR RECEIVE SIDE
;	5		; LOCAL RECEIVE SOCKET
;	6		; FOREIGN SEND SOCKET
; FUNCTION=8.		; SKIP IF ANY INPUT IS PRESENT
; FUNCTION=9.		; SEND INTERRUPT
;	1		; STATUS BITS RETURNED HERE
;	2		; NEED SOCKET NUMBER HERE
; FUNCTION=10.		; RESSURECT IMP IF DOWN
; FUNCTION=11.		; BLESS THIS HOST
;	1		; HOST NUMBER REQUIRED HERE
; MORE MTAPE UUO CODES

; FUNCTION=12.		; TEST AND CLEAR INTERRUPT BITS
;	1		; SEND SIDE. 0 FOR NO INT., -1 FOR INT. PRESENT
;	2		; RECEIVE SIDE. 0 FOR NO INT., -1 FOR INT. PRESENT
; FUNCTION=13.		; SET ALLOCATION
;	1		; FUNCTION CODE. 0 NORM, 1 FOR SYS MAX, 2 FOR MIN
;	2		; NUMBER OF BITS OF ALLOCATION
;	3		; NUMBER OF MESSGES OF ALLOCATION
; FUNCTION=14.		; WHAT ARE THE ALLOCATIONS
;	1		; NUMBER OF BITS WE HAVE ALLOCATED HIM
;	2		; NUMBER OF MESSAGES WE HAVE ALLOCATED HIM
;	3		; NUMBER OF BITS HE HAS LEFT
;	4		; NUMBER OF MESSAGES HE HAS LEFT
;	5		; NUMBER OF BITS IN FREE STORAGE
;	6		; NUMBER OF MESSAGES IN FREE STORAGE
;	7		; NUMBER OF BITS HE HAS ALLOCATED US
;	10		; NUMBER OF MESSAGES HE HAS ALLOCATED US
; FUNCTION=15.		; SET TIMEOUTS
;	1		; WORD OF 6-BIT BYTES. GIVES NUMBER OF 2-SECOND UNITS
;			; FOR TIMEOUTS ON CLS, RFNM, ALL, RFC, OR INP
;			; 0 MEANS WAIT INDEFINITELY
; FUNCTION=16.		; GET TIMEOUTS
;	1		; CURRENT TIMEOUT WORD WILL BE PLACED HERE
; POSITIONS IN USER TABLE OF VARIOUS QUANTITIES

STLOC←←1	; STATUS WORD LOCATION
LSLOC←←2	; LOCAL SOCKET LOCATION
WFLOC←←3	; WAIT FLAG
BSLOC←←4	; BYTE SIZE LOCATION
FSLOC←←5	; FOREIGN SOCKET LOCATION
HLOC←←6		; HOST NUMBER LOCATION

; ERROR CODES
; EVERYONE WHO RETURNS STATUS BITS MAY RETURN AN ERROR CODE INSTEAD

SIU←←1		; SOCKET IN USE
CCS←←2		; CAN'T CHANGE SOCKET AFTER RFC DONE
SYS←←3		; HORRIBLE SYSTEM ERROR
NLA←←4		; NO LINK AVAILABLE
ILB←←5		; ILLEGAL BYTE SIZE
IDD←←6		; IMP DEAD
; UUO DISPATCH TABLE

	JRST IMPCLR
	JRST IMPSET
	JRST IMPINI
	JRST CPOPJ
↑IMPDSP:
	JRST IMPRLS	; RELEASE
	JRST CLSO	; CLOSE OUTPUT
	JRST BUFO	; BUFFERED OUTPUT
	JRST BUFI	; BUFFERED INPUT
	JRST CPOPJ1	; ENTER
	JRST CPOPJ1	; LOOKUP
	JRST DMPO	; DUMP MODE OUTPUT
	JRST DMPI	; DUMP MODE INPUT
	JRST CPOPJ	; USETO
	JRST CPOPJ	; USETI
	JRST CPOPJ	; UGETF
	JRST CPOPJ1	; RENAME
	JRST CLSI	; CLOSE INPUT
	JRST CPOPJ	; UTPCLR
	JRST MTAPE	; MTAPE
; INITIALIZE ROUTINE

IMPINI:	SETZM IMPST		; CLEAR DATA AREA
	MOVE AC1,[XWD IMPST,IMPST+1]
	BLT AC1,IMPEND-1
	MOVEI AC1,MAXNLK
	MOVEM AC1,LNKMAX
	MOVE AC1,[P1PID]
	MOVEM AC1,IMPPID
	MOVEI AC1,IBEGIN	; INITIALIZE THE I-LEVEL DISPATCH ADDRESSES
	MOVEM AC1,IMPIDSP
	HRLOI AC1,377777	; SET OUTPUT COUNT-DOWN TO RANDOM LARGE NUMBER
	MOVEM AC1,IMPOCT
	MOVEI AC1,DONOP
	MOVEM AC1,IMPODSP
	MOVEI AC1,10		; GIVE A LITTLE WHILE FOR THE IMP RELAY TO COOL OFF
	MOVEM AC1,POLCNT
	MOVEI AC1,10		; PICK UP A BUNCH OF SPARE FREE STORAGE BLOCKS
	MOVEM AC1,IMPSPN
	MOVE AC1,[XWD -INTPLN,IMPIPL-1]
	MOVEM AC1,IMPIPD
	MOVE AC1,[XWD -INTPLN,IMPOPL-1]
	MOVEM AC1,IMPOPD
	MOVEI AC1,LPTDDB
	HRLM AC1,DEVSER+DDBMDL	; RELINK DEVICE DATA BLOCK CHAIN
	SKIPN IMPDIE		; DO WE KEEP THE IMP DOWN TODAY?
	JRST IMPGAH
	SETOM IMPDEAD		; YES
	MOVEI AC1,LPTDDB	; LINK AROUND IMP DDB
	HRLM AC1,PTPDDB+DEVSER
	POPJ P,

IMPGAH:	PUSHJ P,IMPGET		; GET A FREE BLOCK FOR THE INPUT LIST
	HALT NOCORE
	MOVEM AC1,IMPSPARE
	CONO IMP,ODPIEN
	CONO IMP,STRIN!CLRWT!IDPIEN!IEPIEN!IMPCHN
	PUSHJ P,SNDNOP		;SEND THE IMP 4 NOPS
	PUSHJ P,IMPGET		; GET A FREE BLOCK FOR SENDING RESETS TO EVERYONE
	HALT NOCORE
	PUSHJ P,CLRBLK
	MOVEI AC2,377
	DPB AC2,SRCP		; PUT IN BIGGEST HOST NUMBER
	MOVEI AC2,10
	DPB AC2,SIZEP		; PUT IN BYTE SIZE
	MOVEI AC2,1
	DPB AC2,COUNTP		; PUT IN BYTE COUNT
	MOVSI AC2,(<BYTE (8)RST>)
	MOVEM AC2,TDATA+2(AC1)	; PUT IN RST OPCODE
	MOVEI AC2,3
	MOVEM AC2,TWC(AC1)	; AND DATA WORD COUNT
	MOVEI AC2,377		; LARGEST HOST NUMBER
	MOVEM AC2,RSTHST	; SET UP NUMBER OF NEXT HOST TO BE RESET
	JRST CLKOUT	; QUEUE RST BLOCK.  INT ROUTINE WILL DECREMENT HOST NUMBER
; MTAPE DISPATCH

MTAPE:	XCTR	XR,[HRRZ TAC,(UUO)]	;GET FUNCTION CODE.
	CAIL	TAC,MXUUO		;FUNCTION IN BOUNDS?
	JRST	UUOERR			;NO. ILLEGAL FUNCTION.
	MOVE	TAC1,UUODSP(TAC)	;GET THE DISPATCH ADDRESS
	SKIPE	IMPDEAD			;SKIP IF IMP IS UP
	JRST	MTAPE2			;IMP DOWN.
	JUMPG	TAC1,(TAC1)		;JUMP IF LEGAL WITH IMP UP.
	JRST	UUOERR			;ILLEGAL WITH IMP UP.

MTAPE2:	JUMPL	TAC1,(TAC1)		;JUMP IF LEGAL WITH IMP DEAD.
	TLNE	TAC1,200000		;DOES THIS MTAPE EXPECT STATUS BITS?
	JRST IDERR			;YES. GIVE THEM.
	POPJ P,				;NO JUST GIVE FAILURE RETURN


UUODSP:	200000,,CONECT			;0
	200000,,LISTEN			;1
	200000,,STATUS			;2
	200000,,TERMIN			;3
	SWAIT				;4
	DUMP				;5
	WAKE				;6
	GSOCKS				;7
	INPSKP				;10
	200000,,SNDINT			;11
	400000,,NEWINI			;12 ONLY IF IMP DEAD
	CPOPJ	;CHKSIT			;13 BLESS
	TSINT				;14
	USETAL				;15
	UGETAL				;16
	USETTM				;17
	UGETTM				;20
MXUUO←←.-UUODSP
; TERMINATE CONNECTION

TERMIN:	XCTR	XR,[MOVE AC2,LSLOC(UUO)]
	XCTR	XW,[SETZM STLOC(UUO)]
	PUSHJ P,GETIDX
	POPJ P,
	MOVEI AC1,(DDB)
	SKIPE IMPDDB-1(AC3)		; IF NOBODY HOME, LET HIM KILL IT
	CAMN AC1,IMPDDB-1(AC3)		; IS IT OURS?
	JRST TEROK
	PUSHJ P,TTYERR
	PUSHJ P,INLMES
	ASCIZ /CAN'T TERMINATE SOMEONE ELSE'S SOCKET!
/
TTYSTG:	MOVSI IOS,USRB
	ORB IOS,DEVIOS(DDB)
	JRST TTYSTR

TEROK:	TRNE AC2,1			; USE DIFFERENT CLOSE ROUTINE IF SEND SIDE
	JRST TERS
	PUSHJ P,URCLS			; SEND OUT THE CLS
TERW:	XCTR	XR,[SKIPE WFLOC(UUO)]	; DOES HE WANT TO WAIT FOR IT?
	PUSHJ	P,TCLSW			; YES, DO A TIMED CLS WAIT
	XCTR	XR,[MOVE AC2,LSLOC(UUO)]	; NOW GET THE CONNECTION INDEX AGAIN
	PUSHJ	P,GETIDX
	POPJ	P,
	MOVE	AC1,IMPSTB-1(AC3)
	XCTR	XW,[MOVEM AC1,STLOC(UUO)]
	POPJ	P,

TERS:	PUSHJ P,USCLS
	JRST TERW
; REINITIALIZE THE IMP SYSTEM, BRING UP THE IMP

NEWINI:	SKIPN	AC3,FFLNK	;SEE IF THERE ARE ANY LINKS STILL ACTIVE
	JRST	NEWIN1
NEWIN2:	SKIPN	AC2,IMPDDB-1(AC3)
	JRST	NEWIN3
	CAIE	AC2,(DDB)
	JRST	NEWLOS
NEWIN3:	SOJGE	AC3,NEWIN2
NEWIN1:	PUSHJ	P,DISDATE
	PUSHJ	P,DISJOB	;BLAME IT ON THE STONES.
	PUSHJ	P,DISTAB
	MOVE	TAC1,PRJPRG(J)	;GET THE NAME OF LOSER.
	PUSHJ	P,DISSIX
	PUSHJ	P,DISMES
	ASCIZ	/ IS ATTEMPTING TO RESSURECT THE IMP.
/
	SETZM	IMPDIE
	JRST	IMPINI

NEWLOS:	PUSHJ	P,TTYERR
	PUSHJ	P,INLMES
	ASCIZ	/LINKS STILL ACTIVE
/
	JRST	TTYSTG
; TEST AND CLEAR INTERRUPT BITS - SET SYSTEM DEFAULT TIMEOUTS
; RETURNS FLAG FOR SEND SIDE IN 1(UUO), RECEIVE SIDE IN 2(UUO)

TSINT:	ANDI	DDB,-1
	XCTR	XW,[SETZM 1(UUO)]
	XCTR	XW,[SETZM 2(UUO)]
	SKIPN	AC3,FFLNK
	POPJ	P,
TSINLP:	CAMN DDB,IMPDDB-1(AC3)
	JRST TSINDF
TSINCR:	SOJG AC3,TSINLP
	POPJ P,

TSINDF:	MOVE AC2,IMPLS-1(AC3)
	MOVE AC1,IMPSTB-1(AC3)
	TLZE AC1,INTINS
	XCTR	XW,[SETOM 1(UUO)]
	TLZE	AC1,INTINR
	XCTR	XW,[SETOM 2(UUO)]
	MOVEM AC1,IMPSTB-1(AC3)
	JRST TSINCR

; SET SYSTEM DEFAULT TIMEOUTS. PUT WORD OF 6-BIT FIELDS IN 1(UUO).
; THE FIELDS ARE IN UNITS OF 2-SECONDS. I.E., THE MAXIMUM WAIT IS 126 SECONDS
; AND THE MINIMUM WAIT IS 2 SECONDS.

USETTM:	XCTR	XR,[MOVE AC1,1(UUO)]
	MOVEM	AC1,TIMES(DDB)
	POPJ	P,

; ROUTINE TO GET CURRENT TIMEOUTS

UGETTM:	MOVE AC1,TIMES(DDB)
	XCTR	XW,[MOVEM AC1,1(UUO)]
	POPJ P,
; LISTEN CODE

LISTEN:	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	PUSHJ P,NSCHECK
	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	PUSHJ P,GETIDX
	JRST LISTN2		; NO KNOWN SOCKET. MAKE US WAIT.
	JRST LISTNG		; KNOWN SOCKET. WHAT'S THIS?

LISTN2:	AOS AC3,FFLNK		; PICK UP NEW LINK NUMBER
	CAILE AC3,MAXNLK
	JRST LISNLK		; NO LINK AVAILABLE
LISTN4:	SETZ DAT,		; ZERO HOST-LINK NUMBER
	SETO TEM,		; MARK FOREIGN SOCKET UNUSED
	PUSHJ P,CLRSKT
CHKWAT:	MOVSI AC2,RFCR		; HAVE WE RECEIVED A REQUEST FOR CONNECTION?
	TDNN AC2,IMPSTB-1(AC3)
	JRST WAIT		; NO, WAIT FOR ONE
	MOVSI AC2,RFCS		; YES, HAS IT BEEN ACKNOWLEDGED?
	TDNN AC2,IMPSTB-1(AC3)
	PUSHJ P,SNDRFC		; NO, DO SO NOW AND LEAVE WITHOUT WAITING
	JRST SETST		; HAS CHANGED, DON'T WAIT

WAIT:	XCTR XR,[SKIPN WFLOC(UUO)]
	JRST SETST		; NO WAIT, JUST SET STATUS WORD AND RETURN
	MOVNI TAC,IOWQ
	MOVEM TAC,JOBQUE(J)
	MOVSI IOS,RFCW		; NOTE THAT WE ARE WAITING FOR CONNECTION
	ORM IOS,DEVIOS(DDB)
	LDB TEM,RFCTP		; PICK UP RFC WAIT TIME
	PUSHJ P,TW		; DO A TIMED WAIT IF WAIT TIME≠0. OTHERWISE WAIT FOREVER.
	JFCL			; IGNORE ERROR RETURN, GIVE LOSER STATUS BITS
SETST:	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	PUSHJ P,GETIDX
	JRST NOCONN		; HELP, LINK DISSAPEARED!
	MOVE TAC,IMPFS-1(AC3)
	XCTR XW,[MOVEM TAC,FSLOC(UUO)]
	MOVE AC2,IMPBS-1(AC3)	; GIVE HIM BYTE SIZE FOR KICKS
	XCTR XW,[MOVEM AC3,BSLOC(UUO)]
	MOVE AC2,LNKTAB-1(AC3)	; PICK UP HOST NUMBER
	LSH AC2,-10		; RIGHT-ADJUST IT
	XCTR XW,[MOVEM AC2,HLOC(UUO)]
STST:	MOVE AC2,IMPSTB-1(AC3)
	TLZ AC2,ANYC		; NOTE WE ARE GIVING HIM UP-TO-DATE STATUS BITS
	MOVEM AC2,IMPSTB-1(AC3)
	XCTR XW,[MOVEM AC2,STLOC(UUO)]
	POPJ P,
; LISTEN CODE - HERE HE WANTS TO LISTEN TO AN EXTANT SOCKET

LISTNG:	MOVE AC1,IMPSTB-1(AC3)
	SKIPN TAC,IMPDDB-1(AC3)	; DOES IT HAVE A DDB?
	JRST LNODDB		; NO, WE MIGHT BE ABLE TO CONNECT UP
SIUERR:	MOVEI TAC,SIU		; NO, SOCKET IN USE
	JRST DEPERC

LNODDB:	TLNE AC1,CLSS
	JRST WCLS
	TLNN AC1,RFCR		; HAS A STR BEEN RECEIVED?
	JRST LISTN4		; NO, WAIT FOR ONE
	TLNN AC1,RFCS		; YES, HAS A RTS BEEN RETURNED?
	JRST USRTSR		; NO, RETURN A RTS AND WE ARE CONNECTED!
ILLST:	TELCTR(NILLST,<ILLEGAL STATE: STR AND RTS BUT NO DDB!>)
SYSERR:	MOVEI TAC,SYS		; GIVE HIM SYSTEM ERROR CODE
DEPERC:	XCTR XW,[MOVEM TAC,STLOC(UUO)]
	POPJ P,

WCLS:	HRRZM DDB,IMPDDB-1(AC3)
	TLNN AC1,CLSR
	PUSHJ P,TCLSW		; WAIT FOR THE MATCHING CLOSE FOR A WHILE
	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	TLZ AC1,CLSS!CLSR!RFCR!RFCS
	MOVEM AC1,IMPSTB-1(AC3)
	MOVEM AC2,IMPLS-1(AC3)
	TRNN AC2,1		; IS IT A SEND SOCKET?
	JRST LNOBS		; NO, HE DOESN'T GET TO SET THE BYTE SIDE.
	ANDI AC1,77
	CAIG AC1,44		; CHECK FOR LEGAL BYTE SIZE
	SKIPGE BPW(AC1)
	JRST UILLBS
	XCTR XR,[MOVE AC1,BSLOC(UUO)]
	MOVEM AC1,IMPBS-1(AC3)
LNOBS:	SETZM LNKTAB-1(AC3)	; NOTE THAT THERE IS NO HOST NUMBER
	SETOM IMPFS-1(AC3)	; OR FOREIGN SOCKET EITHER
	SKIPE AC1,IMPRFQ-1(AC3)	; ANY PENDING RFCS?
	PUSHJ P,DISPQ		; RUN DOWN RFQ LIST FOR A STR THAT MATCHES OUR SOCKET
	JRST CHKWAT		; NONE FOUND, WAIT FOR ONE
	JRST SETST		; ONE FOUND AND PROCESSED, RETURN TO LOSER

UILLBS:	MOVEI TAC,ILB
	JRST DEPERC

IDERR:	MOVEI TAC,IDD
	JRST DEPERC
; LISTEN - GET HERE WHEN THE SLOT IN THE TABLE IS OKED FOR CONNECTION

USRTSR:	HRRZM DDB,IMPDDB-1(AC3)
SNDRAL:	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	XCTR XR,[MOVE TEM,BSLOC(UUO)]
	TRNE AC2,1
	MOVEM TEM,IMPBS-1(AC3)		; IF WE ARE SENDING SET BYTE SIZE
	PUSHJ P,SNDRFC			; SEND BACK A RTS
	JRST SETST			; GIVE HIM SOME STATUS BITS TOO

; GET HERE IF THERE IS NO ROOM IN THE LINK TABLE FOR HIS LISTEN

LISNLK:	SOS FFLNK
	MOVEI TAC,NLA		; GIVE HIM "nO-LINK AVAILABLE" ERROR
	XCTR XW,[MOVEM TAC,STLOC(UUO)]
	POPJ P,
; CONNECT CODE - FIRST CHECK FOR A PENDING SOCKET, THEN SEND OUT A RFC

CONECT:	SKIPE IMPDEAD
	JRST IDERR
	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	PUSHJ P,NSCHECK
	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	PUSHJ P,GETIDX		; SEE IF THIS SOCKET NUMBER EXISTS YET
	JRST MAKRFC		; NO, SEND OUT RFC
	MOVE AC1,IMPSTB-1(AC3)	; YES, SEE IF IT IS PENDING
	SKIPE TAC,IMPDDB-1(AC3)	; DOES IT ALREADY HAVE A DDB?
	JRST SIUERR		; NO, SOCKET IN USE
	TLNE AC1,RFCR		; HAVE WE RECEIVED A RFC?
	TLNE AC1,RFCS		; HAS RFC BEEN SENT?
	JRST CHKCL		; YES, SEE IF IT HAS BEEN CLOSED.
	XCTR XR,[MOVE TEM,FSLOC(UUO)]
	CAME TEM,IMPFS-1(AC3)
	JRST SIUERR
	XCTR XR,[MOVE TEM,HLOC(UUO)]
	LSH TEM,10
	XOR TEM,LNKTAB-1(AC3)	; CHECK HOST NUMBERS
	TRNE TEM,177400
	JRST SIUERR		; NO MATCH, SOCKET IN USE
	HRRZM DDB,IMPDDB-1(AC3)
	JRST SNDRAL		; GO SEND ALLOCATION IF NECESSARY
; CONNECT CODE. CHECK SOCKET FOR CLOSURE. IF CLOSED, WE MAY GO AHEAD AND USE IT

CHKCL:	TLNN AC1,CLSS
	JRST ILLST
	HRRZM DDB,IMPDDB-1(AC3)
	TLNN AC1,CLSR		; HAVE WE RECEIVED A CLOSE?
	PUSHJ P,TCLSW		; NO, WAIT FOR A WHILE FOR ONE
	XCTR XR,[MOVE AC2,LSLOC(UUO)]
CONSRL:	TLZ AC1,CLSS!CLSR!RFCR!RFCS
	MOVEM AC1,IMPSTB-1(AC3)
	MOVEM AC2,IMPLS-1(AC3)	; SET RECEIVE SOCKET NUMBER
	XCTR XR,[MOVE TEM,FSLOC(UUO)]
	MOVEM TEM,IMPFS-1(AC3)
	XCTR XR,[MOVE AC1,HLOC(UUO)]
	ANDI AC1,377
	LSH AC1,10
	MOVEM AC1,LNKTAB-1(AC3)
	TRNN AC2,1		; SEND SOCKET?
	JRST CNOBS		; NO, HE CAN'T SET BYTE SIZE
	XCTR XR,[MOVE AC1,BSLOC(UUO)]
	ANDI AC1,77
	CAIG AC1,44
	SKIPGE BPW(AC1)
	JRST UILLBS		; ILLEGAL BYTE SIZE
	MOVEM AC1,IMPBS-1(AC3)
CNOBS:	SKIPE AC1,IMPRFQ-1(AC3)	; ANYONE WAITING?
	PUSHJ P,DISPQ		; RUN DOWN LIST OF RFCS FOR ONE THAT MATCHES US
	JRST MSSRFC		; NOONE WAITING, SEND OUT RFC
	JRST CONWAT		; FOUND SOMEONE, GO SET USER UP

MSSRFC:	PUSHJ P,SNDRFC		; SEND OUT REQUEST FOR CONNECTION
	MOVE IOS,DEVIOS(DDB)
	TRNE IOS,IODERR!IODTER!HDEAD!RSET
	POPJ P,			; IF ERRORS, LEAVE NOW
	JRST CONWAT		; WAIT FOR REPLY IF LOSER SO CHOSES
; CONNECT CODE. ROUTINE TO SET UP THE INDEX AND TRY TO WAIT FOR CONNECTION.

CONWAT:	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	PUSHJ P,GETIDX		; PICK UP CONNECTION INDEX AGAIN
	JRST NOCONN
	JRST CHKWAT

NOCONR:	TELCTR(NNOCLW,<NO RETURN CLS SENT!>)
	JRST CONSRL

; HERE WE INITIALIZE A SOCKET AND SEND OUT RFC

MAKRFC:	XCTR XR,[MOVE TEM,FSLOC(UUO)]
	AOS AC3,FFLNK		; GET NEW INDEX NUMBER
	CAILE AC3,MAXNLK
	JRST LISNLK
	XCTR XR,[MOVE DAT,HLOC(UUO)]
	ANDI DAT,377
	LSH DAT,10
	PUSHJ P,CLRSKT
	JRST MSSRFC
; DUMP. GIVE LOSER A DUMP OF THE MONITOR TABLES.

DUMP:	XCTR XR,[MOVE AC2,2(UUO)]
	MOVEI TAC1,(AC2)
	XCTR XRW,[MOVSS (AC2)]
	MOVEI AC3,(AC2)
	XCTR XR,[ADD AC3,1(UUO)]
	XCTR XRW,[MOVSS -1(AC3)]
	XOR AC3,TAC1
	JUMPL AC3,ADRERR
	PUSHJ P,DOLOC		; RELOCATE ADDRESS IN TAC1, PUT RESOLT IN DSER
	HRLI DSER,SYSTBS
	HRRZI AC3,-1(DSER)
	XCTR XR,[ADD AC3,1(UUO)]
	BLT DSER,(AC3)
	POPJ P,

; GIVE LOSER THE STATUS OF HIS CONNECTION

STATUS:	PUSHJ P,UUSIDX
	JRST STAT1
	MOVSI AC2,ANYC
	ANDCAB AC2,IMPSTB-1(AC3)
	XCTR XW,[MOVEM AC2,1(UUO)]
	JRST STAT2

STAT1:	XCTR XW,[SETZM 1(UUO)]
STAT2:	PUSHJ P,UURIDX
	JRST STAT3
	MOVSI AC2,ANYC
	ANDCAB AC2,IMPSTB-1(AC3)
	XCTR XW,[MOVEM AC2,2(UUO)]
	POPJ P,

STAT3:	XCTR XW,[SETZM 2(UUO)]
	POPJ P,

; WAKE UP MONITOR IF WAITING FOR IMP. SETS TMO IN IOS TO INDICATE ERROR CONDITION

WAKE:	SKIPN INTACT
	POPJ P,
	MOVE IOS,DEVIOS(DDB)
	TLNN IOS,ANYW
	POPJ P,
	TRO IOS,TMO
	MOVEM IOS,DEVIOS(DDB)
	JRST QRUN
; ROUTINE TO GIVE LOSER HIS SOCKET NUMBERS

GSOCKS:	PUSHJ P,UUSIDX
	JRST GSOCKA
	PUSHJ P,DMPTBS		; DUMP THEM INTO HIS CORE IMAGE
GSOCKB:	ADDI UUO,3
	PUSHJ P,UURIDX		; ANY RECEIVE SIDE?
	JRST ZTAB		; NO, CLEAR CELLS
	JRST DMPTBS		; YES, DUMP THEM

GSOCKA:	PUSHJ P,ZTAB
	JRST GSOCKB

ZTAB:	XCTR XW,[SETZM 1(UUO)]
	XCTR XW,[SETZM 2(UUO)]
	XCTR XW,[SETZM 3(UUO)]
	POPJ P,

DMPTBS:	MOVE AC1,LNKTAB-1(AC3)
	XCTR XW,[MOVEM AC1,1(UUO)]
	MOVE AC1,IMPLS-1(AC3)
	XCTR XW,[MOVEM AC1,2(UUO)]
	MOVE AC1,IMPFS-1(AC3)
	XCTR XW,[MOVEM AC1,3(UUO)]
	POPJ P,
; ROUTINE TO WAIT FOR CONNECTION

SWAIT:	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	PUSHJ P,GETIDX
	JRST NOCONN
	MOVE AC1,IMPSTB-1(AC3)
	TLC AC1,RFCS!RFCR
	TLCE AC1,RFCS!RFCR
	TLNE AC1,CLSR!CLSS
	JRST SWSTST
	MOVNI AC1,IOWQ
	MOVEM AC1,JOBQUE(J)
	MOVSI IOS,RFCW
	ORM IOS,DEVIOS(DDB)
	LDB TEM,RFCTP		; PICK UP RFC WAIT TIMEOUT PERIOD
	PUSHJ P,TW		; DO A TIMED WAIT
	JRST NSW		; TIMEOUT. NO CONNECTION
	MOVSI IOS,RFCW
	ANDCAB IOS,DEVIOS(DDB)
	JRST SWAIT		; IF NO TIME-OUT, GO BACK AND MAKE SURE WE ARE CONNECTED

NSW:	MOVSI IOS,RFCW
	ANDCAB IOS,DEVIOS(DDB)	; CLEAR BIT IN MEMORY
	POPJ P,			; IF TIMED OUT, GO BACK TO USER NOW

SWSTST:	XCTR XW,[MOVEM AC1,STLOC(UUO)]
	POPJ P,

; ROUTINE TO SKIP IF THERE IS ANY INPUT PRESENT

INPSKP:	SKIPE INL(DDB)
	JRST CPOPJ1
	JRST INIALL		; CHECK ON INITIAL ALLOCATION
; MTAPE 13 - SET ALLOCATION
; LOCATION 1 OF THE USER TABLE IS A CODE
;	0 MEANS TAKE LOC 2 AS BIT ALLOCATION AND LOC 3 AS MESSAGE ALLOCATION
;	1 MEANS SET ALLOCATION TO SYSTEM MAXIMUM
;	2 MEANS SET ALLOCATION TO SYSTEM MINIMUM
;	3 MEANS SET ALLOCATION TO SYSTEM DEFAULT
; LOCATION 2 IS THE BIT ALLOCATION
; LOCATION 3 IS THE MESSAGE ALLOCATION

USETAL:	XCTR XR,[SKIPL TAC,1(UUO)]
	CAILE TAC,3		; CHECK CODE FOR LEGAL RANGE
	JRST UUOERR
	JRST @USETTB(TAC)	; DISPATCH TO RELEVANT ROUTINE

USETTB:	USETSP
	USETMX
	USETMN
	USETDF

USETMX:	MOVEI AC3,MAXBAL	; PICK UP MAXIMUM ALLOCATIONS
	MOVEI AC2,MAXMAL
	JRST UCHKB

USETMN:	MOVEI AC3,MINBAL
	MOVEI AC2,MINMAL
	JRST UCHKB

USETDF:	MOVEI AC3,DEFBAL	; USE DEFAULT ALLOCATIONS
	MOVEI AC2,DEFMAL
	JRST UCHKB

USETSP:	XCTR XR,[MOVE AC3,2(UUO)]
	XCTR XR,[MOVE AC2,3(UUO)]
	CAIGE AC3,MINBAL	; IS IT ABOVE MINIMUM ALLOCATION?
	MOVEI AC3,MINBAL	; NO, GIVE HIM AT LEAST THIS MUCH
	CAILE AC3,MAXBAL	; IS IT OVER MAXIMUM?
	MOVEI AC3,MAXBAL	; NO, PUT A LID ON AT AT THE MAXIMUM
	CAIGE AC2,MINMAL	; SAME FOR MESSAGE ALLOCATION
	MOVEI AC2,MINMAL
	CAILE AC2,MAXMAL
	MOVEI AC2,MAXMAL
	JRST UCHKB		; PROCEED ON TO NEXT PAGE
; UUO TO SET ALLOCATION. HERE ALLOCATION HE WANTS IS IN AC2 & AC3
; PUT IT IN THE DDB AND SEND HIM A CONTROL MESSAGE IF NECESSARY

UCHKB:	MOVEM AC3,NHBA(DDB)	; SET NOMINAL ALLOCATION
	MOVEM AC2,NHMA(DDB)
	LSH AC3,-1		; SET HALFWAY MARKERS TOO FOR SPEED
	LSH AC2,-1
	MOVEM AC3,NHBA2(DDB)
	MOVEM AC2,NHMA2(DDB)
	PUSHJ P,UURIDX		; PICK UP CONNECTION INDEX
	POPJ P,			; NONE YET, DON'T HAVE TO TELL HIM ANYTHING
	MOVE AC1,IMPSTB-1(AC3)	; PICK UP STATUS BITS
	TLC AC1,RFCR!RFCS	; SEE IF CONNECTION IS REALLY OPEN YET
	TLNN AC1,CLSS!CLSR	; OR REALLY CLOSING
	TLNE AC1,RFCR!RFCS
	POPJ P,			; NOT REALLY OPEN FOR BUSINESS. LEAVE NOW
	MOVE UUO,LNKTAB-1(AC3)	; SAVE HOST-LINK NUMBER HERE
	MOVE AC3,HBA(DDB)	; NOW SEE IF HE NEEDS TO BE ALLOCATED RIGHT NOW
	MOVE AC2,HMA(DDB)
	CAMG AC3,NHBA(DDB)	; ARE WE DECREASING HIS ALLOCATION?
	CAMLE AC2,NHMA(DDB)	; OF EITHER FLAVOR?
	JRST AFSB		; YES, ASK FOR SOME BACK
	ADD AC3,BIIL(DDB)
	ADD AC2,MIIL(DDB)
	CAML AC2,NHMA2(DDB)	; IS HE PAST THE HALFWAY MARK?
	CAMGE AC3,NHBA2(DDB)	; IN EITHER KIND OF ALLOCATION?
	PUSHJ P,SNDBAL		; YES, SEND HIM SOME MORE
	POPJ P,			; END OF UUO
; HERE WE DECREMENT HIS ALLOCATION AND ASK FOR SOME BACK IF NEED BE

AFSB:	SUB AC3,NHBA(DDB)	; GET AMOUNT OF BIT ALLOCATION TO ASK FOR
	SKIPGE AC3
	SETZ AC3,		; POSITIVE ONLY
	SUB AC2,NHMA(DDB)	; SAME FOR MESSAGE ALLOCATION
	SKIPGE AC2
	SETZ AC2,
	LSH AC2,7		; SET UP FOR GETTING 7-BIT FRACTION
	LSH AC3,7
	IDIV AC2,HMA(DDB)	; DIVIDE WHAT WE WANT BACK BY WHAT HE HAS
	IDIV AC3,HBA(DDB)
	LSH AC2,8
	ORI AC2,(AC3)		; PACK THEM INTO ONE WORD
	HRLI AC2,GVB⊗6		; PUT IN OPCODE
	PUSHJ P,IMPGET		; GET SOME FREE STORAGE FOR A MESSAGE
	JRST NOCORE
	LSH AC2,4		; LEFT JUSTIFY THE COMMAND WORD
	MOVEM AC2,TDATA+2(AC1)	; AND PLACE INTO OUTPUT BLOCK
	SETZM TDATA(AC1)	; CLEAR OUT JUNK IN LEADER
	SETZM TDATA+1(AC1)
	MOVEI AC2,3		; SET WORD COUNT
	MOVEM AC2,TWC(AC1)
	DPB UUO,OLINKP		; PUT IN THE LINK NUMBER
	ANDCMI UUO,177400	; NOW THE HOST NUMBER WITH LINK SET TO ZERO
	DPB UUO,ELINKP
	MOVEI AC2,10
	DPB AC2,SIZEP
	MOVEI AC2,4
	DPB AC2,COUNTP
	JRST UUOQ		; AND AWAY IT GOES!
; MTAPE 14 - GIVE USER THE CURRENT ALLOCATIONS

UGETAL:	MOVE TAC,NHBA(DDB)
	XCTR XW,[MOVEM TAC,1(UUO)]
	MOVE TAC,NHMA(DDB)
	XCTR XW,[MOVEM TAC,2(UUO)]
	MOVE TAC,HBA(DDB)
	XCTR XW,[MOVEM TAC,3(UUO)]
	MOVE TAC,HMA(DDB)
	XCTR XW,[MOVEM TAC,4(UUO)]
	MOVE TAC,BIIL(DDB)
	XCTR XW,[MOVEM TAC,5(UUO)]
	MOVE TAC,MIIL(DDB)
	XCTR XW,[MOVEM TAC,6(UUO)]
	MOVE TAC,BAL(DDB)
	XCTR XW,[MOVEM TAC,7(UUO)]
	MOVE TAC,MAL(DDB)
	XCTR XW,[MOVEM TAC,10(UUO)]
	POPJ P,
; ROUTINE TO SEND AN INTERRUPT

SNDINT:	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	PUSHJ P,IMPGET
	JRST NOCORE
	XCTR XW,[SETZM STLOC(UUO)]
	PUSHJ P,GETIDX
	JRST IMPREL
	MOVE DAT,IMPSTB-1(AC3)
	XCTR XW,[MOVEM DAT,STLOC(UUO)]
	SETZM TDATA(AC1)
	SETZM TDATA+1(AC1)
	SETZM TDATA+2(AC1)
	MOVEI DAT,10
	DPB DAT,SIZEP
	MOVEI DAT,2
	DPB DAT,COUNTP
	MOVEI DAT,3
	MOVEM DAT,TWC(AC1)
	MOVE DAT,LNKTAB-1(AC3)
	ANDI DAT,177400
	DPB DAT,ELINKP
	MOVE DAT,LNKTAB-1(AC3)
	DPB DAT,OLINKP
	MOVEI DAT,INS
	TRNN AC2,1
	MOVEI DAT,INR
	DPB DAT,OPCDP
	JRST UUOQ
; RELEAS CODE. SEND OUT CLSS IF NOT ALREADY.

IMPRLS:	SKIPL TIM(DDB)		; TIME INITIALIZED?
	SOS TIMWAIT		; YES, NOT ANY MORE
	SETOM TIM(DDB)
	SKIPE AC1,INL(DDB)	; ANYTHING STILL ON INPUT LIST?
	PUSHJ P,RELBLS		; YES, GIVE IT BACK
	SKIPE IMPDEAD
	JRST RLDI
	MOVE IOS,DEVIOS(DDB)
	TRNE IOS,BLOK
	PUSHJ P,RFNMWT		; IF STILL DATA ON THE LINK, WAIT FOR IT
	PUSHJ P,UUSIDX
	JRST IMPRL3
	MOVE AC1,IMPSTB-1(AC3)
	TLNE AC1,RFCS
	TLNE AC1,CLSS
	JRST IMPRL1
	PUSHJ P,USCLS
	PUSHJ P,UUSIDX
	JRST IMPRL3
IMPRL1:	SETZM IMPDDB-1(AC3)
	PUSHJ P,ZEROLK
IMPRL3:	PUSHJ P,UURIDX
	POPJ P,
	MOVE AC1,IMPSTB-1(AC3)
	TLNE AC1,RFCS
	TLNE AC1,CLSS
	JRST IMPRL4
	PUSHJ P,URCLS
	PUSHJ P,UURIDX
	POPJ P,
IMPRL4:	SETZM IMPDDB-1(AC3)
	JRST ZEROLK		; RELEASE CONNECTION IF ALL CLSS ARE PROPERLY EXCHANGED

; WE GET HERE IF THE IMP IS DEAD

RLDI:	PUSHJ P,UUSIDX		; SEE IF HE HAS A SEND SOCKET
	JRST RLDI1
	SETZM IMPDDB-1(AC3)	; YES, KILL IT
	PUSHJ P,ZEROLK
RLDI1:	PUSHJ P,UURIDX
	POPJ P,
	SETZM IMPDDB-1(AC3)
	JRST ZEROLK
; BUFFERED OUTPUT . . .

BUFO:	PUSHJ P,UUOOOK		; IS HOST ALIVE AND ALL?
	JRST UUXIT		; NO, LEAVE WITH ERROR BITS
	HRRZ TAC1,DEVOAD(DDB)	; PICK UP OUT BUFFER ADDRESS
	XCTR XR,[HRRZ TAC,1(TAC1)]	; PICK UP WORD COUNT
	ADDI TAC1,2		; MOVE POINTER TO DATA AREA
	PUSHJ P,NEWOX		; DO TRANSFER USING USER ADDR IN TAC1 AND WD CT IN TAC
	PUSHJ P,ADVBFE		; ADVANCE BUFFER
	JRST UUXIT
	JRST BUFO		; TRY FOR ANOTHER ONE

; DUMP MODE OUTPUT . . .

DMPO:	PUSHJ P,UUOOOK
	JRST UUXIT
DMPO1:	PUSHJ P,DMPCMD		; RETURNS UPLEVEL WHEN DONE
	MOVNS TAC		; GET POSITIVE WD CT IN TAC
	PUSH P,UUO
	PUSHJ P,NEWOX		; DO TRANSFER
	POP P,UUO		; GET PTR TO DMP MODE CMD LIST BACK
	AOJA UUO,DMPO		; DO NEXT COMMAND
; ROUTINE TO ACTUALLY DO THE OUTPUT
; ENTER WITH WORD COUNT IN TAC AND USER ADDRESS IN TAC1

NEWOX:	JUMPE TAC,CPOPJ		; LEAVE IF USER WORD COUNT=0
	ADD P,[XWD 1,1]		; BUMP STACK FOR FULL WORD FLAG
OUTAGN:	PUSHJ P,ALLOK		; WAIT FOR ALLOCATION IF NECESSARY
	JRST SPOPJ		; LEAVE ON ERRORS
	HRLI TAC1,440000	; MAKE INPUT POINTER INTO BYTE POINTER
	MOVE IOS,IMPBS-1(AC3)	; CONNECTION INDEX SET UP BY ALLOK
	DPB IOS,[POINT 6,TAC1,11]
	MOVE AC3,IOS
	MOVE AC3,BPW(AC3)	; GET BITS PER WORD IN AC3
	IDIV AC3,IOS		; AC3 NOW HAS BYTES PER WORD
	LDB IOS,[POINT 6,TAC1,11]
	SETOM (P)		; ASSUME FULL WORD MODE
	CAIN IOS,8
	JRST GOBAAT		; ALWAYS DO BYTE AT A TIME FOR 8 BIT BYTES
	MOVE TEM,BAL(DDB)	; HOW MUCH ALLOCATION HAS HE GIVEN US?
	CAILE TEM,400		; IF LESS THAN 8 WORDS, DO BYTE AT A TIME
	CAIGE TAC,10		; IF LESS THAN 8 WORDS, IS MORE EFFICIENT TO GO BYTE AT A TIME
	JRST GOBAAT		; BYTE AT A TIME
	JRST GOFW

GOBAAT:	IMULI TAC,(AC3)		; IF BYTE AT A TIME, CONVERT TO BYTE COUNT
	SETZM (P)		; CLEAR FULL WORD FLAG
GOFW:	MOVEI TEM,(AC3)		; SAVE BYTES/WD IN TEM
NEWMSO:	PUSHJ P,IMPGET		; PICK UP FIRST BUFFER OF MESSAGE
	JRST NOCORE
	SETZM TDATA(AC1)	; CLEAR SPARE BITS IN LEADER
	SETZM TDATA+1(AC1)
	PUSHJ P,UUSIDX		; PICK UP THE LINK TABLE INDEX AGAIN
	JRST NOCONN
	MOVE IOS,LNKTAB-1(AC3)	; PICK UP HOST-LINK NUMBER
	DPB IOS,ELINKP		; PUT IN DESTINATION FIELD
	MOVE IOS,IMPBS-1(AC3)	; PICK UP BYTE SIZE
	DPB IOS,SIZEP		; SET INTO LEADER
	MOVE DAT,TLEN(AC1)	; PICK UP LENGTH OF DATA PORTION OF BUFFER
	MOVEM DAT,TWC(AC1)	; PUT INTO INITIAL WORD COUNT
	SUBI DAT,2		; KNOCK OFF TWO FOR LEADER WORDS
	PUSH P,AC1		; SAVE FIRST BLOCK OF MESSAGE ON STACK
	SETZB AC2,UCHN		; CLEAR BYTE COUNT AND BIT COUNT
	SKIPGE -1(P)		; FULL WORD OR BYTE AT A TIME?
	JRST BFOHW		; FULL WORD MODE
; FULL WORD MODE OUTPUT - BYTE AT A TIME
; HERE IS THE ACTUAL OUTPUT LOOP

NBLOOP:	PUSH P,AC1		; PUT CURRENT BLOCK ON THE STACK
	IMULI DAT,(TEM)		; DAT NOW HAS NUMBER OF FREE BYTES IN BUFFER
	SETZM TLINK(AC1)
	CAMN AC1,-1(P)		; IS THIS THE FIRST BLOCK
	ADDI AC1,2		; YES, BUMP POINTER PAST LEADER
	ADDI AC1,TDATA		; BUMP BUFFER POINTER TO PAST OVERHEAD WORDS IN BLOCK
	HRLI AC1,440000		; MAKE UP BYTE POINTER TO BUFFER
	DPB IOS,[POINT 6,AC1,11]
NWLOOP:	ADD UCHN,IOS		; ADD NUMBER OF BITS IN THIS NEXT TRANSFER
	CAIG UCHN,=7900		; MORE THAN THE IMP CAN STAND?
	CAMLE UCHN,BAL(DDB)	; HAVE WE OVERSHOT THE ALLOCATION?
	JRST OUTNOW		; YES, SEND THE MESSAGE NOW AND WAIT FOR MORE ALLOCATION
	XCTR XLB,[ILDB DSER,TAC1]	; PICK UP DATA BYTE
	IDPB DSER,AC1		; PLACE INTO MESSAGE BUFFER
	ADDI AC2,1		; BUMP BYTE COUNT
	CAIN IOS,8
	SOJA TAC,NWTNLP		; CHECK FOR LAST WORD
	SOJLE TAC,ENDNOW	; BUMP USER DATA COUNT, IF END OF MESSAGE, LEAVE
NWLOP1:	SOJG DAT,NWLOOP		; BUMP FREE BYTE COUNT
	PUSHJ P,IMPGET		; GET ANOTHER BUFFER
	JRST NOCORE
	POP P,UUO		; GET BACK LAST ONE
	HRRZM AC1,TLINK(UUO)	; LINK NEW ONE TO OLD ONE
	MOVE DAT,TLEN(AC1)	; FILL THE WORD COUNT
	MOVEM DAT,TWC(AC1)
	JRST NBLOOP

NWTNLP:	JUMPE TAC,ENDNOW
	CAILE TAC,4		; SKIP IF DOWN TO LAST WORD
	JRST NWLOP1
	CAIN TAC,4
	ADD TAC1,[400000,,1]	; TAC1 ← 441000,,LAST WORD OF USER BUF
	MOVEI AC3,1
	LSH AC3,-1(TAC)		; SHIFT TO BIT POSITION IN LAST WORD OF USER BUF
	XCTR XR,[TDNN AC3,(TAC1)]
	JRST NWLOP1		; BIT CLEAR, OK TO USE THAT BYTE
	IBP TAC1		; ADVANCE THE BYTE POINTER
	SOJA TAC,NWTNLP		; TRY NEXT BYTE

OUTNOW:	SUB UCHN,IOS		; SUBTRACT OFF THE AMOUNT WE ADDED IN ALREADY
	PUSHJ P,UUFNO		; FINISH OFF BLOCK
	PUSHJ P,ALLOK		; DO WE HAVE ANY ALLOCATION?
	JRST SPOPJ			; NO, LEAVE NOW
	JRST NEWMSO		; YES, MAKE UP A NEW MESSAGE

ENDNOW:	SUBI DAT,1
	PUSHJ P,UUFNO
SPOPJ:	SUB P,[XWD 1,1]		; NORMALIZE STACK WITHOUT CLOBBERING AN AC
	POPJ P,
; ROUTINE TO CORRECT WORD COUNT, ALLOCATION, AND SEND OFF MESSAGE

UUFNO:	PUSH P,TEM
	SETZ TEM,
UUFILL:	LDB AC3,[POINT 6,AC1,5]
	CAMGE AC3,IOS		; IS POSITION GREATER THAN BYTE LENGTH?
	JRST UUFIN		; NO, WORD IS FULL
	IDPB TEM,AC1		; YES, FILL THE WORD WITH ANOTHER ZERO BYTE
	JRST UUFILL

UUFIN:	MOVNS UCHN		; NEGATE BIT COUNT
	ADDM UCHN,BAL(DDB)	; UPDATE ALLOCATION
	SOS MAL(DDB)		; NOTE ONE MORE MESSAGE GONE
	MOVE AC1,-2(P)		; PICK UP ADDRESS OF CURRENT BLOCK
	MOVE TEM,(P)		; PICK UP BYTES/WD FROM STACK
	IDIVM DAT,TEM		; CONVERT FREE BYTE COUNT TO FREE WORD COUNT IN TEM
	MOVNS TEM		; NEGATE FREE WORD COUNT
	ADDM TEM,TWC(AC1)	; MAKE INTO FULL WORD COUNT
	MOVE AC1,-3(P)		; PICK UP TOP TO MESSAGE
	DPB AC2,COUNTP		; SET BYTE COUNT THIS TRANSFER
	PUSHJ P,UUOQ		; SEND IT OUT
	POP P,TEM		; GET BACK THE BYTES/WD.
	SUB P,[XWD 3,3]
	JRST @3(P)
; BUFFERED OUTPUT. GET HERE TO DO A BLT INTO THE MESSAGE BUFFERS.

BFOHW:	MOVE TEM,IOS		; PICK UP BITS PER WORD
	MOVE TEM,BPW(TEM)	; FROM MAJIK TABLE
	MOVEI AC3,(TEM)
	IMULI AC3,(TAC)		; AC3 NOW HAS NUMBER OF BITS IN TRANSFER
	CAML AC3,BAL(DDB)	; IS THIS OVER THE ALLOCATION?
	MOVE AC3,BAL(DDB)	; YES, ONLY TRANSFER THAT MUCH
	CAILE AC3,=8000		; MORE THAN THE IMP CAN HANDLE?
	MOVEI AC3,=8000		; YES, JUST ONE BIT MESSAGE AT A TIME.
	MOVEI UCHN,(AC3)	; SAVE BITS PER MESSAGE IN UCHN
	IDIVI AC3,(TEM)		; AC3 IS NOW WORD COUNT OF THIS TRANSFER
	CAME AC1,(P)
	JRST HWNB
	LDB IOS,SIZEP		; PICK UP BYTE SIZE OF CONNECTION
	IDIVM TEM,IOS		; GET BYTES PER WORD IN IOS
	IMULI IOS,(AC3)		; IOS NOW HAS NUMBER OF BYTES IN MESSAGE
	DPB IOS,COUNTP		; USE THIS AS BYTE COUNT
HWNB:	SETZM TLINK(AC1)	; CLEAR LINKAGE WORD
	MOVEI AC2,(AC3)
	CAIL AC2,(DAT)		; MORE WORDS IN XFR THAN IN BUFFER?
	MOVEI AC2,(DAT)		; YES, TRANSFER WHOLE BUFFER FULL
	PUSHJ P,DOLOC		; RELOCATE → RESULT IN DSER
	HRLI UCHN,(DSER)	; AC2 HAS WD CT THIS BUFFER
	CAME AC1,(P)		; IS THIS THE FIRST BLOCK?
	HRRI UCHN,TDATA(AC1)	; UCHN IS BLT POINTER
	CAMN AC1,(P)
	HRRI UCHN,TDATA+2(AC1)	; IS FIRST BLOCK, BUMP POINTER PAST LEADER
	MOVEI UUO,(UCHN)
	ADDI UUO,-1(AC2)
	BLT UCHN,(UUO)
	SUBI AC3,(AC2)		; BUMP WORD COUNT THIS TRANSFER
	ADDI TAC1,(AC2)		; ADD IN WORDS IN BLOCK TO USER POINTER
	ADDI DSER,(AC2)
	SUBI TAC,(AC2)		; DECREMENT WORDS IN ENTIRE OUTPUT
	CAMN AC1,(P)		; IS THIS THE STARTING BLOCK
	ADDI AC2,2		; YES, SKIP OVER THE LEADER
	MOVEM AC2,TWC(AC1)	; SET WORD COUNT INTO BUFFER
	JUMPLE TAC,HWEND	; IF NONE LEFT, LEAVE
	JUMPLE AC3,HWDOX	; MORE WDS LEFT, BUT NOT THIS TRANSFER
	MOVE UUO,AC1		; GET ANOTHER BLOCK
	PUSHJ P,IMPGET
	JRST NOCORE
	SETZM TLINK(AC1)
	HRRZM AC1,TLINK(UUO)	; LINK US ON TO THE LAST ONE
	MOVE DAT,TLEN(AC1)	; PICK UP LENGTH OF DATA PORTION OF BUFFER
	MOVEM DAT,TWC(AC1)
	JRST HWNB
; HERE WE HAVE DECIDED TO SEND THE MESSAGE, WHETHER THERE IS MORE IN THE BUFFER OR NOT


HWDOX:	POP P,AC1		; GET BACK ADDRESS OF MESSAGE
	PUSHJ P,UPDALL
	PUSHJ P,UUOQ
	JRST OUTAGN

HWEND:	POP P,AC1
	PUSHJ P,UPDALL
	SUB P,[XWD 1,1]		; SKIP OVER FULL WORD FLAG
	JRST UUOQ

; ROUTINE TO UPDATE THE ALLOCATION FROM THE MESSAGE

UPDALL:	PUSH P,AC2
	PUSH P,AC3
	LDB AC2,SIZEP
	LDB AC3,COUNTP
	IMULI AC3,(AC2)
	MOVNS AC3
	ADDM AC3,BAL(DDB)
	SOS MAL(DDB)
	POP P,AC3
	POP P,AC2
	POPJ P,
; IMP INPUT UUOS - BUFFERED MODE AND DUMP MODE

BUFI:	HRRZ TAC1,DEVIAD(DDB)	; PICK UP ADDRESS OF LOSER BUFFER
	XCTR	XR,[HLRZ TAC,(TAC1)]
	ANDCMI TAC,400000
	MOVEI DSER,(TAC1)
	ADDI DSER,-1(TAC)	; GET ADDRESS OF LAST WORD IN BUFFER IN DSER
	XCTR	XRW,[MOVSS (DSER)]	; ADDRESS CHECK IT BY GETTIN ILM ON ILLEGAL ADDRESS
	SUBI TAC,1		; REDUCE WORD COUNT TO SKIP OVER BUFFER HEAD
	ADDI TAC1,2
	PUSHJ P,INPT		; DO THE INPUT
	JRST ENDCHK		; ERROR OR EOF
	HRRZ AC2,DEVIAD(DDB)	; PICK UP BUFFER ADDRESS
	XCTR	XW,[MOVEM DAT,1(AC2)]; SET WORD COUNT IN BUFFER
	PUSHJ P,ADVBFF		; ADVANCE THE BUFFER
	JRST UUXIT
UUXIT:	MOVE IOS,DEVIOS(DDB)	; UUOCON EXPECTS THIS
	POPJ P,

ENDCHK:	TLZE IOS,IOEND		; DID WE HIT EOF?
	ORI IOS,IODEND		; YES, SET EOF BIT
	TRNE IOS,TMO		; TIMED OUT.
	ORI IOS,IODERR		; YES, GIVE ERROR BIT SO UUOCON WON'T SHIT ON US
	MOVEM IOS,DEVIOS(DDB)
	POPJ P,

; DUMP MODE INPUT

DMPI:	PUSHJ P,DMPCMD		; RETURNS UPLEVEL ON END OF COMMAND LIST
	MOVNS TAC
	XCTR	XRW,[MOVSS (TAC1)]
	MOVEI DSER,(TAC1)
	ADDI DSER,-1(TAC)
	XCTR	XRW,[MOVSS (DSER)]
DMPIT:	PUSHJ P,INPT		; DO AN INPUT
	JRST ENDCHK
	JUMPG TAC,DMPIT		; IF WE HAVEN'T GOTTEN WHAT HE ASKED FOR, GO BACK FOR MORE
	AOJA UUO,DMPI		; CHECK FOR MORE COMMANDS
; COMMON INPUT ROUTINE.
; ENTER WITH USER ADDRESS IN TAC1 AND DESIRED WORD COUNT IN TAC
; RETURNS COUNT OF WORDS TRANSFERRED IN DAT
; RETURNS +1 IF ERROR OR NO DATA AVAILABLE, +2 ON SOME DATA TRANSFERRED

INPT:	PUSHJ P,UUOIOK		; MAKE SURE HOST ALIVE AND ALL
	POPJ P,			; HOST DEAD
INPTM:	SETZ DAT,		; CLEAR WORD COUNT
	SKIPE AC1,INL(DDB)	; IS THERE SOME INPUT WAITING FOR US?
	JRST INPT1		; YES, GO GIVE IT TO LOSER
	MOVE AC1,IMPSTB-1(AC3)	; PICK UP STATUS BITS
	TLNN AC1,CLSR		; HAS HE SENT US A CLS?
	JRST INPWT		; NO, WAIT FOR SOME MORE DATA
	MOVSI IOS,IOEND		; YES, END OF FILE
	ORB IOS,DEVIOS(DDB)
	POPJ P,

INPWT:	PUSHJ P,INIALL		; CHECK IF INITIAL ALLOCATION DONE YET
	MOVSI IOS,INPW		; NO, GO INTO INPUT WAIT FOR IT
	ORM IOS,DEVIOS(DDB)
	LDB TEM,INPTP		; PICK UP INPUT WAIT TIMEOUT
	PUSHJ P,TW		; WAIT FOR INPUT OR TIMEOUT
	JRST ISETEB		; LEAVE IF TIMEOUT
	MOVE IOS,DEVIOS(DDB)
	TRNN IOS,TMO!IODERR!IODTER!HDEAD!RSET
	PUSHJ P,UURIDX		; GET CONNECTION INDEX BACK
	POPJ P,			; LEAVE ON ERRORS
	MOVE AC1,IMPSTB-1(AC3)
	TLNN AC1,CLSS!CLSR	; SEE IF CONNECTION WENT AWAY
	JRST INPT
	SKIPE INL(DDB)		; DID ANY INPUT SNEAK IN AFTER THE CLOSE?
	JRST INPTOK		; YES, SET UP CONNECTION INDEX AND INPUT FURTHER
	MOVSI IOS,INPW		; NO, WAIT FOR MORE INPUT FOR A LITTLE WHILE
	ORM IOS,DEVIOS(DDB)
	LDB TEM,INPTP		; PICK UP HIS TIMEOUT
	CAIGE TEM,2		; FOUR SECONDS OR MORE, PLEASE.
	MOVEI TEM,2
	PUSHJ P,TW		; WAIT
	JFCL			; WE WILL TELL THAT NOTHING HAPPENED BY INL BEING EMPTY
INPTOK:	PUSHJ P,UURIDX		; PICK UP CONNECTION INDEX AGAIN
	POPJ P,			; NOBODY HOME, LEAVE
	JRST INPTM		; GOT IT. CHECK INL AGAIN.

ISETEB:	MOVEI IOS,IODERR		; SET ERROR BIT SO WE CAN GET OUT OF UUOCON
	ORB IOS,DEVIOS(DDB)
	POPJ P,
; COMMON INPUT ROUTINE. READ DATA OUT OF INPUT LIST AND INTO USER CORE

INPT1:	SKIPGE AC2,TLEN(AC1)	; HAS THIS LIST BEEN INITIALIZED?
	JRST INPT2		; YES, GO ON WITH IT
	LDB AC3,SIZEP		; PICK UP MESSAGE BYTE SIZE
	LDB AC2,COUNTP		; AND LENGTH OF MESSAGE
	IMULI AC3,(AC2)		; GET NUMBER OF BITS IN MESSAGE
	MOVNS AC3
	SOS AC2,MIIL(DDB)	; NOTE ONE LESS MESSAGE IN INPUT LIST
	ADDB AC3,BIIL(DDB)	; NOTE THAT MANY LESS BITS NOW IN INPUT LIST
	ADD AC2,HMA(DDB)	; ADD IN HOW MUCH HE HAS NOW
	ADD AC3,HBA(DDB)	; IN BOTH FLAVORS
	CAMLE AC2,NHMA2(DDB)	; NOW HAS EITHER ONE DROPPED BELOW HALF THE NOMINAL VALUE
	CAMG AC3,NHBA2(DDB)
	PUSHJ P,SNDBAL		; GET SOME MORE ALLOCATION
	LDB AC3,SIZEP		; PICK UP BYTE SIZE OF MESSAGE
	MOVEI AC2,44		; FIRST GET BYTES/WD IN AC3
	IDIVM AC2,AC3
	LDB AC2,COUNTP		; NOW GET WDS/THIS MESSAGE
	IDIVI AC2,(AC3)
	SKIPE AC3
	ADDI AC2,1		; AC2 IS WD CT THIS MESSAGE
	MOVE AC3,TWC(AC1)	; PICK UP WD CT THIS BLOCK
	SUBI AC3,2		; SUBTRACT OFF LEADER
	MOVEM AC3,TWC(AC1)
	MOVEI UCHN,(AC1)	; SAVE BLOCK ADDRESS
COMPTB:	CAILE AC2,(AC3)		; IS WD CT IN MESSAGE LESS THAN WD CT THIS BLOCK?
	JRST GTNXB		; NO, GO ON TO NEXT BLOCK
	MOVEM AC2,TWC(UCHN)	; YES, CORRECT IT TO SMALLER VALUE
	PUSH P,AC1
	HRRZ AC1,TLINK(UCHN)	; NOW GET RID OF ANY SPURIOUS PADDING WHAT MAY BE
	HLLZS TLINK(UCHN)
	SKIPE AC1
	PUSHJ P,RELLST
	POP P,AC1
	MOVEI AC2,TDATA+2(AC1)	; PICK UP POINTER TO DATA PAST LEADER
	JRST INPT2		; AND GO ON WITH INPUT

GTNXB:	SUBI AC2,(AC3)		; KNOCK OFF AMOUNT IN THIS BUFFER
	HRRZ UCHN,TLINK(UCHN)	; AND MOVE ON TO NEXT BUFFER
	JUMPN UCHN,GNXWC
	JSP TAC,UUOMES
	ASCIZ /MESSAGE LENGTH NOT CONSISTANT WITH BYTE SIZE, UUO/

GNXWC:	MOVE AC3,TWC(UCHN)	; PICK UP WC THIS BUFFER
	JRST COMPTB
; HERE WE HAVE CORRECTED THE WORD COUNTS IN THE BUFFERS AND ARE READY TO DO THE INPUT

INPT2:	MOVE AC3,TWC(AC1)	; PICK UP DATA WORD COUNT
	CAIL AC3,(TAC)		; DOES THE USER WANT LESS THAN THERE IS?
	MOVEI AC3,(TAC)		; YES, JUST GIVE HIM WHAT HE WANTS
	PUSHJ P,DOLOC		; DO SOFTWARE RELOCATION, TAC1 TO DSER
	MOVEI UCHN,(DSER)	; MAKE UP BLT PTR INTO LOSER CORE
	HRLI DSER,(AC2)
	ADDI UCHN,-1(AC3)
	BLT DSER,(UCHN)
	ADDI AC2,(AC3)		; BUMP POINTER INTO MESSAGE BUFFER
	ADDI DAT,(AC3)		; ADD INTO NUMBER OF WORDS TRANSFERRED
	SUBI TAC,(AC3)		; NOTE THAT HE HAS GOTTEN THAT MANY WORDS
	ADDI TAC1,(AC3)		; INCREMENT USER ADDRESS
	TLO AC2,400000		; TURN ON BIT FLAGING PARTIALLY EMPTIED BUFFER
	MOVEM AC2,TLEN(AC1)
	MOVNS AC3		; DECREMENT COUNT OF WORDS LEFT IN MESSAGE BUFFER
	ADDB AC3,TWC(AC1)
	JUMPG AC3,INPMOR	; BUFFER NOT EMPTY, SEE IF HE WANTS ANY MORE
	HRRZ UCHN,TLINK(AC1)	; PICK UP ADDRESS OF NEXT BLOCK IN MESSAGE
	JUMPE UCHN,UNLST	; IF NONE, END OF LIST
	HLRZ DSER,TLINK(AC1)	; THERE IS A BLOCK. PASS DOWN CDR POINTER TO IT
	HRLM DSER,TLINK(UCHN)
	HRRM UCHN,INL(DDB)	; AND MOVE US INTO TOP POSITION
	HLRZ DSER,INL(DDB)	; ARE WE ALSO THE END?
	CAIN DSER,(AC1)
	HRLM UCHN,INL(DDB)
	PUSHJ P,IMPREL		; RELEASE THE FREE STORAGE
	MOVE AC1,UCHN
	TLO UCHN,400000		; SET THE PARTIALLY EMPTY BIT SO WE WON'T TRY TO SKIP OVER THE LEADER
	ADDI UCHN,TDATA		; SKIP OVER THE OVERHEAD WORDS
	MOVEM UCHN,TLEN(AC1)
INPMOR:	JUMPG TAC,INPT1		; HE WANTS MORE, SEE IF WE CAN GIVE IT TO HIM
	JRST CPOPJ1		; NO MORE

UNLST:	HLRZ UCHN,TLINK(AC1)	; NO MORE BLOCKS, MOVE TO NEXT MESSAGE
	HRRM UCHN,INL(DDB)
	SKIPN UCHN
	SETZM INL(DDB)
	PUSHJ P,IMPREL
	SKIPE AC1,UCHN
	JRST INPMOR
	SETZM INL(DDB)		; END OF INPUT LIST
	JRST CPOPJ1
; CLOSE CODE. DOESN'T REALLY DO MUCH EXCEPT FLUSH BUFFERS AND SEND OUT CLSS

CLSO:	SKIPE IMPDEAD
	POPJ P,
	TLNN DDB,OUTBFB!OUTPB	; OUTPUT BUFFER SET UP?
	JRST CLSO1		; NO, FORGET ABOUT FLUSHING LAST BUFFER
	LDB AC1,PIOMOD		; WHAT MODE ARE WE IN?
	CAIGE AC1,DR		; DUMP MAYBE?
	PUSHJ P,OUT		; NO, DO LAST OUTPUT FOR BUFFERED MODE
CLSO1:	PUSHJ P,UUSIDX		; PICK UP LINK TABLE INDEX
	POPJ P,
	MOVE IOS,DEVIOS(DDB)
	TRNE IOS,BLOK		; IS THERE DATA ON THE LINK?
	PUSHJ P,RFNMWT		; YES, WAIT FOR IT
	PUSHJ P,UUSIDX
	POPJ P,
	MOVSI AC2,CLSS		; SEE IF WE HAVE SENT A CLS YET
	TDNE AC2,IMPSTB-1(AC3)
	POPJ P,			; YES, ONE IS ENOUGH
	JRST USCLS		; SEND OUT A SEND-SIDE CLS

; CLOSE INPUT

CLSI:	SKIPN IMPDEAD
	PUSHJ P,UURIDX
	POPJ P,
	MOVE IOS,DEVIOS(DDB)
	TRNE IOS,BLOK
	PUSHJ P,RFNMWT
	PUSHJ P,UURIDX
	POPJ P,
	MOVSI AC2,CLSS
	TDNE AC2,IMPSTB-1(AC3)
	POPJ P,
	JRST URCLS		; SEND OUT A RECEIVE-SIDE CLS
; UTILITY ROUTINES FOR UUO-LEVEL STUFF. ROUTINES TO SEND STR OR RTS
; CONNECTION INDEX MUST BE IN AC3
; POINTER TO USER TABLE MUST BE IN UUO
; DDB MUST BE SET UP
; CAN ONLY BE CALLED AT UUO LEVEL BECAUSE IT DOES XCTR'S

SNDRFC:	HRRZM DDB,IMPDDB-1(AC3)
	PUSHJ P,IMPGET		; GET SOME FREE STORAGE
	PUSHJ P,CLKWAIT		; IF AT CLOCK LEVEL, WAIT FOR IT
	XCTR	XR,[MOVE AC2,LSLOC(UUO)]
	MOVEI TEM,RTS		; WHAT FLAVOR RETURN MESSAGE?
	TRNE AC2,1
	MOVEI TEM,STR		; SEND SIDE, GIVE HIM A STR INSTEAD
	PUSHJ P,GETIDX		; PICK UP INDEX OF CONNECTION AGAIN
	JRST NOCONN		; NONE THERE!
	PUSHJ P,MAKRF
	JRST UUOQ
; ROUTINE TO MAKE UP AN RFC BLOCK. MUST HAVE BLOCK IN AC1, CONNECTION INDEX IN AC3,
; OPCODE (STR OR RTS) IN TEM, DEVICE DATA BLOCK ADDRESS IN DDB

MAKRF:	MOVSI AC2,RFCS		; NOTE AN RFC GOING OUT
	PUSHJ P,CSTAT
	PUSHJ P,CLRBLK
	MOVE AC2,LNKTAB-1(AC3)
	ANDCMI AC2,377		; CONTROL MESSAGES GO OUT ON LINK ZERO
	DPB AC2,ELINKP
	MOVEI AC2,10
	DPB AC2,SIZEP
	MOVEI AC2,12
	DPB AC2,COUNTP
	DPB TEM,OPCDP
	MOVE AC2,IMPLS-1(AC3)
	PUSHJ P,PSOCK1
	MOVE AC2,IMPFS-1(AC3)
	PUSHJ P,PSOCK2
	MOVEI AC2,5
	MOVEM AC2,TWC(AC1)
	CAIE TEM,RTS		; WHAT FLAVOR?
	JRST SNDBS		; SEND SIDE, GIVE HIM A BYTE SIZE
	PUSHJ P,GNLNK		; GET NEW AND UNIQUE LINK NUMBER
	DPB AC2,[POINT 8,LNKTAB-1(AC3),35]
	DPB AC2,SZLKP
	POPJ P,

SNDBS:	MOVE AC2,IMPBS-1(AC3)
	DPB AC2,SZLKP
	POPJ P,
; ERROR ROUTINE FOR NO CONNECTION

NOCONN:	JSP TAC,UUOMES
	ASCIZ /IMP IO WITHOUT REQUEST FOR CONNECTION
UUO/

; ERROR ROUTINE FOR NO CORE AT UUO LEVEL

NOCORE:	TELCTR(NNCOR,<NO CORE AT UUO LEVEL>)
	JRST UUOERR
; ROUTINE TO SEND OUT A MESSAGE AT UUO LEVEL. WAITS FOR
; LINK TO UNBLOCK IF NEED BE. IF IMP DEAD, RELEASES STORAGE.
; ENTER WITH MESSAGE IN AC1

UUOQ:	SKIPN IMPDEAD		; IMP DOWN?
	JRST UUODQ		; NO, GO AHEAD
UUODD:	MOVEI IOS,HDEAD!IODERR	; YES, GIVE ERROR BITS
	ORB IOS,DEVIOS(DDB)
	JRST RELLST

UUODQ:	PUSH P,TAC
	PUSH P,TEM
	LDB TAC,LINKP		; PICK UP LINK NUMBER
	JUMPE TAC,UUOQ0		; IF LINK ZERO, CHECK IT SEPARATELY
	MOVE IOS,DEVIOS(DDB)
	TRNN IOS,BLOK		; ARE WE BLOCKED?
	JRST UUOQNW		; NO, GO AHEAD
	PUSHJ P,RFNMWT		; YES, WAIT FOR LINK TO BECOME UNBLOCKED
	TRNE IOS,IODERR!IODTER!HDEAD!RSET
	JRST UUOQRL
UUOQNW:	ORI IOS,BLOK		; NOTE LINK BLOCKED NOW
	MOVEM IOS,DEVIOS(DDB)
	JRST UUOQO

UUOQ0:	PUSHJ P,L0PTR		; MAKE UP POINTER INTO 8-WORD HOST TABLES
	TDNN AC3,L0BLOK(AC2)	; SEE IF CONTROL LINK BLOCKED
	JRST UUOQ0N		; NOT BLOCKED, GO AHEAD
	MOVSI IOS,LNK0W		; NOTE WAITING FOR CONTROL LINK
	ORM IOS,DEVIOS(DDB)
	AOS L0WAIT		; NOTE ONE MORE WAITOR
	LDB TEM,RFNMTP		; PICK UP TIME TO WAIT FOR RFNM
	PUSHJ P,TW
	JRST UUOQR1		;TIMED OUT - CLEAR BIT AND GO AWAY
	MOVE IOS,DEVIOS(DDB)
	TRNN IOS,IODERR!IODTER!HDEAD!RSET
	JRST UUOQ0		; GO BACK AND CHECK AGAIN
UUOQRL:	PUSHJ P,RELLST
	JRST UUOQXT

UUOQR1:	ANDCAM AC3,L0BLOK(AC2)
	JRST UUOQRL

UUOQ0N:	ORM AC3,L0BLOK(AC2)	; NOTE LINK BLOCKED NOW
UUOQO:	PUSHJ P,QOUT		; SEND MESSAGE OUT
UUOQXT:	POP P,TEM
	POP P,TAC
	POPJ P,
; ROUTINE TO WAIT FOR THE LINK TO CLEAR
; CALL WITH J, DDB AND IOS SET UP
; RESTORES IOS, CLOBBERS TEM

RFNMWT:	SKIPE IMPDEAD
	POPJ P,
	MOVSI IOS,BLOKW
	ORM IOS,DEVIOS(DDB)
	PUSH P,TEM
	LDB TEM,RFNMTP
	PUSHJ P,TW
	JRST [	POP P,TEM
		SKIPN RECOVER
		SETOM RECOVER
		POPJ P,]
	POP P,TEM
	MOVE IOS,DEVIOS(DDB)
	TRNN IOS,HDEAD!RSET!IODERR!IODTER
	TRNN IOS,BLOK
	POPJ P,
	JRST RFNMWT		; GO BACK AND WAIT SOME MORE
; ROUTINE TO BLESS UUO LEVEL OUTPUTS BASED ON HOST STATUS.

UUOOOK:	PUSHJ P,UUSIDX
	POPJ P,
	PUSHJ P,UUOCHK		; CHECK FOR CONNECTION
	POPJ P,			; NONE THERE OR HOST DEAD
	PUSHJ P,UUSIDX		; GET INDEX INTO LINK TABLE
	JRST NOCONN
	MOVE AC2,IMPSTB-1(AC3)
	TLNN AC2,CLSR		; HAS HE SENT US A CLS?
	JRST CPOPJ1		; NO, OUTPUT IS OK
	MOVEI IOS,IODERR	; YES, ERROR
	ORB IOS,DEVIOS(DDB)
	POPJ P,

UUOIOK:	PUSHJ P,UURIDX
	POPJ P,
	PUSHJ P,UUOCHK
	POPJ P,
	PUSHJ P,UURIDX		; PICK UP LINK TABLE INDEX
	JRST NOCONN
	JRST CPOPJ1
; ROUTINE TO CHECK FOR PROPER CONNECTION AND HOST DEAD.
; SKIPS ON SUCCESS. FAILURE MEANS EITHER HOST DEAD OR NO CONNECTION.

UUOCHK:	SKIPE IMPDEAD
	POPJ P,
	MOVE AC2,IMPSTB-1(AC3)
	TLNN AC2,RFCS		; HAS RFC BEEN SENT?
	JRST NOCONN		; NO, NOTE CONNECTION NOT OPEN YET
	TLNE AC2,RFCR		; YES, HAS IT BEEN ACKNOWLEDGED YET?
	JRST CPOPJ1		; YES, SUCCESS
	MOVSI IOS,RFCW		; NO, WAIT FOR IT
	ORM IOS,DEVIOS(DDB)
	LDB TEM,RFCTP		; DON'T WAIT FOR MORE THAN 5 MINUTES
	PUSH P,IMPLS-1(AC3)	; SAVE SOMETHING SO WE CAN RESET AC3 AFTER TIME WAIT
	PUSHJ P,TW		; DO A TIMED WAIT
	JRST UUOCHL		; ERROR RETURN IF TIMEOUT
	POP P,AC2		; RETRIEVE LOCAL SOCKET NUMBER
	MOVE IOS,DEVIOS(DDB)
	TRNE IOS,IODERR!IODTER
	POPJ P,			; LEAVE ON ERROR
	PUSHJ P,GETIDX		; GET CURRENT AC3 (COULD'VE CHANGED DURING WAIT)
	POPJ P,			; ERROR - AC3 NOT ONLY CHANGED, ITS GONE FOREVER!?!?
	JRST UUOCHK		; GO THROUGH THE LOOP AGAIN
UUOCHL:	POP P,AC2
	POPJ P,			; ERROR RETURN BECAUSE OF TIMEOUT

SETERR:	ORI IOS,IODERR		; SET ERROR BIT
	MOVEM IOS,DEVIOS(DDB)
	POPJ P,
; ROUTINE TO INITIALIZE A CONNECTION
; ENTER WITH CONNECTION INDEX IN AC3
; LOCAL SOCKET NUMBER IN AC2
; FOREIGN SOCKET NUMBER IN TEM
; HOST-LINK NUMBER IN DAT
; POINTER TO USER TABLE IN UUO

CLRSKT:	MOVEM AC2,IMPLS-1(AC3)	; SET LOCAL SOCKET NUMBER
	MOVEM TEM,IMPFS-1(AC3)	; AND FOREIGN SOCKET NUMBER
	MOVEM DAT,LNKTAB-1(AC3)	; AND HOST-LINK NUMBER
	XCTR	XR,[MOVE DAT,BSLOC(UUO)]
	TRNE AC2,1		;IF A SEND SOCKET, THEN
	MOVEM DAT,IMPBS-1(AC3)	; SET BYTE SIZE
	SETZM IMPRFQ-1(AC3)
	SETZM IMPSTB-1(AC3)
	HRRZM DDB,IMPDDB-1(AC3)
	POPJ P,
; ROUTINE TO REQUEUE SOMEONE INTO THE RUN QUEUE
; ENTER WITH J CONTAINING THE JOB NUMBER

QRUN:	LDB J,PJOBN
	SKIPL TIM(DDB)		; MAKE SURE TIMEOUT IS CLEARED
	SOS TIMWAIT		; NOTE ONE LESS WAITOR
	SETOM TIM(DDB)
	MOVM DSER,JOBQUE(J)
	CAIE DSER,IOWQ
	POPJ P,
	MOVE DSER,JBTSTS(J)
	TLNN DSER,RUN
	POPJ P,
	MOVNI DSER,RUNQ
	MOVEM DSER,JOBQUE(J)
	JRST REQUE

; ROUTINE TO CHANGE THE STATUS BITS
; ENTER WITH STATUS BIT TO SET IN AC2
; CONNECTION INDEX IN AC3

CSTAT:	TLO AC2,ANYC
	ORM AC2,IMPSTB-1(AC3)
	PUSH P,DDB
	SKIPN DDB,IMPDDB-1(AC3)
	JRST CSTAT1
	MOVSI AC2,INTIMS
	PUSHJ P,INTCOM
CSTAT1:	POP P,DDB
	POPJ P,

; ROUTINE TO GET A CONNECTION INDEX FROM A LOCAL SOCKET NUMBER IN AC2
; RETURNS INDEX IN AC3

GETIDX:	SKIPN AC3,FFLNK
	POPJ P,
GETID1:	CAMN AC2,IMPLS-1(AC3)
	JRST CPOPJ1
	SOJG AC3,GETID1
	POPJ P,
; ROUTINE TO WAIT FOR ALLOCATION

ALLOCW:	SKIPE IMPDEAD
	POPJ P,
	MOVSI IOS,ALLW
	ORM IOS,DEVIOS(DDB)
	PUSH P,TEM
	MOVNI TEM,IOWQ		; NO INTERNAL TIMEOUT FOR THIS
	MOVEM TEM,JOBQUE(J)
	LDB TEM,ALLTP		; WE WILL WAIT ONLY SO LONG FOR ALLOCATION
	PUSHJ P,TW
	JRST [	POP P,TEM	; GET OUR AC BACK
		JRST ALLXIT]
	POP P,TEM
	MOVE IOS,DEVIOS(DDB)	; CLEAR ALLOCATION WAIT BIT
	TRNN IOS,IODERR!IODTER!HDEAD!RSET!TMO
	AOS (P)
ALLXIT:	MOVSI IOS,ALLW
	ANDCAB IOS,DEVIOS(DDB)
	POPJ P,

; ROUTINE TO CHECK ALLOCATION AND WAIT FOR IT IF NECESSARY

ALLOK1:	PUSHJ P,ALLOCW		; NO, WAIT FOR SOME ROOM
	POPJ P,			; LEAVE ON ERRORS
ALLOK:	PUSHJ P,UUSIDX		; PICK UP INDEX INTO LINK TABLE ANEW
	JRST NOCONN		; NONE THERE! UNTHINKABLE!
	MOVE IOS,IMPSTB-1(AC3)	; PICK UP STATUS BITS
	TLNE IOS,CLSS!CLSR	; HAVE WE BEEN CLOSED?
	JRST ALLERS		; YES, LEAVE NOW, SET ERROR BITS
	MOVE IOS,IMPBS-1(AC3)	; PICK UP BYTE SIZE
	SKIPLE MAL(DDB)		; DO WE HAVE ANY MESSAGE ALLOCATION?
	CAMLE IOS,BAL(DDB)	; IS THERE ROOM FOR AT LEASE ONE BYTE?
	JRST ALLOK1
	JRST CPOPJ1		; YES, GO AHEAD

ALLERS:	MOVEI IOS,IODERR
	ORB IOS,DEVIOS(DDB)	; SET ERROR BITS TO GET THROUGH UUOCON WITHOUT LOSING
	POPJ P,
; ROUTINE TO GET LINK TABLE INDEX FROM A DDB POINTER - SEND SIDE

UUSIDX:	SKIPN AC3,FFLNK
	POPJ P,
	PUSH P,DDB
	HRRZ DDB,DDB
UUSID1:	MOVE AC2,IMPLS-1(AC3)		; WHAT GENDER SOCKET
	TRNN AC2,1
	JRST UUSID2
	CAMN DDB,IMPDDB-1(AC3)
	AOSA -1(P)			;SUCCESS. SKIP RETURN
UUSID2:	SOJG AC3,UUSID1
	POP P,DDB
	POPJ P,

; ROUTINE TO GET LINK TABLE INDEX FROM A DDB POINTER - RECEIVE SIDE

UURIDX:	SKIPN AC3,FFLNK
	POPJ P,
	PUSH P,DDB
	HRRZ DDB,DDB
UURID1:	MOVE AC2,IMPLS-1(AC3)		; WHAT GENDER SOCKET
	TRNE AC2,1
	JRST UURID2
	CAMN DDB,IMPDDB-1(AC3)
	AOSA -1(P)			;SUCCESS
UURID2:	SOJG AC3,UURID1
	POP P,DDB
	POPJ P,
; THIS IS CALLED AT CONNECT AND LISTEN TO DETERMINE
; IF THERE IS ANOTHER SOCKET OPEN ON THIS DDB, AND IF IT IS
; NOT THE SEND-RECEIVE MATE, KILL IT WITHOUT TOO MUCH ADO.
; ENTER WITH SOCKET NUMBER TO BE OPENED IN AC2

NSCHECK:
	SKIPN IMPDEAD
	SKIPN AC3,FFLNK
	POPJ P,
	XORI AC2,1		; PRODUCE THE MATING SOCKET NUMBER
	MOVEI AC1,(DDB)
NSCLOP:	CAMN AC1,IMPDDB-1(AC3)	; IS THIS THE SAME DDB?
	CAMN AC2,IMPLS-1(AC3)	; YES, IS IT THE APPROPRIATE SOCKET?
	JRST [	SOJG AC3,NSCLOP
		POPJ P,]
	MOVE AC2,IMPLS-1(AC3)	; PICK UP THE LOSING SOCKET NUMBER
	MOVE IOS,DEVIOS(DDB)
	TRNE IOS,BLOK
	PUSHJ P,RFNMWT		; WAIT FOR ANY DATA ON THE LINK TO BO BY
	PUSHJ P,GETIDX		; GET BACK THE INDEX TO THE STRANGE SOCKET
	POPJ P,
	MOVE AC1,IMPSTB-1(AC3)
	TLNE AC1,RFCS
	TLNE AC1,CLSS
	JRST NSCZLK
	PUSH P,AC2
	PUSHJ P,USCLS
	POP P,AC2
	PUSHJ P,GETIDX
	POPJ P,
NSCZLK:	SETZM IMPDDB-1(AC3)
	JRST ZEROLK
; FREE STORAGE MANAGER FOR IMP SERVICE

IMPGET:	PUSH P,AC2
	PUSH P,AC3
	MOVEI AC3,TLNG
	PUSHJ P,FSGET
	JRST SCROUNGE
	SKIPG IMPSPN		; NEED ANY SPARES?
	JRST IMPGSX		; NO
	PUSH P,AC1		; YES, SAVE THIS BLOCK AND GET SOME
IMPGE1:	MOVEI AC3,TLNG
	PUSHJ P,FSGET
	JRST IMPGX		; NO MORE, LEAVE WITH THE GOODIES
	CONO PI,IMPOFF
	EXCH AC1,IMPFSL
	HRRZM AC1,@IMPFSL
	CONO PI,IMPON
	SOSLE IMPSPN		; NOTE ONE LESS BLOCK NEEDED
	JRST IMPGE1		; IF ANY MORE, GO GET THEM
IMPGX:	POP P,AC1
IMPGSX:	HRRZ AC3,-1(AC1)	; PICK UP POINTER TO TOP OF BLOCK
	HLRZ AC3,(AC3)		; GET SIZE OF BLOCK
	SUBI AC3,400000+TDATA+2	; SUBTRACT OFF OVERHEAD WORDS
	MOVEM AC3,TLEN(AC1)	; PUT THAT AS LENGTH OF BLOCK
	MOVEM AC3,TWC(AC1)	; AND AS FULL WORD COUNT
	PUSHJ P,LEGAL		; CHECK IT OUT FIRST
	JRST IMPGET		; BAD BLOCK, TRY FOR ANOTHER
	AOS -2(P)		; SET SKIP RETURN
	SETZM TLINK(AC1)	; CLEAR OUT LINKAGE WORD
IMPGEX:	POP P,AC3
	POP P,AC2
	POPJ P,
; HERE WE CAN'T GET FS FROM THE SYSTEM, SEE IF WE CAN SCROUNGE A BLOCK

SCROUNGE:
	CONO PI,IMPOFF
	SKIPN AC1,IMPFSL
	JRST SCRNG1
	MOVE AC3,(AC1)
	MOVEM AC3,IMPFSL
	CONO PI,IMPON
	PUSHJ P,LEGAL		; IS IT A VALID BLOCK?
	JRST SCRERR		; NO, FLUSH SPARE LIST
	AOS NSPSUS
	AOS IMPSPN
	JRST IMPGSX

SCRERR:	SETZM IMPFSL		; BAD BLOCK, KILL SPARE LIST
	MOVEI AC1,10		; AND REFILL IT
	MOVEM AC1,IMPSPN
	JRST IMPGEX		; GIVE ERROR RETURN

SCRNG1:	CONO PI,IMPON
	JRST IMPGEX
; ROUTINE TO RELEASE FREE STORAGE
; REPLENISHES SPARE LIST IF NECESSARY

IMPREL:	ANDI AC1,-1
	PUSHJ P,LEGAL
	POPJ P,
	SKIPG IMPSPN
	JRST FSGIVE
	SOS IMPSPN
	CONO PI,IMPOFF
	EXCH AC1,IMPFSL
	MOVEM AC1,@IMPFSL
	CONO PI,IMPON
	POPJ P,

; ROUTINE TO CHECK THE LEGALITY OF A FS BLOCK
; RETURNS +1 IF BLOCK BAD
; RETURNS +2 IF BLOCK OK

LEGAL:	SKIPN DEBMODE		; ARE WE DEBUGGING?
	JRST CPOPJ1		; NO, LEAVE IMMEDIATELY
	PUSH P,AC2
	PUSH P,AC3
	HRRZ AC2,-1(AC1)
	HLRZ AC3,(AC2)		; PICK UP COUNT HALF-WORD
	CAIN AC3,400000+TLNG!7+1
	JRST LEGPCH
LEGERR:	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ /BAD BLOCK IN IMPSER
CALLERS = /]
	DISARG LOC,<-22(P)>
	[ASCIZ /, /]
	DISARG LOC,<-23(P)>
	[ASCIZ /, /]
	DISARG LOC,<-24(P)>
	[ASCIZ /, /]
	DISARG LOC,<-25(P)>
	[ASCIZ /
/]
	-1
	POPACS
	POP P,AC3
	POP P,AC2
	POPJ P,

LEGPCH:	SUBI AC2,TLNG!7+1
	CAIE AC2,-2(AC1)
	JRST LEGERR
	POP P,AC3
	POP P,AC2
	JRST CPOPJ1
; ROUTINE TO ASSIGN A NEW LINK NUMBER
; ENTER WITH CONNECTION INDEX IN AC3
; RETURNS LINK NUMBER IN AC2

MAXLNK←←=60
MINLNK←←=10

GNLNK:	PUSH P,AC1
	PUSH P,DSER
	MOVE AC2,LSTLNK		; PICK UP ONE PLUS LAST ASSIGNED LINK NUMBER
	CAIL AC2,MINLNK		; LESS THAN MINIMUM LINK NUMBER?
	CAILE AC2,MAXLNK-1	; GREATER THAN MAXIMUM LINK NUMBER?
	MOVEI AC2,MINLNK	; YES, START AT THE BOTTOM AGAIN
	MOVEM AC2,LSTLNK
	ADDI AC2,1
GNLNK5:	SKIPN AC1,FFLNK		; SCAN DOWN LINK TABLE FOR DUPLICATES
	JRST GNLNK6
GNLNK1:	LDB DAT,[POINT 8,LNKTAB-1(AC1),35]
	CAIN DAT,(AC2)		; SAME LINK?
	JRST GNLNK2		; YES, SEE IF IT IS THE SAME HOST TOO
	CAMN AC2,LSTLNK		; HIT OURSELVES YET?
	JRST GNOLNK		; YES, NO LINK!!!
GNLNK4:	SOJG AC1,GNLNK1
GNLNK6:	MOVEM AC2,LSTLNK
	POP P,DSER
	POP P,AC1
	POPJ P,

GNLNK2:	MOVE DSER,LNKTAB-1(AC3)
	XOR DSER,LNKTAB-1(AC1)
	TRNE DSER,177400
	JRST GNLNK4		; IF DIFFERENT HOSTS, IS OK
	ADDI AC2,1		; BUMP LINK NUMBER
	CAILE AC2,MAXLNK
	MOVEI AC2,MINLNK
	JRST GNLNK5

GNOLNK:	TELCTR(NOLKS,<NO NEW LINK!!!>)
	PUSHJ P,DISFLUSH
	JRST AUTOLOAD
; ROUTINE TO SEE IF A TABLE ENTRY MAY BE CLEARED.
; ENTER WITH ENTRY INDEX IN AC3
; IMPDDB-1(AC3) MUST BE ZERO!!!

ZEROLK:	MOVE AC1,IMPSTB-1(AC3)	; PICK UP STATUS BITS
	TLNE AC1,RFCR!RFCS	; ANYTHING HAPPENED ON THE SEND SIDE?
	JRST ZEROL1		; YES, SEE IF WE HAVE GOTTEN THE CLSS
	TLNE AC1,CLSS		; HAVE WE SENT A CLS?
	TLNE AC1,CLSR		; YES, HAVE WE RECEIVED THE MATCHING ONE?
	JRST KILLNK		; YES, GO TEST THE RECEIVE SIDE
	POPJ P,			; NO, DON'T RELEASE SLOT YET

ZEROL1:	TLNE AC1,CLSS		; HAVE WE SENT A CLS YET?
	TLNN AC1,CLSR		; YES, MAKE SURE WE HAVE BOTH SENT AND RECEIVED ONE
	POPJ P,
	JRST KILLNK
; ROUTINE TO SEARCH DOWN QUEUED RFC LIST FOR AN RFC THAT MATCHES OUR SOCKET
; UUO LEVEL ONLY. DDB MUST BE SET UP AS WELL AS AC3

DISPQ:	SETZ TAC1,		; PREPARE TO SCAN DOWN QUEUED RFC'S
RFCQL:	PUSHJ P,LEGAL		; BLESS BLOCK ADDRESS
	JRST [	SETZM IMPRFQ-1(AC3)
		POPJ P,]	; GIVE NO FIND RETURN
	PUSHJ P,GSOCK2		; PICK UP LOCAL SOCKET NUMBER
	CAMN AC2,IMPLS-1(AC3)	; DOES IT MATCH?
	JRST RFCQD1
RFCQI:	MOVEI TAC1,(AC1)	; NO, PUT THIS BLOCK AS LAST BLOCK
	HLRZ AC1,TLINK(AC1)	; PICK UP ADDRESS OF NEXT BLOCK
	JUMPN AC1,RFCQL
	POPJ P,

RFCQD1:	PUSHJ P,GSOCK1		; PICK UP FOREIGN SOCKET NUMBER
	CAME AC2,IMPFS-1(AC3)	; DOES IT MATCH?
	SKIPGE IMPFS-1(AC3)	; OR IS IT UNUSED?
	JRST RFCQD2
	JRST RFCQI

RFCQD2:	LDB DAT,ELINKP		; PICK UP HOST NUMBER
	XOR DAT,LNKTAB-1(AC3)
	TRNE DAT,177400		; DOES IT MATCH
	SKIPN LNKTAB-1(AC3)	; OR IS IT OPEN?
	JRST RFCQD3		; YES, LOAD US UP
	JRST RFCQI

RFCQD3:	LDB DAT,SRCP		; PICK UP HOST NUMBER
	DPB DAT,[POINT 8,LNKTAB-1(AC3),27]
	MOVEM AC2,IMPFS-1(AC3)
	LDB AC2,SZLKP		; PICK UP SIZE-LINK FIELD
	LDB DSER,OPCDP		; GET OPCODE
	PUSHJ P,SETHB		; SET LINK NUMBER OR BYTE SIZE
	PUSHJ P,UNLRFQ		; UNLINK RFC FROM QUEUE
	PUSHJ P,IMPREL		; AND GIVE IT BACK
	JRST CPOPJ1		; GIVE SUCCESS RETURN
; ROUTINE TO APPEND AN ENTIRE RFC QUEUE ONTO ILIST
; ENTER WITH RFC QUEUE IN AC1 (XWD <LAST>,<FIRST>)

APNLST:	SETZM IMPRFQ-1(AC3)
	PUSHJ P,LEGAL		; IS IT A REASONABLE ADDRESS?
	POPJ P,			; NO, LEAVE NOW
	CONO PI,IMPOFF
	SKIPN AC2,ILIST
	JRST APNLS1
	MOVSS AC2
	HRLM AC1,TLINK(AC2)
	HLLM AC1,ILIST
APNLS2:	CONO PI,IMPON
	POPJ P,

APNLS1:	MOVEM AC1,ILIST
	JRST APNLS2

; ROUTINE TO UNLINK A RFC FROM THE QUEUED RFC LIST
; MUST HAVE PREDECESSOR IN TAC1 AND INDEX IN AC3

UNLRFQ:	HLRZ AC2,TLINK(AC1)
	TRNN TAC1,-1
	JRST UNLRF1
	HRLM AC2,TLINK(TAC1)
	SKIPN AC2
	HRLM TAC1,IMPRFQ-1(AC3)
	POPJ P,

UNLRF1:	HRRM AC2,IMPRFQ-1(AC3)
	SKIPN AC2
	SETZM IMPRFQ-1(AC3)
	POPJ P,
; ROUTINE TO GO INTO A WAIT STATE BUT START A COUNTDOWN TOO
; ENTER WITH WAIT BIT IN IOS, TIME TO WAIT IN TEM
; SKIPS IF WAIT SATISFIED, DOESN'T SKIP IF TIMED OUT

JIFMIN←←=60*JIFSEC

TW:	JUMPE TEM,TIMAGN	; NO TIME MEANS WAIT INDEFINITELY
	IMULI TEM,2*JIFSEC	; SCALE TO TIX
TIMEDW:	ADD TEM,TIME		; WRAP AROUND
	CAML TEM,[JIFDAY:	=24*=60*JIFMIN]
	SUB TEM,JIFDAY
	MOVEM TEM,TIM(DDB)
	AOS TIMWAIT		; NOTE THERE IS ANOTHER WAITER
TIMAGN:	MOVNI TEM,IOWQ
	MOVEM TEM,JOBQUE(J)
	PUSHJ P,WSCHED
	MOVE TEM,DEVIOS(DDB)
	TDNN TEM,IOS		; IS THE WAIT SATISFIED?
	JRST TIMXIT		; YES, LEAVE NORMALLY
	TRNN TEM,TMO!IODERR!IODTER	; NO, DID WE TIME OUT?
	JRST TIMAGN		; NO, SPURIOUS WAKEUP (AS IN ↑C - CONT)
TIMXIT:	ANDCA IOS,DEVIOS(DDB)	; CLEAR WAIT BIT
	TRZE IOS,TMO		; DID WE TIME OUT?
	JRST TIMXT1		; YES
	AOS (P)			; SET SKIP RETURN
TIMXT1:	MOVEM IOS,DEVIOS(DDB)
	POPJ P,
; ROUTINE TO WAIT FOR A MATCHING CLS
; ENTER WITH CONNECTION INDEX IN AC3
; RETURNS WITH CONNECTION INDEX IN AC3 AND STATE BITS IN AC1

TCLSW:	PUSH P,AC2
	MOVE AC2,IMPLS-1(AC3)
	MOVSI IOS,CLSW
	ORM IOS,DEVIOS(DDB)
	LDB TEM,CLSTP
	PUSHJ P,TW
	JFCL
	PUSHJ P,GETIDX
	JRST NOCONN
	POP P,AC2
	MOVSI AC1,CLSR
	ORB AC1,IMPSTB-1(AC3)
	POPJ P,
; ROUTINE TO SEND AN ALLOCATION
; ENTER WITH NUMBER OF BITS OF ALLOCATION HE HAS LEFT IN AC3,
; AND NUMBER OF MESSAGES HE HAS IN AC2

SNDBAL:	PUSH P,TAC
	PUSH P,TAC1
	PUSH P,AC1
	MOVNI TAC1,(AC3)	; PUT BIT ALLOCATION IN TAC1
	ADD TAC1,NHBA(DDB)	; CONVERT TO NUMBER OF BITS HE NEEDS
	MOVNI TAC,(AC2)		; AND MESSAGE ALLOCATION IN TAC
	ADD TAC,NHMA(DDB)	; CONVERT TO NUMBER OF MESSAGES HE NEEDS
	PUSHJ P,IMPGET
	JRST NOCORE
	SETZM TDATA(AC1)
	SETZM TDATA+1(AC1)
	SETZM TDATA+2(AC1)
	PUSHJ P,UURIDX
	JRST NOCONN
	DPB TAC1,[POINT 32,TDATA+3(AC1),31]
	ADDM TAC1,HBA(DDB)	; INCREMENT BIT ALLOCATION
	DPB TAC,[POINT 16,TDATA+2(AC1),31]
	ADDM TAC,HMA(DDB)	; ADD THAT IN TO HIS MESSAGE ALLOCATION
	MOVE TAC,IMPSTB-1(AC3)	; IS THE SOCKET STILL OPEN?
	TLC TAC,RFCS!RFCR	; MAKE SURE THE SOCKET IS REALLY OPEN
	TLNN TAC,RFCS!RFCR	; IF NOT, LEAVE NOW
	TLNE TAC,CLSS!CLSR
	JRST SNDPOP		; NO, DON'T SEND ANY MORE CONTROL COMMANDS
	MOVEI TAC,ALL
	DPB TAC,OPCDP
	MOVE TAC,LNKTAB-1(AC3)
	DPB TAC,OLINKP
	ANDCMI TAC,377
	DPB TAC,ELINKP
	MOVEI TAC,10
	DPB TAC,SIZEP
	DPB TAC,COUNTP
	PUSHJ P,UUOQ
SNDPPX:	POP P,AC1
	POP P,TAC1
	POP P,TAC
	POPJ P,

SNDPOP:	PUSHJ P,IMPREL		; CONNECTION CLOSED, RELEASE STORAGE AND LEAVE
	JRST SNDPPX
; ROUTINE TO CHECK AND SEND INITIAL ALLOCATION
; MUST BE CALLED AT UUO LEVEL ONLY

INIALL:	SKIPE NHMA(DDB)		; IS THERE A NOMINAL ALLOCATION YET?
	JRST CHKENF		; YES, SEE IF IT HAS BEEN SENT YET
	MOVEI AC2,DEFBAL	; GIVE DEFAULT BIT ALLOCATION
	MOVEM AC2,NHBA(DDB)
	LSH AC2,-1
	MOVEM AC2,NHBA2(DDB)
	MOVEI AC2,DEFMAL	; AND A BUNCH OF MESSAGES
	MOVEM AC2,NHMA(DDB)
	LSH AC2,-1
	MOVEM AC2,NHMA2(DDB)
CHKENF:	MOVE AC3,HBA(DDB)	; PICK UP CURRENT BIT ALLOCATION
	ADD AC3,BIIL(DDB)	; ADD IN AMOUNT IN INPUT LIST
	MOVE AC2,HMA(DDB)	; SAME FOR MESSAGE ALLOCATION
	ADD AC2,MIIL(DDB)
	CAML AC3,NHBA2(DDB)	; IS BIT ALLOCATION LESS THAN HALF DEPLETED?
	CAMGE AC2,NHMA2(DDB)	; OR MESSAGE ALLOCATION?
	PUSHJ P,SNDBAL		; YES, SEND HIM SOME MORE
	POPJ P,
; ROUTINE TO SEND OUT A SEND-SIDE CLS FROM UUO LEVEL
; CALL WITH DDB SET UP

USCLS:	PUSHJ P,IMPGET
	JRST NOCORE
	PUSHJ P,UUSIDX
	JRST IMPREL
	SETZM BAL(DDB)		; NOTE NO MORE ALLOCATION
	SETZM MAL(DDB)
USCLS1:	MOVE AC2,LNKTAB-1(AC3)
	ANDI AC2,177400
	LSH AC2,14		; PUT HOST NUMBER IN PROPER SLOT
	PUSHJ P,MCLSB		; MAKE UP A CLOSE BLOCK
	MOVE AC2,IMPLS-1(AC3)	; PUT IN OUR SOCKET NUMBER
	PUSH P,AC2		;SAVE SOCKET NUMBER
	PUSHJ P,PSOCK1
	MOVE AC2,IMPFS-1(AC3)	; PUT IN HIS SOCKET NUMBER
	PUSHJ P,PSOCK2
	MOVSI AC2,CLSS		; HAS CLOSE ALREADY BEEN SENT?
	TDNE AC2,IMPSTB-1(AC3)
	JRST [SUB P,[1,,1]
	      JRST IMPREL]	; YES, RELEASE STORAGE AND LEAVE
	PUSHJ P,CSTAT		; NO, SET CLS SENT BIT
	PUSHJ P,UUOQ		; AND SEND OUT THE CLS
	POP P,AC2		;GET BACK SOCKET NUMBER
	PUSHJ P,GETIDX		;AND INDEX
	JRST NOCONN		;ARGGGGHHH!!!
	POPJ P,

; RECEIVE SIDE CLS AT UUO LEVEL
; CALL WITH DDB SET UP

URCLS:	PUSHJ P,IMPGET
	JRST NOCORE
	PUSHJ P,UURIDX
	JRST IMPREL
	JRST USCLS1
