COMMENT ⊗   VALID 00058 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00007 00002	BEGIN SCHEDU ↔ SUBTTL SCHEDULING ALGORITHM FOR SWAPPING SYSTEM
C00009 00003	NXTJOB DECREMENTS CURRENT JOB'S QUANT. AND PROTECT
C00012 00004	BUG TRAP
C00014 00005	CKJB1:	JUMPN	PID,SCHED
C00017 00006	 SCAN JOB STATUS TABLES FOR A JOB TO RUN
C00019 00007	 THIS ROUTINE CHECKS TO SEE IF THE JOB IN J IS REALLY RUNNABLE
C00021 00008	 HERE WE SEE IF THIS JOB'S HIGH SEGMENT IS IN CORE
C00023 00009	 AT THIS POINT, WE HAVE ALMOST DECIDED ON A JOB
C00024 00010	2-PROCESSOR ROUTINES TO INTERLOCK JOBS
C00026 00011	 HERE, WE SORT THE RUN QUEUE INTO PRIORITY ORDER
C00030 00012	 THIS ROUTINE CALCULATES THE VARIOUS JOB PRIORITIES
C00033 00013	 CALCULATE ONE JOB'S NEW PRIORITY
C00039 00014	 ADD UP THE SERVICES TO HIS VARIOUS RELATIVES
C00043 00015	QCSS	24 JULY 67
C00046 00016	QUEUE INITIALIZATION
C00048 00017	DELETES A JOB FROM ITS "SOURCE-Q", DETERMINES A "DEST-Q"
C00049 00018	CALLING SEQUENCE:
C00057 00019	 JOB IS NOT RUNNING.  REQUEUE HIS SEGMENT IF NEEDED.
C00060 00020	SCANS THE QS RETURNING THE NUMBERS OF THE JOBS IN THE QS.
C00062 00021	↑QSCAN:	SKIPN QR,(DAT)	END OF SCAN TABLE?
C00064 00022	DEFINE X'(A),<
C00065 00023	CORRESPONDENCE TABLE BETWEEN JOB STATUS CODES AND QUEUE TRANSFER TABLES
C00067 00024	IFN FTSWAP,<
C00069 00025	HERE RESIDES ALL THE SWAP IN LIST CODE -- RPH 1/15/74
C00074 00026	SWAP	4 AUG 67
C00076 00027	↑SWAP:	PUSH PDP,[SWPXIT]	 MAKE SURE WE EXIT THROUGH HERE
C00078 00028	 WE COME HERE TO FINISH A SWAPPING INPUT REQUEST
C00081 00029	 HERE WE CONTINUE ANY SPW JOB THAT WAS ACTIVE AND GIVE SWAPIN INTS
C00085 00030	 WE CLEAR JOB DATA AREA IF REQUIRED ALSO
C00086 00031	HERE WE CHECK ALL THE SWAPIN BITS
C00089 00032	CHECK IF UPPER WANTS IN
C00091 00033	HERE THERE'S A SWAPIN ERROR.
C00093 00034	ERROR AND NOT WRITE PROTECTED SEGMENT, OR LOWER.
C00095 00035	 HERE WE CHECK THE NUMBER OF DDB'S HE HAS, ALSO REGENERATE JOB DATA AREA
C00098 00036	 ROUTINE TO RELEASE A JOB'S SWAPPING BANDS (LIBRASCOPE ONLY)
C00099 00037	 AND HERE IS WHERE WE GO TO FINISH A SWAP OUTPUT REQUEST
C00103 00038	SCAN FOR INPUT - LOOK FOR A JOB ON THE DISK WHICH OUGHT TO COME IN.
C00107 00039	 "DEADUP" IS CALLED FROM NEAR SCNIN2, IF THE JOB TO BE SWAPPED IN IS AN
C00110 00040	 THIS SENDS THE MESSAGE TO A DEADLOCKED LOWER
C00111 00041	 HERE WE SEE IF JOB CAN EVER FIT. IF SO, TRY TO COMPACT CORE TO GET HIM IN
C00113 00042	 HERE WE HAVE DETECTED A CORE DEADLOCK
C00115 00043	 CLOCK REQUEST TIMES OUT IN 15-SOME-ODD-SECONDS AND COMES HERE:
C00117 00044		GCMAX - ROUTINE TO CALCULATE HOW MUCH CORE IS AVAILABLE FOR A
C00122 00045	SCAN FOR OUTPUT
C00126 00046	FORCE4:	CAME J,SEGWAIT		 IF WAITING FOR SEGMENT, MUST STAY IN
C00129 00047	OUTPUT A JOB
C00134 00048	 ROUTINE TO ADD THIS JOB'S SIZE TO CURRENT TOTAL AND SEE IF WE
C00136 00049	 ROUTINE TO DECREMENT REFERENCE TO THIS JOB'S UPPER, IF ANY
C00137 00050	 ALL SWAP RETURNS THROUGH HERE
C00138 00051	INPUT A JOB
C00140 00052	XPAND SETS CONDITIONS TO GET MORE CORE FOR A JOB BY SWAPPING IT OUT
C00143 00053	SWPSER	4 AUG 67
C00146 00054	 FAST-BAND SWAPPER . .  .
C00148 00055	 HERE WE HAVE ENOUGH BANDS, SET UP CALL
C00150 00056	 LIBRASCOPE INPUT ROUTINE
C00152 00057	 LIBRASCOPE SWAPPING ERROR ROUTINES
C00153 00058	FIND A SERIES OF BLOCKS ON THE DISK TO SWAP ONTO. CALLED
C00155 ENDMK
C⊗;
BEGIN SCHEDU ↔ SUBTTL SCHEDULING ALGORITHM FOR SWAPPING SYSTEM
;11 SEPT 67 REDESIGNED PERIODICALLY BY JAM (AND OTHERS)


;AC'S
QJ←DDB		;QJOB WORD
Q←PROG		; QUEUE NUMBER
PC←UUO		; PC ON QUEUE SCAN CALLS
QR←AC1		; RESCAN ADDRESS ON QUEUE SCAN CALLS

;INITIALIZE SCHEDULER  (CALLED FROM IOINI1 BEFORE ALL OTHER
;	DEVICES ARE INITIALIZED)


↑NXTINI:
REPEAT 0,<
	SYNINI	JBTCSC
	MOVE	DDB,[XWD JBTOWN,JBTOWN+1]
	SETZM	JBTOWN
	BLT	DDB,JBTOWN+JOBN-1
>
	SETZM	SCHBEG		;ZERO JOB PRIORITY STUFF
	MOVE	DDB,[XWD SCHBEG,SCHBEG+1]
	BLT	DDB,SCHEND
	MOVEI	DDB,MAXQ		;MAXIMUM NUMBER OF QUEUES
NXTIN1:	SETZM	AVALTB(DDB)		;CLEAR SHARABLE DEVICE AVAIL. FLAGS
	SETOM	REQTAB(DDB)		;SET SHARABLE DEVICE REQUEST COUNT
					;TO -1,  I.E. NO JOB WAITING OR
					;USING DEVICE OTHER THAN INITIALIZATION
	SOJGE	DDB,NXTIN1
	SETZM	SWPCNT			;CLEAR SWAPPER COUNT
	SETZM	SCHMQT			;WAKE SWAPPER UP THE FIRST TIME AROUND
	SETZM	QJOB
	MOVE	DDB,[XWD QJOB,QJOB+1]
	BLT	DDB,QJOB+JOBN-1
IFN FTSWAP,<
	PUSHJ	P,FBINI
	JRST	SWPINI
>
IFE FTSWAP,<POPJ P,>
;NXTJOB DECREMENTS CURRENT JOB'S QUANT. AND PROTECT
;TIMES AND REQUEUES IT IF QUANT. TIME GONE TO 0.
;SERVICES ANY JOB REQUEUING REQUESTED AT OTHER PRIORITY
;LEVELS THEN CALLS SHUFFLER,SWAPPER AND SCHEDULER
;MAKES NO ASSUMPTIONS RE. ACS
;RETURNS NEXT JOB TO RUN IN J.


↑NXTJOB:
	JUMPN PID,SCHD1		;PDP-6 GETS TO RUN THE NULL JOB A LOT.

; HERE, WE SEE IF CURRENT JOB IS RUNNABLE. IF IT IS, WE
; SEE IF ITS QUANTUM TIME HAS RUN OUT. IF IT HAS, WE REQUEUE THE
; JOB. IF NOT, WE LEAVE NOW

CKJB3:	SKIPN J,JOB(PID)	;CURRENT JOB NO., IS IT NULL JOB?
	JRST CKJB1		;YES,GO SEE IF OTHER JOBS NEED RESCHEDULING
	CONO PI,PIOFF		;AVOID CONFUSION BETWEEN NEXT 2 INSTRS
	MOVE DAT,JOBQUE(J)	;PICK UP HIS NEW QUEUE
	MOVMM DAT,JOBQUE(J)	;STORE BACK POS (NO MORE INT NEEDED)
	CONO PI,PION
	MOVM DDB,DAT		;GET POSITIVE FORM
	HLRZ IOS,JBTSTS(J)	;GET JOB STATUS BITS AND CODES
	ANDCMI IOS,RUNMSK	;MASK OUT DO NOT CARE BITS
	CAIE IOS,RUNABLE	;IS CURRENT JOB RUNABLE?
	JRST CKJB10		;NO, REQUE CURRENT JOB
	CAIE DDB,RUNQ		; IS HE STILL RUNNABLE?
	CAIN DDB,TQ
	CAIA
	JRST CKJB10		; NO. REQUE HIM.
	SKIPE TIMEF(PID)	;YES, IS THIS A TIME INTERRUPT?
	SOSLE SCHMQT(PID)	; YES, DO WE RUN THE SCHEDULER THIS TICK?
	CAIA			;  NO
	JRST CKJB9		;  YES
IFN FTSWAP,<	SKIPE XJOB(J)	; NO, THIS JOB EXPANDING?
	JRST CHKXJ1		; YES, SCHEDULE TO GET SWAPPED OUT>
	LDB DDB,PSEGN		; GOT AN UPPER?
	JUMPE DDB,CPOPJ		; NO, FORGET IT
IFN FTSWAP,<	SKIPE XJOB(DDB)	;IS HIS UPPER SEGMENT EXPANDING?
	JRST CHKXJ3		;  YES	>
	MOVE DDB,JBTSTS(DDB)	;IS IT IN TRANSIT?
	TLNE DDB,SHF!SWP
	JRST CKJB2A		; YES, SHUT THIS JOB OFF
	POPJ P,			;  NO
;BUG TRAP
CHKXJB:	SKIPE XJOB	;THIS SHOULD BE SET.
	POPJ P,		;ALL IS WELL
	AOS XJOB	;GET IT TAKEN CARE OF.
	PUSHACS
	PUSHJ	P,DISJOB
	PUSHJ	P,DISMES
	ASCIZ	/ XJOB(J) SET BUT NOT XJOB(0)
/
	POPACS
	POPJ P,

CHKXJ4:	PUSH P,J
	MOVE J,DDB
	PUSHJ P,CHKXJB
	POP P,J
	POPJ P,

CHKXJ3:	PUSHJ P,CHKXJ4
	JRST CKJB2A

CHKXJ1:	PUSHJ P,CHKXJB
	JRST CKJB2A

CKJB9:	MOVEI DAT,QQMQT		; RESET SCHEDULER WAIT TIME
	MOVEM DAT,SCHMQT(PID)
	AOS NTMOS		; BUMP NUMBER OF TIME-OUTS
	CAIE DDB,TQ		; IF IN TQ, WE HAVE TO REQUEUE THIS JOB
	JRST CKJB2A
	MOVEI	DDB,RUNQ	; PUT HIM INTO STANDARD RUN QUEUE
	MOVEM	DDB,JOBQUE(J)	;SAVE QUEUE CODE (POS SINCE INT TAKEN CARE OF HERE)
	SKIPA DAT,[-1,,QRUNW]
CKJB10:
	HRR DAT,QBITS(DDB)	;GET ADR FROM POS CODE IN DDB, PRESERVE SIGN OF ORIG
	PUSHJ P,QXFER
	MOVE J,JOB(PID)
CKJB2A:
REPEAT 0,<
	PUSHJ P,JOBRLS		;ARRIVE HERE TO TURN OFF A JOB
>
CKJB1:	JUMPN	PID,SCHED
CKJB2:	SETZ TAC1,
	CONO PI,PIOFF		;MAKE SURE LIST STAYS HONEST
	SKIPN J,QJOB
	JRST CKJB4
	EXCH TAC1,(J)		;GET LIST LINK AND ZERO THIS ENTRY
	HRRZM TAC1,QJOB		;LINK HIM OUT
	CONO PI,PION
	SUBI J,QJOB		;GET JOB NUMBER
	CONO PI,PIOFF		;PROBABLY BETTER DUPLICATED THAN OFF TOO LONG
	MOVE DAT,JOBQUE(J)	;NEW QUEUE, - => GEN INT IF ENABLED
	MOVMM DAT,JOBQUE(J)	;INT NO LONGER NEEDED
	CONO PI,PION
	MOVM DDB,DAT		;GET POS FORM
	HRR DAT,QBITS(DDB)	;AND BITS (PRESERVE SIGN)
	PUSHJ P,QXFER		;DO THE QXFER THING
	JRST CKJB2

CKJB4:	CONO PI,PION		;TURN PI'S BACK ON
	MOVEI QJ,AVLNUM		;CK AVAL FLAGS FOR SHAR. DEVS.
CKJB6:	SKIPN AVALTB(QJ)	;FLAG=0?
	SOJGE QJ,CKJB6		;YES - TRY NEXT ONE
	CAIGE QJ,MINQ		;LESS THAN MIN. SHAR. DEV.Q?
	JRST CKJB7		;YES. IGNORE.
	MOVN J,QJ		;NO--GET 1ST JOB IN Q
	HRRE J,JBTQ(J)
	JUMPLE J,CKJB8		;FINISHED Q?
	MOVNI DAT,RUNQ		; REQUEUE HIM TO THE RUN QUEUE
	MOVEM DAT,JOBQUE(J)
	HRROI DAT,QRUNW		;- SO INT CAN HAPPEN
	SETZM AVALTB(QJ)	;CLEAR AVAL FLAG
	PUSHJ PDP,QXFER		;REQUEUE THE JOB AND PUT IT IN
				;PROCESSOR Q SO SCHEDULER WILL RUN IT
CKJB8:	SOJG QJ,CKJB6		;CONTINUE IF ANY MORE FLAGS TO LOOK AT
CKJB7:				;NONE--GO SHUFFLE AND SWAP
	SKIPE INTREQ		;BUT FIRST A WORD FROM OUR INTERRUPTS
	PUSHJ P,INTRUN		;(QXFER MAY HAVE GENERATED INTS)
IFE FTSWAP,<	
	PUSHJ PDP,CHKSHF
>
IFN FTSWAP,<
	HGMAC(10)
	PUSHJ PDP,SWAP
	HGMAC(6)	>
; SCAN JOB STATUS TABLES FOR A JOB TO RUN

SCHED:	AOS NSCHEDS		; COUNT NUMBER OF TIMES THROUGH HERE
	MOVEI DAT,ALLRUNSCAN	; SCAN TQ AND RUNQ ONLY
	JSP PC,QSCAN
	JRST SCHD1		; NOBODY LEFT, RUN NULL JOB
	PUSH P,DAT		; SAVE POINTER TO QUEUE SCAN LIST
	PUSHJ P,CHKJOB		; IS HE REALLY RUNNABLE?
	JRST SCHPDR		; NO, TRY NEXT GUY
	POP P,DAT
	JRST SCH1		; YES, DO IT

SCHPDR:	POP P,DAT
SCH2:	JRST (QR)

REPEAT 0,<			;FLUSH THIS
SCHSCN:	MOVE J,JOB(PID)		; START AT CURRENT JOB NUMBER MINUS ONE
SCHD2:	SOJG J,SCHD3		; WRAP JOB 0 AROUND TO MAXIMUM LEGAL JOB NUMBER
	MOVEI J,JOBN-1
SCHD3:	PUSHJ P,CHKJOB		; IS HE REALLY RUNNABLE?
	JRST SCH2		; NO
	JRST SCH1		; YES, DO IT.

SCH2:	CAIN J,1		; IS THIS JOB 1?
	SKIPE JOB(PID)		; IF THIS IS JOB 1 AND THE NULL JOB RAN LAST, WE ARE DONE
	CAMN J,JOB(PID)		; ARE WE BACK TO WHERE WE STARTED?
	JRST SCHD1		; YES, RETURN NULL JOB
	JRST SCHD2		; NO, SCAN NEXT JOB
>;END REPEAT 0
; THIS ROUTINE CHECKS TO SEE IF THE JOB IN J IS REALLY RUNNABLE
; RETURNS IF NOT RUNNABLE, TAKES SKIP RETURN IF RUNNABLE

CHKJOB:	HLRZ	IOS,JBTSTS(J)		;PICK UP STATUS BITS
	ANDCMI	IOS,RUNMSK		;ZERO THE BITS THAT DON'T MATTER
IFN FTSWAP,<
	SKIPE	XJOB(J)
	JRST	CHKXJB			;JOB IS EXPANDING.  CAN'T BE RUN.
>
	CAIN	IOS,RUNABLE		;IS THIS JOB RUNNABLE
	JRST	SCHD4			;YES.  MAKE SURE THAT SEGMENT IS THERE.
	TRNE	IOS,RUN
	POPJ	P,
	MOVM	DAT,JOBQUE(J)
	CAIE	DAT,RUNQ
	POPJ	P,
	PUSHACS
	MOVSI	DAT,RUN
	ANDCAM	DAT,JBTSTS(J)
	MOVNI	DAT,STOPQ
	MOVEM	DAT,JOBQUE(J)
	PUSHJ	P,REQUE
	PUSHJ	P,DISJOB
	PUSHJ	P,DISMES
	ASCIZ	/  IN RUNQ; NOT RUNNABLE. JBTSTS= /
	MOVE	TAC,JBTSTS(J)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
	POPACS
	POPJ	P,
; HERE WE SEE IF THIS JOB'S HIGH SEGMENT IS IN CORE

SCHD4:	LDB DDB,PSEGN		; DOES THIS JOB HAVE A HIGH SEGMENT?
	JUMPE DDB,CPOPJ1
	JUMPN PID,CPOPJ
	MOVE DSER,JBTSTS(DDB)
	TLNE DSER,SWP		; IF SO, IS IT IN CORE?
	JRST SCH5		;NO. SWAPPED OUT. LET'S DRAG IT IN!
	TLNE DSER,SHF
	POPJ P,
	SKIPE XJOB(DDB)
	JRST CHKXJ4
	MOVM DSER,JOBQUE(DDB)
	CAIN DSER,STOPQ
	JRST SCH3
	MOVEI DSER,STOPQ
	MOVNM DSER,JOBQUE(DDB)
	MOVEI DAT,QSTOPW
	PUSH P,J
	MOVE J,DDB
	PUSHJ P,QXFER
	POP P,J
SCH3:	CAMN J,SEGWAIT
	SETZM SEGWAIT
	JRST CPOPJ1

SCH5:	SKIPE SEGWAIT
	POPJ P,
	MOVEM J,SEGWAIT
	MOVM DAT,JOBQUE(DDB)
	CAIN DAT,SEGQ
	POPJ P,			; YES, DON'T REQUEUE HIM
	PUSH P,J		; SWAPPED OUT. BRING IT IN
	MOVE J,DDB
	MOVEI DAT,SEGQ
	MOVNM DAT,JOBQUE(J)
	MOVEI DAT,QSEGW		; PUT IT IN SEGMENT WAIT QUEUE
	PUSHJ P,QXFER
	POP P,J
	POPJ P,
; AT THIS POINT, WE HAVE ALMOST DECIDED ON A JOB
; WE CLAIM IT AND RETURN

SCH1:
REPEAT 0,<
	MOVE DDB,JB2STS(J)
	JUMPE PID,SCH6
	TLNN DDB,RUN2
	JRST SCH2
	JRST SCH4
SCH6:	TLNN DDB,RUN1
	JRST SCH2
SCH4:	PUSHJ P,JOBGET
	JRST SCH2
>
	POPJ	P,		;RETURN

SCHD1:	SETZ J,			;RETURN NULL JOB
	SKIPN PID		; FOR P1, WE WILL
	AOS NNULLJS		; BUMP NUMBER OF TIMES NULL JOB SELECTED
	POPJ PDP,
;;2-PROCESSOR ROUTINES TO INTERLOCK JOBS
		;JBTOWN(J) > 0 MEANS JOB J IS BEING RUN BY P1
		;JBTOWN(J) < 0 MEANS JOB J IS BEING RUN BY P2
REPEAT 0,<

JOBGET:
	PSYNC JBTCSC
	JUMPE PID,JOBG3
	SKIPLE JBTOWN(J)
	JRST JOBG1
	SOS JBTOWN(J)
	JRST JOBG2
JOBG3:	SKIPGE JBTOWN(J)
	JRST JOBG1
	AOS JBTOWN(J)
JOBG2:	AOS (P)
JOBG1:	XSYNC JBTCSC
	POPJ P,

JOBRLS:
	JUMPE PID,JOBRL1
	AOSLE JBTOWN(J)
	JRST JOBRER
	POPJ P,
JOBRL1:	SOSL JBTOWN(J)
	POPJ P,
JOBRER:	PUSHACS
	PUSHJ P,ALTNOW
	JFCL
	PUSHJ P,DISDATE
	PUSHJ P,DISMES
	ASCIZ /ππJOB RELEASED ILLEGALLY
/
	POPACS
	DEBCHECK
	SKIPN DISFLAG
	JRST JOBR2
	PUSHJ P,DISFLUSH
	JRST AUTOLOAD

JOBR2:	JUMPE PID,.+2
	SOSA JBTOWN(J)
	AOS JBTOWN(J)
	POPJ P,
>
; HERE, WE SORT THE RUN QUEUE INTO PRIORITY ORDER

↑ORDER:					;CALLED WHEN ORDYET≠0
	MOVE	DDB,INTIME+P1PID	;TOTAL INTERRUPT TIME
	EXCH	DDB,OINTIME		;SAVE IT
	SUB	DDB,OINTIME		;-(RECENT INTERRUPT TIME)
	MOVE	J,UPTIME+P1PID		;CURRENT UPTIME
	EXCH	J,OUTIME		;SAVE IT
	SUB	J,OUTIME		;-(CHANGE IN UPTIME)
	MOVE	DSER,DDB		;SAVE -(RECENT INTERRUPT TIME)
	SUB	DDB,J			;(DELTA UPTIME)-(DELTA INTERRUPT TIME)
	MOVEM	DDB,JLFACTOR		;SAVE AS WEIGHTING FACTOR.
	MOVEM	DDB,RJLFACTOR
	MOVSI	DDB,1
	IDIVM	DDB,RJLFACTOR		;AVOID REMAINDER
	IMULI	DSER,=1000
	IDIVM	DSER,J
	MOVEM	J,JLRIT			;SAVE RECENT INTERRUPT FRACTION, *1000

	MOVE	TAC,[XWD JBTNPR,JBTPRI]
	BLT	TAC,JBTPRI+JOBN-1
	MOVNI	Q,RUNQ
ORD3:	HRRE	Q,JBTQ(Q)		;PICK UP FIRST JOB IN RUN QUEUE
	JUMPL	Q,ORDX			;NO MORE, EXIT.
ORD2:	HRRE	DSER,JBTQ(Q)		;GET NEXT JOB IN QUEUE.
	JUMPL	DSER,ORDX		;IF NO NEXT JOB, WE'RE DONE.
	MOVE	DDB,JBTPRI(DSER)	;COMPARE PRIORITIES.
	CAMG	DDB,JBTPRI(Q)
	JRST	ORD3		;RIGHT ORDER  PRI[Q]>PRI[DSER].  ADVANCE IN QUEUE.
	HLRE	UCHN,JBTQ(Q)	;WRONG ORDER. SCAN BACKWARDS TO FIND RIGHT SPOT
ORD1:	JUMPL	UCHN,ORDINS		;JUMP IF THERE'S NO FURTHER BACKWARDS.
	CAMG	DDB,JBTPRI(UCHN)	;IS THIS WHERE IT SHOULD BE?
	JRST	ORDINS			;YES. PRI[UCHN]>PRI[DSER]
	HLRE	UCHN,JBTQ(UCHN)		;ADVANCE BACKWARDS.
	JRST	ORD1

;DELETE ENTRY POINTED TO BY DSER; INSERT IT AFTER ENTRY POINTED TO BY UCHN.
ORDINS:	MOVE	DDB,JBTQ(DSER)	;DELETE HIM FROM OLD POSITION.
	HLLM	DDB,JBTQ(DDB)	;SET BACKWARDS LINK IN GUY FORWARD FROM US.
	MOVS	DDB,DDB
	HLRM	DDB,JBTQ(DDB)	;SET FORWARDS LINK IN GUY BACKWARD FROM US.
	MOVE	DDB,JBTQ(UCHN)	;ADD US AFTER (FORWARDS FROM) OUR TRUE PREDECESSOR
	HRRM	DDB,JBTQ(DSER)	;FLINK[DSER]←FLINK[UCHN]
	HRRM 	DSER,JBTQ(UCHN)	;FLINK[UCHN]←DSER
	HRLM	UCHN,JBTQ(DSER)	;BLINK[DSER]←UCHN
	HRLM	DSER,JBTQ(DDB)	;BLINK[FLINK[DSER]]←DSER
	JRST	ORD2		;HE IS IN PLACE, SCAN SOME MORE (DON'T ADVANCE Q)

ORDX:	SETZM	ORDYET			;TELL PDP-6 THAT WE'VE FINISHED OUR SORT
	POPJ	P,
; THIS ROUTINE CALCULATES THE VARIOUS JOB PRIORITIES
; IT DOES SO BY TAKING THE CURRENT JOB LOADING FACTOR,
; DEFINED TO BE TIME WAITING FOR COMPUTE TIME OVER REAL TIME,
; AND PUTS IT IN A TABLE WITH THE PREVIOUS JLLENGTH
; FACTORS. THEN IT MAKES A WEIGHTED AVERAGE OF THESE AND
; ADDS IT INTO THE JOBS TOTAL JOB LOADING HISTORY, WHICH IS
; DECAYED EXPONENTIALLY BY SUBTRACTING A FRACTION EVERY SO OFTEN

GRSPRI←←360000

IFE FTSWAP,<
↑JLCAL:	POPJ	P,
>

IFN FTSWAP,<
↑JLCAL:	MOVE	J,ORDYET		;HAS THE PDP-10 DONE IT'S THING YET?
	JUMPN	J,CPOPJ			;IF NOT, WAIT FOR IT
	SOSLE	J,JLCYET
	JRST	JLCA1
	SETZM	SWPCNT
	MOVEI	DDB,JLTIME
	MOVEM	DDB,JLCYET

	SETOM	ORDYET
	JUMPE	PID,ORDER		;IF WE'RE THE PDP-10, NO NEED TO INTERLOCK
	POPJ	P,

JLCA1:	ROT	J,-1		;DIVIDE BY 2
	JUMPL	J,CPOPJ		;SKIP ODD TICKS.
	CAIL	J,JOBN		;LEGAL JOB NUMBERS ONLY
	POPJ	P,
	SKIPE	DDB,JBTJL(J)	;IS THERE A HISTORY TABLE?
	JRST	JLCA3		;YES, GO RECOMPUTE PRIORITY
	MOVSI	DDB,(3B2)	;NO. MAKE A SILLY ASSUMPTION
	MOVEM	DDB,JBTNPR(J)
	POPJ	P,
; CALCULATE ONE JOB'S NEW PRIORITY
; DECAY PAST, WEIGHT NEAR PAST, THEN COMPUTE PRIORITY
; JBTJLH = DISTANT PAST CELL.
; JBTJL  = TABLE OF FS BLOCKS, ONE-PER-JOB. KEEPS RECENT HISTORY.
; JBTNPR = JOB'S NEW PRIORITY.
; JBTRNB = AMOUNT OF CPU TIME THAT JOB HAS ACCUMULATED SINCE LAST CALL HERE.

JLCA3:	MOVN	DSER,JBTJLH(J)		;FIRST, DECAY DISTANT PAST
	ASH	DSER,-5
	ADDM	DSER,JBTJLH(J)		;PAST ← (31/32)*PAST

	MOVE	UCHN,(DDB)		;ADD OLDEST TO DISTANT HISTORY
	ADDM	UCHN,JBTJLH(J)		;PAST ← PAST+OLDEST "RECENT" HISTORY

	MOVSI	DSER,1(DDB)		;BLT DOWN RECENT HISTORY
	HRRI	DSER,(DDB)
	BLT	DSER,JLLENGTH-2(DDB)	;MAKE ROOM FOR NEW FACTOR

	HRRZ	DSER,JBTRNB(J)		;PICK UP RUN TIME USED
	IMUL	DSER,RJLFACTOR		;DIVIDE BY USEABLE TIME. = PROCESSOR LEVEL
	MOVEM	DSER,JLLENGTH-1(DDB)	;SET IN LAST POSITION IN TABLE (MOST RECENT)
					;1,,0 = 100% PL

	MOVE	DSER,JBTSTS(J)		;GIVE LOGIN AND LOGOUT GOOD SERVICE
	TLNN	DSER,JACCT		;ACCOUNTING?
	JRST	JLCA15			;NO.
	HRLZI	DDB,377777		;GIVE THEM THE HIGHEST POSSIBLE PRIORITY
	HLR	DDB,JBTPRI(J)	;RANDOM	;PUT IN SOME NUMBERS FOR GOOD MEASURE
JLCA9:	MOVEM	DDB,JBTNPR(J)		;SAVE USER'S PRIORITY
	POPJ	P,

JLCA15:	SETZB	AC3,JBTRNB(J)		;
	MOVEI	TEM,=100		;WEIGHT.
	MOVEI	AC1,0			;COUNT WEIGHTS USED
	MOVSI	DSER,JLLENGTH-1
	HRRI	DSER,JLLENGTH-1(DDB)	;DSER ← <JLLENGTH-1,,ADDRESS OF DATA>
JLCA4:	MOVE	AC2,(DSER)		;PICK UP HISTORICAL JOB LOAD
	IMULI	AC2,(TEM)		; %PL * WEIGHT
	ADDI	AC1,(TEM)		;SUM OF ALL WEIGHTS.
	ADD	AC3,AC2
	MOVEI	AC2,(TEM)
	LSH	AC2,-3
	SUBI	TEM,(AC2)		;WEIGHT ← (7/8)*WEIGHT.
	SUB	DSER,[1,,1]
	JUMPG	DSER,JLCA4		;LOOP THROUGH JOB HISTORY

	MOVE	AC2,JBTJLH(J)		;PICK UP DISTANT PAST
	IMULI	AC2,(TEM)		;JUST TO MAKE CURVES JOIN
	ADDI	AC1,(TEM)		;ADD UP WEIGHTS.
	ADD	AC3,AC2
	SUB	AC3,[3B2]		;USAGE - DEFAULT PRIORITY = -(PRIORITY)
	MOVNM	AC3,JBTNPR(J)		;THIS IS THEN HIS PRIORITY

; CHECK THIS JOB'S SERVICE LEVEL TO SEE IF HE DESERVES HIGHER PRIORITY.
;AC2 = SERVICE GUARANTEE LEVEL, TEM = SUM OF ALL THE SERVICE LEVELS

	SKIPE	JBTGSL
	POPJ	P,
	HRRZ	AC2,JBTGSL(J)		;PICK UP THE SERVICE LEVEL GUARANTEE
	CAILE	AC2,320000		;MORE THAN 40.625% SERVICE LEVEL?
	MOVEI	AC2,320000		;REDUCE TO 40% - REG'S UNFAIRNESS.
	HRRZ	DDB,PRJPRG(J)
	MOVEI	TEM,0			;ADD UP SERVICES TO RELATIVES.
	MOVEI	DSER,JOBN-1		;INDEX FOR LOOP THRU JOBS
JLCA5:	HRRZ	UCHN,PRJPRG(DSER)
	CAIN	DDB,(UCHN)		;DOES THIS GUY HAVE THE SAME PPN
	SKIPN	UCHN,JBTJL(DSER)	;YES, DOES HE HAVE ANY PAST
	JRST	JLCA6			;NO. LOOP FOR NEXT GUY

	HRLI	UCHN,-JLLENGTH		;AOBJN POINTER TO PL HISTORY
	ADD	TEM,(UCHN)		;ADD IN THE SERVICE LEVEL
	AOBJN	UCHN,.-1

JLCA6:	SOJG	DSER,JLCA5		;NOW LOOP AROUND TO LOOK FOR ANOTHER GUY WITH SAME PPN
	IDIVI	TEM,JLLENGTH		;NORMALIZE PL.  SUM OF PL OF ALL RELATIVES.
; ADD UP THE SERVICES TO HIS VARIOUS RELATIVES
	CAMG	AC2,TEM		; SEE IF HE GOT MORE THAN HE BARGAINED FOR
	POPJ	P,		; YES, HE NOW JUST FOLLOWS HIS PRIORITY
	SKIPN	SLCOST		; ARE WE CHARGING FOR CORE?
	JRST	JLCA20		;NO SKIP THIS STUFF.
	PUSH	P,AC2		;SAVE HIS GSL 
	PUSH	P,TEM		;SAVE ACTUAL PL
	MOVEI	TAC1,JOBN-1	; OK. NOW SEE IF HE IS A CORE LEVEL VIOLATOR
	HRRZ	AC1,PRJPRG(J)
	MOVEI	AC2,0		;COUNT SUM OF CORE SIZES.
JLCA10:	HRRZ	AC3,PRJPRG(TAC1)
	MOVM	DAT,JOBQUE(TAC1)	; PICK UP HIS QUEUE CODE
	CAME	AC1,AC3
	JRST	JLCA11
	CAIE	DAT,TQ		;ADD HIS CORE SIZE IF RUNNING OR LOCKED IN
	CAIN	DAT,RUNQ
	JRST	JLCA14
	CAIE	DAT,DIOWQ
	SKIPE	JBTST2(TAC1)	;SPACEWAR DOES THIS TOO
	JRST	JLCA14
	MOVEI	DAT,JLOCK
	TDNN	DAT,JBTSTS(TAC1)
	JRST	JLCA11

JLCA14:	PUSH	P,TAC1		;SAVE JOB NUMBER WE'RE THINKING ABOUT.
	PUSHJ	P,CORSGT	;GET HIS CORE SIZE IN TAC1
	ADDI	AC2,(TAC1)	;ADD IN TO CORE TOTAL
	MOVE	TAC1,(P)	;GET JOB NUMBER BACK
	LDB	TAC1,[POINT 6,JBTSTS(TAC1),35]
	JUMPE	TAC1,JLCA13
	MOVEI	DDB,JOBN-1	;HE GETS CHARGED FOR (1/N) OF HIS HIGH SEGMENT CORE
	MOVEI	UCHN,0		;WHERE N WILL BE THE NUMBER OF PEOPLE POINTING AT THIS SEGMENT
JLCA12:	LDB	DSER,[POINT 6,JBTSTS(DDB),35]
	CAMN	DSER,TAC1
	SKIPL	JBTSTS(DDB)	; ONLY IF HE IS ACTIVE
	CAIA
	ADDI	UCHN,1		; BUMP NUMBER OF JOBS POINTING TO THIS SEGMENT BY ONE
	SOJG	DDB,JLCA12
	PUSHJ	P,CORSGT	;GET THE SIZE OF THIS UPPER
	MOVE	TAC,TAC1
	IDIVI	TAC,(UCHN)	; GET HIS SHARE OF THE UPPER SEGMENT CORE
	ADD	AC2,TAC		; AND ADD IT IN TO THE TOTAL
JLCA13:	POP	P,TAC1
JLCA11:	SOJG	TAC1,JLCA10	; LOOP AROUND FOR NEXT JOB

	LSH	AC2,-=10	; CONVERT TO NUMBER OF 1K BLOCKS
	MOVSI	AC2,(AC2)	; PUT CORE IN K IN LEFT HALF
	MOVE	AC3,SLCOST	;AC3←1 OR 2 (LOW OR HIGH COST, RESPCTIVELY)
	IDIV	AC2,[=1000		;CONVERT TO ONE PERCENT FOR EACH
		  =500]-1(AC3)	;	10K (LO) OR 5K(HI) OF CORE
	POP	P,TEM		; GET PROCESSOR LEVEL
	ADD	TEM,AC2		; CALL THIS PROCESSOR LEVEL TOO.
	POP	P,AC2		; GET BACK HIS GSL
JLCA20:	CAMLE	TEM,AC2		; IS HE OVER HIS GUARANTEE?
	POPJ	P,		; YES, HE IS OFFICIALLY A SCROUNGER
	MOVSI	DDB,GRSPRI	; NO, GIVE HIM HIGH PRIORITY
	HLR	DDB,JBTNPR(J)	; WITH HIS REAL PRIORITY AS HIS LOW-ORDER BITS
	MOVEM	DDB,JBTNPR(J)
	POPJ	P,
>
SUBTTL	QCSS	24 JULY 67
;THIS ROUTINE MUST BE ASSEMBLED WITH THE CONFIGURATION
;TAPE TO DEFINE NUMBER OF JOBS
;THIS SECTION CONTAINS 2 ROUTINES FOR Q MANIPULATION
;AND NECESSARY TABLES FOR SPECIFING OPERATIONS PERFORMED
;BY THEM.



;STORAGE:
;EACH Q IS A RING STRUCTURED, FOWARD AND BACKWARD
;LINKED SRING LIST. THE "FIRST" LINK IN A Q IS
;A Q-HEADER POINTING TO THE FIRST AND LAST MEMBERS OF THE Q.
;A NULL Q HAS ONE LINK--THE Q-HEADER ITSELF.  THE LINKS MAKING
;UP THE QS ARE CONTAINED IN A TABLE (JBTQ) WITH NEGATIVE
;INDICIES (ADDRESSES LESS THAN JBTQ) USED FOR Q-HEADERS AND
;POSITIVE INDICIES USED FOR MEMBERS (JOBS). THUS ONLY ONE WORD
;PER LINK IS NECESSARY--ITS ADDRESS RELATIVE TO JBTQ GIVES THE
;JOB NO. (OR Q NO. IF NEGATIVE) WHICH IT REPRESENTS WHILE
;ITS CONTENTS CONTAINS THE LINKING POINTERS. THESE
;POINTERS ARE ALSO INDICIES RELATIVE TO JBTQ RATHER THAN
;ABSOLUTE ADDRESSES--RH(LINK)=FOWARD POINTER;
;LH(LINK)=BACKWARD POINTER.
;A JOB IS ASSUMED TO BE IN NO MORE THAN ONE Q AT A TIME, AND
;THE NULL JOB (JOB 0) DOES NOT APPEAR IN THE QS  (I.E. JBTQ
;ITSELF IS THE Q-HEADER FOR Q 0).

;ROUTINES:
;BOTH ROUTINES ARE "TABLE DRIVEN" IN THE SENSE THAT THE
;CALLING ROUTINE PROVIDES THE ADDRESS OF A TABLE WHICH
;DEFINES THE SPECIFIC OPERATIONS TO BE PERFORMED.
;QUEUE INITIALIZATION
;PUT ALL JOBS IN NULL QUEUE(JOB NO. NOT ASSIGNED)
;CALLED ON RESTART AT LOC. 143


↑QINI:
	MOVNI DDB,MXQUE		;MAKE ALL QUEUE HEADERS POINT TO THEMSELVES
	HRL DDB,DDB		;BACKWARD POINTERS TOO
	MOVEM DDB,JBTQ(DDB)
	AOBJN DDB,.-1
	MOVEI DDB,-NULQ		;PUT JOBS ALL IN NULQ QUEUE
	MOVSM DDB,JBTQ+1	;BACK POINTER FOR JOB 1
	MOVEI J,JOBN-1		;MAX. JOB NO.
	MOVEM DDB,JBTQ(J)	;FOR. POINTER OF JOBMAX JOB NO.
	HRLM J,JBTQ-NULQ	;SET NULQ HEADER TO POINT TO JOB1
	MOVEI DDB,1		;AND JOBMAX
	HRRM DDB,JBTQ-NULQ	;FORWARD POINTER
	MOVNI DSER,NULQ
QINI1:	HRRM J,JBTQ-1(J)	;JOB I-1 POINT TO JOB I
	MOVEM DSER,JOBQUE(J)
	SOJLE J,CPOPJ		;FINISHED?
	SETZM JBTQ
	HRLM J,JBTQ+1(J)	;BACK POINTER JOB I+1 POINTS TO JOB I
	JRST QINI1
;DELETES A JOB FROM ITS "SOURCE-Q", DETERMINES A "DEST-Q"
;ACCORDING TO ONE OF 3 FUNCTIONS, AND INSERTS THE JOB AT
;THE BEGINNING OR END OF THIS DEST-Q.
;THE DRIVING TABLES ARE "TRANSFER TABLES":
;
;
;T. TABLE:	XWD <0 OR -1>, -<QUEUE NUMBER>

;CALLING SEQUENCE:
;	MOVE  J,[JOB NUMBER]
;	MOVEI/HRROI DAT,TRANS TABLE ADDRESS	;DAT NEG MEANS GEN QXFER INT IF NECC
;	PUSHJ PDP,QXFER
;  ON RETURN J IS UNALTERED; LH(Q)=-1  IF QUANT. TIME NOT
;  RESET; =QUANT. TIME IF RESET;RH(Q)=DEST.Q

↑QXFER:	CAIGE	J,JOBN		;JOB NUMBER TOO HIGH?
	JRST	QXFER1		;J OK
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISERR
	[ASCIZ/ILLEGAL JOB NUMBER AT QXFER.
J=/]
	DISARG(DCP,<-20+J(P)>)
	[ASCIZ/
/]
	-1
	POPACS
	POPJ	P,
QXFER1:	JUMPGE DAT,QXFER2	;NO INT NEEDED IF POS
	MOVSI DSER,INTQXF	;DOES HE WANT INT ON Q XFER?
	TDNN DSER,JBTIEN(J)
	JRST QXFER2
	IORM DSER,JBTIRQ(J)
	SETOM INTREQ
QXFER2:	SETZM	SWPCNT		; FIRE UP SWAPPER WHEN THE SITUATION CHANGES
	AOS	NQXFERS		;COUNT A QUEUE TRANSFER
	MOVE	Q,(DAT)		;GET TRANSFER TABLE ADDRESS

	TLNE	Q,200000	;ARE WE NOW WAITING FOR THE SYSTEM?
	JRST	QXFER3		;YES
	MOVE	DSER,UPTIME	;NO, WE ARE WAITING FOR THE USER.
	SKIPGE	JBTWAT(J)	;WERE WE ALREADY WAITING FOR THE USER?
	ADDM	DSER,JBTWAT(J)	;NO.  NOTE THAT WE ARE NOW
	JRST	QXFER4

QXFER3:	MOVN	DSER,UPTIME	;WE ARE WAITING FOR THE SYSTEM
	SKIPL	JBTWAT(J)	;WERE WE ALREADY WAITING FOR THE SYSTEM?
	ADDM	DSER,JBTWAT(J)	;NO.  NOTE THAT WE ARE NOW
QXFER4:	HRRE DSER,Q		; SAVE QUEUE CODE IN DSER
	MOVM DSER,DSER		;GET THE Q CODE. PUT IT IN JBTSTS FOR THIS JOB
	CAIG DSER,MAXQ		;IF RELEVANT TYPE
	DPB DSER,[POINT JWSIZ,JBTSTS(J),JWPOS]

IFN FTSTAT, <			;GATHER STATISTICS.
	PUSH P,TAC
	LSH DSER,6
	MOVEI TAC,QUESTA(DSER)
	PUSHJ P,STAPUT
	POP P,TAC
>;FTSTAT

	MOVE	DSER,JBTQ(J)	;DELETE JOB FROM SOURCE-Q
	MOVS	UCHN,DSER	;DSER=FORW. LINK, UCHN=BACK LINK
	HRRM	DSER,JBTQ(UCHN)	;GO BACK AND LINK FORWARD PAST THIS JOB
	HRLM	UCHN,JBTQ(DSER)	;GO FORWARD AND LINK BACKWARD PAST THIS JOB
	CAME	Q,QRUNW		;ARE WE ENTERING THE RUN QUEUE?
	JRST	QXF3		;NO
	MOVE	AC2,JBTPRI(J)	;GET THIS GUY'S PRIORITY
	CAMGE	AC2,[3B2]	;SKIP IF BIG: WE WILL SCAN FORWARD
	JRST	QXSB		;SMALL PRIORITY: SCAN BACKWARDS.
	HRRE	DSER,JBTQ(Q)	;SEARCH AHEAD. PICK UP FORWARD LINK
	JUMPL	DSER,QXF3	;NO ONE HERE. THERE'S NO ORDERING NEEDED
QXF6:	CAML	AC2,JBTPRI(DSER)	;IS THIS THE RIGHT PLACE FOR HIM?
	JRST	QXF8		;YES. OUR (J) PRIORITY > HIS (DSER)
	HRRE	DSER,JBTQ(DSER)	;OUR PRIORITY IS SMALL, KEEP LOOKING
	JUMPGE	DSER,QXF6	;LOOP UNLESS END OF LIST, STICK HIM AT BOTTOM.
	JRST	QXF3		;GO STICK HIM IN AT THE BOTTOM.
QXF8:	HLRZ	UCHN,JBTQ(DSER)	;PUT US BEFORE DSER, AND AFTER DSER'S BACK LINK.
	HRLZM	UCHN,JBTQ(J)	;STICK HIS BACK LINK IN AS OUR BACK LINK.
	HRLM	J,JBTQ(DSER)	;STICK US IN AS DSER'S BACK LINK.
	HRRM	DSER,JBTQ(J)	;STICK DSER IN AS OUR FORWARD LINK.
	HRRM	J,JBTQ(UCHN)	;STUFF US IN AS UCHN'S FORWARD LINK.
	JRST	QXF4		;ALL DONE WITH TRANSFER.

QXSB:	HLRE	DSER,JBTQ(Q)	;SORTING IN FROM THE BOTTOM. FOLLOW BACK.
	JUMPL	DSER,QXF3	;JUMP IF Q IS EMPTY. PUT US IN THE END.
QXF5:	CAMG	AC2,JBTPRI(DSER)	;SKIP IF OUR PRIORITY ≥ HIS PRIORITY
	JRST	QXF9		;OUR PRIORITY IS SMALL. WE HAVE A HOME.
	HLRE	DSER,JBTQ(DSER)	;LINK BACKWARDS.
	JUMPGE	DSER,QXF5	;CONTINUE SCAN FOR A PLACE TO PUT US.
	JRST	QXF7		;WE BELONG AT TOP OF Q.

QXF9:	HRRZ	UCHN,JBTQ(DSER)	;WE BELONG BELOW DSER. GET DSER'S FORWARD LINK
	MOVEM	UCHN,JBTQ(J)	;SET OUR FORWARD LINK FROM DSER'S LINK.
	HRRM	J,JBTQ(DSER)	;SET US AS DSER'S FORWARD LINK.
	HRLM	DSER,JBTQ(J)	;SET DSER AS OUR BACKWARDS LINK
	HRLM	J,JBTQ(UCHN)	;SET US AS UCHN'S BACKWARDS LINK.
	JRST	QXF4		;ALL DONE.

;QXF3 IS TO ADD GUY AT THE END OF THE QUEUE
;QXF7 IS TO ADD GUY AT THE BEGINNING OF THE QUEUE

QXF3:	HLR	Q,JBTQ(Q)	;GET THE LAST LINK IN Q.
				;UCHN WILL BE SET TO THE Q-HEADER.
QXF7:	MOVE	UCHN,JBTQ(Q)	;UCHN IS FORWARD LINK AND Q IS Q-HEADER.
	HRRM	J,JBTQ(Q)	;SET FORWARD LINK:
				;F/ INSERT IN Q HEAD. B/ INSERT AT END.
	HRLM	J,JBTQ(UCHN)	;SET BACK LINK:
				;F/ INSERT IN FIRST.  B/ INSERT AT Q-HEAD.
	HRRZM	UCHN,JBTQ(J)	;SET OUR FORWARD LINK
	HRLM	Q,JBTQ(J)	;SET OUR BACK LINK.

QXF4:	JUMPL	Q,QNORUN	; RETURN IF QUANTUM TIME NOT REQUESTED

;HERE WE ARE IS JOB IS COMING INTO A RUN QUEUE

QFIX1:	SETZ	DSER,		;CLEAR WAIT STATE CODE IN JBTSTS:
	DPB	DSER,[POINT JWSIZ,JBTSTS(J),JWPOS]
	POPJ	P,		;RETURN
; JOB IS NOT RUNNING.  REQUEUE HIS SEGMENT IF NEEDED.

QNORUN:	CAMN	J,SEGWAIT	; WAS THIS GUY WAITING FOR HIGH SEGMENT?
	SETZM	SEGWAIT		; YES, NOT ANY MORE
	LDB	DSER,PSEGN	; DOES THIS JOB HAVE A HIGH SEGMENT?
	JUMPE	DSER,CPOPJ	; NO, FORGET IT
	MOVM	UCHN,JOBQUE(DSER)	; YES, IS IT IN SEGMENT WAIT QUEUE?
	CAIE	UCHN,SEGQ
	POPJ	P,		;NO, RETURN
	PUSH	P,J		;YES, IF NO ONE ELSE WANTS SEGMENT, REQUE IT
	MOVEI	J,JOBN-1	;LOOK THRU ALL THE WORLD.
QNORU1:	LDB	UCHN,PSEGN
	CAIE	UCHN,(DSER)	;SAME SEGMENT?
	JRST	QNORU3		;NOPE.
	MOVE	AC2,JBTSTS(J)	;GET JOB STATUS OF THIS GUY
	TLNE	AC2,SWP		; DOESN'T COUNT IF HE'S SWAPPED OUT
	JRST	QNORU3		;SO LOOK FOR SOMEONE ELSE.
	MOVM	UCHN,JOBQUE(J)	;AND HIS QUEUE
	CAIE	UCHN,RUNQ	;IS THIS GUY RUNNABLE?
	CAIN	UCHN,TQ
	JRST	QNORU4		;THIS GUY WANTS THIS SEGMENT!
QNORU3:	SOJG	J,QNORU1	;LOOP.
	MOVNI	DAT,STOPQ	;NO ONE CARES FOR THIS.
	MOVEM	DAT,JOBQUE(DSER)	
	MOVEI	DAT,QSTOPW	;NO RUNNABLE JOB USING THIS SEGMENT, REQUEUE IT
	MOVE	J,DSER
	PUSHJ	P,QXFER
QNORU4:	POP	P,J		;RETURN BY POPPING J.
	POPJ	P,		;AND POPJ.
;SCANS THE QS RETURNING THE NUMBERS OF THE JOBS IN THE QS.
;THE ORDER AND MANNER IN WHICH THE QS ARE SEARCHED IS
;DETERMINED BY A "SCAN TABLE" ADDRESSED IN THE CALLING SEQ.
;THE SCAN TABLE HAS THE FORM:
;
;SCANTAB:	XWD <Q1>,<CODE1>	;SCN Q1 ACCRDING TO CODE1
;		...
;		XWD <QN>,<CODEN>	;QN ACCORDING TO CODEN
;		Z		;ZERO TERMINATES TABLE
;
;EACH Q MAY BE SCANNED IN ONE OF FOUR WAYS SPECIFIED BY <CODE>
;THE CODES ARE:
;
;QFOR	SCAN WHOLE Q FOWARD
;QFOR1	SCAN FOR ONLY THE 1ST MEMBER (IF ANY)
;QBAK	SCAN WHOLE Q BACKWARD
;QBAK1	SCAN BACKWARD FOR ALL MEMBERS EXCEPT THE 1ST
;
;CALLING SEQ.
;
;	MOVEI DAT,SCAN TABLE ADDRESS
;	JSP PC,QSCAN	;SET UP PC FOR REPEATED RETURNS
;	...		;RETURN HERE WHEN NO MORE JOBS
;	...		;RETURN HERE WITH NEXT JOB IN AC J
;			;   AND ITS Q IN LH(QR)
;
;	PERFORM ANY NECESSARY TESTING OF THIS JOB
;	J,DAT,PC,QR MUST BE PRESERVED
;
;	JRST (QR)	;RETURN TO QSCAN TO GET NEXT JOB
;			;   IF THIS ONE NOT ACCEPTABLE
;
↑QSCAN:	SKIPN QR,(DAT)	;END OF SCAN TABLE?
	JRST (PC)	;YES--RETURN TO CALL+1
	HLRE J,QR	;NO--GET NO. OF Q
	JRST (QR)	;DISPATCH

QFOR1:	MOVEI QR,QFORB	;ONLY THE FIRST JOB

QFOR:	HRRE J,JBTQ(J)	;SCAN FOWARD ALL JOBS
	JUMPGE J,1(PC)	;RETURN THIS JOB NO. CALL+2 UNLESS--
QFORB:	AOJA DAT,QSCAN	;END OF THIS Q--GET NEXT Q

QBAK1:	HLRE J,JBTQ(J)	;SCAN BACKWARD ALL JOBS EXCEPT 1TT
	SKIPLE JBTQ(J)	;IS THIS THE FIRST MEMBER?
	JRST 1(PC)	;NO--RETURN CALL+2
	AOJA DAT,QSCAN	;YES--GET NEXT Q

QBAK:	HLRE J,JBTQ(J)	;SCAN BACKWARD ALL JOBS
	JUMPG J,1(PC)	;RETURN CALL+2 WITH JOB NO. UNLESS
	AOJA DAT,QSCAN	;BEG OF THIS Q--GET NEXT Q

QFOR2:	HRRE J,JBTQ(J)	; ALL BUT FIRST JOB
	HRRI QR,QFOR	; PUT UP NEW RESCAN ADDRESS
	JUMPGE J,QFOR	; IF NOT END OF QUEUE, GET SECOND JOB
	AOJA DAT,QSCAN	; END OF QUEUE, TRY NEXT ONE
DEFINE X'(A),<

↑A'Q←←ZZ
ZZ←←ZZ+1
>
	ZZ←←0
	QUEUES
	LOC←←ZZ
NQUEUE←←LOC		;NO. OF QUEUES COUNTING RUN QUEUE
XP MAXQ,NQUEUE-1	;MAX. STATE CODE WHICH HAS AN AVAL FLAG
XP MINQ,STQ		;MINIMUM SHARABLE DEVICE QUEUE
XP AVLNUM,MAXQ		;MAX. STATE CODE WHICH HAS AN AVAL FLAG

;DEFINE STATE CODES WHICH DO NOT HAVE AVAL AND REQ FLAGS


DEFINE X!(A)
<
↑A!Q←←LOC
LOC←←LOC+1
>
	CODES
	PQUEUES		; PROCESSOR QUEUES TOO!!
;CORRESPONDENCE TABLE BETWEEN JOB STATUS CODES AND QUEUE TRANSFER TABLES
;USED BY SCHEDULER
;RUNCSS SETS JOB STATUS WORD TO NEW STATE CODE.
;SCHEDULER SETS UP QUEUE TRANSFER TABLE ADDRESS FROM
;FOLLOWING TABLE USING NEW STATE CODE AS INDEX

DEFINE X!(A)
<	Q!A!W
>


↑QBITS:	QUEUES
	CODES
	PQUEUES


;400000,,0 BIT MEANS IS NOT RUNNABLE QUEUE
;200000,,0 BIT MEANS QUEUE REQUIRES WAITING FOR THE SYSTEM RATHER THAN THE USER

QFUCKW:
QTW:	XWD 200000,-TQ
QRUNW:	XWD 200000,-RUNQ
QSTW:	XWD 600000,-STQ		; SYST TAPE
QDTW:	XWD 600000,-DTQ		; DEC TAPE
QDCW:	XWD 600000,-DCQ		; DATA CONTROL WAIT
QMTW:	XWD 600000,-MTQ		; MAG TAPE
QIOWW:	XWD 400000,-IOWQ	; IOW(EXDEPT TTY) HELD IN IOWQ
QINTWW:	XWD 400000,-INTWQ	; INTERRUPT WAIT QUEUE
QDIOWW:	XWD 600000,-DIOWQ
QNULW:	XWD 400000,-NULQ	; NULL QUEUE JOB NO. NOT ASSIGNED
↑QSTOP:
QSTOPW:	XWD 400000,-STOPQ	; UNRUNABLE JOBS TO END OF STOPQ
↑QSEGW:	XWD 600000,-SEGQ	; SEGMENT WAIT QUEUE
QDWW:	XWD 400000,-DWQ		; DEVICE WAIT GOES BACK TO DEVICE WAIT
IFN FTSWAP,<
ISCAN:	;SCAN FOR INPUT
	XWD -SEGQ,QFOR	; SEGMENT WAIT QUEUE
	XWD -TQ,QFOR	; TELETYPE IO WAIT QUEUE
	XWD -RUNQ,QFOR
	XWD -DCQ,QFOR1
	XWD -STQ,QFOR1
	XWD -DTQ,QFOR1
	XWD -MTQ,QFOR1
	XWD -DCQ,QFOR2
	XWD -STQ,QFOR2
	XWD -DTQ,QFOR2
	XWD -MTQ,QFOR2
	0

; TABLE TO DECIDE ON WHICH JOB TO SWAP OUT
OSCAN:	XWD -STOPQ,QBAK	;UNRUNABLE JOBS FIRST
	XWD -MTQ,QBAK1
	XWD -DTQ,QBAK1
	XWD -STQ,QBAK1
	XWD -DCQ,QBAK1
	XWD -MTQ,QFOR1
	XWD -DTQ,QFOR1
	XWD -STQ,QFOR1
	XWD -DCQ,QFOR1
	XWD -DWQ,QBAK
	XWD -INTWQ,QBAK
	XWD -IOWQ,QBAK
	XWD -RUNQ,QBAK
	XWD -TQ,QBAK
	0

ALLRUNSCAN:
	XWD -TQ,QFOR
RUNSCAN:
	XWD -RUNQ,QFOR
	0

↑DVWSCAN:
	XWD -DWQ,QFOR
	0

TQSCAN:	XWD -TQ,QFOR
	0
;HERE RESIDES ALL THE SWAP IN LIST CODE -- RPH 1/15/74

;CALL WITH C(J)=JOB, C(TAC)=BIT TO SET
↑SETSIN:CONO PI,PIOFF
	SETZM SWPCNT			;RUN SWAPPER
	TDNE TAC,JBTSIN(J)		;BIT ON ALREADY?
	JRST PIONJ			;YES, LEAVE
IFN FTSTAT,<PUSH P,TAC
	PUSH P,TAC1
	JFFO TAC,.+1
	LSH TAC1,6
	MOVEI TAC,SINSTA+4000(TAC1)	;SETTING BIT
	PUSHJ P,STAPUT
	POP P,TAC1
	POP P,TAC
>;FTSTAT
	IORM TAC,JBTSIN(J)		;TURN IT ON
	ANDCA TAC,JBTSIN(J)		;PICK UP ALL OTHER BITS
	JUMPN TAC,PIONJ			;LEAVE IF ALREADY LINKED IN
	LDB TAC,PSINB0			;PUT AT END OF LIST
	DPB J,PSINB0			;NOW WE ARE END
	DPB TAC,PSINBJ			;AND WE POINT TO OLD LAST
	DPB J,PSINFT			;AND HE POINTS TO US
	SETZ TAC,
	DPB TAC,PSINFJ			;AND WE ARE END
	JRST PIONJ			;ALL DONE

;ENTER HERE WITH C(J)=JOB, C(TAC)=BIT(S) TO CLEAR
↑CLRSIN:CONO PI,PIOFF
	TDNN TAC,JBTSIN(J)		;IN CASE SOMEONE SNUCK IN
	JRST PIONJ
IFN FTSTAT,<PUSH P,TAC
	PUSH P,TAC1
	JFFO TAC,.+1
	LSH TAC1,6
	MOVEI TAC,SINSTA(TAC1)		;CLEARING BIT
	PUSHJ P,STAPUT
	POP P,TAC1
	POP P,TAC
>;FTSTAT
	ANDCAB TAC,JBTSIN(J)		;TURN OF REQUESTED BIT
	TLNE TAC,-1			;ANY BITS LEFT ON?
	JRST PIONJ			;YES, DON'T HAVE TO DE-LINK
	LDB TAC,PSINFJ			;GET OUR FORWARD LINK
	PUSH P,J			;USE J HERE
	LDB J,PSINBJ			;AND OUR BACKWARD LINK
	DPB J,PSINBT			;STORE OUR BACK IN OUR FORWARD
	DPB TAC,PSINFJ			;AND OUR FORWARD IN OUR BACK
	POP P,J
	SETZM JBTSIN(J)			;ZERO FOR TESTS
	JRST PIONJ			;ALL DONE

;ENTER HERE WITH J SETUP TO FLUSH ALL SWAPIN BITS (DOESN'T CLOBBER ACS)
↑FLUSIN:PUSH P,TAC			;KEEP THIS ROUTINE AUTONOMOUS
	MOVE TAC,JBTSIN(J)
	TLNN TAC,HLDSNB			;BITS WHICH MAY SET JHLDIN
	PUSHJ P,FLUHLD			;FLUSH
	TLNN TAC,JRDSNB
	JRST FLUSN1
	PUSHJ P,JRSRCH			;IF JOB READ BIT ON
	  JRDLOS			;SEND EVERYONE TO LOSE ROUTINE
FLUSN1:	MOVSI TAC,-1
	PUSHJ P,CLRSIN			;CLEAR ALL BITS
	POP P,TAC
	POPJ P,

;SEARCH FOR ALL OTHER JOBS TRYING TO READ THIS ONE (J)
;AND CALL SUBROUTINE FOLLOWING CALL ON JRSRCH
↑JRSRCH:PUSH P,J
	MOVEI J,JOBN-1			;SCAN ALL JOBS
JRSRC1:	HLRZ TAC,JBTFS(J)
	CAME TAC,(P)
	JRST JRSRC2
	MOVE TAC1,@-1(P)		;GET ROUTINE TO CALL
	PUSHJ P,(TAC1)			;CALL IT
JRSRC2:	SOJG J,JRSRC1
	POP P,J
	JRST CPOPJ1			;SKIP ROUTINE NAME

;FLUSH JHLDIN FROM UPPER OR LOWERS OF THIS JOB
↑FLUHLD:PUSH P,TAC
	PUSH P,J
	MOVE TAC,JBTSTS(J)
	TLNN TAC,JSEG			;SEGMENT?
	JRST FLUHL1			;NO, EASY
	MOVEI J,JOBN-1
FLUHL2:	LDB TAC,PSEGN			;GET HIS SEGMENT
	CAME TAC,(P)			;DOES THIS JOB POINT TO US?
	JRST FLUHL3			;NO
	MOVSI TAC,JHLDIN
	ANDCAM TAC,JBTSTS(J)
FLUHL3:	SOJG J,FLUHL2
FLUHL4:	POP P,J
	POP P,TAC
	POPJ P,

FLUHL1:	LDB J,PSEGN
	JUMPE J,FLUHL4			;ANY SEGMENT?
	MOVSI TAC,JHLDIN
	ANDCAM TAC,JBTSTS(J)		;CLEAR BIT IN UPPER
	JRST FLUHL4

;CALLED FROM SCNIN TO SWAP GUYS IN JBTSIN IN FIRST
GETSIN:	SETZ J,
	MOVEI QR,GETSN1
GETSN1:	LDB J,PSINFJ			;FOLLOW FORWARD LINK
	JUMPN J,(PC)			;GOT ANOTHER JOB
	JRST 1(PC)			;NO MORE
SUBTTL	SWAP	4 AUG 67

;SWAPPER CALLED EVERY CLOCK TIC.
;SINCE MOST OPERATIONS STARTED BY THE SWAPPER REQUIRE SEVERAL
;TICS TO RUN TO COMPLETION, SEVERAL FLAGS(FINISH,FIT,FORCE,
;XPANDF) ARE USED TO "REMEMBER" PREVIOUS STATES.
;THE BASIC ALGORITHM:
;IS CORE SHUFFLER WAITING FOR IO TO FINISH FOR SOME JOB?
;  YES--TRY AGAIN TO SHUFFLE(WHEN IO STOPS)
;IS CORE SHUFFLER STILL WAITING FOR IO TO FINISH?
;  YES--RETURN AND DO NOTHING
;IS SWAPPER STILL BUSY?
;  YES--RETURN AND DO NOTHING
;SCAN QS FOR 1ST JOB OUT OF CORE.
; IF NONE--RETURN
;A:
; IF ONE--WILL IT FIT IN LARGEST HOLE IN CORE?
;  YES--START INPUT AND RETURN
;  NO--IS TOTAL FREE CORE(CORTAL) ENOUGH TO ACCOMMODATE IT?
;    YES--CALL CORE SHUFFLER
;       IS SHUFFLER WAITING FOR IO TO STOP?
;         YES--RETURN AND DO NOTHING
;         NO--GO TO A:
;   NO--"REMBER" THIS JOB FOR INPUT AND LOOK FOR OUTPUT:
;ANY JOBS WAITING TO XPAND CORE BY SWAP OUT/IN?
; YES--OUTPUT ONE AND RETURN
; NO--SCAN QS BACKWARD FOR JOB IN CORE WHOSE PROTECT TIME
;		(SET ON INPUT) HAS GONE TO 0.
;  IF NONE--RETURN
;  IF ONE--IS IT SWAPPABLE?
;   YES--OUTPUT AND RETURN
;   NO--SET SWP BIT(FORCE JOB TO BECOME SWAPPABLE)--RETURN








;SOME DEVICE DEPENDENT CODE IS MARKED WITH A "*"
↑SWAP:	PUSH PDP,[SWPXIT]	; MAKE SURE WE EXIT THROUGH HERE
	SOSLE SWPCNT		;SHOULD WE RUN THE SWAPPER THIS TICK?
	POPJ PDP,		;NO.
	MOVEI TAC,500		; RUN THE SWAPPER EVERY SO OFTEN
	MOVEM TAC,SWPCNT
	SKIPE SHFWAT		;IS CORE SHUFFLER WAITING FOR IO TO STOP
				;FOR SOME JOB?
	PUSHJ PDP,CHKSHF	;YES, CALL CORE SHUFFLER TO SEE IF
				;IO STOPPED YET
	SKIPN SHFWAT		;IS SHUFFLER STILL WAITING?
	SKIPE SQREQ		;*NO--IS SWAP SERV. ROUT. STILL BUSY?
	POPJ PDP,		;*YES--RETURN
	SKIPN FBACT		; ARE WE SWAPPING ON FAST BANDS TODAY?
	JRST .+3		; NO, FORGET IT
	SKIPE SWPBSY		; YES, IS THE FAST BANS SWAPPER STILL BUSY?
	POPJ PDP,		; YES, COME BACK LATER
FINSWP:	SKIPN J,FINISH		;NO--ANY IN/OUTPUT TO FINISH?
	JRST SWP2		;NO-
	SETZM SWPCNT		; SET TO RESCAN NEXT TIME AROUND
	JUMPL J,FINOUT		;YES--INPUT OR OUTPUT?
; WE COME HERE TO FINISH A SWAPPING INPUT REQUEST

FININ:
	MOVEM J,LASTIN#
;RESTORE PARTS OF HIS JOB DATA AREA FROM JBTPDL IF IT WAS SAVED THERE....
	MOVE	DAT,JBTSTS(J)	;GET STATUS
	TLNN	DAT,JSEG	;SKIP IF THIS IS A SEGMENT
	TRZN	DAT,SAVJDA	;NOT A SEGMENT. DOES HE HAVE A DATA AREA SAVED?
	JRST	FININA		;SEGMENT OR NOT SAVED IN PDL
	SKIPN	JBTPDL(J)
	JRST	FININA		;CANT BE IN THE PDL IF THERE'S NO PDL.

	MOVEM	DAT,JBTSTS(J)	;NOT SAVED ON PDL ANYMORE.
	HRLZ	TAC1,JBTPDL(J)	;SOURCE (SORT OF)
	HRR	TAC1,JBTDAT(J)	;DESTINATION (SORT OF)
	ADD	TAC1,[<JBTPLN+JOBPRT-JOBPFI>,,JOBPRT]	;ADD OFFSETS.
	HRRZ	DAT,JBTDAT(J)
	BLT	TAC1,JOBPFI(DAT);RESTORE JOB DATA AREA TO USER CORE.
	
FININA:	SKIPE	DAT,SERA	;ANY INPUT ERRORS?
	JRST	INERR		;YES
	LDB	DAT,IMGOUT	;*INPUT--RETURN STORAGE TO DEVICE
	HLRZ	TAC,JBTSWP(J)	;*1ST BLOCK ADDR.
	PUSHJ	P,FXSAT		;*
	MOVE	JDAT,JBTDAT(J)
IFN JDMPRG,<
	MOVE	PROG,JBTADR(J)
>
	MOVE	DDB,JBTSTS(J)	;IS THIS A HIGH SEGMENT?
	TLNN	DDB,JSEG
	JRST	FININ5		;NOT A SEGMENT.
	PUSHJ	P,UAPPLY	;FOR ALL LOWERS OF THIS UPPER,
	 PUSHJ	P,SPWCNT	;CONTINUE SPACEWAR (ARGUMENT TO UAPPLY)
	SKIPN	AC1,SEGWAIT	
	JRST	FININ1		;SEGWAIT WASN'T SET.
	LDB	AC1,[POINT 6,JBTSTS(AC1),35]
	CAIE	AC1,(J)		;WAS THAT GUY WAITING FOR US?
	JRST	FININ1		;NO. SEGWAIT WASN'T SET ON OUT ACCOUNT
	SETZM	SEGWAIT		;IT WAS OUR FAULT. CLEAR SEGWAIT
	MOVNI	AC1,STOPQ
	MOVEM	AC1,JOBQUE(J)
	PUSHJ	P,REQUE		;QUEUE THIS SEGMENT BACK TO STOPQ
	JRST	FININ1
; HERE WE CONTINUE ANY SPW JOB THAT WAS ACTIVE AND GIVE SWAPIN INTS
; NOTE HERE THAT THE ONLY WAY I KNOW THAT A JOB WITH SPW ACTIVE CAN
; GET SWAPPED OUT IS IF IT EXPANDS ITS CORE SIZE, OR IF THE FREE
; STORAGE MECHANISM NEEDS THE 1K BLOCK THE JOB IS SITTING ON.

FININ5:	PUSHJ P,SPWCNT		; CONTINUE ITS SPW JOB, IF ANY
	MOVE DDB,JOBPC(JDAT)
	TLNE DDB,USRMOD
	JRST FININ1		;NO
	HRRZ DDB,JOBDPG(JDAT)	;YES, ADJUST PROG AND PDP IN DUMP AC AREA
	SUBI DDB,(PROG)		;OLD RELOC-NEW RELOC
	MOVNS DDB		;NEW RELOC-OLD RELOC
	HRRZ DSER,JOBDAC+PDP(JDAT); SEE IF DUMP PDL IS IN USER'S AREA
	CAMLE DSER,SYSSIZ	; IS IT ABOVE SYSTEM
	CAML DSER,MEMSIZ	; AND BELOW FREE STORAGE AREA?
	JRST FINZR2		; NO
	ADDM DDB,JOBDAC+PDP(JDAT)	; YES, RELOCATE PDL
FINZR2:	MOVEM PROG,JOBDPG(JDAT)	;STORE NEW AC PROG
FININ1:	LDB DSER,PSEGN		; # OF UPPER
	JUMPE DSER,FINZRL	;NONE IF 0
	MOVE DDB,JBTSTS(DSER)
	HLRZ DSER,JBTADR(DSER)	;PROTECTION OF UPPER
	JUMPN DSER,FINZR1
	LDB DSER,PSEGN
	LDB DSER,[POINT 8,JBTSWP(DSER),35]
	ASH DSER,12
	SUBI DSER,1
FINZR1:	TLNE DDB,JWP
	TLO DSER,400000		;FLAG WRITE PROT
	TRO DSER,400000		;MAKE IT UPPER SEG ADDR
FINZRL:	MOVSI DDB,SWP		;CLEAR SWP BIT
	ANDCAB DDB,JBTSTS(J)
	TLNN DDB,JSEG		;ONLY SET JOBRL2 FOR LOWERS
	CAMN DSER,JOBRL2(PROG)	;AND SEE IF ITS REALLY NECESSARY
	JRST FINZ1A
	SKIPE JBTPR2(J)
	JRST FINZ1A		;AVOID CLOBBERING PEEK-POKE JOBRL2
	SETOM STIME(J)		;MARK CORE IMAGE MODIFIED IF CHANGED
	MOVEM DSER,JOBRL2(PROG)	;SET NEW SEG2 JOBREL
FINZ1A:	HRRE	DSER,JBTLIN(J)
	JUMPL	DSER,FINDET	;DETACHED?
	MOVSI	DDB,DLYBIT
	CONO	PI,SCNOFF	;KEEP TTYSER OUT
	TDNN	DDB,TTYTAB(DSER);WAS HE DELAYED?
	JRST	NOTSET		;NO.
	MOVSI	DDB,COMBIT
	TDNE	DDB,TTYTAB(DSER);COMMAND ALREADY IN?
	JRST	NOTSET		;YES
	AOS	COMCNT		;NOW LOOK AT HIM AGAIN!
	IORM	DDB,TTYTAB(DSER);SET BIT
IFN FTTTYBUG,<
	PUSHJ	P,COMBCK
	PUSHJ	P,CNTCOM	;MAKE SURE ALL IS WELL
>
NOTSET:	CONO PI,SCNON
FINDET:	MOVSI DSER,INTSWD
	TDNN DSER,JBTIEN(J)
	JRST FININ2
	IORM DSER,JBTIRQ(J)
	PUSH P,J
	PUSHJ P,INTRUN
	POP P,J
FININ2:
; WE CLEAR JOB DATA AREA IF REQUIRED ALSO

	SETZM STIME(J)		; MARK FRESH IMAGE IN CORE
	SKIPN	BLTSWP		;ARE WE TESTING CORE IMAGE AFTER SWAP IN?
	JRST	FINAFB		;NO.
 
	SETCM	DDB,JBTADR(J)	;- SIZE IN LEFT
	HRR	DDB,JBTADR(J)	;GET ADDRESS IN RIGHT
	JUMPL	DDB,.+3
	MOVE	DSER,(DDB)
	AOBJP	DDB,.-1
	MOVE	DSER,(DDB)
	AOBJN	DDB,.-1

FINAFB:	MOVE DDB,JBTSTS(J)	; PICK UP JOB STATUS WORD AGAIN(MAY BE CLOBBERED BY INTRUN)
	TRZN DDB,WIPEJD		; MUST WE WIPE THE JOB DATA AREA?
	JRST FININS		; NO, GO AHEAD
	HRRM DDB,JBTSTS(J)
	MOVE PROG,JBTADR(J)
	PUSHJ P,CLRINI
FININS:
;HERE WE CHECK ALL THE SWAPIN BITS
	HLRZ TAC,JBTSIN(J)
	JUMPE TAC,NSINBT	;NO JBTSIN BITS ARE SET. SKIP THIS STUFF.
	PUSH P,J
	MOVSI TAC,HLDSNB	;BITS WHICH MAY CAUSE JHLDIN TO BE SET ELSEWHERE
	TDNE TAC,JBTSIN(J)
	PUSHJ P,FLUHLD		;FLUSH
	MOVSI TAC,INTSNB
	TDNN TAC,JBTSIN(J)	;INTERRUPT HANDLER TRYING TO GET HIM IN?
	JRST NOSINT		;NO
	PUSHJ P,CLRSIN		;YES, TURN OFF BIT
	PUSH P,HGCODE
	MOVEI TAC,7
	MOVEM TAC,HGCODE
	PUSHJ P,INTRUN
	POP P,HGCODE
	MOVE J,(P)		;RESET J
NOSINT:	MOVSI TAC,BATSNB	;PHANTON TRYING TO START UP?
	TDNN TAC,JBTSIN(J)
	JRST NOSBAT
	PUSHJ P,CLRSIN
	PUSHJ P,BATSW		;FINISH HIM OFF
	MOVE J,(P)
NOSBAT:	MOVSI TAC,JRDSNB	;JOB READ?
	TDNN TAC,JBTSIN(J)
	JRST NOSJRD
	PUSHJ P,CLRSIN
	PUSHJ P,JRSRCH		;FIND EVERYONE TRYING TO READ THIS JOB
	 JRDWIN			;AND SEND THEM HERE
	MOVE J,(P)
NOSJRD:	MOVSI TAC,COMSNB	;COMMAND WAIT?
	TDNN TAC,JBTSIN(J)
	JRST NOSCOM
	PUSHJ P,CLRSIN
	PUSH P,HGCODE
	MOVEI TAC,1
	MOVEM TAC,HGCODE
	SKIPE COMCNT
	PUSHJ P,COMMAND		;CALL COMMAND DECODER (NOTE THIS MAY NOT GET THE RIGTH GUY)
	POP P,HGCODE
NOSCOM:	POP P,J
	MOVSI TAC,SPWSNB
	TDNE TAC,JBTSIN(J)	;FORCED OUT BY FS OR LOCK AND SPACEWAR ACTIVE?
	PUSHJ P,CLRSIN		;YES. JUST CLEAR BIT.
NSINBT:	
;CHECK IF UPPER WANTS IN
	MOVE DSER,J
	LDB J,PSEGN		; DOES THIS JOB HAVE AN UPPER?
	JUMPE J,SWAPSCAN	; NO, SCAN FOR MORE INPUT
	MOVE DDB,JBTSTS(J)
	TLNN DDB,SWP		; IS HIGH SEGMENT SWAPPED OUT?
	JRST SWAPSCAN		; NO
	MOVM UCHN,JOBQUE(DSER)
	CAIE UCHN,RUNQ		;LOWER RUNABLE?
	CAIN UCHN,TQ
	PUSHJ P,FININ7		;YES, CAUSE UPPER TO COME IN
	LDB TAC,IMGIN		; NOW, CAN UPPER FIT IN NOW?
	CAMG TAC,BIGHOL
	JRST INJOB		; YES, GET IT
	JRST SWAPSCAN

FININ7:	MOVNI DAT,SEGQ
	MOVEM DAT,JOBQUE(J)
	SKIPN SEGWAIT
	MOVEM DSER,SEGWAIT	; MAKE SURE THIS GUY STAYS AROUND!
	MOVEI DAT,QSEGW
	JRST QXFER
;HERE THERE'S A SWAPIN ERROR.

INERR:	SKIPN	FBACT			;LIBRASCOPE FAST BANDS?
	TRNE	DAT,IODTER!IODERR	;NO. IBM DISK.  ANY ERRORS?
	JRST	.+2			;L'SCOPE OR IBM ERRORS.
	JRST	FININ8			;GO TRY DOING INPUT AGAIN.
	MOVE	DDB,JBTSTS(J)
	TLNN	DDB,JSEG
	JRST	INERNS			;THIS WAS A LOWER.
	SKIPE	FBACT
	SKIPE	FIRSTOUT
	JRST	INERNS			;WE HAVE NO SPARE COPY (THAT WORKS)
;THIS IS A WRITE PROTECTED UPPER. TRY TO SWAP IN THE SPARE.
	SETOM	FIRSTOUT		;FLAG TO AVOID COMING HERE AGAIN.
	SETZM	SERA			;CLEAR SWAPPER ERROR FLAG
	LDB	DDB,IMGIN		;THIS IS LIFTED DIRECTLY FROM INJOB
	LDB	TAC,IMGOUT
	CAML	DDB,TAC
	MOVE	DDB,TAC
	LSH	DDB,=18+=10
	MOVN	TAC1,DDB
	HRR	TAC1,JBTADR(J)
	MOVE	DAT,[XWD J,JB2SWP]
	HLRZ	DSER,JBTSWP(J)
	ADDI	DSER,1
	HRRZS	JBTSWP(J)		;NO PRIMARY SWAPPING BANDS IN USE
	JRST	FBIREQ

FININ8:	SETZM	FIRSTOUT		;FOR IBM DISK ERRORS, WE TRY AGAIN
	SETZM	FIT
	JRST	INJO1
;ERROR AND NOT WRITE PROTECTED SEGMENT, OR LOWER.

INERNS:	PUSHJ P,FLUSIN
	MOVE DDB,JBTSTS(J)	; IS THIS A HIGH SEGMENT?
	TLNN DDB,JSEG
	JRST INERR7		;NO.

	MOVSI DDB,SWP		; YES, CALL KILSEG ON ALL JOBS THAT POINT TO THIS SEGMENT
	ANDCAM DDB,JBTSTS(J)
	MOVE AC1,PRJPRG(J)
	MOVEM AC1,JOBNAM(J)	; MAKE SURE NO ONE WILL ATTATCH TO HIM
IFN FTSTAT,<PUSHJ P,NAMSTT>

	PUSHJ	P,UAPPLY
	 PUSHJ	P,SEGERR	;CALL SEGERR FOR EACH LOWER.
	JRST	SWAPSCAN


;TRY TO RECONSTRUCT JOB DATA AREA

INERR7:	MOVE PROG,JBTADR(J)
	SETZ DAT,
	SKIPN TAC,JOBHCU(PROG)	; ANY IO CHANNELS?
	JRST INERC0		; NO, REGENERATE ANY WHAT MAY EXIST
	MOVEI TAC1,JOBJDA(PROG)	; SCAN THEM ALL AND CHECK FOR VALIDITY
	HRLI TAC1,TAC
INERJL:	SKIPN DDB,@TAC1		; PICK UP ADDRESS OF IO DDB
INERJ1:	SOJGE	TAC,INERJL
	JUMPL	TAC,INERCN	;IF ALL CHECKED OUT OK, GO ON
	HRRZ	DDB,DDB
	CAIL	DDB,CHKBEG	;DDB IN SYSTEM LOW CORE?
	CAML	DDB,MEMSIZ	;NO. IN FREE STORAGE?
	CAML	DDB,RMEMSIZ	;MUST BE IN PHYSICAL CORE.
	AOJA	DAT,INERR1	;LOSER.
	AOJA	DAT,INERJC	;IS OK.
; HERE WE CHECK THE NUMBER OF DDB'S HE HAS, ALSO REGENERATE JOB DATA AREA

INERC0:	SETZM JOBJDA(PROG)	; MAYBE NO CHANNELS??????
INERCN:	SETZ TAC,
	HLRZ DDB,DEVLST		; COUNT NUMBER OF DDB'S ON CHAIN THAT ARE HIS
INERC1:	MOVE AC1,DEVMOD(DDB)
	TRNN AC1,ASSPRG		; DOES HE HAVE IT INITED?
	JRST INERC2
	LDB AC1,PJOBN
	CAIN AC1,(J)
	ADDI TAC,1
INERC2:	HLRZ DDB,DEVSER(DDB)
	JUMPN DDB,INERC1
	CAIN DAT,(TAC)		; DID WE CHECK AS MANY AS WE FOUND?
	JRST INERR4		; YES, ALL IS WELL
	JRST INERR1		; NO, REGENERATE DATA AREA

INERJC:	LDB AC1,PJOBN		; NOW CHECK JOB NUMBERS
	CAIN AC1,(J)
	JRST INERJ1
INERR1:	MOVE PROG,JBTADR(J)
	PUSHJ P,CLRJB1		; CLEAN IT OUT
	SETZM JOBHCU(PROG)
	MOVEI DSER,JOBJDA(PROG)
	HLRZ DDB,DEVLST
INERR2:	SETZM (DSER)
	MOVE UCHN,DEVMOD(DDB)
	TRNN UCHN,ASSPRG	; DOES HE HAVE IT INITED??
	JRST INERR3
	LDB UCHN,PJOBN		; DOES THIS DDB BELONG TO HIM?
	CAME UCHN,J
	JRST INERR3
	MOVEM DDB,(DSER)	; YES, PUT ITS ADDRESS IN JOBJDA
	AOS JOBHCU(PROG)
	ADDI DSER,1
INERR3:	HLRZ DDB,DEVSER(DDB)	; MOVE DOWN TO NEXT DDB
	JUMPN DDB,INERR2
	PUSHJ P,ESTOP
INERR4:	MOVE DSER,JOBHCU(PROG)
	MOVSI DAT,GOBIT
INERRG:	MOVEI DDB,JOBJDA(PROG)
	ADD DDB,DSER
	MOVE DDB,(DDB)
	MOVE UCHN,DEVMOD(DDB)
	TLNE UCHN,DVDSK!DVUDP
	ANDCAM DAT,DEVIOS(DDB)	;CLEAR GOBIT SO USER DOESN'T HANG
	SOJGE DSER,INERRG
	MOVM J,FINISH
INERR6:	MOVSI DDB,SWP
	ANDCAM DDB,JBTSTS(J)
	SETZM XPANDF
	SETZM FINISH
SEGERR:	CAMN J,SEGWAIT
	SETZM SEGWAIT
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/
SWAP READ ERROR /
	PUSHJ	P,DISJOB
	PUSHJ	P,DISCRLF
	POPACS
	PUSHJ P,TTYERP
	PUSHJ P,INLMES
	ASCIZ /SWAP READ ERROR/
	PUSHJ P,PRCRCC
	PUSHJ P,TTYSTC
	MOVE AC1,JBTSTS(J)
	TLNE AC1,JLOG		; IS HE REALLY LOGGED IN?
	JRST STOP1
	JRST ESTOP
; ROUTINE TO RELEASE A JOB'S SWAPPING BANDS (LIBRASCOPE ONLY)

GIVEBANDS:
	SKIPN FBACT
	POPJ P,
	HLRZ UCHN,JB2SWP(J)
	SKIPN UCHN
	HLRZ UCHN,JBTSWP(J)
INERX:	PUSHJ P,FBGIVE
	CAIE UCHN,MAXFB
	SOJA UCHN,INERX
	HRRZS JBTSWP(J)
	HRRZS JB2SWP(J)
	POPJ P,
; AND HERE IS WHERE WE GO TO FINISH A SWAP OUTPUT REQUEST

FINOUT:
	MOVNS J			;FINISH OUTPUT, -FINISH=JOB NO.
	SKIPN SERA		;ANY ERRORS
	JRST FINOU1
	PUSHJ P,GIVEBANDS	; RELEASE ALL HIS BANDS AND TRY AGAIN
	JRST OUTJOB

FINOU1:	SKIPE FBACT
	SKIPE FIRSTOUT
	JRST OUTP1
	MOVE DDB,JBTSTS(J)
	TLNN DDB,JSEG
	JRST OUTP1
	SETOM FIRSTOUT
	HLRZ DDB,JBTADR(J)
	MOVNM DDB,TAC		; IF A WRITE-PROTECTED UPPER, SWAP OUT A SPARE COPY
	HRRZ TAC1,JBTADR(J)
	HRLI TAC1,-1(TAC)
	MOVE DAT,[XWD J,JB2SWP]
	HLRZ DSER,JBTSWP(J)
	ADDI DSER,1
	JRST FBOREQ

OUTP1:	MOVEI TAC,0		;RETURN CORE
	MOVE PROG,JBTADR(J)	;XWD PROTECT.,RELOC.
IFN JDMPRG,<
	MOVE JDAT,JBTDAT(J)	;JOB DATA AREA
>
	PUSHJ PDP,CORE0
	JSP DAT,CERROR		;SHOULD NEVER HAPPEN
	SKIPN	FSCLKF		;FREE STORAGE FORCING USERS?
	SKIPE	LOCKNO		;NO. LOCK UUO FORCING?
	TDZA	TAC,TAC		;THIS GUY IS BEING FORCED BY FS OR LOCK (ZERO TAC) 
	JRST	SWAPSCAN
	MOVE	DDB,JBTSTS(J)
	TLNE	DDB,JSEG	;SEGMENT?
	PUSHJ	P,UAPPLY	;YES. APPLY ROUTINE TO ALL LOWERS
	PUSHJ	P,PSPWAC	;IS SPACEWAR ACTIVE FOR THIS USER? (SET TAC)
	JUMPE	TAC,SWAPSCAN	;NO.
	PUSHJ	P,SETSIN	;FORCE THIS GUY TO GET SWAPPED IN

SWAPSCAN:
	SETZM	XPANDF		;CLEAR XPANDING JOB OUTPUT TO DISK FLAG
	SETZM	FINISH		;CLEAR FINISH FLAG
SWP2:	SKIPE	J,FORCE		;WAITING FOR JOB TO BECOME SWAPPABLE?
	JRST	FORCE1		;YES
	SETZM	FIT		;RESCAN FOR INPUT NEXT TIME
	SKIPE	XJOB		;IS THERE SOMEONE WHO WANTS TO BE KICKED OUT?
	JRST	SCNIN		;YES.  SCNIN WILL DO IT (BELIEVE IT OR NOT)
	SKIPGE	FSCLKF		;ARE WE WAITING FOR FREE STORAGE?
 	POPJ	P,		;YES.
	SKIPG	J,LOCKNO	;ARE WE WAITING FOR A JOB TO BE LOCKED IN?
	JRST	SCNIN		;NO.
	MOVE	DDB,JBTSTS(J)	;IS THE LOCKING JOB STILL IN CORE?
	TLNN	DDB,SWP		;
	POPJ	P,		;JOB IS STILL IN CORE. FOREGO SWAPIN UNTIL LOCKNO=0
	JRST	SCNINX		;J AND DDB ARE SET TO GET THIS GUY IN.


PSPWAC:	SKIPN	SPWGO(J)
	SKIPE	SP2GO(J)
	MOVSI	TAC,SPWSNB	;INDICATE WE HAVE SPACEWAR ACTIVE
	POPJ	P,
;SCAN FOR INPUT - LOOK FOR A JOB ON THE DISK WHICH OUGHT TO COME IN.
JN←←TEM

SCNIN:
	HGMAC	(2)		;TELL HG ROUTINES WE ARE IN SCNIN

;FORCE EXPANDING JOBS OUT before SCAN FOR INPUT
	PUSHJ	P,XPAND1	;CHECK XPANDING JOB FIRST
	SKIPN	SQREQ		;*WERE THERE ANY?
	SKIPE	FORCE
	POPJ	P,		;YES
	SKIPN	FBACT		; ARE WE SWAPPING IN FBPACK TODAY?
	JRST	.+3		; NO
	SKIPE	SWPBSY		; YES, IS THE FBPACK SWAPPER BUSY?
	POPJ	P,		; YES, LEAVE NOW

	PUSHJ P,GCMAX		;GET TOTAL AMOUNT OF AVAILABLE CORE (CORE IS 
	MOVEM AC3,CORMX		;AVAILABLE IF NOT OCCUPIED BY SYSTEM OR SPW JOBS)
				;OR LOCKED CORE.
	JSP PC,GETSIN
	JRST SCNINZ		;FOUND A JOB IN SWAP IN LIST
	MOVEI DAT,ISCAN		;NO MORE IN SWAP IN LIST, TRY QUEUES
	JSP PC,QSCAN		;C(J)← NEXT MOST IMPORTANT JOB TO SWAP IN
	POPJ	P,		;(THERE IS NO NEXT MOST IMPORTANT JOB)
SCNINZ:	MOVE DDB,JBTSTS(J)	;THIS JOB OUT OF CORE?
	TLNN DDB,SWP
	JRST (QR)		;NO--CONTINUE SCAN
	
SCNINX:	LDB TAC,IMGIN		;YES--WILL IT FIT IN BIGGEST HOLE?
SCNIN1:
IFN FTSTAT,<
	PUSH P,TAC
	MOVEI TAC,FITSTA
	PUSHJ P,STAPUT
	POP P,TAC
>;FTSTAT
	CAMG TAC,BIGHOL
	JRST INJOB		;YES
	MOVEM J,FIT		;NO--SET FIT FLAG
	
	
SCNIN2:	MOVE DDB,JBTSTS(J)
	TLNE DDB,JSEG		;IS THIS JOB AN UPPER SEGMENT?
	JRST DEADUP		;  YES
	LDB DDB,PSEGN		;GET NUMBER OF THIS JOB'S UPPER SEGMENT
	MOVE DSER,JBTSTS(DDB)
	TLNN DSER,SWP		;IS UPPER SEGMENT IN CORE?
	JRST DEADR1		;  YES, (OR ELSE THERE IS NO UPPER)
	LDB DSER,IMGINT		;C(DSER) ← INCORE IMAGE SIZE OF THE UPPER
	ADD TAC,DSER		;C(TAC) ← CORZ SIZE OF SWAPPED OUT PORTION OF JOB
DEADR1:	MOVE AC3,CORMX		;AC3 ← TOTAL CORE SPACE AVAILABLE TO OUR JOB
	SKIPN TAC1,DDB		;DOES THIS JOB HAVE AN UPPER SEGMENT?
	JRST DEADR9		;  NO
	PUSHJ P,GCMCK		;  YES, IS IT'S SIZE ALREADY REFLECTED IN CORMX?
	JRST DEADR9		;  YES
	PUSHJ P,CORSGT		;  NO, C(TAC1) ← SIZE OF UPPER SEGMENT
	SUB AC3,TAC1		;AC3 ← (AVAILABLE CORE) - (UPPER CORE SIZE)
DEADR9:	LDB DDB,IMGIN
	LSH DDB,=10		;DDB ← CORE SIZE OF JOB (LOWER SEG ONLY)
	CAMG DDB,AC3		;WILL WE FIT INTO AVAILABLE CORE?
	JRST SCNIN9		;  YES
	PUSHJ P,DEADLOCK	;  NO
	JRST (QR)		;CONTINUE SCAN FOR A JOB TO SWAP IN
; "DEADUP" IS CALLED FROM NEAR SCNIN2, IF THE JOB TO BE SWAPPED IN IS AN
;UPPER SEGMENT AND NO SINGLE HOLE IS LARGE ENOUGH TO CONTAIN IT;
;	CODE BY JAM		COMMENTS BY JHS

DEADUP:	SETZB DSER,JN
	SETZM ISONE
	MOVE DDB,J
	MOVEI J,JOBN-1		;SCAN JOB TABLE, LOOKING FOR OUR LOWERS
DEADU1:	LDB UCHN,PSEGN
	CAIE UCHN,(DDB)		;IS THIS JOB POINTING TO US?
DEADU2:	SOJG J,DEADU1		;  NO, CONTINUE SCAN
	JUMPE J,DEADU3		;JUMP WHEN SCAN COMPLETED
	MOVE UCHN,JBTSTS(J)
	TLNN UCHN,JHLDIN	;LOWER HOLDING?
	SKIPE JBTSIN(J)
	JRST DEADU7		;COMING IN
	MOVM UCHN,JOBQUE(J)	;IF OUR LOWER IS
	CAIE UCHN,RUNQ		;IN RUNQ OR TQ
	CAIN UCHN,TQ		;THEN GO TO DEADU7
	JRST DEADU7		;ELSE CONTINUE SCAN
	MOVE UCHN,JBTMSK(J)
	AND UCHN,JBTIEN(J)
	AND UCHN,JBTIRQ(J)
	JUMPN UCHN,DEADU7
	SKIPN JBTST2(J)
	JRST DEADU2		;NONE OF THE ABOVE, CONTINUE SCAN
DEADU7:	MOVE TAC1,JBTSTS(J)
	TLNE TAC1,SWP		;THIS LOWER OF OURS IS SWAPPED OUT?
	JRST DEADUC		;	YES
	HLRZ TAC1,JBTADR(J)
	ADDI TAC1,1
	LDB UCHN,IMGINT
	LSH UCHN,=10
	ADDI TAC1,(UCHN)	;C(TAC1) ← COMBINED SIZE OF LOWER AND UPPER
	CAMG TAC1,CORMX		;BOTH WILL FIT IN CORE AT ONE TIME?
	SETOM ISONE		;  YEP, INDICATE THAT THERE ISONE THAT FITS
DEADUC:	MOVE TAC1,J
	PUSHJ P,CORSGT		;C(TAC1) ← SIZE OF LOWER
	CAMG TAC1,DSER		;HAS SUCH A LARGE LOWER BEEN FOUND BEFORE?
	JRST DEADU2		;  NO, CONTINUE SCAN FOR LOWERS
	MOVE DSER,TAC1		;  YES, REMEMBER SIZE IN DSER
	MOVE JN,J		;   AND REMEMBER JOB# IN JN
	JRST DEADU2		;	AND CONTINUE SCAN
	
DEADU3:	JUMPN JN,DEADU4		;ARRIVE HERE WHEN SCAN FOR LOWERS COMPLETE
	MOVE J,DDB		;ARRIVE HERE IF WE HAVE NO LOWERS ! (?)
	JRST (QR)		;DON'T BRING IN UPPER, LOOK FOR SOME OTHER
				;  JOB TO SWAP IN
; THIS SENDS THE MESSAGE TO A DEADLOCKED LOWER
	
DEADU4:	MOVE J,JN		;C(JN) = JOB# OF LARGEST LOWER SEGMENT
	MOVE UCHN,TAC		;C(TAC) = SIZE OF UPPER SEGMENT
	LSH UCHN,=10
	ADD UCHN,DSER
	CAMG UCHN,CORMX		;WILL LARGEST LOWER BE LOCKED OUT?
	JRST SCNIN9		;  NO, GO SHUFFLE ETC.
	PUSH P,DDB		;  YES, ETC.
	CAMN J,SEGWAIT
	SETZM SEGWAIT
	PUSHJ P,DEADLOCK
	POP P,J
	SKIPN ISONE
	JRST (QR)
	JRST SCNIN9

		;NOTE:  IF MORE THAN ONE LOWER IS SO LARGE THAT
		;  IT TOGETHER WITH THE UPPER WON'T FIT, THEN ONLY
		;  ONE OF THEM WILL GET THE DEADLOCK MESSAGE,
		;  AND THIS IS PROBABLY A BUG.
; HERE WE SEE IF JOB CAN EVER FIT. IF SO, TRY TO COMPACT CORE TO GET HIM IN
; IF NOT, SCAN FOR SOMEBODY ELSE

SCNIN9:	MOVEI DDB,SDEAD1	; J MAY CONTAIN THE NUMBER OF THE LOWER HERE
	ANDCAM DDB,JBTSTS(J)	; TELL SOMEONE WE GOT HIM IN.
	CAMLE TAC,CORTAL	; ENOUGH FREE CORE TO EVENTUALLY
				;FIT IN CORE?
	JRST SCNOUT		;NO, SCAN FOR SOME JOB TO OUTPUT TO MAKE ROOM
	PUSHJ PDP,CHKSHF	;YES, CALL CORE SHUFFLER TO MOVE JOBS AROUND
	SKIPN FORCE		;REG 12/3/73 SHUFFLER CAN SET FORCE!
	SKIPE SHFWAT		; SHUFFLER WAITING FOR IO OR SPW?
	POPJ PDP,		; YES, GOODBYE
	MOVE J,FIT		; NO, SEE IF WE WILL FIT NOW
	LDB TAC,IMGIN
	CAMG TAC,BIGHOL
	JRST INJOB
	HGMAC	(2)
	JRST SCNIN2

RESCNIN:
	MOVEI DAT,ALLRUNSCAN
	JSP PC,QSCAN
	JRST NOFIT
	MOVE DDB,JBTSTS(J)
	TLNN DDB,SWP
	JRST (QR)
	LDB TAC,IMGIN
	LDB DDB,PSEGN		; SECOND SEGMENT NUMBER
	JUMPE DDB,RESCN2
	MOVE DSER,JBTSTS(DDB)
	TLNN DSER,SWP
	JRST RESCN2
	LDB DSER,[POINT 8,JBTSWP(DDB),35]
	ADD TAC,DSER
RESCN2:	CAMLE TAC,CORTAL
	JRST (QR)
	LDB TAC,IMGIN
	JRST SCNIN1
; HERE WE HAVE DETECTED A CORE DEADLOCK

DEADLOCK:
	MOVEI DDB,SDEADIN
	TDNE DDB,JBTSTS(J)
	POPJ P,			; WE KNOW ABOUT HIM
	PUSH P,J
	TRO DDB,SDEAD1		;NOTE REALLY DEAD AT THIS TIME.
	ORM DDB,JBTSTS(J)	; MARK IT AS DETECTED
	PUSHJ P,GCS
	CAMLE DSER,CORMAX	; IS HE TOO BIG ALTOGETHER, OR IS SOMEONE KEEPING HIM OUT
	JRST DEADL2		; TOO BIG ALTOGETHER.
	PUSHJ P,HALFIN
	JRST DEADL1

HALFIN:	LSH J,=12		; SOMEBODY'S FAULT. TELL HIM ABOUT IT.
	ADD J,[XWD HALFD,=30*JIFSEC]
PLANT:	CONO PI,PIOFF
	IDPB J,CLOCK(PID)
	CONO PI,PION
	POPJ P,

DEADL2:	PUSHJ P,DEACLN
DEADL1:	POP P,J
	POPJ P,

DEACLN:	LSH J,=12
	ADD J,[XWD SDEAD,=15*JIFSEC]
	JRST PLANT		;GO PLANT IT
; CLOCK REQUEST TIMES OUT IN 15-SOME-ODD-SECONDS AND COMES HERE:

SDEAD:	MOVEI J,SDEADIN
	ANDCAB J,JBTSTS(TAC)	;CLEAR SDEADIN (NO MORE CLOCK REQUESTS).
	TRNN J,SDEAD1		;HAS HE BEEN IN SINCE DETECTION?
	POPJ P,			;YES
	MOVE J,TAC
	PUSHJ P,GCS
	CAMG DSER,CORMAX
	POPJ P,
	MOVM DDB,JOBQUE(J)	; SEE IF HE HAS STOPPED HIS JOB
	CAIN DDB,STOPQ
	JRST DEACLN		; YES, WE WILL GIVE HIM SOME TIME
	PUSHJ P,FLUSIN		;FLUSH FROM SWAP IN LIST
	PUSH P,J
	LDB J,PSEGN
	SKIPE J
	PUSHJ P,FLUSIN		;ALSO UPPER
	POP P,J
	PUSHJ P,TTYERP		; FIND HIS TTY FOR HIM
	PUSHJ P,INLMES
	ASCIZ /CORE DEADLOCK.

/
	PUSHJ P,PRCRCC
	PUSHJ P,TTYSTC
	JRST STOP1

HALFD:	MOVE J,TAC
	MOVM AC3,JOBQUE(J)
	MOVE TAC,JBTSTS(J)
	CAIE AC3,STOPQ		;CLEAR BIT IF HE STOPPED HIMSELF
	TRNN TAC,SDEAD1		;HAS HE BEEN IN SINCE DETECTION?
	JRST KILLIN
	PUSHJ P,GCS
	CAMG DSER,CORMAX
	JRST HALFD1
	PUSH P,J
	JRST DEADL2
HALFD1:	PUSH P,DSER
	PUSHJ P,GCMAX
	POP P,DSER
	CAMG DSER,AC3
	JRST KILLIN
	PUSHJ P,TTYERR			;THIS GUY ONLY SETS ERROR BIT
					;DOESN'T CLEAR INPUT UNLESS NECESSARY
	PUSHJ P,INLMES
	ASCIZ /
YOU ARE LOCKED OUT OF CORE!
/
	MOVSI IOS,USRB
	IORB IOS,DEVIOS(DDB)
	PUSHJ P,TTYSTR
	JRST HALFIN

KILLIN:	MOVEI DDB,SDEADIN
	ANDCAM DDB,JBTSTS(J)
	POPJ P,
;	GCMAX - ROUTINE TO CALCULATE HOW MUCH CORE IS AVAILABLE FOR A
;	JOB ON THE DISK WHICH WANTS TO COME IN.  CORE IS CONSIDERED
;	TO BE AVAILABLE IF IT IS USER CORE NOT OCCUPIED BY SPW JOBS.

GCMAX:	SETZM	GCBITS			;72 BITS FOR REMEMBERING
	SETZM	GCBITS+1
	MOVE	AC3,SYSTOP		;COMPUTE -(LOKTOP-SYSTOP)
	SUB	AC3,LOKTOP		;LOCKED CORE SIZE = LOKTOP-SYSTOP
	ADD	AC3,CORMAX		;ADD SIZE FROM SYSTOP TO MEMSIZ
	SKIPG	SPWACT			;ANY ONE IN SPW MODE?
	POPJ	P,			;NO. THIS IS SIMPLE
	PUSH	P,DDB
	PUSH	P,[POINT 6,SPWGO(JN),5]	;GET A BYTE POINTER
	PUSHJ	P,GCLP			;CALL THINK ABOUT P1 SPW JOBS
	MOVE	DSER,[POINT 6,SP2GO(JN),5];GET ANOTHER BYTE POINTER
	MOVEM	DSER,(P)		;STUFF IT WHERE GCLP WILL SEE IT
	PUSHJ	P,GCLP
	SUB	P,[1,,1]		;ADJUST STACK(A LESS USEFUL COMMENT-FW)
	POP	P,DDB
	POPJ	P,

GCLP:	MOVEI	JN,0			;INITIALLY LOOK AT LIST BASE
GCLP1:	LDB	JN,-1(P)		;GET NUMBER OF SOME SPW JOB.
	JUMPE	JN,CPOPJ		;0 MEANS END OF LIST.
	SKIPN	JBTST2(JN)		;SKIP IF SPACEWAR IS ACTIVE
	JRST	GCLP1			;NOT STILL ACTIVE
	MOVEI	DDB,(JN)		;GET JOB NUMBER INTO DDB
	PUSHJ	P,GCMCK			;HAVE WE SEEN THIS JOB BEFORE?
	JRST	GCLP1			;YES. DON'T COUNT AGAIN
	MOVEM	IOS,GCBITS(DSER)	;SO WE WON'T COUNT THIS JOB AGAIN
	MOVE	DDB,JBTSTS(JN)	
	TRNE	DDB,JLOCK		;IS THIS JOB LOCKED IN?
	JRST	GCLP2			;YES. DON'T COUNT IT TWICE
	HLRZ	DSER,JBTADR(JN)		;GET THE PROTECTION
	SUBI	AC3,1(DSER)		;DECREASE THE AVAILABLE SIZE.
GCLP2:	ANDI	DDB,77			;SEGMENT NUMBER FROM JBTSTS
	JUMPE	DDB,GCLP1		;LOOP IF NO SEGMENT
	PUSHJ	P,GCMCK			;SEGMENT SEEN BEFORE?
	JRST	GCLP1			;YES. DON'T DO IT AGAIN.
	MOVEM	IOS,GCBITS(DSER)	;DON'T COUNT THIS SEGMENT AGAIN
	HLRZ	DDB,JBTADR(DDB)		;GET THE PROTECTION SIZE
	SUBI	AC3,1(DDB)
	JRST	GCLP1			;LOOP

;JOB NUMBER IN DDB. SKIP IF WE'VE NOT SEEN THIS JOB BEFORE.
;IOS IS SET WITH WORD TO DEPOSIT IF YOU WANT TO MARK THIS JOB AS SEEN:
; USE	MOVEM	IOS,GCBITS(DSER)	TO REMEMBER HAVING SEEN THIS JOB.
GCMCK:	MOVE	DSER,DDB
	ANDI	DSER,1		;THIS BIT WILL INDEX THE TWO WORD BIT TABLE
	MOVEI	IOS,1		;THIS BIT WILL BE SHIFTED TO UNIQUE POSITION
	ROT	DDB,-1
	ROT	IOS,-=16(DDB)	;
	ROT	DDB,1		;RESTORE DDB
	IOR	IOS,GCBITS(DSER);TURN ON OTHER JOB BITS WE HAVE SEEN AND SET
	CAME	IOS,GCBITS(DSER);IS THIS AN OLD JOB NUMBER?
	AOS	(P)		;  NO, SKIP RETURN
	POPJ	P,		;  YES, NORMAL RETURN


GCS:	MOVE TAC1,J
	PUSHJ P,CORSGT		; ADD UP HIS CORE SIZE AND SEE IF WE ARE STILL DEADLOCKED
	MOVE DSER,TAC1
	LDB TAC1,PSEGN
	MOVE DDB,TAC1
	JUMPE TAC1,CPOPJ
	PUSHJ P,CORSGT
	ADD DSER,TAC1
	POPJ P,

;SCAN FOR OUTPUT

SCNOUT:	HGMAC(3)
;(CODE TO LOOK FOR EXPANDING JOBS HAS BEEN MOVED TO SCNIN)
	MOVE DDB,CORTAL		;INITIALIZE FREE CORE COUNTER
	MOVEM DDB,SUMCOR
	SETZM MAXSIZ		;CLEAR SIZE OF LARGEST JOB
	SETZM MAXJBN
	SETZM MAXRSZ
	SETZM MAXRJB
	SETZM MAXSSZ
	SETZM MAXSJB
	MOVE TAC,[XWD NJOBS,CJOBS]
	BLT TAC,CJOBS+JOBN-1	; MOVE OVER TABLE OF REFERENCE COUNTS
	MOVE DDB,FIT		;ENOUGH SEEN YET?
	LDB DSER,[POINT 6,JBTSTS(DDB),35]
	JUMPE DSER,FORCE3
	MOVE UCHN,JBTSTS(DSER)
	TLNE UCHN,SWP
	LDB DSER,[POINT 8,JBTSWP(DSER),35]
	TLNN UCHN,SWP		; OR IS HE SWAPPED IN?
	SETZ DSER,		; YES, HE DOESN'T COUNT INTO CORE WE HAVE TO GET
FORCE3:	LDB DDB,IMGINT
	ADD DDB,DSER		; ADD IN SIZE OF UPPER
	MOVEM DDB,NEEDED	; AND STORE AS AMOUNT NEEDED
	MOVEI DAT,OSCAN		;NO--SCAN QS
	JSP PC,QSCAN
	JRST RESCNIN
	CAME J,FIT		; REACHED OURSELVES YET?
	JRST SCNOF1		; NO.
	SKIPN JBTSIN(J)		; GIVE HIGH PRIORITY TO GUYS IN SWAP IN LIST
	CAMN J,SEGWAIT		; IS THIS GUY WAITING FOR A SEGMENT?
	JRST (QR)		; YES, EXCEPT FOR US, SCAN BACK ALL THE WAY
	JRST RESCNIN		; NO, SCAN FOR MORE INPUT

SCNOF1:	MOVE DDB,JBTSTS(J)	;GET JOB STATUS BITS
	TLNE	DDB,SWP		;NO, IS JOB ON DISK OR ON ITS WAY?
	JRST	CJOB		;YES,CONTINUE SCAN TO FIND ANOTHER JOB TO OUTPUT
	TLNE DDB,JHLDIN		;SOMEONE TRYING TO KEEP THIS GUY IN?
	JRST (QR)		;YES, SKIP HIM
	TLNE	DDB,JSEG	;SEGMENT?
	JRST	FRCE4A		;YES. CHECK NJOBS TO SEE IF IT SHOULD BE SWAPPED
	TRNE	DDB,JLOCK	;LOCKED JOB?
	JRST	(QR)		;YES. CAN'T BE SWAPPED.
	CAME	J,SEGWAIT	;DON'T SWAP OUT IF WAITING FOR A HIGH SEGMENT
	CAMN 	J,LOCKNO
	JRST	(QR)		;DON'T SWAP OUT THE GUY WE'RE TRYING TO LOCK IN.

REPEAT 0,<		;LET'S TRY NOT CLOGGING UP CORE WITH LOW PRIORITY LOSERS
	MOVM DDB,JOBQUE(J)	; PICK UP HIS QUEUE
	CAIE DDB,TQ		; IS HE IN A RUN QUEUE?
	CAIN DDB,RUNQ
	CAIA
	JRST FORCE4
	LDB DDB,PSEGN		; YES, DOES HE HAVE AN UPPER?
	JUMPE DDB,FORCE5	; NO
	MOVE DDB,JBTSTS(DDB)	; YES, IS IT IN CORE?
	TLNE DDB,SWP
	JRST FORCE4		; NO, DOESN'T MATTER
FORCE5:	SKIPN STIME(J)		; HAS THIS JOB BEEN RUN?
	JRST (QR)		; NO, GO BACK AND LET IT RUN.
>
FORCE4:	CAME J,SEGWAIT		; IF WAITING FOR SEGMENT, MUST STAY IN
	SKIPE JBTST2(J)		; DOES HE HAVE A SPACEWAR MODULE?
	JRST (QR)		;YES. CANT SWAP HIM OUT.
	HLRZ DDB,JBTDAT(J)	;PICK UP SIZE OF JOB
	JUMPE DDB,(QR)
	PUSHJ P,SIZCHK		;UPDATE SUMCOR AND CHECK IF ENOUGH YET
	JRST CJOB		;NO. LOOK FOR MORE
FORCE6:	SKIPN J,MAXJBN		;YES, SWAP OUT LARGEST
	MOVE J,MAXRJB
	JUMPN J,FORCE0
	MOVE J,MAXSJB		;AS A LAST RESORT, SWAP SEGMENT
FORCE0:	MOVSI DDB,SWP
	IORM DDB,JBTSTS(J)
	MOVEM J,FORCE		;ASSUME NOT SWAPPABLE--IS IT?

FORCE1:
IFN JDMPRG,<
	MOVE JDAT,JBTDAT(J)
>
	SKIPN PROG,JBTADR(J)	;LOC. IN PHYSICAL CORE, IS CORE
				;ASSIGNED IN MEMORY?
	JRST OUTJOB		;NO, CANNOT HAVE ACTIVE DEVICES
	CAME J,JOB(PID)		;IF THIS IS CURRENT JOB, WAIT UNTIL
				;PROTECTED AREA IS MOVED BACK TO JOB DATA AREA
	PUSHJ PDP,ANYACT	;ANY ACTIVE DEVICES?
	POPJ PDP,		;YES--RETURN AND WAIT FOR I/O TO STOP.
	SKIPN DDB,SEGWAIT	; IS ANYONE WAITING FOR A SEGMENT?
	JRST OUTJOB		; NO
	LDB TAC,[POINT 6,JBTSTS(DDB),35]
	CAIE TAC,(J)		; YES, IS IT US?
	JRST OUTJOB		; NO
	MOVSI TAC,SWP		; YES, WE ARE NO LONGER SWAPPABLE
	ANDCAM TAC,JBTSTS(J)
	SETZM FORCE
	SETZM SWPCNT		; BE SURE AND SCAN AGAIN NEXT TICK
	POPJ P,

FRCE4A:	SKIPE	NJOBS(J)	;ANYONE LEFT USING THIS?
	JRST	(QR)		;YES. SEGMENT SWAP OUT WILL BE CONSIDERED W/LOWERS
	JRST	FORCE4		;THIS MAY BE A DETACHED SEGMENT. SWAP IT
;OUTPUT A JOB

OUTJOB:	HGMAC(4)
	MOVNM J,FINISH		;SET FINISH FLAG FOR OUTJOB
	AOS NOUTSWPS
	SETZM FORCE		;CLEAR FORCE FLAG
	PUSHJ P,QNORUN		; REQUE HI SEGMENT IF NECESSARY
	SETZM FIRSTOUT#
	MOVSI DDB,INTSWW
	TDNN DDB,JBTIEN(J)
	JRST OUTJO1
	IORM DDB,JBTIRQ(J)
	PUSHJ P,INTRUN
	MOVM J,FINISH
OUTJO1:	HLRZ	DDB,JBTADR(J)	;COMPUTE CORE IMAGE SIZE
	JUMPE	DDB,SWP5	;DONT OUTPUT IF 0 CORE
;HERE WE SAVE THE JOB DATA AREA OF A LOWER
	MOVE	TAC1,JBTSTS(J)	;GET STATUS
	SKIPE	JBTPDL(J)	;DON'T SAVE IF THERE'S NO PLACE.
	TLNE	TAC1,JSEG	;IS THIS A SEGMENT?
	JRST	OUTJO3		;YES. THERE IS NOTHING TO SAVE.
	HRLZ	TAC1,JBTDAT(J)	;SOURCE (SORT OF)
	HRR	TAC1,JBTPDL(J)	;DESTINATION (SORT OF)
	ADD	TAC1,[JOBPRT,,<JBTPLN+JOBPRT-JOBPFI>]
	HRRZ	DAT,JBTPDL(J)	;
	BLT	TAC1,JBTPLN(DAT);SAVE THE DATA.
	MOVEI	TAC1,SAVJDA
	IORM	TAC1,JBTSTS(J)	;DATA AREA IS NOW SAVED IN CORE.
OUTJO3:	HRRZ	TAC1,JBTADR(J)	;LOCATION OF CORE IMAGE
	MOVNM	DDB,TAC		;*SAVE COUNT FOR CALL TO SQOUT. -(SIZE-1)
	ASH	DDB,-=10	;CONVERT TO 1K BLOCKS
	ADDI	DDB,1
	DPB	DDB,IMGOUT	;RECORD AS OUT IMAGE
	SKIPN	XPANDF		;DONT SET IMGIN IF FROM XPAND1
	DPB	DDB,IMGIN
	SKIPE	STIME(J)	;HAS HIS CORE IMAGE BEEN MODIFIED?
	JRST	OUTJ1		;YES.
	HLRZ	DDB,JBTSWP(J)	;SEE IF HE HAS BEEN SWAPPED OUT BEFORE
	JUMPN	DDB,OUTP1	;WAS SWAPPED OUT BEFORE.
	LDB	DDB,IMGOUT	;FIX DDB FOR CALL ON OUTJ1

; WE HAVE DECIDED THAT JOB IS REALLY TO BE SWAPPED
; CALL THE OUTPUT ROUTINE.
;DDB = IMGOUT SIZE. TAC1=LOCATION OF JOB. TAC = -(SIZE-1)

OUTJ1:	SKIPN	BLTSWP		;ARE WE DOING BLT AFTER SWAPIN?
	JRST	OUTJ2		;NO. THEN NO BLT BEFORE SWAP OUT.
	HRL	TAC1,TAC1	;LOCATION,,LOCATION
	HLRZ	DAT,JBTADR(J)	;GET THE SIZE
	ADDI	DAT,(TAC1)	;COMPUTE ENDING ADDRESS
	BLT	TAC1,(DAT)	;BLT TO SELF.
	HRRZ	TAC1,JBTADR(J)	;RESTORE TAC1.
	
OUTJ2:	HRLI	TAC1,-1(TAC)	;*BUILD AND SAVE IOWD FOR SQOUT
	PUSH	P,TAC1		;*
	MOVE	DAT,DDB		;*CONVERT CORE IMAGE TO 128 WD BLOCKS
	PUSHJ	P,GXSAT		;*GET DEVICE STORAGE
	JRST	FULL		;*NONE AVAILABLE
	SKIPN	FBACT
	HRLM	TAC,JBTSWP(J)	;*SAVE DEVICE ADDRESS
	POP	P,TAC1		;*GET IOWD
	JRST	SQOUT		;*START OUTPUT AND RETURN

SWP5:
	DPB DDB,IMGOUT		;SET OUTPUT IMAGE TO 0
	JRST SWAPSCAN		;GO LOOK FOR SOMETHING ELSE TO DO

NOFIT:	SETZM FIT		;FORGET ABOUT FITTING IN A JOB ON DISK
	POPJ PDP,		;ALL JOBS IN CORE ARE HIGHER PRIORITY.
; ROUTINE TO ADD THIS JOB'S SIZE TO CURRENT TOTAL AND SEE IF WE
; HAVE MADE ENOUGH ROOM FOR THE JOB WE ARE TRYING TO FIT IN
; EXPECTS RELOCATION IN DDB, JOB NUMBER IN J

SIZCHK:	ASH DDB,-12		;CONVERT TO 1K BLOCKS
	ADDI DDB,1
	MOVE TAC,JBTSTS(J)
	TLNE TAC,JSEG
	JRST SETMRS
	MOVM TAC,JOBQUE(J)	; IS HE RUNNABLE?
	CAIE TAC,TQ
	CAIN TAC,RUNQ
	JRST SETMRJ		; YES, GET SEPARATE MAXIMUM.
	CAMG DDB,MAXSIZ		;LARGEST SO FAR?
	JRST FORCE2		;NO
	MOVEM DDB,MAXSIZ	;YES, SAVE SIZE
	MOVEM J,MAXJBN		;AND JOB NUMBER
FORCE2:	ADDB DDB,SUMCOR		;ADD TO TOTAL
	CAML DDB,NEEDED		;IS IT WHAT WE NEEDED
	AOS (P)			;YES
	POPJ P,

SETMRS:	CAMG DDB,MAXSSZ
	JRST FORCE2
	MOVEM DDB,MAXSSZ
	MOVEM J,MAXSJB
	JRST FORCE2

SETMRJ:	CAMG DDB,MAXRSZ
	JRST FORCE2
	MOVEM DDB,MAXRSZ
	MOVEM J,MAXRJB
	JRST FORCE2
; ROUTINE TO DECREMENT REFERENCE TO THIS JOB'S UPPER, IF ANY
; IF ALL REFERENCES HAVE BEEN SELECTED FOR SWAPOUT, THEN ADD
; IN THE UPPER SIZE TOO.

CJOB:	LDB DDB,PSEGN		; PICK UP NUMBER OF UPPER
	JUMPE DDB,(QR)
	MOVE TAC,JBTSTS(DDB)	; IS UPPER IN CORE?
	SOSN CJOBS(DDB)		; DECREMENT REFERENCE COUNT
	TLNE TAC,SWP
	JRST (QR)
	PUSH P,J
	MOVE J,DDB
	HLRZ DDB,JBTADR(J)
	JUMPE DDB,CJBXIT
	PUSHJ P,SIZCHK		; UPDATE SUMCOR AND CHECK IF ENOUGH YET
	JRST CJBXIT		; NO, KEEP LOOKING
	SUB P,[XWD 1,1]		; YES, SWAP OUT LARGEST
	JRST FORCE6

CJBXIT:	POP P,J
	JRST (QR)
; ALL SWAP RETURNS THROUGH HERE

SWPXIT:	SKIPN FIT		; ARE WE FITTING SOMEBODY?
	SKIPE FORCE		; OR PERHAPS FORCING SOMEONE?
	SETZM SWPCNT		; IF SO, FIRE UP SWAPPER SOMETIME
	POPJ P,

FULL:	POP PDP,TAC
	SOSL FULCNT		;PRINT MESSAGE EVERY 30 SECONDS
	POPJ PDP,
	MOVEI TAC,=30*JIFSEC
	MOVEM TAC,FULCNT
	JSP TAC,ERRPNT
	ASCIZ /SWAPPING DEVICE FULL/
	JRST EXCALP
;INPUT A JOB

INJOB:	HGMAC(5)
	MOVEM J,FINISH		;SET FINISH FLAG TO INJOB
	AOS NINSWPS
	SETZM FIRSTOUT
	SETZM FIT		;CLEAR FIT FLAG
	LSH TAC,=10
	SUBI TAC,1
	SETZB JDAT,PROG		;NO CORE NOW
	PUSHJ PDP,CORGET
	JRST INJO3		; NOT AVAILABLE, FREE STORAGE SYSTEM MUST HAVE SNUK IN. RESCAN FOR INPUT.
INJO1:	LDB DDB,IMGOUT		;GET OUTPUT IMAGE
	JUMPE DDB,FININ1	;DONT INPUT IF OUT IMAGE IS 0
	LDB TAC,IMGIN		;GET IN-CORE SIZE.
	CAML DDB,TAC		;SMALLER THAN OUT?
	MOVE DDB,TAC		;YES. READ ONLY WHAT WILL FIT.
	LSH DDB,=18+=10		;*BUILD IOWD FOR SQIN
	MOVN TAC1,DDB		;*
	HRR TAC1,JBTADR(J)	;*
	HLRZ TAC,JBTSWP(J)	;*GET DEVICE ADDRESS
	JRST SQIN		;*START INPUT

INJO3:	SETZM FINISH
	SKIPN SHFWAT
	JRST SWP2
	SETZM SWPCNT
	POPJ P,
;XPAND SETS CONDITIONS TO GET MORE CORE FOR A JOB BY SWAPPING IT OUT
;THEN BACK IN TO DESIRED AMOUNT.
;JOBS POSITION IN QS NOT AFFECTED.
;CALL:
;	MOVE J,[JOB NO.]
;	MOVE TAC,[HIGHEST LEGAL ADDRESS DESIRED]
;	PUSHJ P,XPAND

↑XPAND:	PUSH P,DDB
	MOVE DDB,TAC		;ADDRESS TO 1K BLOCKS
	ROT DDB,-=10
	ADDI DDB,1
	DPB DDB,IMGIN
IFN FTSTAT,<
	EXCH TAC,DDB
	LSH TAC,6
	ANDI TAC,37700
	TRO TAC,CSZSTA
	PUSHJ P,STAPUT
	MOVE TAC,DDB
>;FTSTAT
	HLRZ DDB,JBTADR(J)
	JUMPE DDB,XPAND4	;ANY CORE IN MEMORY NOW? (NORMAL XPAND)
	SKIPE	XJOB(J)		;EXPAND FLAG ALREADY SET?
	JRST	XPAND3		;YES.  DONT INCREASE XJOB COUNT.
	SETOM	XJOB(J)		;SET EXPAND FLAG
	AOS	XJOB		;INCREASE COUNT OF JOBS TO EXPAND.
XPAND3:	POP P,DDB
	SETZM SWPCNT
	POPJ P,

XPAND4:	DPB DDB,IMGOUT		;CLEAR IMGOUT NOW
	MOVSI DDB,SWP
	IORM DDB,JBTSTS(J)	;AND MARK AS SWAPPED OUT
	JRST XPAND3

;XPAND1 COMPLETES ACTION REQUESTED BY XPAND.
;CALLED WHEN NO INPUT TO DO OR ON SEARCH FOR OUTPUT.

XPAND1:	SKIPN	XJOB		;ANY JOBS TO EXPAND?
	POPJ	P,		;NO.
	MOVEI	J,JOBN		;SCAN FOR EXPANDING JOBS.
	SKIPN	XJOB(J)		;THIS JOB NEED TO EXPAND?
	SOJG	J,.-1
	SETZM	XJOB(J)		;CLEAR THIS JOB.
	JUMPE	J,XPAND2	;LOSE!
	SOS	XJOB		;REDUCE THE COUNT.
	SETOM XPANDF		;SET FLAG SO IMGIN WONT BE RESET
	SETZM	SWPCNT
	JRST FORCE0		;GO START OUTPUT

XPAND2:	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISMES
	ASCIZ /ππXJOB SET BUT NO JOB EXPANDING
/
	POPACS
	POPJ P,
SUBTTL	SWPSER	4 AUG 67

;PUT A REQUEST IN THE SWAPPING QUEUE. ENTER AT SQIN FOR
;	INPUT, SWOUT FOR OUTPUT
;CALL:	MOVE TAC1,XWD -NO. OF WORDS,FIRST CORE LOC.
;	HRRZ TAC,DISK BLOCK NO.
;	PUSHJ PDP,SQIN/SQOUT
;	RETURN HERE ALWAYS
;	CONTENTS OF TAC,TAC1 LOST

↑SQIN:
	SKIPE FBACT
	JRST FBIN
	TLO TAC,400000		;SET READ INDICATOR
↑SQOUT:
	SKIPE FBACT
	JRST FBOUT
	MOVEM TAC,SERA		;STORE THE BLOCK NUMBER
	MOVEM TAC1,SQREQ	;STORE THE IOWD
	MOVNI TAC,1		;IS THE DEVICE BUSY?
	EXCH TAC,DFBUSY
	JUMPN TAC,CPOPJ		;YES IF JUMP


ERATRY←←3	;NO. OF TIMES TO READ AND WRITE ON ERRORS

;START UP DEVICE WITH SWAPPING REQUEST.
;IF A SWAPPER REQUEST IS WAITING(SQREQ WILL BE NON-ZERO)

	MOVEI TAC1,ERATRY
	MOVEM TAC1,SERACT
	MOVE TAC1,SQREQ		;*PUT IOWD INTO TAC1
	MOVSI TAC,200000	;*SET "SWAPPER I/O GOING" FLAG ON
	ORB TAC,SERA		;*
	MOVM ITEM,FINISH	; PICK UP JOB NUMBER FOR OUTPUT
	HRROS ITEM		; MAKE LH NEG TO FLAG SWAP OPERATION
	TLZE TAC,400000		;*IS THIS JOB A READ?
	SOJA TAC1,DFRED		;*YES  -CALL DSKSER
	SOJA TAC1,DFWRT		;*NO, WRITE.
; FAST-BAND SWAPPER . .  .

FBOUT:	MOVE DAT,[XWD J,JBTSWP]
	MOVEI DSER,MAXFB
FBOREQ:	HLRZ UCHN,@DAT	; PICK UP SWAPPING BAND NUMBER
	JUMPN UCHN,FBOUT1
	MOVEI UCHN,(DSER)
	JRST FBOUT3
FBOUT1:	HLRO DDB,TAC1
	MOVNS DDB
	SUBI DDB,1
	IDIVI DDB,=76*2000
	ADDI DDB,(DSER)
	CAMN DDB,UCHN
	JRST FBOUT6
	CAMG UCHN,DDB
	JRST FBOUT2
	PUSHJ P,FBGIVE		; TOO MANY BANDS. GIVE SURPLUS BACK.
	SUBI UCHN,1
	HRLM UCHN,@DAT
	JRST FBOUT1

FBOUT2:	ADDI UCHN,1		; NOT ENOUGH. GET MORE BANDS.
FBOUT3:	PUSHJ P,FBGET
	JRST FBOUT7
	HRLM UCHN,@DAT
	JRST FBOUT1

FBOUT7:	MOVEM TAC1,DIOWD#
	MOVE TAC,[XWD FBCLK,1]
	CONO PI,PIOFF
	IDPB TAC,CLOCK
	CONO PI,PION
	POPJ P,

FBCLK:	MOVM J,FINISH
	MOVE TAC1,DIOWD
	JRST FBOUT
; HERE WE HAVE ENOUGH BANDS, SET UP CALL

FBOUT6:	MOVEI UCHN,(DSER)
	HRRZ TAC,TAC1
	HLRO AC2,TAC1
	MOVNS AC2
	SETZM TAC1
	SETOM SWPBSY#
	SETZM SERA
FBOUT4:	CAIG AC2,=76*2000
	JRST FBOUT5
	PUSH P,TAC
	PUSH P,AC2
	PUSH P,DSER
	PUSH P,DAT
	MOVEI AC2,=76*2000
	MOVSI DAT,DONE1
	PUSHJ P,FBWRITE
	JRST FBERR1
	POP P,DAT
	POP P,DSER
	POP P,AC2
	POP P,TAC
	ADDI TAC,=76*2000
	SUBI AC2,=76*2000
	ADDI UCHN,1
	JRST FBOUT4

FBERR1:	POP P,DAT
	POP P,DSER
	POP P,AC2
	POP P,TAC
	JRST FBERR

FBOUT5:	MOVSI DAT,DONE
	PUSHJ P,FBWRITE
	JRST FBERR
	POPJ P,

DONE:	SETZM SWPCNT
	SETZM SWPBSY
DONE1:	HRRZM DAT,SERA
	POPJ P,
; LIBRASCOPE INPUT ROUTINE

FBIN:	MOVE DAT,[XWD J,JBTSWP]
	MOVEI DSER,MAXFB
FBIREQ:	HLRZ UCHN,@DAT
	HLRO DDB,TAC1
	MOVNS DDB
	SUBI DDB,1
	IDIVI DDB,=76*2000
	ADDI DDB,(DSER)
	CAMGE UCHN,DDB
	JRST FBINA
	MOVEI UCHN,(DSER)
	HRRZ TAC,TAC1
	HLRO AC2,TAC1
	MOVNS AC2
	SETZM TAC1
	SETOM SWPBSY
	SETZM SERA
FBIN2:	CAIG AC2,=76*2000
	JRST FBIN1
	PUSH P,TAC
	PUSH P,AC2
	PUSH P,DSER
	PUSH P,DAT
	MOVEI AC2,=76*2000
	MOVSI DAT,DONE1
	PUSHJ P,FBREAD
	JRST FBERR1
	POP P,DAT
	POP P,DSER
	POP P,AC2
	POP P,TAC
	ADDI TAC,=76*2000
	SUBI AC2,=76*2000
	ADDI UCHN,1
	JRST FBIN2

FBIN1:	MOVSI DAT,DONE
	PUSHJ P,FBREAD
	JRST FBERR
	POPJ P,
; LIBRASCOPE SWAPPING ERROR ROUTINES

FBERR:	SETZM SWPCNT
	SETZM SWPBSY
	SETOM SERA
	JRST FINSWP

FBINA:	JUMPE UCHN,FBINB
	SUBI UCHN,(DSER)-1
	MOVNI DDB,=76*2000
	IMULI DDB,(UCHN)
	HRL TAC1,DDB
	JRST FBIN

FBINB:	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ/SWAP REQUEST WITH NO BANDS.
J=/]
	DISARG(DCP,<-20+J(P)>)
	[ASCIZ/
/]
	-1
	POPACS
	JRST FBERR	;ERROR OUT
;FIND A SERIES OF BLOCKS ON THE DISK TO SWAP ONTO. CALLED
;AT CLOCK LEVEL.
;CALL:	MOVEI DAT,NO. OF 1K BLOCKS DESIRED
;	PUSHJ PDP,GXSAT
;	ERROR EXIT	(DISK IS FULL)
;	NORMAL EXIT	;C(TAC) = BLOCK NO.

;CONTENTS OF ACS TAC,TAC1,DAT WILL BE LOST.



↑GXSAT:
	SETZM TAC
	SKIPE FBACT
	JRST CPOPJ1
	MOVE TAC,ITEM	;PUT IT ON BAND NUMBER;JS
	IMULI TAC,1140	;CORRESPONDING TO ITS JOB NUMBER
	AOS (PDP)	;ALWAYS GIVE OK RETURN
↑FXSAT:	POPJ PDP,	;DONT NEED FXSAT

SWPINI:	SETZM SWPBSY
	SETZM SWPCNT
	SETZM FIT
	SETZM FORCE
	SETZM FINISH
	SETZM SERA
	POPJ PDP,

>
	BEND SCHEDU
