COMMENT ⊗   VALID 00149 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00014 00002	UUOCON	NON-IO SECTION
C00017 00003	HERE WE FIGURE OUT WHOSE FAULT THE UUO IS AND WHO IT IS FOR
C00020 00004	UUO SETUP ROUTINES FOR P2
C00022 00005	HERE WE TELL THE WORLD WE HIT A UUO AT INTERUPT LEVEL AND TRY
C00024 00006	SAVE USER'S ACS, GET A PDL
C00026 00007	HERE WE SET UP A CHANNEL AND DISPATCH
C00029 00008	USRXIT  - WE RETURN HERE EVENTUALLY TO CHECK WITH SCHEDULER
C00032 00009	RESTORE ACS AND DISMISS UUO 
C00035 00010	GET HERE WHEN UUOPTR≠0 TO THINK ABOUT LETTING LOSER SIMULATE UUO
C00037 00011	ROUTINE TO ASSIGN A CHANNEL NUMBER
C00039 00012	TABLE OF UUO DISPATCH ADDRESSES
C00041 00013	IOT UUO DISPATCH TABLE
C00043 00014	CALL AND CALLI
C00046 00015	CALL UUO DISPATCH TABLE
C00049 00016	 THE FOLLOWING ARE STANFORD'S OWN PRIVATE CALLI'S
C00055 00017	 MACROS TO DEFINE CALLI TABLES
C00056 00018	EXIT UUO ROUTINE
C00058 00019	SETPOV - SET PUSH DOWN OVERFLOW TRAP
C00059 00020	RESET UUO ROUTINE
C00062 00021	 ROUTINE TO RESET ONE'S UPPER SEGMENT
C00063 00022	APRDKL  ROUTINE TO KILL ANY CLOCK INTERRUPT REQUESTS FOR JOB J
C00064 00023	APRENB - ROUTINE TO SET UP APR FOR USER TRAPPING
C00066 00024	PJOB, DATE, DAYCNT, ACCTIM, DSKTIM, JOBTIM, MSTIME UUO'S
C00068 00025	SLEEP	PUT JOB TO SLEEP FOR NSECONDS
C00069 00026	SWITCH	RETURN DATA SWITCHES
C00070 00027	DVCHR, DEVNUM
C00072 00028	GETPPN -- DSKPPN
C00076 00029	SETNAM, SETCRD, SETDDT, GETNAM
C00078 00030	WAIT FOR IO TO BECOME INACTIVE ON CHANNEL AC
C00079 00031	GETLN:	PUSHJ PDP,TTYFND	GET NAME OF TTY
C00080 00032	CRKSER -- READ THE PETIT CROCK, J. SAUTER, REST OF PAGE.
C00082 00033	 FINISH READING PCROCK, CONVERT TO STANDARD FORM
C00084 00034	LOGIN UUO.	FOR LOGIN CUSP ONLY.
C00088 00035	 ROUTINE TO SET UP SCHEDULER DATA STRUCTURE FOR A JOB
C00089 00036	SETPRV, GETPRV
C00092 00037	GET A PPN'S SERVICE LEVEL RESERVATION.
C00099 00038	LOGOUT UUO
C00100 00039	 ROUTINE TO READ SPACEWAR BUTTONS
C00101 00040	 ROUTINE TO COMPLEMENT STATE OF DUPLEXING
C00102 00041	 ROUTINE TO GET A WORD FROM MONITOR CORE
C00103 00042	 RUN A JOB UUO
C00105 00043	 SWAP UUO - CONTINUED . . .
C00108 00044	 SWAP UUO - LOG IN NEW JOB AND RUN THIS ON IT - PHANTOM STARTUP
C00112 00045	 ROUTINE TO DO THE GETTING OF A JOB FROM UUO LEVEL
C00115 00046	 ROUTINE TO SAVE ACCUMULATORS OVER RUNJOB UUO
C00117 00047	 EIOTM AND LIOTM UUO'S
C00118 00048	 UUO TO GET THE PHYSICAL NAME OF A DEVICE
C00119 00049	 GET A JOB'S JOB STATUS WORD
C00120 00050	 GET A TELETYPE'S DEVIOS
C00122 00051	COMMENT $		WAKEME
C00125 00052	TRANSLATE SYSTEM CALL TO/FROM SIXBIT.
C00128 00053	CALTU:	ANDI TAC1,777000
C00130 00054	CALT2:	MOVSI TAC1,-IUUMAX*2-40	TOTAL # MAJOR OPCODES
C00132 00055	SETPR2, BEGIN SEGUUO
C00135 00056	 HERE WE ADDRESS CHECK HIS PR REQUEST
C00136 00057	GETPR2
C00137 00058	 REMAP UUO . . .
C00139 00059	 REMAP - CHECK IF HE WANTS IT WRITE PROTECTED
C00141 00060	 REMAP - IF HE IS NOT ON 1K BOUNDARY, ADJUST HIM
C00144 00061	BLTUP - FAST UPWARDS BLT
C00146 00062	HERE WE ITERATE ON BLTS, POSSIBLY STARTING WITH A SMALLER ONE
C00148 00063	 UUO TO SET OR CLEAR USER WRITE-PROTECT BIT
C00149 00064	UNPURE - MAKE A WRITEABLE COPY OF WRITE-PROTECTED UPPER, IF NECESSARY
C00153 00065	UNPURE CONTINUED:
C00156 00066	 CORE UUO FOR HIGH SEGMENTS
C00159 00067	 CORE2 - SCAN FOR ALL JOBS USING THIS SEGMENT AND TELL THEM HE HAS CHANGED SIZE
C00160 00068	 ATTACH HIGH SEGMENT
C00163 00069	ATTSEG	 SEARCH FOR A SEGMENT OF A GIVEN NAME
C00164 00070	DETSEG  DETACH SEGMENT
C00167 00071	 DETSEG - COMMON SEGMENT UUO EXIT ROUTINE
C00168 00072	 GET NUMBER OF SEGMENT BELONGING TO JOB N
C00169 00073	 SEGSIZ CALLING . . .
C00170 00074	 SETNM2 CALLING . . .
C00172 00075	 ROUTINE TO GET YOUR SEGMENT'S NAME
C00173 00076	 THIS UUO FIRST KILLS ANY HIGH SEGMENT YOU MAY HAVE.
C00174 00077	 RETURNS LIST OF JOB NUMBERS WHO POINT TO YOUR UPPER SEGMENT.
C00175 00078	 SET PROTECTION ON A HIGH SEGMENT
C00177 00079		SUBTTL	INTUUO - UUOS FOR NEW STYLE INTERRUPT SYSTEM
C00178 00080	 INTENB
C00180 00081	 CLKENB, CLKENA  - ENABLE FOR USER CLOCK INTERRUPTS
C00184 00082	 INTORM - ROUTINE TO SET BITS IN INTERUPT ENABLE MASK
C00185 00083	 INTACM - CLEARS BITS IN INTERRUPT ENABLE MASK
C00186 00084	 INTENS, INTIIP - ROUTINES TO GIVE BACK INFORMATION
C00187 00085	 INTIRQ - TELLS YOU WHAT INTERRUPTS ARE PENDING
C00188 00086	 DISMIS - TERMINATES CURRENT I-LEVEL RUN
C00190 00087	 INTGEN - ROUTINE TO GENERATE AN INTERRUPT FOR YOURSELF
C00191 00088	 USKIP - ROUTINE TO TELL USER IF HE IS INSIDE A UUO
C00192 00089	 UWAIT - WAITS FOR UUO TO TERMINATE
C00194 00090	 DEBREAK - MAKES I-LEVEL PROCESS TAKE PLACE OF U-LEVEL PROCESS
C00195 00091	 IWAIT - GO INTO INTERRUPT WAIT UNTIL AWAKENED BY AN APPROPRIATE INTERRUPT
C00196 00092	 ROUTINE TO ENABLE INTERRUPTS AND THEN GO INTO INTERRUPT WAIT
C00197 00093	UUOS TO SET THE INTERRUPT MASK
C00199 00094	IMSKST  IMSKCL
C00200 00095	 CLKINT UUO  (CLKUUO) START UP A CLOCKED I-LEVEL JOB
C00205 00096	INTUUO - INTDEJ, IMSTW
C00207 00097	 IWKMSK, IMSKCR
C00208 00098	 INTDMP
C00210 00099	 INTDMP - ERROR RETURNS
C00211 00100	 ROUTINE TO GET A JOB NUMBER FROM A JOB NAME
C00212 00101	 INTIPI
C00214 00102	SUBTTL	UUOCON - STANFORD SPECIAL IO ROUTINES
C00215 00103	THIS UUO GETS THE STANDARD BUFFER LENGTH FOR A DEVICE
C00216 00104	 ROUTINE TO GET THE TIME CELLS AND CLEAR THEM
C00218 00105	RETURNS A CODE TELING WHETHER A JOB NAME IS LOGGED IN
C00220 00106	 DEVUSE - HOW MANY JOBS ARE WAITING FOR A PARTICULAR DEVICE.
C00224 00107	 JOBRD  UUO TO BLT DATA FROM SOME OTHER JOB'S CORE IMAGE TO YOURS.
C00227 00108	 JOBRD - PICK UP ADDRESS OF LAST WORD, ADDRESS CHECK IT
C00229 00109	 JOBRD - GET FREE STORAGE FOR DATA, PLANT CLOCK REQUEST TO DO TRANSFER
C00231 00110	 JOBRD - WE GET HERE AT CLOCK LEVEL . . .
C00235 00111	TMPCOR UUO - BEHAVES AS DESCRIBED IN DEC MANUAL
C00239 00112	CHECK & RELOCATE TMPCOR WCMA
C00241 00113	WRITE TMPCOR FILE
C00244 00114	UUOCON	IO SECTION
C00246 00115	IOPUSH, IOPOP, IOPDL
C00251 00116	 CLOSE UUO - CALLING SEQUENCE
C00252 00117	 CLOSE CODE - WAIT FOR IO TO FINISH, FLUSH BUFFERS
C00255 00118	 CLOSE CODE
C00258 00119	 CLOSE - CALL DEVICE DEPENDENT ROUTINE
C00259 00120	 INBUF - CALLING SEQUENCE
C00260 00121	 SET UP BUFFERS OF USER-SPECIFIED LENGTH
C00262 00122	 UINBF - CALLING SEQUENCE . . .
C00264 00123	ERROR MESSAGES FOR INBUF, OUTBUF, UINBF, AND UOUTBF UUOS
C00265 00124	OPEN UUO - PERFORMS SAME OPERATION AS INIT
C00266 00125	 INIT - CALLING SEQUENCE
C00268 00126	 INIT CODE - FIRST FIND DEVICE AND TRY TO ASSIGN IT
C00275 00127	 HERE WE ASK HIM IF HE IS WILLING TO WAIT FOR THE DEVICE
C00278 00128	 DEVICE WAIT - CAN'T GET IT, SEE IF HE WANTS DISK
C00279 00129	CALLING SEQUENCE
C00280 00130	LONG DISPATCH TABLE UUOS - GET HERE ONLY IF DEVICE HAS LONG
C00282 00131	RENAME UUO - HERE ON SHORT DISPATCH TABLE DEVICES TOO
C00284 00132	INPUT UUO
C00286 00133	 HERE IF INPUT NEEDS LOOKUP. GET FILE NAME FROM LOSER.
C00288 00134	 INPUT UUO - HERE, WE ARE SATISFIED DEVICE IS PROPERLY LOOKED UP
C00291 00135	 INPUT UUO CONT.
C00293 00136	HERE ON FIRST INPUT AFTER INIT, INIT & LOOKUP, OR INIT & LOOKUP & INPUT
C00295 00137	 CALL THE DEVICE INPUT ROUTIN
C00297 00138	 OUTPUT UUO - CALLING SEQUENCE
C00300 00139	HERE ON OUTPUT UUO
C00302 00140	 OUTPUT UUO - HERE WE ARE SATISFIED DEVICE HAS BEEN PROPERLY ENTERED
C00305 00141	 OUTPUT UUO - HERE, WE ADVANCE BUFFER ADDRESS, START OUTPUT, AND WAIT FOR
C00309 00142	 SUBROUTINE FOR OUTPUT UUO
C00310 00143	RELEASE A DEVICE
C00314 00144	 RELEAS CODE - SEE IF THERE IS ANYONE WAITING FOR THE DEVICE
C00315 00145	 UUOS TO TEST IO STATUS WORD
C00316 00146	 MORE STATUS UUOS
C00317 00147	 STILL MORE STATUS UUOS
C00318 00148	IN UUO - LIKE INPUT	SKIPS IF  EOF OR ERRORS
C00319 00149	SPACEWAR UUOS
C00320 ENDMK
C⊗;
SUBTTL	UUOCON	NON-IO SECTION
;UUOCON (BOTH SECTIONS) CONSISTS OF THE UUO TRAP HANDLER
;THE CALL UUO ROUTINES AND THE IO UUO ROUTINES
;SOME UUO DO DISPATCH TO OTHER ROUTINES OUTSIDE OF UUOCON
;ALL UUOS DROP THEMSELVES IN REAL LOCATION 40, AND TRAP TO 41.

;SYSTEM UUOS(40-77) FIRST SAVE THE USERS ACS IN RELATIVE LOC 0-17
;THEN THE FOLLOWING ACS ARE LOADED UP BEFORE DISPATCHING:
;	PDP	;PUSHDOWN LIST IN CURRENT JOB DATA AREA
;	PROG	;CURRENT JOB RELOCATION IN RH,PROTECTION IN LH
;	JDAT	;ADDRESS OF CURRENT JOB DATA AREA
;	UUO	;THE CONTENTS OF LOC 40 WITH PROG IN INDEX FIELD
;		;SO THAT RELOCATION CAN BE DONE FOR PICKING UP ARGUMENTS
;	DEVDAT	;ADR. OF DEVICE DATA BLOCK
;	IOS	;DEVICE IO STATUS WORD
;	DSER	;ADR. OF DEVICE SERVICE ROUT. DISPATCH TABLE
;	UCHN	;THE USER IO CHANNEL(AC FIELD) OF UUO

;RETURN IS PUT IN UUOPC(JOB)
;THEN IF CALL WAS FROM USER MODE, THE UUO ROUTINE IS CALLED
;WITH A PUSHJ, SO THAT ALL UUO ROUTINE RETURN WITH A POPJ PDP,
;WHICH WILL RETURN CONTROL TO UUOCON WHICH WILL RESTORE USERS
;ACS AND RETURN TO HIM
;IF THE CALL IS FROM EXEC MODE, THE UUO ROUTINE IS CALLED
;BY DOING JUST A JRST,  WHEN THE UUO ROUTINE RETURNS WITH
;A POPJ, IT WILL RETURN TO THE EXEC WITHOUT RESTORING
;ANY ACS
;CONTROL MAY ALWAYS BE RETURNED BY EXECUTING A
;	POPJ	P,
;WHICH WILL RESTORE THE ACS, APR BITS, AND RETURN.
;THE UUO HANDLER IS PURE IF THE FOLLOWING RESTRICTIONS ARE OBSERVED.
;RESTRICTIONS: UUOS CANNOT BE CALLED BY INTERRUPT SERVICE ROUTINES.
;HERE WE FIGURE OUT WHOSE FAULT THE UUO IS AND WHO IT IS FOR

↑UUO1:	MOVEM	17,UUO.SA+17		;SAVE ALL AC'S FOR ILLUUO FROM EXEC
	MOVEI	17,UUO.SA
	BLT	17,UUO.SA+16
	MOVE	17,UUO.SA+17		;RESTORE AC 17
	CONSO	PI,177⊗8		;ARE WE AT INTERRUPT LEVEL?
	JRST	NOPCK			;NO.
	EXCH	TAC,UUO0+P1PID		;SAVE TAC, GET PC OF UUO + 1
	TLNN	TAC,USRMOD		;USER MODE?
	JRST	UUOX			;UUO FROM EXEC WHILE PI IN PROG - ILLEGAL
	EXCH	TAC,UUO0+P1PID		;RESTORE TAC
NOPCK:	SKIPN	SPWUUF			;ARE WE RUNNING SPACEWAR NOW?
	JRST	UUO1B			;NO.
	MOVEM	17,SPWSAC+17
	MOVEI	17,SPWSAC
	BLT	17,SPWSAC+16		;STUFF THE SPACEWARE AC'S AWAY.
	MOVEI	PID,P1PID
	JRST	SPWUUO			;LET SPWSER PROCESS IT

UUO1B:	MOVEM	17,USRSAV+P1PID		;SAVE AC 17
	MOVE	17,UUO0+P1PID		;GET PROCESSOR FLAGS
	TLNE	17,USRMOD		;IS UUO FROM MONITOR?
	JRST	UUO1A			;NO. ORDINARY FROM USER MODE
	MOVE	DAT,UUO0+P1PID		;UUO FROM EXEC
	MOVEI	PID,P1PID
	MOVE	UUO,@UUOLOC(PID)
	MOVE	J,JOB(PID)
	JRST	UUOSY1			;UUO FROM SYSTEM

↑UUO1A:	SKIPE	17,JOBADR+P1PID		;GET JOB DATA AREA ADDRESS
	JRST	UUOSYS			;HAPPY
	MOVEI	PID,P1PID		;NO JOB DATA AREA
	JRST	NULJB			;MUST BE AILING NULL JOB

↑UUO3:	EXCH	TAC,UUO2+P1PID		;TRAP TO LOCATION 60.
IFN FTXCTR,<
	TLNN TAC,USRMOD
	JRST PGRSM			;SIMULATE XCTRS
↑UUO3A:>
	MOVEM	TAC,UUO0+P1PID		;ILLEGAL FOR NOW.
	MOVE	TAC,UUO2+P1PID		;RESTORE TAC.
	SETZM	@UUOLOC+P1PID		;MAKE LOOK LIKE ILL INSTR.
	JRST	UUO1			;TRAPPING TO 40.
;UUO SETUP ROUTINES FOR P2

↑P2UUO1:
	CONSO	PI,177⊗8		;INTERRUPT LEVEL?
	JRST	P2NOPCK			;NO.
	EXCH	TAC,UUO0+P2PID
	TLNN	TAC,USRMOD		;FROM USER MODE?
	JRST	P2UUOX			;NO, LOSE
	EXCH	TAC,UUO0+P2PID
P2NOPCK:SKIPN	SPWUUF+P2PID
	JRST	P2UU1B			;NOT SPACEWAR LEVEL
	MOVEM	17,SP2SAC+17
	MOVEI	17,SP2SAC
	BLT	17,SP2SAC+16		;SAVE SPACEWAR AC'S
	MOVEI	PID,P2PID
	JRST	SPWUUO			;LET SPWSER THINK ABOUT THIS

P2UU1B:	MOVEM	17,USRSAV+P2PID		;SAVE AC 17
	MOVE	17,UUO0+P2PID		;GET PROCESSOR FLAGS
	TLNE	17,USRMOD		;IS UUO FROM MONITOR?
	JRST	P2UU1A			;USER LEVEL UUO
	MOVE	DAT,UUO0+P2PID		;SYSTEM UUO
	MOVEI	PID,P2PID
	MOVE	UUO,@UUOLOC(PID)
	MOVE	J,JOB(PID)
	JRST	UUOSY1

↑P2UU1A:
	SKIPE	17,JOBADR+P2PID		;GET JOB DATA AREA ADDRESS
	JRST	U2OSYS			;THERE IS ONE.
	MOVEI	PID,P2PID		;NO CORE FOR JOB
	JRST	NULJB			;MUST BE AILING NULL JOB

↑P2UUO3:
	EXCH	TAC,UUO2+P2PID		;TRAP TO LOCATION 60.
	MOVEM	TAC,UUO0+P2PID		;ILLEGAL FOR NOW.
	MOVE	TAC,UUO2+P2PID		;RESTORE TAC.
	SETZM	@UUOLOC+P2PID		;MAKE LOOK LIKE ILL INSTR.
	JRST	P2UUO1			;TRAPPING TO 40.
;HERE WE TELL THE WORLD WE HIT A UUO AT INTERUPT LEVEL AND TRY
;TO FIGURE OUT WHAT TO DO!

UUOX:	EXCH	TAC,UUO0+P1PID		;RESTORE TAC, UUO0
	CONO	PI,PIOFF		;HOLD EVERYTHING
	EXCH	P,ERRPD+P1PID		;GET A PDL
	PUSHACS
	MOVEI	PID,P1PID
	JRST	UUOX1

P2UUOX:	EXCH	TAC,UUO0+P2PID
	CONO	PI,PIOFF
	EXCH	P,ERRPD+P2PID
	PUSHACS
	MOVEI	PID,P2PID
UUOX1:	SOS	UUO0(PID)		;FIX UP ADDRESS FOR PRINTING AND RETURN
	PUSHJ	P,DISMES
	ASCIZ /ILLEGAL UUO FROM EXEC WHILE PI IN PROGRESS
PI = /
	CONI	PI,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISERR
	[ASCIZ/
P  = /]
	DISARG OCT,<ERRPD(PID)>	;OLD STACK
	[ASCIZ/    C(P) = /]
	-1
	HRRZ	TAC,ERRPD(PID)
	MOVE	TAC,(TAC)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISERR
	[ASCIZ/
PC = /]
	DISARG OCT,<UUO0(PID)>
	[ASCIZ/    UUO  = /]
	DISARG OCT,<@UUOLOC(PID)>
	[ASCIZ/
(WILL RETURN VIA JRST 2,@UUO0)
/]
	-1
	PUSHJ P,SYSFIX
	JFCL				;COULDN'T FIX ERROR
	CAIA
	JRST	UUOX2			;FIXED AN ERROR
	PUSHJ	P,DISFLUSH
	PUSHJ	P,DDTCALL
UUOX2:	JUMPN	PID,P2UUX2
	POPACS
	EXCH	P,ERRPD(PID)
	CONO	PI,PION
	JRST	2,@UUO0+P1PID		;TRY TO GO ON!

P2UUX2:	POPACS
	EXCH	P,ERRPD(PID)
	CONO	PI,PION
	JRST	2,@UUO0+P2PID
;SAVE USER'S ACS, GET A PDL

U2OSYS:	MOVEM	16,16(17)
	MOVEI	16,(17)
	BLT	16,15(17)
	MOVE	TAC,USRSAV+P2PID
	MOVEM	TAC,17(17)
	MOVEI	PID,P2PID
	JRST	UUOSY2

UUOSYS:	MOVEM	16,16(17)		;STORE AC16 IN USER 16
	MOVEI	16,(17)			;SET UP BLT POINTER
	BLT	16,15(17)		;MOVE REAL AC'S TO USER AREA
	MOVE	TAC,USRSAV+P1PID	;MOVE USER 17 TO USER'S AREA
	MOVEM	TAC,17(17)
	MOVEI	PID,P1PID
UUOSY2:	MOVE	PROG,17			;LOAD UP POINTER TO USER PROGRAM AREA
IFN JDMPRG,<
	MOVE	JDAT,JOBDAT(PID)	;ADDRESS OF JOB DATA AREA
>
	MOVE	J,JOB(PID)		; PICK UP JOB NUMBER
	MOVE	DAT,UUO0(PID)		; SAVE RETURN IN ACS
	MOVE	UUO,@UUOLOC(PID)	; AND SAVE UUO ALSO
	SKIPE	INTACT(PID)
	SKIPA	P,INTSP(PID)		;USE INTERRUPT LEVEL PDL
	JSP	TAC,GETPDL		; GET US A PDL
;HERE WE SET UP A CHANNEL AND DISPATCH

↑UUOSY1:EXCH	DAT,UUOPC(J)		; SAVE RETURN
	MOVEM	DAT,UUOOPC(J)		; SAVE OLD RETURN IN CASE ILL. UUO INSIDE UUO CODE.
	SKIPE DAT,UUOPTR(J)
	JRST UUOSY4			;MAYBE LOSER WANTS TO SIMULATE IT
UUOSY3:	TLNN	UUO,740000		;SYSTEM UUO?
ILEGAL:	JRST	UUOERR			;NO, 0-37 ARE ILLEGAL,PRINT ERROR
	TLO	UUO,PROG		;SET FOR RELOCATION
	LDB	UCHN,PUUOAC		; SETUP USER DEVICE CHANNEL NUMBER
	LDB	TAC1,[POINT 9,UUO,8]	;PICK UP UUO OP CODE
	XORI	TAC1,700		; IS THIS AN IOT UUO?
	TRCN	TAC1,700
	JRST	UUOIOT			; YES, SEPARATE DISPATCH TABLE
	CAIL	TAC1,100		;ILLEGAL INSTRUCTION?
	JRST	ILLINS			;YES, STOP JOB AND PRINT ERROR
	PUSHJ	P,CHNSET		; CHECK CHANNEL NUMBER AND LOAD IOS AND DSER
	JRST	USRXIT			; NO CHANNEL, BUT UUO LEGAL ANYWAY
	JRST	USRXT1			; THINGS LIKE LOOKUP AND ENTER ON NON-DIRECTORY DEVICES GET HERE
	ROT	TAC1,-1			;DIVIDE UUO OPCODE BY 2, SAVE REMAINDER
	MOVE	DAT,UUOTAB-20(TAC1)	;GET DISPATCH TABLE ENTRY
DISP4:	TLNN	TAC1,400000		;WAS UUO ODD?
	MOVS	DAT,DAT			;NO, USE LH OF DISPATCH ENTRY
	AOS	NUUOS
	PUSHJ	P,(DAT)			;NO, FROM USER. ROUTINES ALL RETURN BY POPJ
					;BEGINNING HERE WE WON'T TAKE USER INTS
USRXT0:
	JRST	USRXIT			;NO SKIP RETURN REQUIRED
	JRST	USRXT1
	MOVE	J,JOB(PID)
	AOSA	UUOPC(J)
USRXT1:	MOVE	J,JOB(PID)
	AOS	UUOPC(J)		; SKIP RETURN TO USER
;USRXIT  - WE RETURN HERE EVENTUALLY TO CHECK WITH SCHEDULER
; TO SEE IF IT WANTS TO RESCHEDULE THIS JOB

↑USRXIT:MOVE	J,JOB(PID)
	SKIPN	SPWUUF(PID)		;ARE WE AT SPACEWAR LEVEL ?
	JRST	USRXT6			;NO.
	MOVE	TAC,UUOPC(ITEM)
	POP	P,UUOPC(J)		; RESTORE OLD PC WORD
	MOVEM	TAC,UUO0(PID)
	JUMPE	PID,USRXT7
	MOVSI	17,SP2SAC
	BLT	17,17
	XCT	SPWXCT+P2PID		;USUALLY JRST 2,@UUO0+P2PID

USRXT7:	MOVSI	17,SPWSAC		; RESTORE SPW ACS
	BLT	17,17
	XCT	SPWXCT			;USUALLY JRST 2,@UUO0 ;RETURN TO SPW JOB

USRXT6:	SKIPE	INTACT(PID)		;USER INTERRUPT LEVEL?
	JRST	USRXT4			;YES, SKIP SCHEDULING CHECK
	SKIPL	TAC,JBTSTS(J)		;STILL RUNNABLE?
	JRST	USRXT9			;NO - RUN BIT OFF - PUT HIM IN STOPQ
	TLNE	TAC,STOPIO		;YES?
USRXT2:	PUSHJ	P,USRXTS		;NO, CAUSE CLK INT ON EXIT
	MOVSI	UCHN,INTWAIT		;ARE WE ENABLED FOR INTERRUPT WAIT INTERRUPT?
	TDNN	UCHN,JBTIEN(J)
	JRST	USRXT4			;NOT ENABLED FOR INT-WAIT INTERRUPT
	SETOM	INTHLD(PID)		;MAKE SURE WE DON'T GET TO INTNOW FROM HERE
	IORM	UCHN,JBTIRQ(J)
	SETZM	INTHLD(PID)		;INTNOW WILL WIN NOW
	SETOM	INTREQ(PID)
USRX4A:	PUSHJ	P,USRXTS		;INT ON WAY BACK TO LOSER
USRXT4:	MOVEI	DAT,USRXT5
	EXCH	DAT,UUOPC(J)
	TLNN	DAT,USRMOD
	JUMPN DAT,@DAT		;RETURN DIRECT IF EXEC MODE, UNLESS 0 (EXIT UUO)
REPEAT 0,<
	MOVSI	AC1,RUN2
	SKIPN	PID
	MOVSI	AC1,RUN1
	TDNN	AC1,JB2STS(J)
	PUSHJ	P,PSWITCH
>
;RESTORE ACS AND DISMISS UUO 

	MOVEM	DAT,UUO0(PID)
	MOVE	JDAT,JBTADR(J)		; MAKE SURE USER'S RELOCATION IS SET UP
	MOVSI	17,JOBAC(PROG)		;RESTORE ALL USER ACS
	JUMPE	PID,USRXT8
	BLT	17,17
	XCT	UUOXIT+P2PID		;JEN @UUO0+P2PID OR CONO PI,PIOFF
	SETOM	CLKFLG+P2PID		;CAUSES TRAP TO CLKIN0 INSTEAD OF CLKINT
	SETOM SCHEDF+P2PID
	CONO	PI,PION!4000!<200⊗-CLKCHN>
	CONSO	PI,77000
	JRST	CL2IN0
	JRST	10,.-2

USRXT8:	BLT	17,17
				; JEN WILL RESTORE FLAGS AND RETURN TO USER
				;DISMISS INTERRUPT ONLY ON TRPJEN UUO
				;IN ALL OTHER CASES NO INTERRUPTS
				;IN PROGRESS
	XCT	UUOXIT		;JEN @UUO0 OR CONO PI,PIOFF
	SETOM	CLKFLG		;HERE WITH INTS OFF IF CLOCK HAS TICKED (SEE CLKINT)
	SETOM SCHEDF		;IN CASE OF 0 PC FROM EXIT
	CONO	PI,PION!4000!<200⊗-CLKCHN>	;NOW (GOES TO CLKIN0 SINCE CLKFLG<0)
	CONSO	PI,77000	;GET HERE ON TRPJEN (ALREADY IN PROGRESS)
	JRST	CLKIN0		;CH7, JUST GO
	JRST	10,.-2		;HIGHER CHN, DISMISS (SHOULDN'T RETURN)

;ROUTINE TO FORCE CLOCK BREAK UPON RETURN TO USER
;ONLY CALL WHEN NEARLY READY TO EXIT FOR INTNOW TO WORK.
USRXTS:	MOVE	TAC,[CONO PI,PIOFF]
	MOVEM	TAC,UUOXIT(PID)
	POPJ	P,

;GET HERE IF RUN BIT WAS OFF
USRXT9:	MOVNI	TAC,STOPQ
	MOVEM	TAC,JOBQUE(J)
	JRST	USRXT2		;GO FORCE SCHEDULE

USRXT5:				;BEYOND HERE USER INTS OK
	CONO	PI,PIOFF
	SETOM	DISFLAG
	PUSHJ	P,DISMES
	ASCIZ	/πππππEXITING UUOCON WITHOUT HAVING ENTERED UUOCON
/
	PUSHJ	P,DISFLUSH
	JRST	AUTOLOAD
;GET HERE WHEN UUOPTR≠0 TO THINK ABOUT LETTING LOSER SIMULATE UUO
;UUOPTR POINTS TO TABLE (IN LOSER'S CORE) OF 3 3-WORD BLOCKS
;EACH BLOCK LOOKS LIKE THIS:

;WD0:	PLACE TO SAVE PC
;WD1:	PLACE TO SAVE UUO ITSELF
;WD2:	PC TO TRANSFER TO

;THE FIRST BLOCK IS USED FOR PDP-10 MAIN PROGRAM UUOS, THE SECOND FOR PDP-10
;INTERRUPT LEVEL UUOS, AND THE THIRD FOR PDP-10 SPACEWAR UUOS. NO PDP-6 UUOS
;CAN BE SIMULATED.  IF EITHER WD1≠0 OR WD2=0 IN A GIVEN BLOCK, THOSE
;UUOS ARE NOT GIVEN TO THE USER'S HANDLER.  THE WD1≠0 CONDITION HAS THE
;EFFECT OF AUTOMATICALLY DISABLING SIMULATION WHILE IN THE SIMULATOR.

UUOSY4:	SKIPE	INTACT(PID)	;FIRST MAKE PNTR TO APPROP BLK
	ADDI	DAT,3
	SKIPE	SPWUUF(PID)
	ADDI	DAT,6
	XCTR	XR,[SKIPN 1(DAT)]	;NOW SEE IF HE REALLY WANTS TO SIMULATE THIS
	XCTR	XR,[SKIPN TAC,2(DAT)]
	JRST	UUOSY3			;NOPE, WE'LL DO OUR THING AS USUAL
	XCTR	XW,[MOVEM UUO,1(DAT)]
	TLO	TAC,USRMOD
	EXCH	TAC,UUOPC(J)		;SWAP PC'S AROUND
	XCTR	XW,[MOVEM TAC,(DAT)]
	JRST	USRXIT			;AND "RETURN" TO HIS SIMULATOR

↑SPWBLK←←6	;TELL SPWSER WHERE TO LOOK

;UUO TO SET UUOPTR TO ENABLE/DISABLE SIMULATOR
;CALL:
;	UUOSIM AC,
;SETS UUOPTR TO C(AC)

UUOSIM:	MOVEM	TAC,UUOPTR(J)
	POPJ	P,
;ROUTINE TO ASSIGN A CHANNEL NUMBER

CHNSET:	POP	P,DAT			;POP UP RETURN ADDRESS
	SKIPE	DDB,USRJDA(UCHN)	;GET ADRESS OF DEVICE DATA BLOCK
	CAMLE	UCHN,USRHCU(PID)	;IS IT LESS THAN OR EQUAL TO HIGHEST
					;USER IO CHANNEL IN USE FOR CURRENT JOB?
	JRST	NOCHAN			;CHANNEL NOT ASSIGNED
CHNSE1:	MOVE	IOS,DEVIOS(DDB)		;GET DATA BLOCK STATUS WORD
	MOVE	DSER,DEVSER(DDB)	;SETUP IO SERVICE DISPATCH TABLE ADDRESS
	CAIL	TAC1,LNGUUO		;LONG DISPATCH TABLE UUO?
	JRST	CHNSE3			;YES
	JRST	2(DAT)

NOCHAN:	MOVE	TAC,UUOPC(J)		;IS UUO FROM USER MODE?
	CAIGE	TAC1,IOUUO		;IO UUO?
	JRST	CHNSE2			;NO.
REPEAT 0,<
	PUSHJ	P,GOTOP1		;ALL IO DONE FROM P1
>
	TLNN	TAC,USRMOD
	JRST	CHNSE1			;EXEC MODE
	CAIE	TAC1,70			;YES,IS IT CLOSE OR RELEASE?
	CAIN	TAC1,71			;CLOSE AND RELEASE ALWAYS LEGAL
	JRST	(DAT)
	JRST	IOIERR			;NO, PRINT IO TO UNASSIGNED CHANNEL AND STOP JOB

CHNSE2:	MOVEI DEVDAT,0		;SET DEVDAT 0 TO FLAG NON-IO UUO
	JRST 2(DAT)		;GO DISPATCH

CHNSE3:	MOVE TAC,DEVMOD(DEVDAT)	;LONG DISPATCH TABLE UUO
	TLNE TAC,DVLNG		;DOES THIS DEVICE HAVE A LONG DISPATCH TABLE?
	JRST 2(DAT)		;YES, DISPATCH
	CAIGE TAC1,76		;NO, IS UUO LOOKUP OR ENTER?
	JRST (DAT)		;NO, RETURN TO USER
	JRST 1(DAT)		;YES, SKIP RETURN TO USER
;TABLE OF UUO DISPATCH ADDRESSES
;IN FORMAT:
;	XWD 40,41
;	XWD 42,43
;	.
;	XWD 76,77
;THERE'D BETTER BE EXACTLY 40 ENTRIES HERE

DEFINE UUOS{FOR X IN(CALL,INIT,,SPCWAR,,,,<CALLI>	;40-47
,OPEN,<TTYUUO,TTYUUO>,,,,RENAME,<IN,TIN>,<OUT,TOUT>	;50-57
,<SETSTS,SETIOS>,STATO,<GETSTS,USTATS>,<STATZ>		;60-63
,<INBUF,UINBF>,<OUTBUF,UOUTBF>,<INPUT,IN>,<OUTPUT,UOUT>	;64-67
,<CLOSE,CLOSE1>,<RELEAS,RELEA1>,MTAPE,<UGETF,UDGF>	;70-73
,<USETI,UDSI>,<USETO,UDSO>,<LOOKUP,UDLK>,<ENTER,UDEN>)}	;74-77

DEFINE UUOADR(C,A,B)
{IFE UUOPHZ,<DEFINE UUOAD1<0,A,B>;>XWD UUOAD2(C,\UUOAD1),UUOAD2(C,,A,B)
UUOPHZ←←1-UUOPHZ}

DEFINE UUOAD2!(C,X,A,B)
{IFIDN <A!B><><UUOERR+>IFDIF <B><><B+>IFDIF <A><><IFIDN <B><><C!A+>>0}

UUOPHZ←←0
UUOTAB:	UUOS
{	UUOADR U,X
}
XP IOUUO,55			;LOWEST IO UUO(RENAME)
XP LNGUUO,72			;LOWEST LONG DISPATCH TABLE UUO
;IOT UUO DISPATCH TABLE

UUOIOT:	SUBI TAC1,700		; MAKE 700-777 INTO 0-77
	CAIL TAC1,2*IUUMAX	; DOES THIS ONE EXIST?
	JRST ILLINS		; NO, ILLEGAL INSTRUCTION
	AOS NIOTS		; BUMP NUMBER OF IOT UUOS USED
	ROT TAC1,-1
	MOVE DAT,IUUTAB(TAC1)	; PICK UP DISPATCH ADDRESS
	MOVEI DEVDAT,[SIXBIT /GARPLY/]	;INIT. FOR ERROR PRINTOUTS.
	AOS NNUUOS		; BUMP COUNT OF DISPATCHES
	JRST DISP4

DEFINE IUUOS{FOR X IN(<,CPOPJ>,DPYCLR,PPIOT,<UPGIOT>		;700-703
,<UINBF,MINBF>,<UOUTBF,MOUTBF>,<FBREAD,UFBRD>,<FBWRT,UFBWRT>	;704-707
,<MAIL,UMAIL>,PTYUUO,POINTS,<UPGMVE,UPGMOV>			;710-713
,UPGMVM,PGIOT,CHNSTS,<CLKINT,CLKUUO>				;714-717
,INTMSK,IMSKST,IMSKCL,INTUUO,IOPUSH,IOPOP,IOPDL)}		;720-726

UUOPHZ←←0
IUUTAB:	IUUOS
{	UUOADR ,X
}
IFN UUOPHZ,<UUOADR>
IUUMAX←←.-IUUTAB

;UUO NAME TABLE, FOR FAIL, ETC.

IFE UUOPHZ,<IUUMAX*2,,UUOFLK;>IUUMAX*2-1,,UUOFLK ;LINK TO TABLES FOR TTYUUO, ETC.
↑UUONAM:UUOS
{	<SIXBIT ,X,>
}	IUUOS
{	<SIXBIT ,X,>
}
;CALL AND CALLI
; CALLING SEQUENCE
;	CALL D,[SIXBIT/NAME/]
; WHERE NAME IS THE NAME OF A SYSTEM ROUTINE.
; IF NO SYSTEM ROUTINE WITH THE SPECIFIED NAME IF FOUND, THIS ROUTINE
; EXITS TO UUOERR.
;CONTENTS OF USER AC PLACED IN AC TAC,UUO SET TO POINT
;TO USER AC, PROG IN LH.
;ITEM SET TO JOB NUMBER



UCALL:
	XCTR	XR,[MOVE DAT,(UUO)]	;PICK UP NAME OF SYSTEM ROUTINE
	MOVSI	TAC1,-UCLLEN
	CAME	DAT,UCLTAB(TAC1)	;SEARCH SYSTEM ROUTINE NAME TABLE
	AOBJN	TAC1,.-1
	TLZN	TAC1,-1			;CLEAR LH. WAS IT ZERO?
	JRST	UUOERR			;YES. RAN OUT OF TABLE
	JRST	UCALL1			;NO. DISPATCH.


;CALLI UUO	-	CALL IMMEDIATE
;CALLI D,E
;WHERE E IS RELATIVE INDEX IN CALL TABLE


↑UCALLI:
	HRRZ	TAC1,UUO
	CAIL	TAC1,UCLDLN		;EXCEED ?
	JRST	UCALL2			;YES. ERROR
UCALL1:	POP	P,TAC			;REMOVE RETURN
	HRR	UUO,UCHN		;UUO AC FIELD
	XCTR	XR,[MOVE TAC,(UUO)]	;PICK UP CONTENTS OF USER AC
	ROT	TAC1,-1			;DIVIDE BY 2 AND SAVE REMAINDER
	MOVE	DAT,UCLJMP(TAC1)	;GET DISPACTH TABLE ENTRY
	MOVE	J,JOB(PID)
	JRST	DISP4			;AND GO DISPATCH

UCALL2:	TRZN	UUO,400000		;IS HE ASKING FOR A STANFORD CALLI?
	JRST	UUOERR			;NO, SHOOT HIM!! BANG!
	MOVEI	TAC1,UCLDLN(UUO)
	CAIL	TAC1,UCLDLN		;IF NOT BIGGER THAN THIS, FLUSH IT!
	CAIL	TAC1,UCLLEN		;STILL TOO LARGE?
	JRST	UUOERR			;YES, FLUSH
	AOS	NSCALL			;BUMP NUMBER OF STANFORD CALLIS USED
	JRST	UCALL1
;CALL UUO DISPATCH TABLE
;NEW UUOS MUST BE ADDED AT END SINCE CALLI DEPENDS ON
;POSITION IN TABLE
;ALSO NUMBER OF DEC CALLIS MUST BE EVEN


DEFINE NAMES!,<
	X RESET,RESETUUO	;RESET IO
	X DDTIN,DDTIN		;EXT-GET DDT CHAR.
	X SETDDT,SETDDT		;SETDDT LOC IN PROTECTED JOB DATA
	X DDTOUT,DDTOUT		;EXT:SEND DDT CHAR.
	X DEVCHR,DVCHR		;DEVICE CHARACTISTICS
	X DDTGT,CPOPJ		;GET DDT MODE
	X GETCHR,DVCHR		;DEVICE CHAR.(DIFF. NAME)
	X DDTRL,CPOPJ		;RELEASE DDT MODE

	X WAIT,WAIT		;WAIT TILL DEVICE INACTIVE
	X CORE,CORUUO		;CORE UUO
	X EXIT,EXIT		;EXIT
	X UTPCLR,UTPCLR		;CLEAR DEC TAPE DIRECTORY 
	X DATE,DATE		;GET DATE
	X LOGIN,LOGIN		;LOGIN
	X APRENB,APRENB		;ENABLE APR FOR TRAPPING
	X LOGOUT,LOGOUT		;LOGOUT

	X SWITCH,SWITCH		;RETURN DATA SWITCHES
	X REASSIGN,REASSIGN	;REASSIGN DEVICE TO ANOTHER JOB
	X TIMER,TIMER		;RETURN JIFFY CLOCK TIME
	X MSTIME,MSTIME		;RETURN TIME OF DAY IN MS
	X GETPPN,GETPPN		;RETURN PROJECT-PROGRAMMER NUMBER
	X <>,UUOERR		;TRPSET ILLEGAL
	X <>,UUOERR		;TRPJEN ILLEGAL
	X RUNTIM,JOBTIM		;RETURN TOTAL JOB RUNNING TIME

	X PJOB,JOBNO		;RETURN JOB NUMBER
	X SLEEP,SLEEP		;SLEEP FOR N SECONDS, THEN RETURN TO USER
	X SETPOV,SETPOV		;SET PUSH DOWN OVERFLOW TRAP (FOR COMPAT ONLY)
	X PEEK,PEEK		;PEEK INTO SYSTEM CORE.		;JS
	X GETLN,GETLN		;GET NAME OF TTY
	X RUN,RUNUUO		;DEC'S SWAP UUO
	X SETUWP,SETUWP		;SET USER WRITE PROTECT
	X REMAP,REMAP		;REDO CORE MAP

	X GETSEG,CPOPJ		;GET SEGMENT
	X GETTAB,CPOPJ		;GETTAB ILLEGAL (ERROR RETURN) HERE.
	X <>,UUOERR		;SPY ALSO ILLEGAL
	X SETNAM,SETNAM		;SET JOB NAME
	X TMPCOR,TMPCOR		;TEMPORARY FILES FOR RPG, ETC.
	X <>,UUOERR		;FILL OUT THE TABLE
>
; THE FOLLOWING ARE STANFORD'S OWN PRIVATE CALLI'S

DEFINE STANFORD <
	X SPWBUT,SPCWAR		;READ SWITCH REGISTER
	X CTLV,CTLV		;PUT TTY IN NON-DUPLEX MODE.
	X <>,SETNAM		;SET JOB NAME FOR SYSTAT (OBSOLETE)
	X SPCWGO,SPCWGO		;ANOTHER SPACEWAR UUO
	X SWAP,SYSRJB		;RUN A JOB
	X EIOTM,EIOTM		;ENTER IOT USER MODE
	X LIOTM,LIOTM		;LEAVE IOT USER MODE
	X PNAME,PNAME		;GET A DEVICE'S PHYSICAL NAME
	X UFBGET,UFBGET		;GET A FAST BAND - 400010
	X UFBGIV,UFBGIV		;RELEASE A FAST BAND
	X UFBCLR,FBFLUSH	;RELEASE ALL FAST BANDS
	X JBTSTS,USTAT		;GET JOB STATUS WORD OF A JOB
	X TTYIOS,TTYIOS		;GET A JOB'S TELETYPES STATUS WORD
	X CORE2,CORE2		;FUNNY CORE UUO FOR HIGH SEGMENTS
	X ATTSEG,ATTSEG		;ATTACH HIGH SEGMENT
	X DETSEG,DETSEG		;DETACH HIGH SEGMENT
	X SETPRO,SETPRO		;CHANGE PROTECTION OF HIGH SEGMENT - 400020
	X SEGNUM,SEGNUM		;GET NUMBER OF HIGH SEGMENT
	X SEGSIZ,SEGSIZ	
	X LINKUP,LINKUP
	X DISMIS,DISMIS
	X INTENB,INTENB		; ENABLE INTERRUPTS
	X INTORM,INTORM
	X INTACM,INTACM
	X INTENS,INTENS		; 400030
	X INTIIP,INTIIP
	X INTIRQ,INTIRQ
	X INTGEN,INTGEN		; GENERATE AN INTERRUPT
	X UWAIT,UWAIT
	X DEBREAK,DEBREAK
	X SETNM2,SETNM2		; SET NAME OF UPPER, IF ANY
	X SEGNAM,SEGNAM		; GET NAME OF UPPER, IF ANY
	X IWAIT,IWAIT		; GO INTO A WAIT STATE, WAKE UP ON ANY INTERRUPT. - 400040
	X USKIP,USKIP		; SKIP IF A UWAIT REALLY HAS TO WAIT.
	X BUFLEN,BUFLEN		; RETURN BUFFER LENGTH FOR A DEVICE
	X NAMEIN,NAMEIN		; SEE IF THIS JOB NAME EXISTS
	X SLEVEL,SETLVL		; SET OR GET SERVICE LEVEL.
	X IENBW,IENBW		; ENABLE INTERRUPTS AND IMMEDIATELY GO INTO WAIT STATE
	X RUNMSK,RUNMSK		; SETS PROCESSOR RUN MASK
	X TTYMES,TTYMES		; SEND A STRING TO A TTY
	X JOBRD,JOBRD		; READ A BLOCK FROM A GUY'S CORE IMAGE - 400050
	X DEVUSE,DEVUSE		; TO TELL HOW MANY PEOPLE ARE WAITING FOR A DEVICE
	X SETPR2,SETPR2		; SET SECOND PROTECT-RELOCATE REGISTER!
	X GETPR2,PR2GET		; GET LAST SETPR2 VALUE
	X RLEVEL,RLEVEL		; GET CURRENT SERVICE LEVEL RESERVATION
	X UFBPHY,FBPHY		; GET PHYSICAL BAND NUMBER
	X UFBSKP,FBSKP		; SKIP IF NO TRANSFER IN PROGRESS
	X FBWAIT,FBWT		; WAIT FOR TRANSFER TO FINISH
	X UFBERR,FBERR		; SKIP IF NO ERRORS IN LAST TRANSFER. 400060
	X WAKEME,WAKEME		; SET ALFRED. TIME TO INITIALIZE A JOB.
	X GETNAM,GETNAM		;RETURN JOBNAME IN AC
	X SNEAKW,SNEAKW		; PEEK AT NEXT TTY CHAR. AND WAIT FOR IT
	X SNEAKS,SNEAKS		; PEEK AT NEXT TTY CHAR. AND SKIP IF ONE THERE
	X GDPTIM,GDPTIM		; GET TIME CELLS
	X SETPRV,SETPRV		; RESET JOBTPRV
	X DDCHAN,DDCHAN		;GET/RELEASE DD CHANS ETC.
	X VDSMAP,VDSMAP		;CHANGE VIDEO SWITCH MAPPING - 400070
	X DSKPPN,UDSKPPN	;GET OR SET DISK ALIAS PPN
	X DSKTIM,DSKTIM		;DATE & TIME A LA DSKSER
	X SETCRD,SETCRD		;SET JOB CREATION DATE & TIME
	X CALLIT,CALLIT		;TRANSLATE CALL TO CALLI OR VICE VERSA
	X XGPUUO,XGPUUO		;FONT COMPILER & XGPSER COMMUNICATION.
	X LOCK,LOCK		;LOCK A JOB IN CORE.
	X UNLOCK,UNLOCK		;UNLOCK A JOB
	X DAYCNT,DAYCT		;SYSTEM DATE TO DAY COUNT. - 400100
	X ACCTIM,ACCTIM		;RETURN <DATE>,,<TIME IN SECS>
	X UNPURE,UNPURE		;UNPURIFY UPPER SEGMENT
	X TMPCRD,TMPCRD		;READ OTHER JOB'S TMPCOR
	X DEVNUM,DEVNUM		;CONVERT LOGICAL DEV NAME OR CHANNEL # TO UNIT #
	X ACTCHR,ACTCHR		;WAIT FOR ACTIVATION AND RETURN CHAR WHICH DUN IT
	X UUOSIM,UUOSIM		;SET UP UUO SIMULATOR
	X PPSPY,PPSPY		;LIKE PPINFO FOR ANOTHER JOB
	X ADSMAP,ADSMAP		;SET/READ AUDIO SWITCH SELECTIONS -400110
	X BEEP,BEEP		;BEEP A TTY'S CHANNEL
	X WHO,WHOUUO		;READ SYSTEM OR USER WHO LINE
	X TTYJOB,TTYJNO		;GET JOB # ON THIS TTY
	X (,UUOERR)		;	"   IOPDL
	X GETPRV,GETPRV		;GET PRIVILEGES BY JOB #
	X TTYSKP,TTYSKP		;SKIP IF TTY INPUT UUO WON'T HANG
	X DIAL,DIAL		;DIAL UUO
>
;NOTE, USE UP THE UUOERR ENTRIES BEFORE MAKING NEW ONES
; MACROS TO DEFINE CALLI TABLES

DEFINE X! (A,B)
<
	<SIXBIT /A/>
>
↑UCLTAB:		;POINTER TO HERE IN OUTER
	XLIST
	NAMES
XP UCLDLN,.-UCLTAB
	STANFORD
	LIST
XP UCLLEN,.-UCLTAB
	UUONAM		;POINTER TO FIND REST OF UUO NAMES

DEFINE X!(A,B)
<IFE ZZ/2*2-ZZ,<DEFINE ZZZ<B>>
IFN ZZ/2*2-ZZ,<XWD ZZZ,B>
ZZ←←ZZ+1
>

ZZ←←0

UCLJMP:
	XLIST
	NAMES
	STANFORD
	LIST

IFN ZZ/2*2-ZZ,<XWD ZZZ,0>
;EXIT UUO ROUTINE

;(1-14-72) EXIT UUO WITH AC FIELD ≠ 0 WILL STOP JOB,
;TYPE CRLF DOT AND ALLOW USER TO TYPE CONTINUE

EXIT:	MOVE	TAC,JBTSTS(J)
	HRRE	TAC1,JBTLIN(J)
	JUMPL	TAC1,EXIT1	;KILL DETACHED JOB THAT EXIT!
	TLNN	TAC,JLOG	;LOGGED IN?
	JRST	EXIT1		;FLUSH DETATCHED OR UNLOGGED IN JOBS
	JUMPN	UCHN,EXIT2	;IS THIS CALLI N,12 WITH N≠0
	PUSHJ	P,IORELS	;FLUSH USER'S IO
	PUSHJ	P,RESETB	;RESET EVERYTHING ELSE
	PUSHJ	P,TTYFUW	;FIND TTY FOR CURRENT JOB
				;SET ITEM TO JOB NO.,DAT TO OUTPUT BYTE POINTER
				;DEVDAT TO TTY DDB
	SETZM JOBOPC(PROG)	;NO MORE OPC
	SETZM UUOPC(J)		;OR USER PC (NOTE ESTOP CHANGED TO GO TO USRXIT)
	SETZM UUOOPC(J)		;OR BACKUP USER PC
				;NOTE ALL THIS MEANS THAT THE NEXT START, ETC.
				;WILL LEAVE A 0 IN JOBOPC (HERE'S TO CLEAN RAID SCREENS)
	JSP TAC,PHOLD		;MOVE "EXIT" TO OUTPUT BUFFER
				;AND STOP JOB, AND START TTY
	ASCIZ /
EXIT/

EXIT1:	PUSHJ	P,IORELS	;HERE TO KILL JOB.  FLUSH USER IO
	PUSHJ	P,KILSPW	; ZERO SPACEWAR CELLS
IFN FTSWAP,<	JRST	JOBKL	>
IFE FTSWAP,<	JRST	ESTOP	>


EXIT2:	PUSHJ	P,KILSPW	; ZERO SPACEWAR CELLS
	PUSHJ	P,TTYFUW	;GET THE USER'S CONSOLE
	PUSHJ P,PRCRCC		;TYPE CRLF ↑C CRLF .
	PUSHJ	P,TTYSTC	;START THE TTY
	JRST	STOP1		;COPIED (BLINDLY) FROM HALT, (LAME EXCUSE)
;SETPOV - SET PUSH DOWN OVERFLOW TRAP
;CALL	MOVE AC,ADR. OF TRAP ON PD OVF
;	CALL AC,[SIXBIT /SETPOV/]


SETPOV:	MOVEM TAC,JOBAPR(JDAT)
	MOVEI TAC,1B19
	JRST APRENB		;SET TRAP LOC.

;RESET UUO ROUTINE

↑RESET:	PUSHJ P,RESETSEG
RESETUUO:
	SKIPE SPWUUF(PID)		;AT SPACEWAR LEVEL?
	JRST SPWERR			;FLUSH THE BASTARD
	SKIPN INTACT(PID)
	JRST RESETA
	JSP TAC,UUOMES
	ASCIZ /RESET CALLED FROM I-LEVEL, OR SPACEWAR LEVEL
UUO/

RESETA:	PUSHJ	P,IOKILL	;RELEASE ALL DEVICES
RESETB:	PUSHJ	P,INTKILL	;CLEAR THE USER INTERRUPT SYSTEM (FLUSHES CLK REQS)
	PUSHJ	P,UNLOCK	;UNLOCK HIM IN CORE.
	SKIPE	TAC,JBTPR2(J)	;IS HE DOING PEEK-POKE?
	TRNE	TAC,2		;DON'T CLEAR PSEUDO-UPPER
	JRST	NOPR2		;NO
	SETZM	JBTPR2(J)	;CLEAR IT
	PUSHJ	P,GETPR
	DATAO	APR,TAC		;AND INDICATE IN PROT.,RELOC, REG.
NOPR2:				;AND RETURN TO USER
	MOVE	J,JOB(PID)
	SKIPE	AC1,JBTFS(J)	;ANY FREE STORAGE?
	PUSHJ	P,FSGIVE	;YES, RETURN IT
	SETZM	JBTFS(J)
	PUSHJ	P,KILSPW
IFN FTSWAP,<
	PUSHJ	P,FBFLUSH	;RELEASE ALL HIS FAST BANDS
>
	SETZM	TAC
	PUSHJ	P,APRENB	;KILL HIS APR INTERRUPTS
	SKIPE	AC1,JBTMAIL(J)	;ANYTHING IN HIS MAILBOX ?
	PUSHJ	P,FSGIVE	;YES. RETURN THE FREE STORAGE.
	SETZM	JBTMAIL(J)	;EMPTY THE MAILBOX.
	PUSHJ	P,PTYCLR	;FLUSH HIS PSEUDO TTY'S, IF ANY.
	MOVSI	TAC,(J)
	PUSHJ	P,DDAREL	;FLUSH HIS DATA DISC CHANNELS
	PUSHJ	P,ADSRES	;RESET AUDIO SWITCH MAP
	MOVE	AC1,JBTLIN(J)	;PICK UP LINE CHARACTERISTICS
	CAME	AC1,[-1]	;DETACHED?
	TLNN	AC1,DISLIN!DDDLIN	;IF III OR DD, GO RESET THE DISPLAY
	POPJ	P,		;NO, NO RESET OF SCREEN
	JRST	DPYRST		;RESET HIS DPY, IF HE HAS ONE.
; ROUTINE TO RESET ONE'S UPPER SEGMENT

RESETSEG:
	PUSH	P,TAC
	PUSH	P,AC1
	PUSH	P,TAC1
	PUSH	P,DDB
	PUSHJ	P,FLUSHSEG	; FLUSH HIS UPPER, IF ANY
	CAME	ITEM,JOB(PID)	; IS THIS THE CURRENT JOB?
	JRST	RESTG1		; NO, DON'T BOTHER TO RESET PR
	PUSHJ	P,GETPR		; RESET HIS PROT-RELOC
	DATAO	APR,TAC
RESTG1:	POP	P,DDB
	POP	P,TAC1
	POP	P,AC1
	POP	P,TAC
	POPJ	P,
;APRDKL  ROUTINE TO KILL ANY CLOCK INTERRUPT REQUESTS FOR JOB J

APRDKL:	JUMPN PID,CPOPJ
	PUSH P,TAC1		;SAVE THIS IN CASE SOMEONE DEPENDS ON IT
	CONI PI,TAC1		;GET STATE OF PI SYSTEM
	ANDI TAC1,APROFF-1000	;MASK FOR ONLY STATE OF APR CHANNEL
	CONO PI,APROFF		;MAKE SURE CHANNEL IS OFF
	SKIPE TAC,APRLST
APRDK3:	SKIPN AC1,(TAC)
	JRST APRDK1		;APRLST EMPTY OR END OF LIST
	CAIN J,(AC1)
	JRST APRDK2		;THIS IS OUR REQUEST
	ADDI TAC,2
	JRST APRDK3

APRDK2:	PUSHJ P,APRDEL		;DELETE REQUEST POINTED TO BY TAC
	JFCL
APRDK1:	CONO PI,2000(TAC1)	;TURN CHANNEL ON ONLY IF WE TURNED IT OFF.
	POP P,TAC1
	POPJ P,
;APRENB - ROUTINE TO SET UP APR FOR USER TRAPPING
;CALL:	CALL AC,[SIXBIT /APRENB/]
;WITH FOLLOWING APR CONSO FLAG BITS
;TO INDICATE WHICH APR CONDITIONS SHOULD
;TRAP TO USER WHEN TRAP OCCURS FROM USER MODE

;1B18	;CONS TRAP		;JS
;1B19	;PUSHDOWN OVERFLOW
;1B22	;ILLEGAL MEMORY
;1B23	;NON-EXISTENT MEMORY
;1B26	;CLOCK
;1B29	;PC CHANGE FLAG (AR FOV ON THE PDP-10)
;1B32	;ARITH. OVERFLOW

CPUMSK←←1B18!1B19!1B22!1B23!1B29!1B32	;MASK FOR CPU INT BITS (EXCEPT CLOCK)

↑APRENB:
	ANDI TAC,CPUMSK!1000		;MASK OUT ILLEGAL BITS ;JS
	MOVEM TAC,JOBENB(JDAT)		;SET RH TO CONSO BITS
	TDNE TAC,APRIN2(PID)
	JRST INTLOS
	IOR TAC,APRIN2(PID)		;MAKE SURE WE INCLUDE OTHER MOORER INTS
APREN2:	HRRM TAC,APRIN1(PID)		;SET CONSO FLAGS IN APRSER ROUTINE WITH
					;WITH FLAGS USER IS ENABLED FOR
	XORI TAC,1B29+1B32		; COMPLEMENT PC CHNG AND AROV
	ADDI TAC,330			; DISABLE THE ENABLED ONES
	ANDI TAC,660
	CONO APR,APRCHN(TAC)		;ENABLE OR DISABLE PC CHANGE AND OR OVF
	POPJ PDP,
;PJOB, DATE, DAYCNT, ACCTIM, DSKTIM, JOBTIM, MSTIME UUO'S

JOBNO:	MOVE	TAC,ITEM		;RETURN JOB NUMBER OF THIS JOB
	JRST	STOTAC			;STORE IN USER AREA.

DATE:	MOVE	TAC,THSDAT		;RETURN DATE TO USER
	JRST	STOTAC

;CONVERT SYSTEM FORMAT DATE TO NUMBER OF DAYS SINCE 1-JAN-64
DAYCT:	JUMPG	TAC,.+2		;ARGUMENT IN SYSTEM FORMAT TO DAY COUNT.
	MOVE	TAC,THSDAT	;ZERO OR NEGATIVE DATE GIVEN GETS TODAY'S DATE
	PUSHJ	P,DAYCNT	;THIS ROUTINE IS IN COMCON
	JRST	STOTAC

ACCTIM:	MOVE	TAC,TIMDAT	;GET <DATE>,,<TIME IN SECS>
	JRST	STOTAC		;AND RETURN IT

DSKTIM:	PUSHJ	P,DSKTM1	;RETURN DATE & TIME IN DSKSER FORMAT
	XCTR	XW,[MOVEM TAC1,(UUO)]
	POPJ	P,

;RETURN JOB RUNNING TIME IN MILLISECONDS
JOBTIM:	JUMPL	TAC,RTZERO	;ILLEGAL JOB NUMBER
	CAIL	TAC,JOBN	
	JRST	RTZERO		;ILLEGAL JOB NUMBER
	JUMPG	TAC,.+2
	MOVEI	TAC,(J)		;ASSUME CURRENT JOB FOR ZERO ARGUMENT
	MOVE	TAC,TTIME(TAC)	;TOTAL JOB RUNNING TIME IN TICKS.
	JRST	MST1		;CONVERT TO MILLISECONDS AND RETURN

TIMER:	MOVE	TAC,TIME	;RETURN TIME OF DAY IN JIFFIES
	JRST	STOTAC

;RETURN TIME OF DAY IN MILLISECONDS
MSTIME:	MOVE	TAC,TIME	;GET TIME OF DAY
MST1:	IMULI	TAC,=1000	;CONVERT TIME FROM JIFFIES TO MILLISECONDS
	IDIVI	TAC,JIFSEC	;DIVIDE BY NO. OF JIFFIES PER SECOND
	JRST	STOTAC
;SLEEP	PUT JOB TO SLEEP FOR NSECONDS
;CALL	CALL AC,[SIXBIT /SLEEP/]


↑SLEEP:
	IMULI TAC,JIFSEC	;MULTIPLY BY NO. OF JIFFIES PER SECOND
↑SLEEPT:MOVSI TAC1,CLKR
	TDNE TAC1,JBTSTS(ITEM)	;DOES THIS JOB HAVE A CLOCK QUEUE
				;REQUEST IN CLOCK QUEUE?
	JRST SETSLP		;YES, DO NOT PUT ANOTHER ONE IN
	TRNN TAC,7777		;0 TIME?  ;JS
SLEEP1:	MOVEI TAC,1		;YES. SLEEP 1 JIFFY
	DPB ITEM,[POINT 6,TAC,23]
	HRLI TAC,WAKE		;ADR. IN RUNCSS WHEN JOB WAKES UP
	CONO PI,PIOFF
	IDPB TAC,CLOCK
	CONO PI,PION
	JRST SETSLP		;SET JOB STATUS WORD SO JOB WILL NOT RUN
;SWITCH	RETURN DATA SWITCHES

SWITCH:	DATAI	TAC			;READ SWITCHES, FALL INTO STOTAC


;ROUTINE TO STORE TAC IN USER AREA AS SPECIFIED BY UUO
;MUST BE CALLED FROM UUO LEVEL WITH PROG SETUP
;ALSO PROG IN INDEX FIELD OF UUO

↑STOTAC:
	XCTR	XW,[MOVEM TAC,(UUO)]	;STORE TAC INTO USER'S AC
	POPJ	P,
;DVCHR, DEVNUM

DVCHR:	PUSHJ	P,FNDDDB	;SEARCH FOR DEVICE (OR CHANNEL)
	TDZA	TAC,TAC		;NOT A DEVICE, RETURN ZERO
	SKIPA	TAC,DEVMOD(DDB)	;DEVICE FOUND,RETURN DEVMOD
	JRST	STOTAC		;RETURN ZERO, DEVICE NOT FOUND
	TLNN	TAC,DVUDP
	JRST	DVCHR2		;EASY OUT UNLESS UDP
	LDB	AC2,PUNIT	;UDP, SCAN ENTIRE DDB LIST OF THIS UDP
	MOVE	TAC1,DKDBML(AC2)
	MOVE	AC1,DEVNAM(DDB)
DVCHR0:	HLRZ	TAC1,DEVSER(TAC1)
	CAME	AC1,DEVNAM(TAC1)
	JRST	DVCHR1		;END OF DDBS FOR THIS DEVICE
	IOR	TAC,DEVMOD(DDB)	;RETURN UNION OF ALL ASSCON AND ASSPRG BITS
	JRST	DVCHR0

DVCHR1:	SKIPL	TAC1,UDPOWN-1(AC2)
	CAMN	TAC1,JOB(PID)
	TLO	TAC,DVAVAL	;AVAILABLE IF HIS OR PUBLIC
	JRST	STOTAC

DVCHR2:	LDB	TAC1,PJOBN	;GET JOB NO.  USING DEVICE
	CAME	TAC1,JOB(PID)	;DOES CURRENT USER ALREADY HAVE IT?
	TDNN	TAC,[XWD TTYATC,ASSCON+ASSPRG]	;NO, IS IT ASSIGNED?
	TLO	TAC,DVAVAL	;NO, BUT HE CAN GET IT.
	JRST	STOTAC

DEVNUM:	PUSHJ	P,FNDDDB
	POPJ P,			;NONE
	LDB TAC,PUNIT		;GET UNIT NUMBER
	AOS (P)
	JRST STOTAC
;GETPPN -- DSKPPN

;DSKPPN
;CALLING:
;	CALL AC,[SIXBIT/DSKPPN/]
;
;AC		MEANING
;0		RETURN CURRENT JOB'S DSKPPN
;1 TO JOBN-1	RETURN DSKPPN OF JOB IN AC
;-1		RESET DSKPPN OF CURRENT JOB
;ANYTHING ELSE	WILL TRY TO BE PPN TO SET DSKPPN TO
;		MUST HAVE NON-ZERO LEFT AND RIGHT HALVES

UDSKPPN:
IFN FTDSKPPN,<
	CAMN	TAC,[-1]	;REQUESTING A RESET?
	AOJA	TAC,RSTPPN	;YES, SET TAC TO 0 AND STORE IT
	TLNN	TAC,-1		;IS IT PPN?
	JRST	RTDSKPPN	;NO, MAYBE JUST GETTING SOMEONES DSKPPN
	TRNN	TAC,-1
	HRR	TAC,PRJPRG(J)	;COPY PRG FROM PRJPRG
RSTPPN:	CAMN	TAC,PRJPRG(J)
	MOVEI	TAC,0		;THIS IS REALLY A RESET
	CAMN	TAC,MFDENT	;SAME AS 1,1?
	POPJ	P,		;DISALLOW SOME FORMS OF LOSSAGE.
	CAME	TAC,DSKPPN(J)
	SETZM	JBTUFD(J)	;CLEAR LOC OF UFD IF DEFAULT UFD IS CHANGING
	MOVEM	TAC,DSKPPN(J)	;SET NEW DISK ALIAS PPN
	POPJ	P,

RTDSKPPN:
	JUMPN	TAC,.+2
	MOVE	TAC,J			;WANTS HIS OWN
	MOVSI	TAC1,JNA
	CAIGE	TAC,JOBN		;LEGAL?
	TDNN	TAC1,JBTSTS(TAC)	;AND A REAL JOB?
	JRST	RTZERO			;NO
	SKIPN	TAC1,DSKPPN(TAC)	;IF THIS IS 0
	MOVE	TAC1,PRJPRG(TAC)	;THEN THIS IS IT
>;FTDSKPPN
IFE FTDSKPPN,<
	MOVE	TAC1,PRJPRG(J)
>;FTDSKPPN
	XCTR	XW,[MOVEM TAC1,(UUO)]	;RETURN IT
	POPJ	P,

↑RTZERO:MOVEI	TAC,0
	JRST	STOTAC

;RETURN PROJECT-PROGRAMMER NUMBER IN AC
GETPPN:
IFE FTLOGIN,<
	JRST	RTZERO
>
IFN FTLOGIN,<	
	MOVSI	TAC,JACCT		;ACCOUNTING PROGRAM?
	TDNE	TAC,JBTSTS(J)
	JRST	GETPPL			;YES. GETPPN DOES DIFFERENT THING
	MOVE	TAC,PRJPRG(J)
	JRST	STOTAC

GETPPL:	SETZM	JBTUFD(J)	;ACCOUNTING: ANY OTHER USERS UNDER SAME PPN?
IFN FTDSKPPN,<
	SETZM	DSKPPN(J)	;RESET DISK ALIAS PPN
>
	MOVE	TAC,DUMPPN	;GET ALL POWERFULL PPN
	EXCH	TAC,PRJPRG(J)	;SET THIS JOB TO THAT PPN
	MOVEI	TAC1,JOBN-1	;LOOK THRU ALL THE WORLD
	CAMN	TAC,PRJPRG(TAC1);SKIP IF NOT MATCHED
	CAMN	J,TAC1		;MATCH. SKIP IF MATCH DIFFERENT FROM JOB NUMBER
	SOJG	TAC1,.-2	;NO MATCH OR MATCHED SELF. LOOP
	JUMPLE	TAC1,STOTAC	;IF TAC1 = 0 THEN NO MATCH
	AOS	(P)		;MAKE IT SKIP RETURN
	JRST	STOTAC		;GO RETURN
;SETNAM, SETCRD, SETDDT, GETNAM

SETNAM:	MOVE J,JOB(PID)
	MOVEM TAC,JOBNAM(J)	;SET JOB NAME FOR SYSTAT
IFN FTSTAT,<PUSHJ P,NAMSTT>
	POPJ PDP,

;SET CREATION DATE & PROT

SETCRD:	TLZE TAC,400000		;CLEAR & CHECK UNUSED BIT
	JRST SETCD2		;ANY OF THESE MEANS DO IT TO THE UPPER
SETCD1:	MOVEM TAC,JOBCRD(J)
	TDNE TAC,[37,,-1]
	POPJ P,
	PUSHJ P,DSKTM1
	IORM TAC1,JOBCRD(J)
	POPJ P,

SETCD2:	PUSH P,J	;SAVE FOR ACCESS
	LDB J,PSEGN
	JUMPE J,TPOPJ	;EASY IF NO UPPER
	MOVE AC1,TAC	;ELSE SAVE ARG
	PUSHJ P,ACCESS	;AND MAKE SURE THIS IS LEGAL
	JRST TPOPJ
	JRST TPOPJ
	SUB P,[1,,1]	;DON'T NEED THAT JOB # ANY MORE
	MOVE TAC,AC1
	JRST SETCD1


SETDDT:	MOVEM	TAC,USRDDT(PID)	;ROUTINE TO SET ONE'S DDT STARTING ADDRESS
	POPJ	P,		;RETURN TO USER

GETNAM:	JUMPLE	TAC,GETNA1	;GET JOBNAME GIVEN JOB NUMBER
	CAIL	TAC,JOBN
GETNA1:	MOVE	TAC,J
	MOVE	TAC,JOBNAM(TAC)
	JRST	STOTAC
;WAIT FOR IO TO BECOME INACTIVE ON CHANNEL AC


WAIT:	JUMPE DEVDAT,IOIERR	;CHANNEL ASSIGNED?
	JRST WAIT1		;WAIT TILL INACTIVE BEFORE
				;RETURNING TO USER.

GETLN:	PUSHJ PDP,TTYFND	;GET NAME OF TTY
	MOVE TAC,DEVNAM(DEVDAT)
	JRST STOTAC
;CRKSER -- READ THE PETIT CROCK, J. SAUTER, REST OF PAGE.

;FOR A DESCRIPTION OF THE ON-LINE CALENDAR CLOCK SEE
;SAILON MEMO NUMBER 9.

;DATIME SKIPS RETURN IF CLOCK IS OK AND RETURNS IN DAT
;THE YEAR, MONTH, AND DAY IN STANDARD SYSTEM FORMAT.
;IN ITEM THE TIME TO THE NEAREST JIFFIE.

;USED TO SKIP RETURN.

↑DATIME:
	MOVEI TAC1,1000		; TRY ONLY 1000 TIMES
DAT2:	CONI PCLK,TEM		;READ FAST PART.
	DATAI PCLK,TAC		;READ SLOW PART.
	JUMPG TAC,DAT1		;CLOCK IS VALID.
DAT2A:	SOJG TAC1,DAT2		;INVALID, RETRY.
	POPJ PDP,		;TOO MANY RETRIES, CONSIDER IT SICK.

DAT1:	SUBI TAC,5004		;NORMALIZE CROCK DATA.
	SUB TEM,[2020136700]	;AND FAST PART.
	LDB ITEM,[POINT 4,TEM,9]
	LDB DAT,[POINT 4,TAC,35]
	CAME DAT,ITEM		;DID READINGS GIVE THE SAME MINUTE?
	JRST DAT2A		;NO. GO RETRY.
	TLNE TAC,200000		;YEAR INVALID?
	POPJ PDP,		;YES. CROCK SICK.
	LDB ITEM,[POINT 4,TAC,19]	;MONTH.
	SUBI ITEM,4
	CAIL ITEM,=12
	POPJ PDP,
	IMULI ITEM,=31
	MOVEM ITEM,DAT
	LDB ITEM,[POINT 5,TAC,24]
	ADDM ITEM,DAT		;ADD IN DAY.
; FINISH READING PCROCK, CONVERT TO STANDARD FORM

	LDB TAC1,[POINT 4,TAC,11]
	CAILE TAC1,=7		;> 1979?
	POPJ PDP,		;YES.
	IMULI TAC1,=10
	LDB ITEM,[POINT 4,TAC,15]
	CAILE ITEM,=9
	POPJ PDP,		;19WHAT?
	ADD ITEM,TAC1
	CAIG ITEM,=67		;ITS AFTER 1-JAN-68.
	POPJ PDP,
	SUBI ITEM,=64		;NORMALIZE TO 1964.
	IMULI ITEM,=12*=31
	ADDM ITEM,DAT		;DAT IS NOW SET UP.
	LDB TAC1,[POINT 5,TAC,29]	;HOUR.
	CAIL TAC1,=24
	POPJ PDP,
	MOVE ITEM,TAC1
	IMULI ITEM,=60*=60*=60
	ANDI TAC,77		;MINUTES
	CAIL TAC,=60
	POPJ PDP,
	IMULI TAC,=60*=60
	ADD ITEM,TAC
	LDB TAC,[POINT 6,TEM,15]	;SECONDS.
	CAIL TAC,=60
	POPJ PDP,
	IMULI TAC,=60
	ADD ITEM,TAC		;ADD INTO RESULT.
	LDB TAC,[POINT 20,TEM,35]
	CAML TAC,[=1000000]	;CHECK MILLISECONDS.
	POPJ PDP,
	IDIVI TAC,<=1000000/JIFSEC>
	ADD ITEM,TAC
	CAML	DAT,THSDAT	;DONT GO BACKWARDS
	CAMGE	ITEM,TIME	;DONT GO BACKWARDS
	POPJ	P,		;LOSER.
	JRST CPOPJ1		;RETURN + 1.

;LOGIN UUO.	FOR LOGIN CUSP ONLY.
;	CALL AC,['LOGIN ']
;	AC = -N,,LOC
; 	LOC = LOCATION OF TABLE OF LENGTH N. TABLE HAS LOGIN GOODIES.
;(1-14-72 REWRITTEN BY REG)

IFN FTLOGIN,<			;ONLY FOR LOGIN SYSTEMS. (IFN INCLUDES SETPRV)
LOGIN:	MOVSI	TAC1,JLOG	;LOAD ONE BIT.
	TDNE	TAC1,JBTSTS(J)	;SKIP IF JOB NOT LOGGED IN
	JRST	UUOERR		;LOGGED IN ALREADY.
	HLRO	AC1,TAC		;GET -WORD COUNT
	HRR	UUO,TAC		;BASE OF DATA TABLE
	MOVE	AC2,[XWD -LOGTOP,LOGTAB]	;SET A DEPOSIT/CONTROL WORD
LOGIN1:	AOJG	AC1,LOGIN2	;INCREMENT USER'S COUNT. SKIP IF EXHAUSTED
	XCTR	XR,[SKIPA AC3,(UUO)]	;GET DATA FROM USER AND SKIP
LOGIN2:	MOVEI	AC3,0		;NO DATA FROM USER. USE ZERO
	MOVEM	AC3,@(AC2)	;STORE DATA IN JOB TABLE
	ADDI	UUO,1		;PUSH USERS POINTER
	AOBJN	AC2,LOGIN1	;LOOP UNTIL WE FILL MONITOR TABLES
	IORM	TAC1,JBTSTS(J)	;SET JLOG BIT IN JBTSTS
	MOVSI	TAC1,JACCT	;
	ANDCAM	TAC1,JBTSTS(J)	;CLEAR ACCOUNTING BIT
	MOVE TAC1,JB2PRV(J)	;INITIALIZE PRIVS TO PASSIVE PRIVS
	MOVEM TAC1,JBTPRV(J)
IFN FTDISK,<	SETZM	JBTUFD(J)  ;ZERO UFD POINTER FOR NEW PPN
IFN FTDSKPPN,<	SETZM	DSKPPN(J)  ;INITIALIZE DISK ALIAS PPN
>;FTDSKPPN
>;FTDISK
↑SETLOG:			;SET-UP USER TABLES FOR LOGIN AND OTHERS!
	SKIPN	JBTJL(J)
	PUSHJ	P,PRIBUF

;SPREAD SERVICE LEVEL TO THIS NEW JOB
	HRRZ	AC1,PRJPRG(J)	;GET PROGRAMMER NAME
	MOVN	TAC,SLNRES	;LOAD -NUMBER OF RESERVATIONS
	JUMPE	TAC,CPOPJ	;NO RESERVATIONS.
	HRLZ	TAC,TAC		;-SLNRES,,0 IN TAC
LOGIN4:	HRRZ	TAC1,SLRES(TAC)	;PROG NAME WHO HAS A RESERVATION
	CAME	TAC1,AC1	;MATCH?
	AOBJN	TAC,LOGIN4	;NO MATCH: LOOP
	JUMPGE	TAC,CPOPJ	;NO MATCH ANYWHERE.
	HLRZ	TAC,SLRES(TAC)	;GET HIS RESERVATION AS A RH FRACTION
	MOVEM	TAC,JBTGSL(J)	;SET GUARANTEED SERVICE LEVEL
	POPJ	P,		;STOW IT.

;TABLE OF TABLES SET BY LOGIN UUO. INCLUDE J AS INDEX REGISTER
;AND STORE @ THRU THIS TABLE.

LOGTAB:	XWD J,PRJPRG	;USER NAME 
	XWD J,JB2PRV	;JOB PASSIVE PRIVLEGE BITS
LOGTOP←←.-LOGTAB	;NO. OF TABLES TO BE SET
; ROUTINE TO SET UP SCHEDULER DATA STRUCTURE FOR A JOB

↑PRIBUF:MOVEI AC3,JLLENGTH
	PUSHJ P,FSGET
	POPJ P,			;IF YOU LOSE, YOU LOSE
	MOVEM AC1,JBTJL(ITEM)
	SETZM JBTJLH(ITEM)
	SETZM JBTGSL(J)
	HRL AC2,AC1
	HRRI AC2,1(AC1)
	SETZM (AC1)
	BLT AC2,JLLENGTH-1(AC1)
	POPJ PDP,
;SETPRV, GETPRV
;	SETPRV	SET JBTPRV	JOB PRIVILEGE BITS
;	CALL AC,['SETPRV']
; JBTPRV WILL BE SET TO CONTENTS OF AC IF 
; EITHER PRIPRV IS SET IN CURRENT JBTPRV OR JBTSTS INDICATES JACCT SET
; RETURN CONTENTS OF JBTPRV IN AC.
; IF AC REQUESTS FEWER PRIVILEGES THAN ARE NOW ALLOWED, THEN
; THE REQUEST WILL BE SUCESSFUL
; IF C(AC) = -1 THEN ONLY RETURN CURRENT CONTENTS OF JBTPRV

SETPRV:	CAMN	TAC,[-1]	;SKIP UNLESS SPECIAL CODE
	JRST	STPRV1		;JUST GIVE HIM THE CURRENT CONTENTS
	MOVSI	TAC1,PRIPRV	;THE PRIVILEGE PRIVILEGE BIT
	MOVSI	AC1,JACCT	;ACCOUNTING PROG, BIT
	TDNN	AC1,JBTSTS(J)	;SKIP IF JACCT SET
	TDNE	TAC1,JB2PRV(J)	;SKIP UNLESS PRIPRV SET
	MOVEM	TAC,JBTPRV(J)	;STORE NEW PRIV BITS IF JACCT ∨ PRIPRV
	CAMN	TAC,JBTPRV(J)	;ARE THESE THE SAME NOW?
	POPJ	P,		;YES RETURN QUICK
	ANDM	TAC,JBTPRV(J)	;TURN OFF THE ONES HE IS NOT REQUESTING
	AND	TAC,JB2PRV(J)	;LEAVE ON THE ONES HE CAN SET
	IORM	TAC,JBTPRV(J)	;AND SET THEM
STPRV1:	MOVSI	TAC,PRIPRV	;RETURN PRIPRV FROM JB2PRV
	AND	TAC,JB2PRV(J)
	IOR	TAC,JBTPRV(J)	;GET THE REST FROM JBTPRV
	JRST	STOTAC		;GIVE THEM BACK TO THE USER

;GET PRIVILEGES FOR JOB
;CALLING SEQUENCE:
;	MOVE AC,[FUNC CODE,,JOB #]
;	GETPRV AC,
;	<ALWAYS RETURN HERE>
;CODE 0 ACTIVE PRIVILEGES
;CODE 1 PASSIVE PRIVILEGES

GETPRV:	HLRZ AC1,TAC		;GET FUNCTION CODE
	CAIL AC1,MAXFNC		;LEGAL FUNCTION CODE
	JRST UUOERR		;NO, FLUSH
	HRRZ TAC,TAC		;GET JUST JOB #
	CAIGE TAC,JOBN		;JOB # TO LARGE?
	JUMPN TAC,.+2		;OR 0?
	MOVE TAC,J		;YES, USE CURRENT JOB
	XCT FNCTAB(AC1)		;DO FUNCTION
	JRST STOTAC		;RETURN ANSWER

FNCTAB:	MOVE TAC,JBTPRV(TAC)
	MOVE TAC,JB2PRV(TAC)
MAXFNC←←.-FNCTAB
>
;GET A PPN'S SERVICE LEVEL RESERVATION.
;CALLING
;	MOVE AC,[SIXBIT /PPN/]		;ONLY THE PROG NAME IS USED
;	CALL AC,[SIXBIT /RLEVEL/]
;	RETURN HERE ALWAYS, AC = <SL RESERVATION IN %>,,PRG NAME,
;		IF RESERVATION ≠ 0, OTHERWISE AC = 0,,0.


RLEVEL:	HRRZ	AC1,TAC		;GET PROGRAMMER NAME
	MOVN	TAC,SLNRES	;LOAD -NUMBER OF RESERVATIONS
	JUMPE	TAC,RTZERO	;NO RESERVATIONS: RETURN ZERO
	HRLZ	TAC,TAC		;-SLNRES,,0 IN TAC
RLEV1:	HRRZ	AC2,SLRES(TAC)	;PROG NAME WHO HAS A RESERVATION
	CAME	AC2,AC1		;MATCH?
	AOBJN	TAC,RLEV1	;NO MATCH: LOOP
	JUMPGE	TAC,RTZERO	;JUMP IF NO MATCH.
RLEV2:	HLRZ	TAC,SLRES(TAC)	;GET HIS RESERVATION AS A RH FRACTION
GETLV1:	IMULI	TAC,=100	;MAKE IT LEFT HALF PERCENT
	ADDI	TAC,400000	;ROUND IT. (LIKE YOU DID IN CLKSER)
	HRR	TAC,AC1		;JOB NUMBER (OR PRG NAME) TO TAC
	JRST	STOTAC		;STOW IT.


;REG 12-5-72
SPRSSL:	SETZM	JBTGSL+1	;SPREAD SERVICE LEVEL TO USERS WITH RESERVATIONS.
	MOVE	TAC,[JBTGSL+1,,JBTGSL+2]	
	BLT	TAC,JBTGSL+JOBN-1	;FIRST ZERO ALL LEVELS.
	SKIPLE	AC2,SLNRES	;GET THE NUMBER OF RESERVATIONS
	CAILE	AC2,SLRMAX	;SKIP IF REASONABLE NUMBER.
	POPJ	P,		;RETURN QUICK IF NONE.
SPRSS0:	HRRZ	TAC1,SLRES-1(AC2)
	MOVE	AC1,JOBNM1	;LOOK THROUGH ALL THE JOBS
SPRSS1:	HRRZ	TAC,PRJPRG(AC1)
	CAIE	TAC1,(TAC)
	JRST	SPRSS2
	HLRZ	TAC,SLRES-1(AC2)
	MOVEM	TAC,JBTGSL(AC1)
SPRSS2:	SOJG	AC1,SPRSS1
	SOJG	AC2,SPRSS0
	POPJ	P,

;SET BELOW IS DISABLED!
;GET OR SET A JOBS SERVICE LEVEL.
;CALLING
;	MOVE AC,[XWD %SLEVEL,JOB # ]
;	CALL AC,[SIXBIT/SLEVEL/]
;	RETURN HERE ALWAYS
;IF %SLEVEL<0 RETURN  CURRENT %SL,,JOB NUMBER
;OTHERWISE SET SLEVEL OF JOB TO %SLEVEL
; SET IS ALLOWED ONLY IF JOB NUMBER GIVEN IS 0 OR USER'S JOB #
; IF SET COMMAND FAILS, USER'S AC WILL BE SET TO 
; - % AVAILABLE 
;ALSO SET IT FOR HIS OTHER JOBS.
;IF JOB # = 0 USE THIS JOB
;IF JOB # = -1, AND SERVICE LEVEL MONITOR IS THE USER,
;	THEN RESET THE SL RESERVATION TABLE.


SETLVL:	HRRZ	AC1,TAC		;GET JOB NUMBER
	CAIL	AC1,JOBN	;LEGAL JOB?
	JRST	SETRES		;NO. MAYBE SL MONITOR CHANGING RESERVATIONS
	JUMPG	AC1,.+2		;SKIP UNLESS ZERO
	MOVE	AC1,J		;ZERO MEANS THIS JOB.

	PUSH	P,AC1		;THESE 5 INSTRUCTIONS: REG 12-5-72
	PUSHJ	P,SPRSSL	;SPREAD ALL SERVICE LEVELS
	POP	P,AC1
	HRRZ	TAC,JBTGSL(AC1)
	JRST	GETLV1
	
;;;	WE ARRIVE HERE IF A NEGATIVE JOB NUMBER IS SPECIFIED.
;;;	THIS IS ALWAYS ILLEGAL UNLESS THE JOB HAS THE SSL PRIVILEGE,
;;;	IN WHICH CASE THE CURRENT SLRESERVATION TABLE IS BEING RESET,
;;;	AND THE CALLING SEQUENCE WAS:
;;;	
;;;		MOVE AC,[XWD [ XWD <0,1OR2>,N
;;;			      <1ST TABLE ENTRY>
;;;			      <2ND TABLE ENTRY>
;;;				    ...
;;;			      <NTH TABLE ENTRY>],-1]
;;;		CALL AC,[SIXBIT /SLEVEL/]
;;;		FAILURE RETURN (N TOO LARGE, TOTAL SL TOO MUCH, ETC.)
;;;		SUCCESS RETURN

SETRES:	CAIE	AC1,-1
	JRST	RTZERO
	MOVE	TAC1,JBTPRV(J)	;GET THE USER'S PRIV BITS
	TLNN	TAC1,SSLPRV	;SKIP IF HE HAS THE PRIVILEGE
	JRST	RTZERO		;RETURN ZERO.

;;;	THIS IS THE CODE THAT READS A NEW SL RESERVATION TABLE FROM
;;;	GSLMON AND GIVES THE RESERVED AMOUNTS TO ANYBODY CURRENTLY
;;;	LOGGED IN, DECREASING THE SL OF SCROUNGERS IF NECESSARY.

	XCTR	XR,[HLRZ TAC1,(UUO)]	;TAC1 ← USER REL. ADDR. OF TABLE INFO.
	PUSHJ	P,RELOCA	;CONVERT TAC1 TO ABSOLUTE ADDRESS
	JRST	UADERR		;  LOSER GOOFED

	HLRZ	AC2,(TAC1)	;AC2 ← CORE COST OF SL = 0,1 OR 2
	CAIL	AC2,3		;IS 0 ≤ (TAC) ≤ 2  ?
	MOVEI	AC2,1		;NO, MAKE IT 1.
	MOVEM	AC2,SLCOST	;STORE IN SL DATA AREA

	HRRZ	TAC,(TAC1)	;TAC ← (# OF RESERVATIONS)
	CAILE	TAC,SLRMAX	;TOO MANY RESERVATIONS?
	JRST	SETAL0		;YES, FAILURE EXIT
	MOVSI	AC2,(TAC1)	;SOURCE OF BLT.
	HRRI	AC2,SLNRES	;DESTINATION OF BLT
	XCTR	XR,[HLRZ TAC1,(UUO)]	;TAC1 ← USER REL. ADDR. OF TABLE INFO.
	ADDI	TAC1,(TAC)	;TAC1 ← USER REL. ADDR. OF TABLE'S END
	PUSHJ	P,RELOCB	;ADDRESS CHECK END OF SOURCE.
	JRST	UADERR		;  USER LOOSES
	BLT	AC2,SLNRES(TAC)	;BLT NEW RES TABLE INTO SYSTEM
	HRRZS	SLNRES		;ZERO OUT THE 0,1,OR 2 IN LEFT HALF,

	MOVEI	TAC1,0		;ADD UP NEW RESERVATIONS...
	HLRZ	AC1,SLNRES(TAC)
	ADD	TAC1,AC1
	SOJG	TAC,.-2

	CAIG	TAC1,<XWD MAXLEV,0>/=100+SLRMAX	;TOO MUCH RESERVED SL?
SETAL1:	AOSA	(P)		;NOT TOO MUCH. SET SKIP RETURN
SETAL0:	SETZM	SLNRES		;TOO MUCH. CLEAR TABLE.
	JRST	SPRSSL		;SPREAD NEW TABLE
;LOGOUT UUO

;JS

IFN FTLOGIN,<
LOGOUT:	MOVSI TAC,JACCT		; IS HE REALLY THE LOGOUT ROUTINE?
	TDNN TAC,JBTSTS(ITEM)	; SEE IF THE ACCOUNTING BIT IS ON
	JRST UUOERR		; NOT ON, HE IS A FAKE!
	JRST JOBKL		; ALL OK. LOG HIM OUT.
>

IFE FTLOGIN,<

LOGIN:
LOGOUT:	JRST UUOERR
>
			;JS, REST OF PAGE
; ROUTINE TO READ SPACEWAR BUTTONS

SPCWAR:	CONI TV,TAC	;READ SWITCH REGISTER
	JRST STOTAC
; ROUTINE TO COMPLEMENT STATE OF DUPLEXING
; DOES NOT AFFECT DUPLEXING OF ALT-MODE

CTLV:	JRST CTLV1	;IN TTYSER. COMPLEMENT STATE OF DUPLEXING.
; ROUTINE TO GET A WORD FROM MONITOR CORE

PEEK:	HRRZS TAC		;ZERO LH OF TAC
	CAML TAC,RMEMSIZ	;OVER END OF CORE?
	JRST RTZERO		;YES. DONT LET HIM GET NON-EX MEM.
	MOVE TAC,@TAC
	JRST STOTAC
; RUN A JOB UUO
; FORMAT AS FOLLOWS . . .
;	CALL AC,[SIXBIT /SWAP/]
;AC:	E,,F

;E:	SIXBIT /DEVICE/
;	SIXBIT /FILENAME/
;	SIXBIT /EXTENSION/ + MODE BITS
;	XWD (CORESIZE - IN K),(STARTING ADDRESS)
;	SIXBIT /PROJ-PROG NUMBER/
; IF STARTING ADDRESS IS ZERO, C(JOBSA) WILL BE USED
; IF E=0, NO SAVE WILL BE DONE

;F:	SIXBIT /DEVICE/
;	SIXBIT /FILENAME/
;	SIXBIT /EXTENSION/ + MODE BITS
;	XWD (CORESIZE - IN K),(STARTING ADDRESS INCREMENT)
;	SIXBIT /PROJ-PROG NUMBER/
; IF F=0, NO RUN WILL BE DONE. IF E=F=0, THE UUO IS A NO-OP
; MODE BIT 35 = DO NOT START JOB. JUST GET CORE IMAGE.
; MODE BIT 34 = MAKE STARTING ADDRESS ABSOLUTE, NOT AN INCREMENT
; MODE BIT 33 = LOGIN NEW JOB AND RUN THIS THERE!
; MODE BIT 32 = DON'T SET JLOG


;THIS VERSION IS INCLUDED FOR COMPATIBILITY WITH DEC
RUNUUO:	PUSHJ	P,SVUACS
	HLRM	TAC,SAVSAI(J)		;SET START INCREMENT
	XCTR	XR,[HRRZ TAC1,5(TAC)]
	MOVEM	TAC1,JOBCOR(JDAT)	;SET CORE SIZE
	HRROI	AC1,(TAC)		;COPY PNTR WITH "RUN" FLAG
	JRST	RUNUU2			;NOW ENTER SWAP UUO
; SWAP UUO - CONTINUED . . .

SYSRJB:	SKIPE	SPWUUF(PID)
	JRST	SPWERR		;FLUSH SPACEWAR
	SKIPN	INTACT(PID)
	JRST	SYSRJ2
	JSP	TAC,UUOMES
	ASCIZ	/SWAP CALLED FROM I-LEVEL
UUO/
SYSRJ2:	XCTR	XR,[SKIPN AC1,(UCHN)]	;PICK UP ADDRESSES OF TABLES, IF ANY
	POPJ	P,			;NONE, NO-OP
	MOVEM	AC1,JOBFDV(JDAT)	;SAVE TABLE ADDRESS OF GET SIDE
	MOVE	AC1,UUOPC(J)		;SAVE RETURN ADDRESS
	MOVEM	AC1,JOBOPC(JDAT)
	PUSHJ	P,SVUACS		;SAVE THE ACCUMULATORS IN FREE STORAGE
	HLRZ	AC1,JOBFDV(JDAT)	;PICK UP 'SAVE' TABLE ADDRESS
	JUMPN	AC1,SYSSJB		;IF NON-ZERO, DO A SAVE FIRST
SYSRJ1:	HRRZ	AC1,JOBFDV(JDAT)	;GET 'RUN' TABLE ADDRESS BACK
	JUMPE	AC1,SYSRXT		;IF ZERO, EXIT GRACEFULLY
	XCTR	XR,[MOVE TAC1,2(AC1)]	;GET MODE BITS FIRST!
	TRNE	TAC1,4			;AND TEST FOR RUN ELSEWHERE BIT
	JRST	PHANTOM			;YES!
RUNUU2:	PUSHJ	P,SYSRS			;DO THE RUN COMMAND BIT
PRUNJB:	JSP	TAC1,SG1		;ASSIGN DEVICE, DO LOOKUP, AND RESET PDL
	JRST	NOFILE			;NO FILE?
	PUSHJ	P,GETJB			;READ JOB IN
	MOVSI	AC1,USRMOD		;MAKE SURE HE GETS INTO USER MODE
	HRR	AC1,JOBSA(JDAT)		;PICK UP STARTING ADDRESS
	MOVE	AC2,INCWRD(JDAT)	;PICK UP OUR MODE BITS AGAIN
	PUSH	P,AC1			;PUT THAT ADDRESS ON THE STACK
	MOVE	J,JOB(PID)		;PICK UP JOB NUMBER
	TRNE	AC2,2			;IF BIT 34 ON, INHIBIT ADDING IN HIS STARTING ADDRESS
	SKIPA	AC1,SAVSAI(J)		;INSTEAD, PICK UP INCREMENT AND USE IT!
	ADD	AC1,SAVSAI(J)		;PICK UP STARTING ADDRESS INCREMENT
	XCTR	XR,[SKIP (AC1)]		;SEE IF ADDRESS IS IN BOUNDS
	HRRM	AC1,(P)			;UPDATE STARTING ADDRESS
	PUSH	P,AC2			;SAVE OUR RANDOM GOOD BITS
	PUSHJ	P,RSUACS		;RESTORE USER'S ACCUMULATORS
	POP	P,AC2			;BRING BACK OUR R.G.B. WORD
	POP	P,UUOPC(J)
	TRNN	AC2,1			;IF MODE BIT 35 IS ON, DON'T START JOB
	JRST	USRXIT
	JRST	GETJ1
; SWAP UUO - LOG IN NEW JOB AND RUN THIS ON IT - PHANTOM STARTUP

PHANTO:	HLLZ	TAC,SAVSAI(J)	;RESTORE ACS NOW, SINCE THEY ARE SAFE
	HRRI	TAC,(PROG)	;AND WE WILL GIVE THE TABLE TO THE NEW JOB
	BLT	TAC,17(PROG)
	XCTR	XR,[SKIPN TAC,5(AC1)]	;PRJPRG
	MOVE	TAC,PRJPRG(J)		;USE CURRENT PPN
	CAMN	TAC,PRJPRG(J)		;IS HE DOING IT TO HIMSELF?
	JRST	PHWIN			;YES
	CAMN	TAC,SYSPPN		;1,1
	JRST	PHLOS1			;LOSE.
PHWIN:	PUSH	P,J			;SAVE PRESENT JOB NUMBER
	PUSH	P,PROG			;INIJOB CLOBBERS PROG!
	PUSHJ	P,INIJOB		;INITIALIZE A NEW JOB
	JRST	PHLOSE			;NO JOBS TO BE HAD
	JFCL	
	POP	P,PROG			;RESTORE PROG
	MOVSI	TAC,JNA
	IORM	TAC,JBTSTS(J)
	MOVEM	TAC1,JOBLOG(J)		;SAVE MODE BITS AND EXTENSION
	MOVSI	TAC,JLOG
	TRNN	TAC1,10			;THIS BIT SAYS DON'T SET JLOG
	IORM	TAC,JBTSTS(J)
	SETZM	JBTUFD(J)		;FLUSH THIS OR ELSE!
IFN FTDSKPPN,<SETZM DSKPPN(J)		;INITIALIZE DISK ALIAS PPN>
	SETZM	JBTKCJ(J)		;INITIALIZE KILO CORE SECONDS
	XCTR	XR,[MOVE TAC1,(AC1)]	;DEVICE
	MOVEM	TAC1,JOBDEV(J)
	XCTR	XR,[MOVE TAC1,1(AC1)]	;FILENAME
	MOVEM	TAC1,JOBNAM(J)
IFN FTSTAT,<PUSHJ P,NAMSTT>
	XCTR	XR,[MOVE TAC1,4(AC1)]	;LOC OF FILE
	MOVEM	TAC1,JOBPPN(J)
	MOVE	TAC,(P)			;GET OUR J TEMPORARILY
	XCTR	XR,[SKIPN TAC1,5(AC1)]	;PPN
	MOVE	TAC1,PRJPRG(TAC)	;NONE, USE CURRENT
	MOVEM	TAC1,PRJPRG(J)
	CAME	TAC1,PRJPRG(TAC)	;SAME AS CALLER?
	TDZA	TAC1,TAC1		;NO. ZERO CELL AND SKIP
	MOVE	TAC1,JBTPRV(TAC)	;SAME PPN. COPY OUR PRIVILEGE
	MOVEM	TAC1,JBTPRV(J)		;TO THE NEW GUY
	MOVE	TAC1,PRJPRG(TAC)	;GET OUR PPN
	CAME	TAC1,PRJPRG(J)		;SAME AS HIS?
	TDZA	TAC1,TAC1		;NO, NO PRIVELEGES
	MOVE	TAC1,JB2PRV(TAC)	;ALSO PASSIVE PRIVELEGES
	MOVEM	TAC1,JB2PRV(J)
	XCTR	XR,[MOVS TAC1,3(AC1)]	;GET S.A.,,CORE SIZE
	HRRZM	TAC1,JOBCRD(J)		;PASS ON CORE SIZE
	MOVE	TAC,(P)			;CALLERS JOB #
	HLR	TAC1,SAVSAI(TAC)
	MOVSM	TAC1,SAVSAI(J)		;GIVE AC BLK AND S.A. TO NEW JOB
	SETZM	SAVSAI(TAC)		;NO LONGER BELONGS TO CALLER
	ADDI	TAC1,(UCHN)
	MOVEM	TAC,(TAC1)		;CALLERS JOB # TO NEW JOB (IN SAME AC)
	XCTR	XW,[MOVEM J,(UCHN)]	;NEW JOB # TO CALLER
	PUSHJ	P,DELBTT
	POP	P,J
	JRST	SYSRX2			;DON'T BOTHER LOOKING FOR ACS

PHLOSE:	POP	P,PROG
	POP	P,J
PHLOS1:	HLRZ	TAC,SAVSAI(J)		;GET LOC OF SAVED AC'S
	ADD	TAC,UCHN		;LOC OF USERS AC
	SETZM	(TAC)			;RETURN 0 TO INDICATE LOSSAGE
	JRST	SYSRXT
; ROUTINE TO DO THE GETTING OF A JOB FROM UUO LEVEL

SYSSJB:	PUSHJ PDP,SYSRS		; PICK UP ARGUEMENTS FROM USER
	JSP TAC1,SG1		; DO LOOKUP
	JFCL
	PUSH P,AC1
	HRRZ AC1,SAVSAI(ITEM)	; PICK UP STARTING ADDRESS
	JUMPE AC1,SYSSJ1
	XCTR	XR,[SKIP (AC1)]
	TLO AC1,USRMOD
	HRRM AC1,JOBSA(JDAT)
SYSSJ1:	POP P,AC1
	PUSHJ PDP,SAVJB		; DO ACTUAL SAVE
	JRST SYSRJ1

SYSRXT:	PUSHJ PDP,RSUACS	; RESTORE ACCUMULATORS
SYSRX2:	MOVE TAC,JOBOPC(JDAT)	; GET UUO RETURN ADDRESS
	MOVEM TAC,UUOPC(ITEM)	; AND RETURN TO IT!
	JRST USRXIT		; MAKE IT LOOK LIKE A UUO EXIT (WHICH IT IS)

; ROUTINE TO PICK UP BITS OF USER'S GOODIE TABLE

SYSRS:	XCTR	XR,[MOVE TAC1,(AC1)]	; PICK UP DEVICE NAME
	MOVEM	TAC1,DEVWRD(JDAT)	; STORE FOR SAVJOB
	XCTR	XR,[MOVE TAC1,1(AC1)]	;PICK UP FILE NAME
	MOVEM	TAC1,FILNAM(JDAT)
	MOVEM	TAC1,JOBNAM(J)		;THIS IS NEW JOB NAME TOO
IFN FTSTAT,<PUSHJ P,NAMSTT>
	XCTR	XR,[HLRZ TAC1,2(AC1)]	;PICK UP EXTENSION
	JUMPN	TAC1,.+2		;NOT SPECIFIED?
	MOVEI	TAC1,'DMP'		;HE REALLY WANTS .DMP
	HRLZM	TAC1,FILEXT(JDAT)
	XCTR	XR,[HRRZ AC2,2(AC1)]	;PICK UP MODE BITS INTO AC2
	MOVEM	AC2,INCWRD(JDAT)	;AND SAVE THEM FOR US TO SEE LATER
	XCTR	XR,[MOVE TAC1,4(AC1)]	;AND PPN TOO
	MOVEM	TAC1,JOBPPN(J)
	JUMPL AC1,CPOPJ			;THAT'S ALL FOR RUN UUO
	XCTR	XR,[HLRZ TAC1,3(AC1)]	;PICK UP CORE SIZE
	LSH	TAC1,12			;CONVERT TO RELOCATABLE ADDRESS
	JUMPE	TAC1,.+2		;UNLESS, OF COURSE, HE ASKED FOR NONE
	SUBI	TAC1,1
	MOVEM	TAC1,JOBCOR(JDAT)
	XCTR	XR,[HRRZ AC1,3(AC1)]	;PICK UP STARTING ADDRESS INCREMENT
	HRRM	AC1,SAVSAI(J)		;TUCK AWAY IN A CONVENIENT TABLE IN APRDAT
	POPJ	P,
; ROUTINE TO SAVE ACCUMULATORS OVER RUNJOB UUO

SVUACS:	HLRZ	AC1,SAVSAI(J)	; ANY FREE STORAGE HERE ALREADY?
	JUMPE	AC1,SVUA2	; NO, GET SOME
	CAML	AC1,MEMSIZ	; IS IT IN THE FREE STORAGE AREA?
	CAML	AC1,RMEMSIZ	; IT IS ABOVE USER CORE. IS IT IN REAL CORE?
	JRST	.+2		;THINK ABOUT IT SOME MORE, ANDY.
	JRST	SVUA1		;YES, USE IT
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/GARBAGE IN SAVSAI LEFT HALF!
/
	POPACS
SVUA2:	MOVEI AC3,20		; GET A 20-WORD BLOCK OF FREE STORAGE
	PUSHJ PDP,FSGET
	HALT .+1		; AT UUO LEVEL, SHOULDN'T HAPPEN
	HRLM AC1,SAVSAI(ITEM)	; SAVE THE POINTER
SVUA1:	HRLI AC1,(PROG)		; SET TO BLT IN USER'S ACS
	HRR AC2,AC1
	BLT AC1,17(AC2)
	POPJ PDP,

RSUACS:	HLLZ AC1,SAVSAI(ITEM)	; PICK UP FREE STORAGE POINTER
	JUMPE AC1,CPOPJ		;NOBODY HOME
	HRRI AC1,(PROG)
	BLT AC1,17(PROG)
	HLRZ AC1,SAVSAI(ITEM)
	SETZM SAVSAI(ITEM)	; ZERO OUT FS POINTER
	JRST FSGIVE
; EIOTM AND LIOTM UUO'S
; CAUSES A PROGRAM TO ENTER IOT USER MODE
; OR LEAVE IOT USER MODE

EIOTM:	MOVE	TAC,JBTPRV(J)
	TLNN	TAC,LUPPRV
	JRST	UUOERR
	MOVSI	TAC,4000
	ORM	TAC,UUOPC(ITEM)
	POPJ	P,

LIOTM:	MOVSI	TAC,4000
	ANDCAM	TAC,UUOPC(ITEM)
	POPJ	P,
; UUO TO GET THE PHYSICAL NAME OF A DEVICE
; PUT THE SIXBIT OF THE DEVICE LOGICAL NAME IN AN AC
; DO A 'CALL AC,[SIXBIT /PNAME/]
; AND THE ROUTINE SKIPS UPON SUCCESS (IE, IF DEVICE NAME EXISTS)
; AND RETURNS PHYSICAL NAME IN THAT AC

PNAME:	PUSHJ	P,FNDDDB	; SEARCH FOR DEVICE NAME (OR CHANNEL #)
	POPJ	P,		; FAILURE
	MOVE	TAC,DEVNAM(DDB)	; PICK UP PHYSICAL NAME
	XCTR	XW,[MOVEM TAC,(UCHN)]
	JRST	CPOPJ1
; GET A JOB'S JOB STATUS WORD
; CALLING . . .
;	MOVE AC,<JOB NUMBER IN QUESTION>
;	CALL AC,[SIXBIT /JBTSTS/]
; RETURNS JOB STATUS WORD IN AC

USTAT:	JUMPG TAC,.+2		; POSITIVE JOB NUMBER?
	MOVE TAC,J		; LESS OR EQUAL TO ZERO MEANS OWN JOB
	CAIL TAC,JOBN		; MUST BE LESS THAN MAXIMUM TOO
	JRST UUOERR		; OR ELSE, ERROR
	MOVE TAC,JBTSTS(TAC)	; GET STATUS WORD
	JRST STOTAC		; AND GIVE IT TO HIM

; GET A TELETYPE'S DEVIOS
; CALLING . . .
;	MOVE AC,<JOB NUMBER WHOSE TTY IOS YOU WANT>
;	CALL AC,[SIXBIT /TTYIOS/]

TTYIOS:	JUMPL	TAC,TTYIO3		;TRY NAME IF ILLEGAL NUMBER
	CAIL	TAC,JOBN
	JRST	TTYIO3			;ILLEGAL AS A JOB NUMBER, TRY AS A DEV NAME.
	HLRZ	DDB,DEVLST
TTYIO1:	HLRZ	TAC1,DEVNAM(DDB)	;IS THIS A TELETYPE?
	CAIE	TAC1,'TTY'
	JRST	TTYIO2			;NO. KEEP LOOKING.
	LDB	TAC1,PJOBN		;YES, DOES THE JOB NUMBER MATCH?
	CAIE	TAC1,(TAC)
	JRST	TTYIO2			;NO, SCAN SOME MORE
TTYIO5:	MOVE	TAC,DEVIOS(DDB)		;YES, PICK UP HIS IOS
	JRST	STOTAC			;AND GIVE IT TO HIM

TTYIO2:	HLRZ	DDB,DEVSER(DDB)		;PICK UP NEXT DEVICE DATA BLOCK ADDRESS
	JUMPN	DDB,TTYIO1		;AND GO BACK IF NOT END OF LIST
TTYIO4:	MOVNI	TAC,1			; IF END OF LIST, GIVE HIM A -1 TO CHEW ON
	JRST	STOTAC

TTYIO3:	PUSHJ	P,DEVSRC		;TRY SEARCHING FOR THIS SIXBIT NAME.
	JRST	TTYIO4			;LOSE.
	JRST	TTYIO5			;WIN.
COMMENT $		WAKEME
CALLED BY:
	MOVE	AC,<ADDRESS OF 3 WORD BLOCK>
	CALL	AC,['WAKEME'] OR CALLI AC,400061
	<ERROR:  JOB NAMED WAS NOT IN BATMAN AND ROBIN, ELSE MAINTMODE SET>


BLOCK CONTAINS
	JOBNAME
	PPN
	DATA

IF JOBNAME AND PPN ARE FOUND IN BATMAN AND ROBIN THEN 
SET ALFRED TO DATA.  DATA IS INTERPRETED AS FOLLOWS
	<0 MEANS NEVER START THIS
	=0 MEANS KEEP THIS JOB RUNNING
	>0 DATA IS INTERPRETED AS 
		DATE,,TIME IN MINUTES 
	WHEN TO START THIS AGAIN.

ALFRED IS ZEROED AT SYSINI, SO ALL JOBS NAMED IN BATMAN WILL
BE STARTED AT RELOADS AND RESTARTS

$
WAKEME:
IFN FTBAT,<
	SKIPE	MAINTMODE		;SKIP IF NORMAL MODE
	POPJ	P,			;ERROR RETURN IF MAINTMODE
	XCTR	XR,[MOVE AC1,(UCHN)]	;GET USER'S POINTER
	XCTR	XR,[MOVE AC2,(AC1)]	;GET JOBNAME
	XCTR	XR,[MOVE AC3,1(AC1)]	;GET PPN
	MOVSI	TAC,-BATLEN		;GET SIZE OF BATMAN
WAKEM1:	CAMN	AC2,BATMAN(TAC)		;LOOK IN TABLE
	CAME	AC3,ROBIN(TAC)		;SAME AS TABLE?
	JRST	WAKEM2			;NO
	XCTR	XR,[SKIPGE AC3,2(AC1)]	;GET DATA FOR ALFRED
	JRST	WAKEM3			;RUN NEVER.
	MOVE	AC1,TIME
	IDIVI	AC1,=60*JIFSEC
	HRL	AC1,THSDAT
	CAMG	AC3,AC1			;SKIP IF RUN IN THE FUTURE
	SETZM	BATYET			;MAKE CH7 LOOK NEXT TICK
WAKEM3:	MOVEM	AC3,ALFRED(TAC)		;STUFF IT
	JRST	CPOPJ1			;GIVE HIM SUCCESS RETURN

WAKEM2:	AOBJN	TAC,WAKEM1		;LOOK THRU TABLE
>
	POPJ	P,			;LOSE

;TRANSLATE SYSTEM CALL TO/FROM SIXBIT.

;CALL:	MOVE AC,[SIXBIT OR NUMERIC UUO]
;	CALLIT AC,
;	RETURN WITH NUMERIC OR SIXBIT FORM (RESP.), 0 IF ERROR

;IF AC12-16 ≠ 0,  ARG IS ASSUMED TO BE SIXBIT (ALL UUO MNEMONICS ARE > 2 CHARS)
; NUMERIC REPRESENTATION WILL BE RETURNED, OR 0 IF THE SPECIFIED UUO DOES
; NOT EXIST.  NOTE THAT CALLING THIS WITH 1- OR 2-CHARACTER NAMES MAY HAVE 
; STRANGE RESULTS.

;IF AC12-17 = 0,  ARG IS ASSUMED TO BE A NUMERIC UUO OF SOME FORM.  THE AC AND
; ADDRESS FIELDS MUST BE 0 UNLESS RELEVANT FOR DECODING (I.E. ADR OF CALLI,
; AC OF TTYUUO, ETC.).  IF THE ARG IS A LEGAL UUO, ITS SIXBIT MNEMONIC WILL BE
; RETURNED, OTHERWISE 0.  IN THE EVENT OF AMBIGUITY, THE MORE SPECIFIC MNEMONIC
; WILL BE RETURNED (E.G. INCHRW RATHER THAN TTYUUO).

;IF AC12-17 = 1, THE MNEMONIC FOR THE SPECIFIED MAJOR OPCODE WILL BE RETURNED.
; THE AC AND ADDRESS FIELDS MUST BE 0.  THIS PROVIDES A WAY TO GET AT MNEMONICS
; SUCH AS "TTYUUO".

CALLIT:	TLNE TAC,36		;IF ITS SIXBIT
	JRST CALT0		;    THEN GO LOOK IT UP
	HLRZ TAC1,TAC
	CAIE TAC1,(<CALLI>)
	JUMPN TAC1,CALTU
	ANDI TAC,-1
	CAIGE TAC,UCLDLN	;IF ITS A DEC CALLI
	JRST CALT1		;    THEN GET THE SIXBIT
	TRZN TAC,400000		;IF NOT A STANFORD CALLI
	JRST RTZERO		;    THEN RETURN 0
	MOVEI TAC,UCLDLN(TAC)	;GET ACTUAL POINTER
	CAIL TAC,UCLLEN		;IF ITS OFF THE END
	JRST RTZERO		;    THEN RETURN 0
CALT1:	MOVE TAC,UCLTAB(TAC)	;ELSE PICK UP SIXBIT
	JRST STOTAC		;THEN PUT IT IN AC AND RETURN

CALT0:	MOVSI TAC1,-UCLLEN
	CAME TAC,UCLTAB(TAC1)	;SEARCH CALLI SIXBIT TABLE
	AOBJN TAC1,.-1
	JUMPGE TAC1,CALT2	;IF OFF THE END, TRY FOR OPCODES
	MOVEI TAC,(TAC1)
	CAIL TAC,UCLDLN		;IF STANFORD CALL
	MOVEI TAC,400000-UCLDLN(TAC)	;THEN CONVERT
	HRLI TAC,(<CALLI>)	;MAKE IT A CALLI
	JRST STOTAC		; AND SHIP IT
CALTU:	ANDI TAC1,777000
	CAIL TAC1,40000
	CAIL TAC1,700000+IUUMAX*2000
	JRST CALT0		;OUTSIDE UUO RANGE - TRY AS SIXBIT
	CAIL TAC1,100000
	CAIL TAC1,700000
	TRNE TAC,-1
	JRST CALT0		;IN BETWEEN RANGES OR RH NOT ZERO
	TLZE TAC,1
	JRST CALTU2		;SPECIAL - FORCE MAJOR OPCODE NAME
	MOVSI AC1,(TAC1)
	MOVSI AC2,1000(TAC1)
	MOVEI TAC1,UUONAM	;HEADER FOR SECOND LEVEL TABLES
CALTU1:	HRRZ TAC1,-1(TAC1)
	JUMPE TAC1,CALTU2	;NO MORE - MUST BE PLAIN UUO
	CAMG AC1,-1(TAC1)
	CAMG AC2,-1(TAC1)
	JRST CALTU1		;NOT THIS ONE
	HLLZ AC3,-1(TAC1)	;GET OPCODE
	CAMLE TAC,AC3
	JRST RTZERO		;ILLEGAL AC FIELD
	ROT TAC,15
	ANDI TAC,17		;ISOLATE AC FIELD
	ADD TAC,TAC1
	MOVE TAC,(TAC)		;GET SIXBIT
	JRST STOTAC

CALTU2:	TLNE TAC,(<17,>)
	JRST RTZERO		;AC FIELD MUST BE ZERO
	ROT TAC,9		;GET OPCODE
	CAIL TAC,700
	SKIPA TAC,UUONAM+40-700(TAC)
	MOVE TAC,UUONAM-40(TAC)
	JRST STOTAC
CALT2:	MOVSI TAC1,-IUUMAX*2-40	;TOTAL # MAJOR OPCODES
	CAME TAC,UUONAM(TAC1)
	AOBJN TAC1,.-1
	JUMPGE TAC1,CALT3	;NOT FOUND - TRY SECOND LEVEL TABLES
	MOVEI TAC,40(TAC1)	;THIS WILL BE THE OPCODE
	CAILE TAC,77
	MOVEI TAC,700-40(TAC1)	;UNLESS IT'S ONE OF THESE
	ROT TAC,-9		;PUT IT IN THE RIGHT PLACE
	JRST STOTAC

CALT3:	MOVE DAT,[,UUONAM(TAC1)];INIT TABLE PNTR TO HDR, (TAC1) FOR @ BELOW
CALT4:	HRR DAT,-1(DAT)		;GET NEXT TABLE LOC
	TRNN DAT,-1
	JRST RTZERO		;IF NO MORE JUST RET 0 FOR FAILURE
	LDB TAC1,[270400,,-1(DAT)];GET MAX #
	MOVNI TAC1,1(TAC1)	;OFFSET BY 1 FOR COUNT
	MOVSI TAC1,(TAC1)	;MAKE AOBJN PNTR
	CAME TAC,@DAT
	AOBJN TAC1,.-1
	JUMPGE TAC1,CALT4	;TRY NEXT TABLE IF NOT FOUND
	HLLZ TAC,-1(DAT)	;FOUND - GET BASE OPCODE
	DPB TAC1,[270400,,TAC]	;SET CORRECT AC FIELD
	JRST STOTAC
;SETPR2, BEGIN SEGUUO
SUBTTL	UUO'S FOR HIGH SEGMENTS ↔ BEGIN SEGUUO
;	SETPR2	UUO
;	MOVE AC,[XWD PROT.,RELOC]
;	CALL AC,['SETPR2']
;	<ERROR RETURN>
;	<SUCCESS RETURN>
;
;	RELOC IS ABSOLUTE ADDRESS YOU WISH AS YOUR BASE ADDRESS
;	IF THE LOW ORDER BIT IS ON THEN RELOC IS A RELATIVE ADDRESS
;	IN YOUR CORE IMAGE.
;	IF THE LOW ORDER BIT OF PROT IS ON THEN ACCESS IS WRITE PROTECTED
;	IF THE ACCESS IS ABSOLUTE AND YOU ARE NOT 1,2 THEN YOU ARE
;	AUTOMATICALLY WRITE PROTECTED.
;	BOTH PROT. AND RELOC. ARE TRUNCATED TO 1K BOUNDARIES WHEN LOADED
;	INTO THE PROT.-RELOC. REGISTER.
;	IN RELATIVE MODE PROT. IS ADJUSTED TO BE WITHIN YOUR CORE IMAGE.


↑SETPR2:
	TRNE TAC,1		;IS THIS RELATIVE?
	JRST PR2REL
	MOVEI TAC1,(TAC)
	ANDCMI TAC1,1777
	CAML TAC1,RMEMSIZ	;IS RELOC GREATER THAN MEMORY?
	POPJ P,			;YES, LOSE
	MOVE TAC1,RMEMSIZ
	CAILE TAC1,-1		;FULL HOUSE?
	JRST SETPRW		;YES. LET HIM WRAP AROUND.
	HLRZ TAC1,TAC		;PROTECTION DESIRED
	TRO TAC1,1777
	HRRZ AC1,TAC		;RELOCATION DESIRED
	ANDCMI AC1,1777
	ADDI TAC1,(AC1)		;BH 7/30/74 HE REALLY WANTED THE UPPER BOUND!
	CAML TAC1,RMEMSIZ	;IS PROTECT GREATER THAN MEMORY?
	POPJ P,			;YES
SETPRW:	MOVE TAC1,JBTPRV(J)	;GET THIS GUY'S PRIV BITS
	TLNN TAC1,ACWPRV	;SKIP IF HE HAS ABS CORE WRITE PRIV
	TLO TAC,1		;NO, WRITE PROTECT AUTOMATICALLY
	JRST PR2SET
; HERE WE ADDRESS CHECK HIS PR REQUEST

PR2REL:	HLRZ TAC1,JBTADR(J)	;JOBS PROTECTION
	HRRZ AC1,TAC		;RELOC REQUESTED(RELATIVE TO CORE IMAGE).
	ANDCMI AC1,1777
	CAMLE AC1,TAC1		;TOO HIGH?
	POPJ P,			;LOSE
	HLRZ AC1,TAC		;PROT.
	TRO AC1,1777
	HRRZ AC2,TAC
	ANDCMI AC2,1777
	ADDI AC1,(AC2)		;+RELOC
	CAMLE AC1,TAC1		;TOO BIG?
	POPJ P,			;YES, LOSE
PR2SET:	PUSH P,TAC
	PUSHJ P,KILSEG
	POP P,TAC
	AOS (P)
	TRZ TAC,1776		;MAKE IT PRETTY
	TLO TAC,1776		;	"
↑STPR2:	MOVEM TAC,JBTPR2(J)
	JRST SEGXIT	;SET UP PR AND JOBRL2
;GETPR2
;CALLING SEQUENCE:
;	CALL AC,['GETPR2']
;	<ALWAYS RETURNS HERE>
;
;	AC NOW CONTAINS XWD PROT.,RELOC. 
;	LOW ORDER BIT OF PROT IS ON IF ACCESS IS WRITE PROTECTED.
;	LOW ORDER BIT OF RELOC IS ON IF RELATIVE MODE.

↑PR2GET:MOVE TAC,JBTPR2(J)
	JRST STOTAC		;GIVE HIM CURRENT VALUE
; REMAP UUO . . .
; CALLING . . .
;	MOVEI AC,<HIGHEST ADDRESS IN LOW PART>
;	CALL AC,[SIXBIT /REMAP/]
;	<NO CAN DO>
; RETURNS JOB NUMBER OF SEGMENT IN ACCUMULATOR
; IF SIGN BIT IN AC IS ON, SETS SEGMENT AS WRITE-PROTECTED

↑REMAP:
	PUSH P,TAC
	PUSHJ P,LINKSEG
	PUSHJ P,MAKESEG
	LDB TAC1,PSEGN
	JUMPE TAC1,TPOPJ
	MOVE TAC,JBTSTS(TAC1)	; IF WE GOT AN OLD ONE, MAKE SURE IT IS IN CORE
	TLNE TAC,SWP!SHF
	PUSHJ P,WSCHED		; WAIT FOR IT TO GET IN
	SKIPN JBTADR(TAC1)	; DID WE GET A FRESH SEGMENT, OR LINK ON TO AN EXISTING ONE?
	JRST REMAP1		; WE GOT A NEW ONE
	TLNE TAC,JSEG
	JRST REMAP6
	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ/NO UPPER AT REMAP
J=/]
	DISARG(DCP,<-20+J(P)>)
	[ASCIZ/  TAC1=/]
	DISARG(DCP,<-20+TAC1(P)>)
	[ASCIZ/
/]
	-1
	POPACS
	JSP DAT,UERROR
; REMAP - CHECK IF HE WANTS IT WRITE PROTECTED

REMAP6:	TLNE TAC,JWP		; IS IT WRITE PROTECTED?
	SKIPL (P)		; YES, IS THAT WHAT WE WANT?
	CAIA
	JRST REMAP5		; YES

	TLNN TAC,JWP		; IS IT UNPROTECTED?
	SKIPGE (P)		; YES, IS THAT WHAT WE WANT?
	CAIA
	JRST REMAP5
	PUSHJ P,MAKESEG		; NO, GET A NEW ONE
	LDB TAC1,PSEGN		;GET SEGMENT #
	JUMPE TAC1,TPOPJ	; LEAVE NOW IF WE DIDN'T GET ONE!
	JRST REMAP1

REMAP5:	POP P,TAC		; GET NEW CORE ASSIGNMENT BACK
	HRRZS TAC
	ORI TAC,1777
	PUSHJ P,CORUUO
	CAIA
	JRST REMAP7
	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ/ERROR RETURN FROM CORUUO AT REMAP5
J=/]
	DISARG(DCP,<-20+J(P)>)
	-1
	POPACS
	JSP DAT,UERROR
REMAP7:	LDB TAC1,PSEGN
	LDB UCHN,PUUOAC		; CORUUO USES UCHN ITSELF!
	JRST REMAP2
; REMAP - IF HE IS NOT ON 1K BOUNDARY, ADJUST HIM

REMAP1:	SETCM TAC,(P)		; NOW WE DO THE SIMULATED UPWARDS BLT
	TRNN TAC,1777		; IS HE ALREADY AT A 1K BOUNDARY
	JRST REMAP3		; YES.
	HRRZ TAC,USRREL(PID)	; NO. GET AN EXTRA 1K TO BLT HIM UP INTO
	ADDI TAC,2000
	PUSHJ P,CORUUO
	CAIA
	JRST REMAP8
	POP P,TAC
	JRST KILSEG

REMAP8:	HRRZ TAC,(P)
	PUSHJ P,BLTUP		;MOVE UP UPPER
	LDB TAC1,PSEGN
	LDB UCHN,PUUOAC		; CORUUO USES UCHN ITSELF!
REMAP3:	POP P,TAC
	MOVSI DAT,JWP
	SKIPG TAC
	ORM DAT,JBTSTS(TAC1)
	HRRZS TAC
	ORI TAC,1777
	CAML TAC,USRREL(PID)
	JRST KILSEG
	HRLM TAC,JBTADR(J)
	HRLM TAC,JOBADR
	HRRM TAC,USRREL(PID)
	HRRM TAC,JOBREL(JDAT)
IFN FTSTAT,<
	PUSH P,TAC
	LSH TAC,-4
	ANDI TAC,37700
	ADDI TAC,CSZSTA+100
	PUSHJ P,STAPUT
	POP P,TAC
>;FTSTAT
	ADDI TAC,1(PROG)
	HRRM TAC,JBTADR(TAC1)
IFN FTSTAT,<
	LSH TAC,-4
	ANDI TAC,37700
	TRO TAC,CPSSTA
	PUSHJ P,STAPUT
>;FTSTAT
	HLRZ TAC,PROG
	SUB TAC,USRREL(PID)
	SUBI TAC,1
	HRLM TAC,JBTADR(TAC1)
IFN FTSTAT,<
	LSH TAC,-4
	ANDI TAC,37700
	ADDI TAC,CSZSTA+100
	PUSHJ P,STAPUT
>;FTSTAT
	HRL PROG,USRREL(PID)
	PUSH	P,TAC1			;REG. FIX CORTAB AT REMAP TIME.
	HRRZ	DSER,JBTADR(TAC1)	;GET THE LOWEST ADDRESS IN UPPER
	HLRZ	AC1,JBTADR(TAC1)	;GET THE PROTECTION OF UPPER.
	MOVEI	UCHN,0			;SET TO RELEASE CORE.
	PUSHJ	P,CORSTG		;RELEASE THIS FROM CORTAB
	MOVE	UCHN,(P)		;GET THE JOB NUMBER OF UPPER.
	HLRZ	AC1,JBTADR(UCHN)	;GET THE PROTECTION AGAIN
	PUSHJ	P,CORSTG		;CLAIM BLOCKS IN CORTAB
	POP	P,TAC1
	LDB	UCHN,PUUOAC		;RESTORE UCHN
REMAP2:	XCTR	XW,[MOVEM TAC1,(UCHN)]
	AOS	(P)
	JRST	SEGXIT
;BLTUP - FAST UPWARDS BLT
;TAKES SOURCE ADDRESS-1 IN TAC (RELATIVE)
;BLTS UP REST OF CORE IMAGE TO NEXT 1K BOUNDARY
;CAN ALSO ENTER AT FASBLT WITH TAC1=DEST-1 AND AC2=END DEST
;CLOBBERS TAC,TAC1,AC1,AC2,AC3
;THIS CODE IS MORE OR LESS COPIED FROM CORE ROUTINES IN 'E'

↑BLTUP:	MOVEI TAC1,(TAC)
	IORI TAC1,1777		;DEST ADR
	HLRZ AC2,PROG
FASBLT:	SUBI AC2,(TAC1)		;LENGTH OF XFER
	SUBI TAC1,(TAC)		;DIST OF XFER
	ADDI TAC,(PROG)		;RELOCATE
	CAILE AC2,(TAC1)	;EASY (NO OVERLAP) IF LENGTH<DIST
	JUMPGE TAC1,BLTUP1	;NOW WE NEED TO WORRY
	JUMPLE AC2,CPOPJ
	MOVEI AC3,(TAC)
	ADD AC3,TAC1		;GET BACK DEST
	HRLI AC3,(TAC)
	ADDI AC2,(AC3)		;END LOC+1
	BLT AC3,-1(AC2)
	POPJ P,

BLTUP1:	CAILE TAC1,5		;THIS IS BELIEVED TO BE THE ROUGH BREAK-EVEN POINT
	JRST BLTUP2		;BETWEEN THE TWO METHODS
	JUMPE TAC1,CPOPJ
	MOVSI AC1,(<POP TAC1,(TAC1)>)
	HRRI AC1,(TAC1)
	MOVSI TAC1,377777(AC3)	;SET COUNT TO GO NEG AFTER APPROP # OF WDS
	HRRI TAC1,(TAC)
	ADDI TAC1,(AC3)		;INITIAL FETCH ADR
	MOVE AC2,[JUMPL TAC1,AC1]
	MOVE AC3,[POPJ P,]	;TO GET US BACK
	JRST AC1		;ROAR
;HERE WE ITERATE ON BLTS, POSSIBLY STARTING WITH A SMALLER ONE

BLTUP2:	PUSH P,AC2
	IDIVI AC2,(TAC1)	;REMAINDER WILL BWE SIZE OF SHORT ONE
	MOVE AC2,(P)
	ADDI AC2,1(TAC)		;SOURCE END ADR+1
	HRLI AC2,(AC2)
	ADDI AC2,(TAC1)		;SOURCE END+1,,DEST END+1
	JUMPE AC3,BLTUP3	;SKIP INITIAL STEP IF 0 REMAINDER
	MOVSI AC1,(<BLT AC3,(AC2)>)
	HRRI AC1,-1(AC3)
	HRLI AC3,(AC3)
	SUBB AC2,AC3		;BACK UP & DUPLICATE POINTER
	XCT AC1
BLTUP3:	HRLI TAC1,(<BLT AC3,(AC2)>)	;CREATE BLT WITH APPROP OFFSET
	MOVEM TAC1,(P)
	SOS (P)
	HRLI TAC1,(TAC1)	;DIST,,DIST
	MOVEI AC1,1(TAC)
	ADDI AC1,(TAC1)		;DEST ADR
BLTUP4:	SUB AC2,TAC1		;BACKUP PNTR OVER NEXT BLT
	MOVE AC3,AC2		;DUPLICATE FOR BLT
	XCT (P)			;DO BLT
	CAIGE AC1,(AC2)		;DOWN TO STARTING DEST ADR YET?
	JRST BLTUP4		;NO - DO SOME MORE
	SUB P,[1,,1]
	POPJ P,
; UUO TO SET OR CLEAR USER WRITE-PROTECT BIT
; CALLING . . .
;	MOVE AC,<0 FOR CLEAR, ≠0 FOR SET>
;	CALL AC,[SIXBIT /SETUWP/]
;	<NO CAN DO>

↑SETUWP:
	PUSH P,J
	PUSH P,TAC
	LDB J,PSEGN
	JUMPN J,SETUW1
	POP P,TAC
	POP P,J
	JRST SEGXIT

SETUW1:	PUSHJ P,ACCESS
	JFCL
	JRST SETUW2
	POP P,TAC1
	MOVSI TAC,JWP
	JUMPE TAC1,.+2
	IORB TAC,JBTSTS(J)
	JUMPN TAC1,.+2
	ANDCAB TAC,JBTSTS(J)
	HLRZ TAC1,JBTADR(J)	;FOR CORE2X
	JRST CORE2X	;UPDATE EVERYONE'S JOBRL2 WP FLAG

SETUW2:	POP P,TAC
	POP P,J		; FORGET IMMEDIATELY IF READ-ONLY ACCESS
	JUMPN TAC,CPOPJ1
	POPJ P,
;UNPURE - MAKE A WRITEABLE COPY OF WRITE-PROTECTED UPPER, IF NECESSARY
;SKIPS IF SUCCESSFUL, IF ALREADY WRITEABLE, OR IF NO UPPER
;NO-SKIP MEANS COPY COULDN'T BE CREATED (JOB SLOTS OR CORE NEEDED)

↑UNPURE:
	LDB AC1,PSEGN
	JUMPE AC1,UNPNON	;NONE AT ALL, CHECK PR2
	MOVE TAC,JBTSTS(AC1)
	TLZN TAC,JWP
	JRST CPOPJ1		;NOT WRITE-PROTECTED
	MOVE TAC1,NJOBS(AC1)
	SOJE TAC1,UNPUR3	;SEE IF WE HAVE SOLE ACCESS
	PUSHJ P,ANYACT		;NO - WAIT FOR I/O & SPW
	PUSHJ P,IOWAIT
	LDB AC1,PSEGN
	PUSHJ P,ESTSEG		;TRY TO CREATE FRESH UPPER
	JRST SPWCNT		;NO JOBS
	MOVSI TAC,SWP
	IORM TAC,JBTSTS(J)	;PRETEND SWAPPED OUT SO CORGET WON'T CALL XPAND
	MOVEI PROG,		;NO CORE YET
	HLRZ TAC,JBTADR(AC1)	;HOW MUCH WE WOULD LIKE
	PUSHJ P,CORGET		;TRY TO GET IT
	JRST UNPNC		;NO CAN DO - MUST HACK VIA SWAPPER
	MOVSI TAC,SWP
	ANDCAM TAC,JBTSTS(J)	;FIX THIS BEFORE WE FORGET
	MOVE AC1,JOB
	LDB AC1,[600,,JBTSTS(AC1)]	;GET CURRENT SEGMENT AGAIN
	HLRZ TAC,PROG
	ADDI TAC,(PROG)
	HRL PROG,JBTADR(AC1)
	BLT PROG,(TAC)		;COPY DATA TO NEW SEGMENT
UNPURX:	PUSH P,J
	MOVE J,JOB
	MOVE PROG,JBTADR(J)
	PUSHJ P,SPWCNT		;IN CASE SPW STOPPED
	PUSH P,AC1
	PUSHJ P,KILSEG		;GET RID OF OLD SEGMENT
	POP P,J
	POP P,TAC
	PUSHJ P,MAKSE2		;COPY PARAMETERS FROM OLD
	MOVE J,JOB(PID)
	DPB TAC,PSEGN		;THIS IS NOW OUR SEGMENT
IFN FTSTAT,<
	PUSHJ P,SEGSTT
	LDB TAC,PSEGN
>;FTSTAT
UNPUR2:	MOVEI AC1,(TAC)
UNPU21:	MOVE TAC,JOBNAM(AC1)	;MUNG JOBNAM SO THE OLD ONE IS STILL UNIQUE
	LSH TAC,-6		;CLEVERLY PRESERVING THE INFO FOR HUMANS
	MOVEM TAC,JOBNAM(AC1)
	MOVEI TAC,400(J)	;400 BIT WILL FEND OFF ACCESS
	DPB TAC,[331100,,JOBCRD(AC1)]	;CLEAR PROTECTION
	JRST SEGXT1		;RETURN SUCCESSFULLY

UNPUR3:	MOVEM TAC,JBTSTS(AC1)	;OURS ALONE - JUST UNPROTECT IT
	JRST UNPU21

UNPNON:	MOVSI TAC,1
	TSNE TAC,JBTPR2(J)	;IF HE HAS RELATIVE PR2
	ANDCAM TAC,JBTPR2(J)	;THEN UNPROTECT IT
	JRST SEGXT1		;NOW UPDATE PR & JOBHRL & SKIP RETURN
;UNPURE CONTINUED:
;HERE WE COULDN'T GET CORE IMMEDIATELY FOR THE NEW SEGMENT, SO WE'LL GET
;THE SWAPPER TO DO THE WORK

;FIRST WE MAKE SURE THE CORE AND DISK COPIES OF OUR PRESENT UPPER AGREE.
;IF NOT, WE WAIT WHILE TRYING TO FORCE A SWAP
UNPNC:	MOVSI TAC,SWP
	ANDCAM TAC,JBTSTS(J)	;FIRST PUT THIS BACK
	MOVE AC1,JOB(PID)
	LDB AC1,[600,,JBTSTS(AC1)]	;GET BACK OLD UPPER #
	HLRZ TAC,JBTSWP(AC1)
	SKIPN STIME(AC1)
	JUMPN TAC,UNPNC4	;AH, UPPER HAS BEEN SWAPPED AND NOT CHANGED
	MOVSI TAC,JSEG!JNA!JLOG
	ANDCAM TAC,JBTSTS(J)	;MUST WAIT - MEANWHILE GIVE BACK JOB SLOT
	SETZM PRJPRG(J)
	MOVEI TAC,NULQ
	MOVNM TAC,JOBQUE(J)
	PUSHJ P,REQUE
	MOVE J,JOB(PID)		;NOW BE OURSELVES, WAITING FOR OUR UPPER TO GET SWAPPED
UNPNC1:	LDB AC1,PSEGN
	HLRZ TAC,JBTSWP(AC1)
	SKIPN STIME(AC1)
	JUMPN TAC,UNPNC3	;NOW WE'RE ALMOST READY
	SKIPN FINISH		;NOT YET - SEE IF WE CAN DIDDLE THE SWAPPER
	SKIPE FORCE
	JRST UNPNC2		;NO - WAIT A LITTLE
	MOVEM AC1,FORCE		;YES - THIS OUGHT TO GET IT OUT THERE
	SETZM SWPCNT
UNPNC2:	PUSHJ P,WSCHED		;WASTE A LITTLE TIME
	JRST UNPNC1		;AND TRY AGAIN

;SWAPPING IS NOW COMPLETE. NOW TRY TO GET BACK JOB SLOT.
UNPNC3:	PUSHJ P,ESTSEG
	JRST SPWCNT		;AFTER ALL THAT WORK ...

;THE CORE AND DISK COPIES OF THE UPPER NOW AGREE. WE WILL STEAL THE CORE COPY,
;LEAVING THE OTHER LOSERS TO FIGHT OVER GETTING THE DISK ONE SWAPPED BACK IN.
UNPNC4:	MOVSI TAC,SWP
	IORM TAC,JBTSTS(AC1)	;SEE US SCREW ALL THE OTHER POOR LOSERS
	MOVEI DSER,
	EXCH DSER,JBTADR(AC1)	;THE OLD UPPER IS NOW OFFICIALLY SWAPPED OUT!
	MOVEM DSER,JBTADR(J)	;GEE, WHAT AN EASY CORE UUO
	PUSH P,AC1
	HLRZ AC1,DSER		;NOW ALL WE HAVE TO DO IS FIX CORTAB
	ANDI DSER,-1
	MOVEI UCHN,
	PUSHJ P,CORSTG		;OUT WITH THE OLD JOB
	MOVEI UCHN,(J)
	HLRZ AC1,JBTADR(J)
	PUSHJ P,CORSTG		;AND IN WITH THE GOOD
	POP P,AC1		;RESTORE JOB NUMBER OF OLD SEG TO COPY DATA
	JRST UNPURX		;DO THE FINAL CLEANUP AND LEAVE
; CORE UUO FOR HIGH SEGMENTS
; CALLING . . .
;	MOVE AC,<HIGHEST REL. ADR. IN UPPER, INCLUDING 0>
;	CALL AC,[SIXBIT /CORE2/]
;	<ERROR RETURN>

↑CORE2:
	TRNE	TAC,377777		;IS HE REQUESTING ANY CORE AT ALL?
	JRST	CORE2A			;YES.
	AOS	(P)			;NO. GIVE HIM THE SUCCESS RETURN
	JRST	KILSEG			;AND KILL THE SEGMENT

CORE2A:	ORI	TAC,1777		;ROUND UP TO NORMAL BOUNDARY
	ANDI	TAC,377777		;ZERO SOME BITS.
	PUSH	P,J
	LDB	J,PSEGN
	JUMPN	J,CORE2B		;JUMP IF WE HAVE A SEGMENT ALREADY.
	POP	P,J			;HERE WE HAVE TO MAKE A NEW SEGMENT
	PUSH	P,TAC
	PUSHJ	P,MAKESEG
	POP	P,TAC
	LDB	TAC1,PSEGN
	JUMPE	TAC1,SEGXIT		;WE LOSE SOMEHOW - NO SEGMENT AVAILABLE.
	PUSH	P,J
	LDB	J,PSEGN
	JRST	CORE2N			;AVOID ACCESS CHECK WHEN MAKING A NEW ONE

CORE2B:	PUSH	P,TAC
	PUSH	P,-1(P)			;PUT JOB NUMBER ON TOP OF STACK
	PUSHJ	P,ACCESS
	JFCL				;LOSE?
	JRST	CORE2C			;LOSE?
	POP	P,(P)
	POP	P,TAC
CORE2N:	MOVE	PROG,JBTADR(J)		;J HAS NUMBER OF THE UPPER.
	PUSHJ	P,CORUUO
	JRST	CORE2D
	PUSH	P,PROG
	MOVE TAC,JBTSTS(J)
	TLNN TAC,SWP!SHF	;SWAPPED OR MOVING?
	SKIPE XJOB(J)		;OR TRYING TO GROW?
	PUSHJ P,WSCHED		;YES, WAIT FOR IT
	POP P,PROG		;GET THIS BACK
	HLRZ TAC1,PROG
CORE2X:	TLNE TAC,JWP
	TLO TAC1,400000		;TELL LOSERS ABOUT WRITE PROTECTION
	MOVE TAC,J
	TRO TAC1,400000
	AOS -1(P)		;SET FOR SUCCESS RETURN
; CORE2 - SCAN FOR ALL JOBS USING THIS SEGMENT AND TELL THEM HE HAS CHANGED SIZE

	MOVEI J,JOBN-1		;SET JOBRL2 FOR ALL JOBS USING THIS SEGMENT.
SETRL2:	LDB TEM,PSEGN
	CAMN TEM,TAC
	SKIPN PROG,JBTADR(J)
	JRST .+2
	MOVEM TAC1,JOBRL2(PROG)
	SOJG J,SETRL2
CORE2D:	POP P,J
	MOVE PROG,JBTADR(J)
	JRST SEGXIT

CORE2C:	POP P,(P)
	POP P,TAC
	POP P,J
	JRST KILSEG

; ATTACH HIGH SEGMENT
; CALLING . . .
;	MOVE AC,<JOB NUMBER OR JOB NAME>
;	CALL AC,[SIXBIT /ATTSEG/]
;	<NO CAN DO, ERROR CODE IN AC>
;
; ERROR CODES:
; 0 - PROTECTION VIOLATION
; 1 - AMBIGUOUS ADDRESSEE
; 2 - NOT A HIGH SEGMENT
; 3 - DOES NOT EXIST
; 4 - ALREADY HAVE A HIGH SEGMENT

↑ATTSEG:
	LDB	TAC1,PSEGN
	SKIPN	JBTPR2(J)		;CAN'T ATTACH WHILE DOING PEEK-POKE
	JUMPE	TAC1,ATTSE5
	MOVEI	TAC,4
	JRST	ATTSER
ATTSE5:	TDNE	TAC,[-100]
	JRST	ATTSGJ
ATTSE1:	MOVE	TAC1,JBTSTS(TAC)
	TLNE	TAC1,JSEG
	JRST	ATTSE6
	MOVEI	TAC,1
ATTSER:	XCTR	XW,[MOVEM TAC,(UCHN)]
	POPJ	P,

ATTSE6:	PUSH	P,J
	MOVE	J,TAC
	PUSHJ	P,ACCESS
	JRST	ATTSE7
	JFCL
	MOVE	TAC1,J
	POP	P,J
	DPB	TAC1,PSEGN
IFN FTSTAT,<
	PUSH P,TAC
	PUSHJ P,SEGSTT
	POP P,TAC
>;FTSTAT
	AOS	NJOBS(TAC1)		; BUMP COUNT OF PEOPLE POINTING TO THIS SEGMENT
	SKIPN	AC1,JBTDTS(J)		;DOES HE HAVE A LIST OF DETACHED SEGMENTS?
	JRST	ATTSE2			;NO.
ATTSE3:	LDB	DAT,PDSEGN		;YES, IS THERE A SEGMENT NUMBER THERE
	JUMPE	DAT,ATTSE2		;NO SEGMENTS LEFT IN LIST
	CAME	DAT,TAC1		;IS THIS THE ONE IN QUESTION?
	AOJA	AC1,ATTSE3		;NO, TRY THE NEXT ONE
	MOVE	TEM,AC1			;YES, RUN DOWN TO END OF LIST
	ADDI	TEM,1			;UPDATE LIST OF DETACHED SEGMENTS
ATTSE4:	SKIPE	(TEM)			;IS THIS THE END OF LIST?
	AOJA	TEM,ATTSE4		;NO, TRY AGAIN
	MOVE	DAT,-1(TEM)		;MOVE LAST WORD ONTO WHERE WE'RE DELETING
	MOVEM	DAT,(AC1)
	SETZM	-1(TEM)			;ZERO THE END OF THE LIST
	SUBI	TEM,1
	CAME	TEM,JBTDTS(J)		;DOES HE HAVE ANY DETACHED SEGMENTS LEFT?
	JRST	ATTSE2			;YES, WE ARE DONE
	MOVE	AC1,JBTDTS(J)		;NO, WE CAN GIVE BACK FREE STORAGE
	PUSHJ	P,FSGIVE
	SETZM	JBTDTS(J)
ATTSE2:	AOS	(P)
	PUSHJ	P,WSCHED		;MAKE SURE SEGMENT IS IN CORE
	JRST	SEGXIT			; NOW GO SET PROT-RELOC
;ATTSEG	 SEARCH FOR A SEGMENT OF A GIVEN NAME
ATTSGJ:	MOVE	DAT,JOBNM1
ATTSG1:	CAME	TAC,JOBNAM(DAT)
	JRST	ATTSG4
	MOVE	TAC1,JBTSTS(DAT)
	TLNN	TAC1,JSEG
	JRST	ATTSG4
	MOVE	TAC1,DAT
	JRST	ATTSG2
ATTSG4:	SOJG	DAT,ATTSG1
	MOVEI	TAC,3
	JRST	ATTSER

ATTSG3:	CAME	TAC,JOBNAM(DAT)
	JRST	ATTSG2
	MOVE	TEM,JBTSTS(DAT)
	TLNN	TEM,JSEG
	JRST	ATTSG2
	MOVEI	TAC,1
	HRL	TAC,DAT
	JRST	ATTSER

ATTSG2:	SOJG	DAT,ATTSG3
	MOVE	TAC,TAC1
	JRST	ATTSE1		;GO TRY IT

ATTSE7:	POP	P,J
	MOVEI	TAC,0
	JRST	ATTSER
;DETSEG  DETACH SEGMENT
; CALLING . . .
;	CALL AC,[SIXBIT /DETSEG/]
; IF AC=0, THEN THE SEGMENT IS DETACHED AND PLACED INTO A LIST
; OF THE SEGMENTS THIS GUY HAS DETACHED, SUCH THAT WHEN THE
; SYSTEM CALLES RESET, ALL HIS DETACHED SEGMENTS GO AWAY. IF AC LOW
; ORDER BIT IS ON, SEGEMENT WILL BE SPECIALLY DETACHED- WILL STICK AROUND
; UNTIL THE MAKER KJOBS.

↑DETSEG:
	SKIPE	JBTPR2(J)		;DOING PEEK-POKE?
	JRST	[SETZM	JBTPR2(J)	;FLUSH PEEK-POKE
		JRST	SEGXIT]
	LDB	TAC1,PSEGN
	JUMPE	TAC1,CPOPJ		;NO HIGH SEGMENT HERE, HOW STRANGE!
	SKIPE	AC1,JBTDTS(J)		;PUT THIS ON THE LIST OF DETACHED SEGMENTS.
	JRST	DETSE1			;HE HAS A DETACHED SEGMENT LIST ALREADY.
	MOVEI	AC3,JOBN		;NO, GET HIM ONE ABOUT THIS LONG.
	PUSHJ	P,UFSGET
	HRRZM	AC1,JBTDTS(J)
	JRST	DETSE2

DETSE1:	SKIPE	(AC1)			;NOW RUN DOWN TO END OF LIST
	AOJA	AC1,DETSE1
DETSE2:	TRNE	UCHN,1			;DOES HE HAVE THE 1-BIT ON IN THE AC FIELD?
	TLO	TAC1,400000		;YES, SET SPECIAL DET SEG.
	MOVEM	TAC1,(AC1)		;PUT THIS SEGMENT NUMBER IN THE TABLE
	SOSGE	NJOBS(TAC1)
	PUSHJ	P,NJERR
	SETZB	TAC,1(AC1)		;AND MARK THE END OF LIST
	DPB	TAC,PSEGN
IFN FTSTAT,<
	PUSHJ P,SEGSTT
	LDB TAC,PSEGN
>;FTSTAT
	JRST	SEGXIT

NJERR:	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/NJOB WENT NEGATIVE AT DETSEG
/
	POPACS
	SETZM	NJOBS(TAC1)
	POPJ	P,
; DETSEG - COMMON SEGMENT UUO EXIT ROUTINE

SEGXT1:	AOS (P)
SEGXIT:	PUSHJ P,GETPR
	DATAO APR,TAC
	LSH TAC,-11	;SET JOBHRL DIRECTLY FROM PR WD SO SETPR2 WILL WIN TOO
	TRNN TAC,JWP⊗<22-11>
	TLZA TAC,-1
	HRLI TAC,400000
	IORI TAC,401777
	CAMN PROG,JBTADR(J)
	JRST SEGXT3
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ/πππPROG CLOBBERED AT SEGXIT
PROG=/
	MOVE TAC,PROG
	PUSHJ P,DISOCT
	POPACS
	MOVE PROG,JBTADR(J)
SEGXT3:	MOVEM TAC,JOBRL2(PROG)
	POPJ P,
; GET NUMBER OF SEGMENT BELONGING TO JOB N
; IF N IS ZERO, RETURNS YOUR SEGMENT NUMBER
; ZERO RETURNED MEANS NO SEGMENT

↑SEGNUM:
	CAIL	TAC,0
	CAIL	TAC,JOBN
	JRST	UUOERR
	CAIN	TAC,0
	MOVE	TAC,J
	MOVE	J,TAC
	LDB	TAC,PSEGN
	XCTR	XW,[MOVEM TAC,(UCHN)]
	POPJ	P,
; SEGSIZ CALLING . . .
;	CALL AC,[SIXBIT /SEGSIZ/]
; RETURNS HIGHEST LEGAL ADDRESS IN UPPER SEGMENT
; MINUS 400000
; RETURNS ZERO IF YOU DO NOT HAVE AN UPPER SEGMENT

↑SEGSIZ:
	LDB TAC,PSEGN
	JUMPE TAC,STOTAC
	HLRZ TAC,JBTADR(TAC)
	JRST STOTAC
; SETNM2 CALLING . . .
;	MOVE AC,[SIXBIT /<NAME YOU WISH YOUR UPPER TO HAVE>/]
;	CALL AC,[SIXBIT /SETNM2/]
;	<ERROR RETURN>
; IF YOU HAVE AN UPPER SEGMENT, GIVES IT THE NAME IN ACCUMULATOR AC.
; IF YOU DON'T HAVE AN UPPER, THIS UUO IS A NO-OP.
; UPON SUCCESS, AC IS CLEARED, UNLESS THERE IS ANOTHER SEGMENT OF THE SAME NAME,
;	 IN WHICH CASE YOU GET ITS JOB NUMBER

↑SETNM2:
	LDB TAC1,PSEGN
	JUMPE TAC1,CPOPJ1
	PUSH P,TAC
	PUSH P,J
	MOVE J,TAC1
	PUSHJ P,ACCESS
	JFCL
	JRST JTPOPJ
	POP P,TAC1
	POP P,JOBNAM(J)
IFN FTSTAT,<PUSHJ P,NAMSTT>
	MOVEI TAC1,JOBN-1
SETNM3:	MOVE DAT,JBTSTS(TAC1)
	TLNN DAT,JSEG
	JRST SETNM4
	MOVE DAT,JOBNAM(TAC1)
	CAME TAC1,J
	CAME DAT,JOBNAM(J)
SETNM4:	SOJG	TAC1,SETNM3
	XCTR	XW,[MOVEM TAC1,(UCHN)]
	JRST	CPOPJ1

↑JTPOPJ:POP P,J
	JRST TPOPJ
; ROUTINE TO GET YOUR SEGMENT'S NAME
; CALLING . . .
;	CALL AC,[SIXBIT /SEGNAM/]
; NAME (OR 0) RETURNED IN ACCUMULATOR

↑SEGNAM:
	LDB J,PSEGN
	MOVE TAC,JOBNAM(J)
	JRST STOTAC
; THIS UUO FIRST KILLS ANY HIGH SEGMENT YOU MAY HAVE.
; CALLING . . .
;	CALL [SIXBIT /LINKUP/]
;	<NO CAN DO>
; IT THEN ATTEMPTS TO MAKE A LINKUP WITH ANY HIGH SEGMENT
; IN CORE WITH YOUR CREDENTIALS.

↑LINKUP:
	PUSHJ P,LINKSEG
	POPJ P,
	JRST ATTSE2		; BRING UPPER INTO CORE, AND SKIP RETURN
; RETURNS LIST OF JOB NUMBERS WHO POINT TO YOUR UPPER SEGMENT.
; THE LIST TERMINATES WITH A ZERO
; IF YOU HAVE NO UPPER SEGMENT, ZERO IS RETURNED IN ADR
; ADR BETTER BE AT LEAST JOBN WORDS LONG.
; CALLING . . .
;	POINTS ADR

↑POINTS:
	LDB	DAT,PSEGN
	JUMPE	DAT,POINT3
	MOVEI	J,JOBN-1
POINT2:	LDB	TAC1,PSEGN
	CAME	TAC1,DAT
	JRST	POINT1
	XCTR	XW,[MOVEM J,(UUO)]
	ADDI	UUO,1
POINT1:	SOJG	J,POINT2
POINT3:	XCTR	XW,[SETZM (UUO)]
	POPJ	P,
; SET PROTECTION ON A HIGH SEGMENT
; CALLING . . .
;	MOVE AC,<0-8 NEW PROTECTION KEY; 30-35 SEGMENT NUMBER>
;	CALL AC,[SIXBIT /SETPRO/]
;	<NO CAN DO>
;
; IF SEGMENT NUMBER IS ZERO, REFERS TO YOUR OWN SEGMENT

↑SETPRO:
	PUSH P,TAC
	PUSH P,J
	LDB J,[POINT 6,TAC,35]
	JUMPN J,SETP3
	MOVE J,(P)
	LDB J,PSEGN
	JUMPE J,JTPOPJ
SETP3:	MOVE TAC1,JBTSTS(J)
	TLNN TAC1,JSEG
	JRST JTPOPJ
	PUSHJ P,ACCESS
	JFCL
	JRST JTPOPJ
	MOVE TAC1,(P)
	MOVE TAC1,JBTPRV(TAC1)
	TLNE TAC1,SEGPRV	;SKIP UNLESS HE HAS SEGMENT PRIV
	JRST SETP2		;SEG PRIV. HE WINS
	TRNE TAC,400		;PROTECTION PROTECTED?
	JRST JTPOPJ
SETP2:	MOVE TAC,-1(P)
	LSH TAC,-=27
	ANDI TAC,377		;ONLY REAL BITS
	DPB TAC,[POINT =9,JOBCRD(J),8]
	AOS -2(P)
	JRST JTPOPJ

BEND SEGUUO
	SUBTTL	INTUUO - UUOS FOR NEW STYLE INTERRUPT SYSTEM
; UUO TO SET THE PROCESSOR RUNNING MASK
; CALLING . . .
;	MOVE AC,[<RUN BITS>]
;	CALL AC,[SIXBIT /RUNMSK/]
; THE BITS ARE
; BIT 35 - RUNNABLE ON P1
; BIT 34 - RUNNABLE ON P2

RUNMSK:
REPEAT 0,<
	DPB TAC,PRUNB
>
	POPJ P,
; INTENB
; ENABLE INTERRUPTS . . .
;	MOVE AC,[MAGIC BITS]
;	CALL AC,[SIXBIT /INTENB/]

INTENB:	PUSHJ P,INTCHK
	MOVE AC1,JBTIEN(J)	;OLD ENABLINGS
	MOVEM TAC,JBTIEN(J)	;NEW ENABLINGS
	XOR AC1,TAC
	TLNN AC1,INTCLK		;SKIP IF INTCLK CHANGING
	JRST INTAPC		;INTAPC NEEDS TAC = JBTIEN
	TLNN TAC,INTCLK		;SKIP IF TURNING INTCLK ON
	JRST INTEN1		;TURNING IT OFF
	PUSHJ P,CLKENB		;PLANT CLOCK REQUEST IN APRLST FOR 1 TICK
	JRST INTAPC

INTEN1:	PUSHJ P,INTAPC
	MOVSI TAC,INTCLK
	ANDCAM TAC,JBTIRQ(J)	;FLUSH PENDING CLOCK INTERRUPT
	JRST APRDKL		;KILL ANY CLOCK REQUESTS WE MIGHT HAVE

INTCHK:	TLZ TAC,INTWAIT		;UUO WAIT IS THE ONLY PROTECTED INTERRUPT BIT
	TDNN TAC,JOBENB(PROG)
	POPJ P,
INTLOS:	JSP TAC,UUOMES
	ASCIZ /INTERRUPT ENABLINGS CONFLICT
UUO/
; CLKENB, CLKENA  - ENABLE FOR USER CLOCK INTERRUPTS
; CLKENA - SAME AS CLKENB EXCEPT TAC HAS NUMBER OF TICKS FOR REQ

CLKENB:	PUSH P,TAC
	TDZA TAC,TAC		;FLAG NOT TO STORE TIME
CLKENA:	PUSH P,TAC
	JUMPN PID,TPOPJ		;NO INTERRUPTS ON P2
CLKNB1:	CONO PI,APROFF
	SKIPN AC1,APRLST
	JRST CLKNB2		;HAVE TO CREATE APRLST BLOCK
CLKNBL:	SKIPN AC2,(AC1)		;FIND THE FIRST BLANK SPOT
	JRST CLKNB5		;END OF LIST AND THIS JOB HAS NO REQ YET
	CAIN J,(AC2)		;IS THERE AN ENTRY FOR THIS JOB?
	JRST CLKNB4
	ADDI AC1,2		;LOOP AROUND
	JRST CLKNBL

CLKNB2:	CONO PI,APRON
	MOVEI AC3,2*JOBN
	PUSHJ P,UFSGET		;GET A BLOCK OF FREE STORAGE
	SETZM (AC1)
	CONO PI,APROFF
	SKIPN APRLST		;SEE IF SOMEONE ELSE HAS MADE IT ALREADY
	JRST CLKNB3		;NO, WE STILL GET TO DO IT
	CONO PI,APRON
	PUSHJ P,FSGIVE		;FALSE ALARM
	JRST CLKNB1
CLKNB3:	MOVEM AC1,APRLST
	JRST CLKNBL

CLKNB4:	JUMPE TAC,CLKNB7	;ALREADY AN ENTRY AND DON'T CHANGE TIME
CLKNB6:	HRLM TAC,(AC1)
	MOVNM TAC,1(AC1)
CLKNB7:	CONO PI,APRON
	JRST TPOPJ

CLKNB5:	SETZM 2(AC1)		;MAKE A FRESH ENTRY
	HRRZM J,(AC1)
	JUMPN TAC,CLKNB6	;STORE NEW TIME
	AOJA TAC,CLKNB6
; INTORM - ROUTINE TO SET BITS IN INTERUPT ENABLE MASK

INTORM:	PUSHJ P,INTCHK
	MOVE AC1,TAC		;INTERRUPT BITS BEING TURNED ON
	IORB TAC,JBTIEN(J)	;TAC MUST HAVE JBTIEN AT INTAPC
	TLNE AC1,INTCLK
	PUSHJ P,CLKENB		;PLANT CLOCK REQ FOR 1 TICK
	JRST INTAPC
; INTACM - CLEARS BITS IN INTERRUPT ENABLE MASK

INTACM:	PUSHJ P,INTCHK
	MOVE AC1,TAC		;INTERRUPT BITS BEING TURNED OFF
	ANDCAB TAC,JBTIEN(J)
	TLNE AC1,INTCLK		;SKIP IF NOT CLEARING INTCLK
	JRST INTEN1
INTAPC:	ANDI TAC,CPUMSK
	HRRZM TAC,APRIN2(PID)	;ONLY LEGAL BITS
	IOR TAC,JOBENB(PROG)
	ANDI TAC,CPUMSK!1000	;MASK THIS TOO, SINCE IT'S UNPROTECTED
	JRST APREN2		;SET UP PROCESSOR CONO
; INTENS, INTIIP - ROUTINES TO GIVE BACK INFORMATION

INTENS:	SKIPA TAC,JBTIEN(J)
INTIIP:	MOVE TAC,JBTIIP(J)
	JRST STOTAC
; INTIRQ - TELLS YOU WHAT INTERRUPTS ARE PENDING

INTIRQ:	MOVE TAC,JBTIRQ(J)
	JRST STOTAC
; DISMIS - TERMINATES CURRENT I-LEVEL RUN

DISMIS:	SKIPE INTACT(PID)
	JRST DISM2
	SKIPE SPWUUF(PID)
	JRST SPWXIT		;MUST LEAVE THROUGH HERE!!!!!!!
	JRST DISLOS
DISM2:	MOVEI AC1,INTDSM
DISM1:	JUMPE UCHN,DISM3	;NONZERO AC FIELD REQUEUES JOB AS SPEC BY C(AC)
	MOVM TAC,JOBQUE(J)
	XCTR XR,[MOVE TAC1,(UCHN)]	;LH(AC) IS MASK FOR LEGAL SOURCE Q'S
	LSH TAC1,(TAC)
	JUMPGE TAC1,DISM3		;NOT IN LEGAL SOURCE Q
	XCTR XR,[HRRZ TAC,(UCHN)]	;GET NEW CODE
	CAIL TAC,NDISQS
	JRST DISM3			;OUT OF BOUNDS
	MOVE TAC,DISQTB(TAC)
	MOVEM TAC,JOBQUE(J)
	PUSHJ P,REQUE
DISM3:	CONO PI,PIOFF		;AVOID EXTRANEOUS CLK INTS
	MOVEM AC1,INTDISP(PID)
	HLLOS CLKFLG(PID)		; MAKE SURE CH7 KNOWS WE'RE COMING!
	CONO PI,PION!1B24!1⊗(7-CLKCHN)
	JUMPN PID,CL2INT
	JRST CLKINT

DISLOS:	JSP TAC,UUOMES
ASCIZ /I-LEVEL UUO GIVEN WHEN NOT AT I-LEVEL
UUO/

DISQTB:	TQ		;THESE ARE POSITIVE SO THEY WON'T GENERATE QXFER INTS
	RUNQ
	INTWQ
	IOWQ
NDISQS←←.-DISQTB
; INTGEN - ROUTINE TO GENERATE AN INTERRUPT FOR YOURSELF

INTGEN:	SETCM AC1,JBTIEN(J)
	TDNN AC1,TAC
	JRST INTGN1
	JSP TAC,UUOMES
	ASCIZ /INTGEN OF NON-ENABLED INTERRUPT
UUO/
INTGN1:	IORM TAC,JBTIRQ(J)
	SETOM INTREQ(PID)
	SKIPN INTACT(PID)
	JRST WSCHED
	POPJ P,
; USKIP - ROUTINE TO TELL USER IF HE IS INSIDE A UUO

USKIP:	SKIPN INTACT(PID)
	JRST DISLOS
	MOVE AC1,USRPC(PID)	;PC OF SUSPENDING MAIN JOB
	TLNN AC1,USRMOD
	AOS (P)
	POPJ P,
; UWAIT - WAITS FOR UUO TO TERMINATE

UWAIT:	PUSHJ P,USKIP		;SKIP IF INTERRUPTED OUT OF A UUO, RETURNING
	JRST UWNPC		; IN AC1 THE PC OF THE SUSPENDED PROCESSES
	MOVE DSER,JBTSTS(J)	; HE HAS BEEN REQUEUED IF HE IS IN INTERRUPT WAIT,
				; NOW CHECK FOR SLEEPING.
	TLNE DSER,CLKR		; DOES HE HAVE A SLEEP REQUEST IN?
	PUSHJ P,UWAIT1		; YES, GO WAKE HIM UP
	MOVSI AC1,INTWAIT
	IORM AC1,JBTIEN(J)
	IORM AC1,JBTMSK(J)
	MOVE AC1,UUOPC(J)
	MOVEM AC1,JBTUPC(J)	;USER ADDRESS AFTER UWAIT
	JRST DISMIS

UWAIT1:	MOVE TAC,J		;SIMULATE UUO LEVEL CALL BY PUTTING JOB NUMBER IN TAC
	JRST WAKE

UWNPC:	MOVEM AC1,JOBTPC(PROG)
	MOVSI AC1,JOBDAC(PROG)	;GET MAIN PROGRAM ACS (20-37) BACK INTO REAL ACS
	HRRI AC1,JOBAC(PROG)
	BLT AC1,JOBAC+17(PROG)
	POPJ P,
; DEBREAK - MAKES I-LEVEL PROCESS TAKE PLACE OF U-LEVEL PROCESS

DEBREAK:
	SKIPN INTACT(PID)
	JRST DISLOS
	MOVEI AC1,INTDEB
	JRST DISM1
; IWAIT - GO INTO INTERRUPT WAIT UNTIL AWAKENED BY AN APPROPRIATE INTERRUPT

IWAIT:	MOVEI AC1,INTWQ
	MOVNM AC1,JOBQUE(J)
	JRST WSCHED
; ROUTINE TO ENABLE INTERRUPTS AND THEN GO INTO INTERRUPT WAIT
; CALLING . . .
;	MOVE AC,[<INTERRUPT BITS>]
;	CALL AC,[SIXBIT /IENBW/]
; YOU ARE NOW IN INTERRUPT WAIT.

IENBW:	MOVEI AC1,INTWQ		; PUT US IN INTERRUPT WAIT
	MOVNM AC1,JOBQUE(J)
	PUSHJ P,INTENB		; ENABLE INTERRUPTS
	JRST WSCHED		; WAIT.
;;UUOS TO SET THE INTERRUPT MASK
; CALLING . . .
;	INTMSK [<MASK BITS>]


INTMSK:	XCTR XR,[MOVE AC1,(UUO)]
	MOVEM AC1,JBTMSK(J)
IMCALL:	SKIPN INTACT(PID)	;DON'T CALL WSCHED IF ALREADY AT I-LEVEL
	TDNN AC1,JBTIRQ(J)	; DOES HE HAVE ANY INTERRUPTS PENDING?
	POPJ P,
	SETOM INTREQ(PID)	; YES, GIVE THEM
	JRST WSCHED
;IMSKST  IMSKCL
; THIS ONE SETS BITS IN THE MASK . . .

IMSKST:	XCTR XR,[MOVE AC1,(UUO)]
	IORM AC1,JBTMSK(J)
	JRST IMCALL

; AND THIS ONE CLEARS BITS . . .

IMSKCL:	XCTR XR,[MOVE AC1,(UUO)]
	ANDCAM AC1,JBTMSK(J)
	POPJ P,
; CLKINT UUO  (CLKUUO) START UP A CLOCKED I-LEVEL JOB
; CALLING . . .
;	CLKINT TIX
; TIX IS THE TIME IN TICKS BETWEEN STARTUPS
; IF TIX IS ZERO, ANY CLOCKED JOB IS FLUSHED

CLKUUO:	TRNN UUO,-1		;ZERO TIX?
	JRST CLKUU2		;YES, GO KILL JOB
	MOVSI TAC,INTCLK
	IORM TAC,JBTIEN(J)	;ENABLE CLOCK INTERRUPTS
	ANDCAM TAC,JBTIRQ(J)	;FLUSH PENDING OLD CLOCK INTERRUPT
	HRRZ TAC,UUO
	JRST CLKENA		;PLANT THE CLOCK REQUEST

CLKUU2:	PUSHJ P,APRDKL		;KILL CLOCK REQUEST
	MOVSI TAC,INTCLK
	ANDCAM TAC,JBTIEN(J)
	ANDCAM TAC,JBTIRQ(J)
	POPJ P,
;INTUUO - INTDEJ, IMSTW
; MULTI-PURPOSE INTERRUPT UUO

INTUUO:	CAILE UCHN,INTMXU
	JRST UUOERR
	JRST @INTUTB(UCHN)

DEFINE UUOS{FOR X IN(INTDEJ,IMSTW,IWKMSK,INTDMP,INTIPI,IMSKCR)}

UUOMAC INTUTB,INTUUO
INTMXU←←UUOCNT

; RESET INTERRUPT MASK AND JUMP TO ADDRESS UUO.
; CALLING . . .
;	INTDEJ ADR
; WITH THE FOLLOWING DATA . . .
; ADR:	<INTERRUPT BITS TO BE ORED INTO MASK>
;	<PC WORD TO GO TO>
; THIS UUO DOES NOT RETURN, BUT INSTEAD JUMPS TO THE ADDRESS

INTDEJ:	XCTR XR,[MOVE TAC,1(UUO)];FETCH PC WORD
	TLO TAC,USRMOD		; KEEP THE LOSER OUT OF THE SYSTEM
	PUSH P,TAC
	PUSHJ P,IMSKST		; OR IN MASK BITS
	POP P,UUOPC(J)		; SET UP RETURN ADDRESS
	POPJ P,			; RETURN TO LOSER

; SET MASK FROM FIRST WORD OF UUO AND GO INTO WAIT STATE.
; CALLING . . .
;	IMSTW ADR
;
; ADR:	<MASK BITS>

IMSTW:	MOVEI AC1,INTWQ		; PUT US INTO INTERRUPT WAIT FIRST
	MOVNM AC1,JOBQUE(J)
	PUSHJ P,INTMSK		; SET THE MASK
	JRST WSCHED		; DO THE WAIT STATE THING.
; IWKMSK, IMSKCR
; SET MASK THAT ALLOWS THE MAIN JOB TO BE AWAKENED
; FROM IWAIT QUEUE.
; CALLING . . .
;	IWKMSK ADR
;
; ADR:	<INTERRUPT BITS WHICH SHOULD AWAKEN>

IWKMSK:	XCTR XR,[MOVE TAC,(UUO)]
	MOVEM TAC,JBTWKM(J)
	POPJ P,

;CLEAR SPECIFIED BITS OF MASK (PDP-10 ONLY) AND RETURN OLD MASK
;CALL:
;	IMSKCR ADR
;
;ADR:	BITS TO TURN OFF IN MASK, REPLACED BY OLD MASK VALUE

IMSKCR:	MOVE TAC,JBTMSK(J)
	XCTR XR,[ANDCM TAC,(UUO)]
	EXCH TAC,JBTMSK(J)
	JRST STOTAC
; INTDMP
; ROUTINE TO DUMP OUT INFORMATION ABOUT A PARTICULAR JOB'S INTERRUPT
; CONDITION. CALLING . . .
;	INTDMP ADR
;	<FAILURE - ERROR CODE IN ADR+1>
;
; ADR:	<JOB NUMBER OR JOB NAME>
;	<ENABLE BITS OR ERROR CODE, 1 FOR NON-EX JOB NUMBER,
;		2 FOR AMBIGUOUS JOB NAME, 3 FOR NON-EX JOB NAME>
;	<P1 INTERRUPT MASK>
;	ZERO
;	<WAKEUP MASK>
;	<JOB QUEUE>

INTDMP:	XCTR XR,[MOVE TAC,(UUO)]	;PICK UP JOB NUMBER OR NAME
	TDNE TAC,[-100]		; SEE WHICH IT IS
	JRST INTDGJ		; NAME, FIND OUT WHICH
	JUMPE TAC,INTDM2	; IF ZERO, USE HIS OWN
	CAIL TAC,JOBN		; IS JOB NUMBER IN BOUNDS?
	JRST INTDR1		; NO.  GIVE BAD JOB # ERROR RETURN
INTDM1:	MOVE AC1,JBTIEN(TAC)	; GIVE THE GUY HIS ENABLE BITS
	XCTR XW,[MOVEM AC1,1(UUO)]
	MOVE AC1,JBTMSK(J)	; AND HIS PROCESSOR MASKS
	XCTR XW,[MOVEM AC1,2(UUO)]
	XCTR XW,[SETZM 3(UUO)]
	MOVE AC1,JBTWKM(TAC)	; HIS WAKEUP MASK
	XCTR XW,[MOVEM AC1,4(UUO)]
	MOVM AC1,JOBQUE(TAC)	; AND HIS CURRENT QUEUE
	XCTR XW,[MOVEM AC1,5(UUO)]
	JRST CPOPJ1		; GIVE SUCCESS RETURN
; INTDMP - ERROR RETURNS

INTDM2:	MOVE TAC,J
	JRST INTDM1

INTDR3:	MOVEI AC1,3
	JRST INTDR4

INTDR2:	SKIPA AC1,[2]
INTDR1:	MOVEI AC1,1
INTDR4:	XCTR XW,[MOVEM AC1,1(UUO)]
	POPJ P,

INTDGJ:	PUSHJ P,GJOBN		; GET JOB NUMBER FROM NAME IN TAC
	JRST INTDR2		; AMBIGUOUS NAME
	JRST INTDR3		; NON-EX NAME
	JRST INTDM1		; WIN!
; ROUTINE TO GET A JOB NUMBER FROM A JOB NAME

GJOBN:	MOVEI AC1,JOBN-1
GJOBN1:	CAMN TAC,JOBNAM(AC1)
	JRST GJOBN2
GJOBN4:	SOJG AC1,GJOBN1
	JRST CPOPJ1

GJOBN2:	MOVE AC2,JBTSTS(AC1)
	TLNE AC2,JSEG
	JRST GJOBN4
	MOVE AC2,AC1
	JRST GJOBN5
GJOBN3:	CAMN TAC,JOBNAM(AC2)
	POPJ P,
GJOBN5:	SOJG AC2,GJOBN3
	MOVE TAC,AC1
	JRST CPOPJ2
; INTIPI
; INTER-PROCESS INTERRUPT SYSTEM
; CALLING . . .
;	INTIPI ADR
;	<ERROR - CODE IN ADR+1 - 1 FOR NON-EX JOB NUMBER
;			2 FOR AMBIGUOUS JOB NAME
;			3 FOR NON-EX JOB NAME
;			4 FOR JOB NOT ENABLED FOR THOSE INTERRUPTS>
; ADR:	<JOB NUMBER OR NAME>
;	<INTERRUPT BITS OR ERROR CODE>

INTIPI:	XCTR XR,[MOVE TAC,(UUO)]	;GET JOB NAME OR NUMBER
	TDNE TAC,[-100]
	JRST INTIP1		;JOB NAME
	JUMPE TAC,INTIP2	;IF 0 USE OWN JOB
	CAIL TAC,JOBN
	JRST INTDR1
INTIP3:	XCTR XR,[MOVE AC1,1(UUO)]	;INTERRUPT BITS
	SETCM AC2,JBTIEN(TAC)
	TDNE AC1,AC2
	JRST INTIR4
	IORM AC1,JBTIRQ(TAC)
	SETOM INTREQ(PID)
	JRST CPOPJ1

INTIP1:	PUSHJ P,GJOBN
	JRST INTDR2		;AMBIGUOUS
	JRST INTDR3		;NOT FOUND
	JRST INTIP3		;UNIQUE

INTIP2:	MOVE TAC,J
	JRST INTIP3

INTIR4:	MOVEI AC1,4
	JRST INTDR4
SUBTTL	UUOCON - STANFORD SPECIAL IO ROUTINES
;;UUO TO GET USE BITS FOR A CHANNEL
;	CHNSTS <CHANNEL NUMBER>,ADR
; PUTS USRJDA IN ADR, 0 FOR UNUSED.

CHNSTS:
	CAMLE	UCHN,USRHCU(PID)
	TDZA	TAC,TAC
	HLRZ	TAC,USRJDA(UCHN)
	XCTR	XW,[MOVEM TAC,(UUO)]
	POPJ	P,
;;THIS UUO GETS THE STANDARD BUFFER LENGTH FOR A DEVICE
;	MOVE AC,[DEVICE NAME IN SIXBIT]
;	CALL AC,[SIXBIT /BUFLEN/]
;	<RETURNS HERE WITH BUFFER LENGTH, OR 0, IN AC>

BUFLEN:	PUSHJ P,FNDDDB		; LOOK FOR DEVICE WITH THIS NAME (OR CHANNEL #)
	JRST RTZERO		; GIVE BACK A ZERO IF NOT FOUND
	LDB TAC,PDVBLN		; RETURN BUFFER LENGTH
	JRST STOTAC
; ROUTINE TO GET THE TIME CELLS AND CLEAR THEM
; CALLING . . .
;	MOVE AC,<ADDRESS OF 2-WORD BUFFER>
;	CALL AC,[SIXBIT /GDPTIM/]
; RETURNS KEYBOARD TIME IN <BUFFER> AND DISPLAY TIME IN <BUFFER>+1
; CLEARS BOTH CELLS IN THE MONITOR
; RETURNS ZEROS IF YOU ARE NOT A DPY

GDPTIM:
REPEAT 0 < ;GDPTIM UUO REMOVED 23-MAR-73
	MOVE	TAC1,JBTLIN(J)		;GET OUR LINE NUMBER
	XCTR	XR,[MOVE TAC,(UCHN)]	;FIND WHERE TO STUFF DATA
	SETZB	AC1,AC2			;ZERO A PAIR OF AC'S 
	TLNE	TAC1,DISLIN!DDDLIN	;SKIP IF NOT III OR DATA DISK
	SKIPN	DDB,LETAB-DPYL0(TAC1)
	JRST	NOTDPY			;NOT A DPY
	EXCH	AC1,DPKTIM(DDB)		
	EXCH	AC2,DPGTIM(DDB)
NOTDPY:	XCTR	XW,[MOVEM AC1,(TAC)]
	XCTR	XW,[MOVEM AC2,1(TAC)]
>;END DELETION OF GDPTIM
	POPJ	P,

;;RETURNS A CODE TELING WHETHER A JOB NAME IS LOGGED IN
;	MOVE AC,[<JOB NAME IN SIXBIT>]
;	CALL AC,[SIXBIT /NAMEIN/]
;	<NO SUCH JOB - ERROR CODE IN AC>
;
; ERROR CODE IS 3 FOR MULTIPLY DEFINED JOB NAME, 1 FOR NO SUCH NAME

NAMEIN:
	MOVEI TAC1,JOBN-1
NAMEI1:	CAME TAC,JOBNAM(TAC1)	; IS THIS IT?
NAMEI2:	SOJG TAC1,NAMEI1
	JUMPN TAC1,NAMEI4
	MOVEI TAC,1
	JRST STOTAC	; NO SUCH NAME, GIVE ERROR 1 RETURN
NAMEI4:	MOVE AC1,JBTSTS(TAC1)
	TLNN AC1,JNA		; NOW, IS IT A JOB?
	JRST NAMEI2
	MOVE AC2,TAC1		;GIVE BACK JOB NUMBER
NAMEI3:	SOJLE TAC1,NAMEI5	; SEARCH REMAINDER OF NAMES FOR MATCH
	CAME TAC,JOBNAM(TAC1)
	JRST NAMEI3
	MOVE AC1,JBTSTS(TAC1)
	TLNN AC1,JNA
	JRST NAMEI3
	MOVEI TAC,3
	JRST STOTAC
NAMEI5:	MOVE TAC,AC2
	AOS (P)			; SKIP RETURN
	JRST STOTAC		; AND GIVE HIM THE JOB NUMBER
; DEVUSE - HOW MANY JOBS ARE WAITING FOR A PARTICULAR DEVICE.
; CALLING . . .
;	MOVE AC,<DEVICE NAME>
;	CALL AC,[SIXBIT /DEVUSE/]
; RETURNS NUMBER OF JOBS WAITING FOR THIS DEVICE IN AC (NOT INCLUDING YOUR JOB)

DEVUSE:	PUSHJ	P,FNDDDB	; PICK UP DEVICE DATA BLOCK ADDRESS
	JRST	RTZERO		; NO SUCH DEVICE, NOBODY WAITING FOR IT!
	MOVEI	AC1,JOBN-1	; PREPARE TO SCAN JOB TABLES
	SETZ	TAC,
DEVUS1:	CAME	DDB,JBTDVW(AC1)	; IS THIS THE DEVICE?
DEVUS2:	SOJG	AC1,DEVUS1	; NO, LOOP AROUND
	JUMPE	AC1,DEVUS3	; RETURN ARGUMENT AND LEAVE
	CAIN	AC1,(J)
	JRST	DEVUS2		; DON'T COUNT YOURSELF.
	MOVE	AC2,JBTSTS(AC1)	; SEE IF THE JOB EXISTS
	MOVM	AC3,JOBQUE(AC1)	; AND IF IT IS IN DEVICE WAIT
	TLNE	AC2,JNA
	CAIE	AC3,DWQ
	JRST	DEVUS2
	AOJA	TAC,DEVUS2	; BUMP COUNT AND LOOP BACK

DEVUS3:	MOVE	TAC1,DEVMOD(DDB)
	TLNE	TAC1,DVUDP
	JRST	DEVUS4		;COMPLICATED FOR UDP
	LDB	AC1,PJOBN	;GET JOB NUMBER OF DEVICE OWNER
	TLNE	TAC1,TTYATC
	TRO	AC1,100000
	TRNE	TAC1,ASSCON
	TRO	AC1,400000
	TRNE	TAC1,ASSPRG
	TRO	AC1,200000
	HRL	TAC,AC1
	JRST	STOTAC

DEVUS4:	LDB AC1,PUNIT		;UDP, SCAN ALL DDBS FOR ASSCON, ASSPRG
	MOVE AC2,DKDBML(AC1)	;MODEL DDB FOR THIS UDP
	MOVE AC3,DEVNAM(DDB)
DEVUS5:	HLR AC2,DEVSER(AC2)
	CAME AC3,DEVNAM(AC2)
	JRST DEVUS7		;NO MORE DDBS
	MOVE TAC1,DEVMOD(AC2)
	TRNE TAC1,ASSCON
	TLO AC2,400000
	TRNE TAC1,ASSPRG
	TLO AC2,200000
	LDB AC1,[POINT 6,DEVCHR(AC2),5]
	CAIE AC1,(J)		;EXTRA BITS FOR UDP ONLY,
	JRST DEVUS6		;NAMELY ASSCON AND ASSPRG FOR YOUR OWN JOB
	TRNE TAC1,ASSCON
	TLO AC2,40000
	TRNE TAC1,ASSPRG
	TLO AC2,20000
	JRST DEVUS5

DEVUS6:	TRNE TAC1,ASSCON	;AND SEPARATELY FOR OTHER JOBS
	TLO AC2,10000
	TRNE TAC1,ASSPRG
	TLO AC2,4000
	JRST DEVUS5

DEVUS7:	LDB TAC1,PUNIT		;GET UDP NUMBER
	HLRZ AC1,AC2		;FLAGS INTO AC1
	TRO AC1,2000		;THIS IS PRIVATE OWNERSHIP FLAG
	SKIPGE UDPOWN-1(TAC1)	;SKIP IF PRIVATE
	TRZA AC1,2000		;PUBLIC, TURN OFF PRIVATE FLAG
	ADD AC1,UDPOWN-1(TAC1)	;JOB NUMBER OF OWNER OR 0 FOR PUBLIC
	HRL TAC,AC1
	JRST STOTAC
; JOBRD  UUO TO BLT DATA FROM SOME OTHER JOB'S CORE IMAGE TO YOURS.
; CALLING . . .
;	MOVEI AC,ADR
;	CALL AC,[SIXBIT /JOBRD/]
;	<ERROR - CODE IN ADR+1>
;
;ADR:	<JOB NAME OR NUMBER>
;	<XWD -NWDS,HISADR - OR ERROR CODE,
;		1 FOR NON-EX JOB NUMBER
;		2 FOR AMBIGUOUS JOB NAME
;		3 FOR NON-EX JOB NAME
;		4 FOR ADDRESS OUT OF BOUNDS
;		5 FOR JOB NOT LOGGED IN
;		6 FOR BLOCK TOO LARGE!>
;	<ADDRESS IN YOUR CORE IMAGE WHERE YOU WANT THE DATA>

JOBRD:	HRR	UUO,TAC		; PUT DATA BLOCK ADDRESS IN UUO
	SKIPE	AC1,JBTFS(J)	; DOES HE HAVE ANY FREE STORAGE?
	PUSHJ	P,FSGIVE	; YES, RETURN IT
	SETZM	JBTFS(J)
	XCTR	XR,[HLRO TAC,1(UUO)]	; PICK UP LENGTH OF TRANSFER
	CAMGE	1,[-2000]	; MORE THAN ONE K?
	JRST	[MOVEI	AC1,6	; YES, VERBOTEN
		JRST INTDR4]	; BLOCK TOO LARGE --  RPH 4-14-73
	XCTR	XR,[MOVE TAC,(UUO)]	; PICK UP JOB NUMBER OR NAME
	TDNE	TAC,[-100]	; IS IT A NUMBER?
	JRST	JOBRD1		; NO, GO PARSE IT
	JUMPLE	TAC,INTDR1	; IF NON-EX JOB NUMBER, FLUSH HIM NOW
	CAIL	TAC,JOBN
	JRST	INTDR1
JOBRD2:	MOVE	AC1,JBTSTS(TAC)	; JOB NUMBER OK, SEE IF JOB EXISTS
	TLNN	AC1,JNA
	JRST	[MOVEI	AC1,5
		JRST	INTDR4]	; NO SUCH JOB
	TLNE	AC1,SWP!SHF	;IS OTHER GUY BEING SWUFFLED OR SCHWAPPED?
	JRST	JOBRD3		;YES, THIS IS HARDER
	HLRZ	AC1,JBTADR(TAC)	; NOW DOES IT HAVE ENOUGH CORE?
	XCTR	XR,[HRRZ AC2,1(UUO)]	; PICK UP STARTING ADDRESS
	MOVE	TAC1,AC2
	ADD	TAC1,JBTADR(TAC)	; RELOCATE THE ADDRESS
	XCTR	XR,[HLRO AC3,1(UUO)]	; AND WORD COUNT
	MOVN	AC3,AC3
; JOBRD - PICK UP ADDRESS OF LAST WORD, ADDRESS CHECK IT

	ADDI	AC3,(AC2)		; THIS IS LAST WORD TO BE TRANSFERRED
	SUBI	AC3,1
	CAILE	AC3,(AC1)
	JRST	JOBRD4
	SUBI	AC3,(AC2)		; GET BACK WORD COUNT-1
JOBRD5:	XCTR	XR,[HRRZ AC2,2(UUO)]	; PICK UP ADDRESS IN HIS CORE
	ADD	AC3,AC2			; AND END OF TRANSFER
	HLRZ	AC1,PROG		; PICK UP OUR PROTECTION
	CAIG	AC2,(AC1)
	CAILE	AC3,(AC1)
	JRST	JOBRD6
	ADDI	AC2,(PROG)		; COMPUTE ABSOLUTE ADDRESS OF DESTINATION
	ADDI	AC3,(PROG)		; ABSOLUTE ADDRESS OF LAST WORD.
	HRL	AC2,TAC1		; PUT INTO BLT
	BLT	AC2,(AC3)		; DO THE TRANSFER
	AOS	(P)			; INDICATE SUCCESS RETURN
	SKIPN	AC1,JBTFS(J)		; IS THERE ANY FREE STORAGE THERE?
	POPJ	P,			; NO, LEAVE NOW
	SETZM	JBTFS(J)		; NOT ANY MORE
	JRST	FSGIVE			; YES, RETURN IT

JOBRD6:	SKIPN	AC1,JBTFS(J)		; IF NO FREE STORAGE, GIVE ERROR MESSAGE
	JRST	JOBRD4
	SETZM	JBTFS(J)
	PUSHJ	P,FSGIVE
JOBRD4:	MOVEI	AC1,4
	JRST	INTDR4

JOBRD1:	PUSHJ	P,GJOBN		; GET JOB NUMBER FROM JOB NAME
	JRST	INTDR2
	JRST	INTDR3
	JRST	JOBRD2
; JOBRD - GET FREE STORAGE FOR DATA, PLANT CLOCK REQUEST TO DO TRANSFER

JOBRD3:	XCTR	XR,[HLRO AC3,1(UUO)]	; PICK UP WORD COUNT
	MOVN	AC3,AC3
	ADDI	AC3,1
	PUSHJ	P,UFSGET		; F.S. BLOCK IS MINIMUM OF 6 WORDS
	HRL AC1,TAC			; STORE JOB TO READ IN JBTFS
	MOVEM	AC1,JBTFS(J)		; SAVE FREE STORAGE ADDRESS
	MOVE DAT,J			; ARG IS JOB NUMBER
	HRLI DAT,JOBRCK			; ROUTINE TO CALL
	PUSHJ P,DPYTIM
	XCTR	XR,[MOVE AC2,1(UUO)]
	MOVEM	AC2,(AC1)
JOBRDX:	MOVNI	AC3,IOWQ		; WAIT FOR IT ALL
	MOVEM	AC3,JOBQUE(J)
	PUSHJ	P,WSCHED		; WAIT FOR GUYS TO FILL IT
	SKIPN AC1,JBTFS(J)		; BLOCK STILL THERE?
	JRST JOBRD6			; NO, GIVE ILL ADDR ERROR
	HRRZI	TAC1,1(AC1)		; PICK UP ADDRRESS PLUS ONE
	SKIPGE (AC1)			; DONE YET?
	JRST JOBRDX			; NO, WAIT AGAIN
	SKIPE	TAC,(AC1)		; WAS THERE AN ERROR?
	JRST	JOBRDY			; YES, RETURN CODE
	XCTR	XR,[HLRO AC3,1(UUO)]
	MOVN	AC3,AC3
	SOJA	AC3,JOBRD5		; GO DO BLT TO USER

JOBRDY:	XCTR XW,[MOVEM TAC,1(UUO)]	; STORE ERROR CODE
	SETZM JBTFS(J)
	JRST FSGIVE			; RETURN BLOCK

;FREE STORAGE BLOCK LOCATIONS
;	BEFORE			AFTER
;0	-WC,,MA TO READ		-1=ERROR, 0=SUCCESS
;1	RANDOM			DATA TO END OF BLOCK
;2					.
; JOBRD - WE GET HERE AT CLOCK LEVEL . . .

JOBRCK:	HRRZ J,DAT		;JOB # IS ARG
	SKIPN TEM,JBTFS(J)	; DID FREE STORAGE BLOCK GO AWAY?
	POPJ P,			; YES, DISAPPEAR
	HLRZ TAC,TEM		;GET JOB # WE ARE READING
	MOVE AC1,JBTSTS(TAC)
	TLNN AC1,JNA		; IS JOB STILL THERE?
	JRST JOBRC3		; NO, ERROR
	TLNE AC1,SHF		;IF SHUFFLING
	JRST DPYTIM		;JUST REPLANT CLOCK REQUEST
	TLNE AC1,SWP		;IF SWAPPED,
	JRST JOBRCQ		;BRING HIM IN
	PUSHJ P,JRDBLT		;DO BLT
	JRST JOBRC2		;NOW CONTINUE USER

JOBRCQ:	MOVE J,TAC		;TRANSFER CONTROL TO SWAP IN LIST
	MOVSI TAC,JRDSNB
	JRST SETSIN

;CALL WITH TEM=FS BLOCK, TAC=JOB # WE ARE READING FROM
JRDBLT:	HRRZ AC2,(TEM)		; PICK UP STARTING ADDRESS
	HLRO AC3,(TEM)		; AND WORD COUNT
	MOVNS AC3
	HLRZ AC1,JBTADR(TAC)
	ADDI AC3,(AC2)
	SUBI AC3,1
	CAILE AC3,(AC1)
	JRST JRDBL1
	SUBI AC3,-1(AC2)	; BACK UP TO JUST WORD COUNT - 1
	ADD AC2,JBTADR(TAC)	; RELOCATE
	HRLI AC2,1(TEM)		; PREPARE TO MOVE DATA
	MOVSS AC2
	ADD AC3,TEM		; ADD IN FS ADDRESS
	BLT AC2,(AC3)
	SETZM (TEM)		; CLEAR THE ERROR FLAG
	POPJ P,

JRDBL1:	MOVEI TAC,4
	MOVEM TAC,(TEM)		; FLAG ERROR
	POPJ P,

;ENTER HERE WITH TAC=JOB JUST SWAPPED IN, J=JOB # WHO WANTS TO READ HIM
;CALLED FROM FININ
↑JRDWIN:PUSH P,TEM		;FIRST SAVE SOME ACS
	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	HRRZ TEM,JBTFS(J)
	PUSHJ P,JRDBLT		;DO BLT
	PUSHJ P,JOBRC2		;RESTART USER
JRDLEV:	POP P,AC3		;NOW RESTORE ACS
	POP P,AC2
	POP P,AC1
	POP P,TEM
	POPJ P,

;CALLED FROM FININ
↑JRDLOS:PUSH P,TEM		;FIRST SAVE SOME ACS
	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	HRRZ TEM,JBTFS(J)	; J IS JOB # OF JOB DOING JOBRD
	PUSHJ P,JOBRC1		; GIVE ADDR ERROR RETURN ON SWAP ERROR
	JRST JRDLEV

;DONE, RESTART USER
JOBRC3:	SKIPA TAC,[5]		;NO JOB THERE
JOBRC1:	MOVEI TAC,4		;ADDR ERROR
	MOVEM TAC,(TEM)
JOBRC2:	MOVM AC3,JOBQUE(J)
	CAIE AC3,IOWQ		;IS HE WERE WE LEFT HIM?
	JRST [	MOVE AC1,JBTFS(J);NO, GIVE BACK FS AND GO AWAY
		SETZM JBTFS(J)
		JRST FSGIVE]
	MOVNI AC3,RUNQ
	MOVEM AC3,JOBQUE(J)
	JRST REQUE
;TMPCOR UUO - BEHAVES AS DESCRIBED IN DEC MANUAL

TMPMAX←←400	;MAX TOTAL SIZE OF ONE JOB'S TMPCOR FILES

;FORMAT OF TMPCOR BLOCK
TMPLNK←←0	;DOUBLE LINK WORD
TMPNAM←←1	;NAME,,SIZE
TMPPPN←←2	;PPN (ALIAS) OF TMP FILE
TMPDAT←←3	;BEGINNING OF DATA

TMPCRD:	XCTR XR,[HRRZ DSER,(TAC)]	;TMPCOR TO OTHER JOB:
	JUMPN DSER,.+2
	MOVEI DSER,(J)
	MOVEI TAC1,0
	CAMLE DSER,JOBNM1
	JRST TMPCR1
	MOVE AC1,JBTSTS(DSER)
	TLNN AC1,JNA
	JRST TMPCR1			;NO SUCH JOB
	XCTR XR,[SKIPN UUO,2(TAC)]	;GET JOB, ALIAS FROM USER
	MOVE UUO,PRJPRG(DSER)		;DEFAULT IS HIS PPN
	JRST TMPCO1

TMPCOR:	MOVEI DSER,(J)			;TMPCOR TO YOURSELF:
	SKIPN UUO,DSKPPN(DSER)		;DSER IS YOUR JOB
	MOVE UUO,PRJPRG(DSER)		;UUO IS YOUR ALIAS
TMPCO1:	HLRZ TAC1,TAC
	CAIL TAC1,NUMTMP
	JRST UUOERR
	CAIE DSER,(J)
	SKIPGE TMPDSP(TAC1)		;ONLY SOME ALLOWED FOR TMPCRD
	JRST .+2
	JRST UUOERR
	PUSHJ P,@TMPDSP(TAC1)
	JRST .+2
	AOS (P)
TMPCR1:	XCTR XW,[MOVEM TAC1,(UCHN)]	;STORE PARAM FROM TAC1 (OFTEN SIZE)
	POPJ P,

TMPDSP:	SETZ TMPSZ1			;4.9 IMPLIES ALLOWED FOR OTHER JOBS
	SETZ TMPRED
	TMPRDD
	TMPWRT
	SETZ TMPDIR
	TMPCLR
NUMTMP←←.-TMPDSP

;CALCULATE AMT OF ROOM LEFT (TMPMAX-CURRENT TOTAL)
TMPSZ1:	AOSA (P)
TMPWRX:	PUSHJ P,FSGIVE		;HERE IF XFER ABORTS AFTER GETTING FS
TMPSIZ:	MOVEI TAC1,TMPMAX
	JSP DAT,TM1SCN		;COUNT ALL FILES WITHOUT REGARD TO ALIAS
	 SUB TAC1,TMPNAM(AC1)
	 TLZA TAC1,-1
	POPJ P,

;SCAN A JOB'S TMPCOR FILES AND EXECUTE 2 INSTRS FOLLOWING CALL
TMPSCN:	HRRZ AC3,JBTTCR(DSER)
TMPSC1:	SKIPN AC1,AC3
	JRST 2(DAT)
	CAME UUO,TMPPPN(AC1)	;IGNORE ALL TMP FILES WITH WRONG ALIAS
	JRST TMPSC2
	HRRZ AC3,TMPLNK(AC1)	;SAVE LINK NOW IN CASE DELETING
	XCT (DAT)
	XCT 1(DAT)		;THIS ONE USUALLY SKIPS
	JRST 3(DAT)		;BUT SKIP RETURN NOW IF NOT
	JRST TMPSC1
TMPSC2:	HRRZ AC3,TMPLNK(AC1)
	JRST TMPSC1

;SCAN A JOB'S TMPCOR FILES AND EXECUTE 2 INSTRS FOLLOWING CALL--IGNORE ALIAS
TM1SCN:	HRRZ AC3,JBTTCR(DSER)
TM1SC1:	SKIPN AC1,AC3
	JRST 2(DAT)
	HRRZ AC3,TMPLNK(AC1)	;SAVE LINK NOW IN CASE DELETING
	XCT (DAT)
	XCT 1(DAT)		;THIS ONE USUALLY SKIPS
	JRST 3(DAT)		;BUT SKIP RETURN NOW IF NOT
	JRST TM1SC1

;FIND REQUESTED TMPCOR FILE
TMPFND:	XCTR XR,[HLLZ TAC1,(TAC)]
	JSP DAT,TMPSCN
	 HLLZ AC2,TMPNAM(AC1)
	 CAMN AC2,TAC1
	POPJ P,
	JRST CPOPJ1
;CHECK & RELOCATE TMPCOR WCMA
TMPSET:	MOVEI TAC1,-1		;UPPER LIM ON WC
TMPST1:	XCTR XR,[HLRE AC2,1(TAC)]
	JUMPGE AC2,CPOPJ
	MOVN AC2,AC2		;+ WC
	CAILE TAC1,(AC2)	;USE MIN OF FILE & USER WC'S
	SKIPA TAC1,AC2
	MOVEI AC2,(TAC1)
	XCTR XR,[HRRZ AC3,1(TAC)]	;START ADR-1
	PUSH P,AC1
	ADDI TAC1,(AC3)		;CALCULATE END ADR
	PUSHJ P,RELOCA		;CHECK IT
	JRST UUOERR
	MOVEI TAC1,1(AC3)	;START ADR
	PUSHJ P,RELOCB		;CHECK THAT TOO
	JRST UUOERR
	POP P,AC1
	JRST CPOPJ1

;READ TMPCOR FILE
TMPRED:	PUSHJ P,TMPFND		;LOOK FOR FILE
	JRST TMPSIZ		;NOT THERE - RETURN FREE SIZE
	HRRZ TAC1,TMPNAM(AC1)	;LIMIT XFER TO SIZE
	PUSHJ P,TMPST1
	JRST TMPRDX
	JUMPL TAC1,UUOERR	;CAN'T CLOBBER WRITE PROTECTED CORE
	HRLI TAC1,TMPDAT(AC1)
	ADDI AC2,(TAC1)
	BLT TAC1,-1(AC2)
TMPRDX:	HRRZ TAC1,TMPNAM(AC1)	;RETURN ACTUAL FILE SIZE
	JRST CPOPJ1

;READ & DELETE TMPCOR FILE
TMPRDD:	PUSHJ P,TMPRED		;TRY TO READ FILE
	POPJ P,
	AOSA (P)		;SET SKIP & SKIP INTO TMPDEL

;READ & CLEAR TMPCOR DIRECTORY
TMPCLR:	JSP TEM,TMPDR2		;SET TEM TO CALL TMPDEL FOR EACH ITEM

;DELETE TMPCOR FILE SPECIFIED BY (AC1)
TMPDEL:	MOVE AC2,TMPLNK(AC1)
	TRNE AC2,-1
	HLLM AC2,(AC2)
	MOVS AC2,AC2
	HLRM AC2,(AC2)
	JRST FSGIVE
;WRITE TMPCOR FILE
TMPWRT:	PUSHJ P,TMPFND	;SEE IF IT ALREADY EXISTS
	JRST .+2	;NO
	PUSHJ P,TMPDEL	;YES - DELETE IT
	PUSHJ P,TMPSET
	JRST TMPSIZ	;NO XFER
	MOVSI DAT,(TAC1)	;SAVE USER ADR
	PUSHJ P,TMPSIZ
	CAILE AC2,(TAC1)
	POPJ P,			;NOT ENOUGH ROOM LEFT
	MOVEI AC3,TMPDAT(AC2)
	PUSHJ P,UFSGET		;GET A BLOCK
	PUSHJ P,TMPSET		;NOW DO THIS AGAIN (MAY HAVE MOVED)
	JRST TMPWRX
	MOVSI DAT,(TAC1)	;LH OF BLT PNTR
	MOVSI TAC1,JBTTCR(DSER)
	HRR TAC1,JBTTCR(DSER)	;& LINK IT IN
	MOVEM TAC1,TMPLNK(AC1)
	HRRM AC1,JBTTCR(DSER)
	HRLM AC1,(TAC1)
	XCTR XR,[HLL AC2,(TAC)]	;GET NAME
	MOVEM AC2,TMPNAM(AC1)	;STORE NAME & SIZE
	MOVEM UUO,TMPPPN(AC1)	;AND ALIAS WITH TMP FILE
	HRRI DAT,TMPDAT(AC1)	;MAKE BLT PNTR
	ADDI AC2,(DAT)		;CALC END ADR
	BLT DAT,-1(AC2)
	JRST TMPSZ1		;SKIP RETURN WITH NEW FREE CNT

;READ TMPCOR DIRECTORY
TMPDIR:	MOVEI TEM,CPOPJ		;NO DELETING
TMPDR2:	PUSHJ P,TMPSET
	JFCL
	JUMPL TAC1,UUOERR	;ERR IF R/O CORE
	MOVSI AC2,1(AC2)	;BUGGER BY 1 FOR PRE-AOBJN
	MOVN AC2,AC2
	HRRI AC2,(TAC1)		;MAKE AOBJN PNTR
	MOVEI TAC1,		;INIT CNT
	JSP DAT,TMPSCN
	 PUSHJ P,TMPDR1
	 CAIA
	JRST CPOPJ1

TMPDR1:	MOVE TAC,TMPNAM(AC1)	;GET NAME & SIZE
	AOBJP AC2,.+2
	MOVEM TAC,-1(AC2)	;STORE IF ROOM
	AOJA TAC1,(TEM)		;COUNT ITEM & DO EXIT THING

;DELETE ALL TMPCOR FILES (REGARDLESS OF ALIAS PPNS)
TMPKIL:	MOVEI DSER,(J)		;THIS ROUTINE DOES OWN JOB!!
	JSP DAT,TM1SCN		;FIND ALL TMP FILES, IGNORING ALIAS
	 PUSHJ P,TMPDEL		;DELETE EACH ONE
	 CAIA
	POPJ P,
SUBTTL	UUOCON	IO SECTION
;FOR PURPOSES OF COMMENTING THIS SUBROUTINE THE
;TERM 'BUFFER HEADER' SHALL REFER TO THE 3 WORD HEADER
;WHICH IS USED BY THE USER PROGRAM AND THIS EXEC FOR
;REFERING TO THE RING BUFFERS.

;THE CONTENTS OF THE 3 WORD HEADER (AS SET BY THE MONITOR
;		ON EACH INPUT AND OUTPUT UUO).
;		BIT 18-35=ADDRESS OF SECOND WORD OF THE
;		CURRENT BUFFER IN RING WHICH USER IS REFERENCING
;	WORD 2:	BYTE POINTER TO CURRENT ITEM.
;	WORD 3:	POSITIVE ITEM COUNT (NO. OF ITEMS LEFT ON
;		INPUT, NO. OF FREE ITEMS TO GO ON OUTPUT).

;EACH BUFFER IN THE RING HAS FOLLOWING FORMAT (AS THE USER SEES IT)

;	WORD 1:	RESERVED FOR BLOCK NUMBER FOR FIXED ADDRESS DEVICES
;	WORD 2:	BIT 0=USE BIT FOR THIS BUFFER
;		BIT 1-17=NO. OF WORDS WHICH FOLLOW (LENGTH OF BUFFER)/
;		BIT 18-35=ADDRESS OF SECOND WORD OF NEXT BUFFER IN RING
;	WORD 3:	LH=LINK TO NEXT BLOCK (SET BY MONITOR FOR DECTAPE)
;		RH=NO. OF WORDS OF DATA WHICH FOLLOW (USUALLY
;		SET BY EXEC EXCEPT IF THE USER HAS SPECIFIED
;		THAT HE WANTS TO COMPUTE WORD COUNT
;		HIMSELF INSTEAD OF HAVING THE MONITOR DO IT
;		USING THE BYTE POINTER IN THE 3 WORD HEADER).
;IOPUSH, IOPOP, IOPDL

;IOPUSH CHN,ID
;	PUSH DEVICE ON CHANNEL "CHN" ON STACK WITH ID "ID"
IOPUSH:	SKIPE AC1,JBTIOP(J)
	JRST IOPSH1
	MOVEI AC3,IOPDLN
	PUSHJ P,UFSGET
	MOVEM AC1,JBTIOP(J)
IOPSH1:	HLRZ AC3,AC1
	CAIN AC3,-IOPDLN
	POPJ P,			;NO SPACE ERROR
	SUBM AC1,AC3
	CAMLE UCHN,USRHCU
	TDZA DDB,DDB
	MOVE DDB,USRJDA(UCHN)
	MOVEM DDB,(AC3)
	SETZM USRJDA(UCHN)
	SKIPN TAC,USRHCU
	JRST IOPSH2		;USRHCU STAYS AT 0 EVEN IF NO CHANNELS OPEN
IOPSH3:	SKIPN USRJDA(TAC)
	SOJG TAC,IOPSH3
	MOVEM TAC,USRHCU
IOPSH2:	MOVEM UCHN,1(AC3)
	HRLM UUO,1(AC3)		;SAVE ID ON STACK WITH CHANNEL NUMBER
	SUB AC1,[2,,0]
IOPOP3:	MOVEM AC1,JBTIOP(J)
	JRST CPOPJ1

;IOPOP CHN,ID
;	RELEASE DEVICE ON CHANNEL "CHN", POP DEVICE WITH ID "ID" INTO CHANNEL "CHN"
IOPOP:	PUSHJ P,FIOPID		;FIND ID WHICH USER SPECIFIED
	POPJ P,			;NO STACK, OR NOT FOUND
IOPOP0:	SKIPE DDB,USRJDA(UCHN)	;IS A DEVICE ALREADY ASSIGNED TO THIS CHAN?
	CAMLE UCHN,USRHCU(PID)	;YES, IS THIS CHAN. LE HIGHEST CHAN. FOR THIS USER?
	JRST IOPOP2		;NO, NO PREVIOUS DEVICE TO RELEASE
	HRRZ DSER,DEVSER(DDB)
	PUSH P,AC3		;SAVE POINTER TO ENTRY WE WILL POP
	PUSHJ P,RELEA0		;RELEASE PREVIOUS DEVICE ON THIS CHAN.
	POP P,AC3
IOPOP2:	MOVE DDB,(AC3)		;THIS POINTS TO STACK ENTRY
	MOVEM DDB,USRJDA(UCHN)	;NEW DEV ON THIS CHANNEL
	JUMPE DDB,IOPOP4	;DON'T READJUST USRHCU IF POPPING A NULL CHANNEL
IOPOP1:	CAMG UCHN,USRHCU
	JRST IOPOP4
	AOS TAC,USRHCU
	SETZM USRJDA(TAC)
	JRST IOPOP1

IOPOP4:	MOVE AC1,JBTIOP(J)
	ADD AC1,[2,,0]
	JUMPG AC1,IOPOP5
	HLRE AC2,AC1
	SUBM AC1,AC2
	HRRZ AC3,AC3
	CAIN AC3,(AC2)		;ARE WE THE END ENTRY?
	JRST IOPOP3		;YES, SKIP BLT
	HRLI AC3,2(AC3)		;BLT DOWN ONE ENTRY
	BLT AC3,-1(AC2)		;LAST WORD OF LAST ENTRY
	JRST IOPOP3

IOPOP5:	SETZM JBTIOP(J)
	AOS (P)
	JRST FSGIVE

IOPDL:	CAIL UCHN,IOPDLL	;LEGAL IOPDL FUNTION?
	JRST UUOERR		;NO
	JRST @IOPDLD(UCHN)	;DISPATCH

;IOPDL 0,
;	RETURN ALL STACKED DEVICES TO WHERE THEY CAME FROM
IOPDL0:	SKIPL AC3,JBTIOP(J)
	POPJ P,
	HLRE AC1,AC3
	SUB AC3,AC1
	HRRZ UCHN,-1(AC3)	;GET JUST CHANNEL NUMBER
	TRZ UUO,-1		;MAKE SURE WE GET TOP OF STACK
	PUSHJ P,IOPOP
	POPJ P,
	JRST IOPDL

;IOPDL 1,
;	RELEASE ALL STACKED DEVICES
IOPDL1:	SKIPL JBTIOP(J)
	POPJ P,			;DONE
	TRZ UUO,-1		;DO IT TO TOP OF STACK
	PUSHJ P,IOPDL2		;RELEASE IT
	POPJ P,			;FOO
	JRST IOPDL1		;LOOP TILL ALL GONE

;IOPDL 2,ID
;	RELEASE STACKED DEVICE WITH ID "ID".
IOPDL2:	PUSHJ P,FIOPID
	POPJ P,			;NOT FOUND
	MOVE DDB,(AC3)		;GET DEVICE HE WANTS RELEASED
	EXCH DDB,USRJDA		;EXCHANGE WITH CHAN 0
	MOVEM DDB,(AC3)		;WHICH WE SAVE ON STACK
	SETZ UCHN,		;NOW RELEASE CHANNEL 0 AND POP OLD ONE BACK THERE
	JRST IOPOP0

IOPDLD:	IOPDL0
	IOPDL1
	IOPDL2
IOPDLL←←.-IOPDLD

FIOPID:	SKIPL AC3,JBTIOP(J)	;ANY STACK AT ALL?
	POPJ P,			;NO
	HLRE AC1,AC3
	SUBI AC3,2(AC1)		;POINT TO TOP OF STACK
	MOVNI AC1,2(AC1)
	HRL AC3,AC1		;PUT COUNT IN LEFT HALF
	TRNN UUO,-1		;ANY ID?
	JRST CPOPJ1		;NO, 0 IS ALWAYS TOP OF STACK
IOPID1:	HLRZ AC1,1(AC3)		;GET ID
	CAIN AC1,(UUO)
	JRST CPOPJ1		;FOUND IT
	SUB AC3,[2,,2]
	JUMPG AC3,IOPID1	;MORE TO GO?
	POPJ P,			;NO, NOT FOUND
; CLOSE UUO - CALLING SEQUENCE
;	CLOSE D,
;	EXIT		ALWAYS RETURNS HERE
; THIS ROUTINES PROCESSES THE CLOSE UUO AND DETERMINES WHETHER THE
;OUTPUT ROUTINE SHOULD BE CALLED IF OUTPUT WERE ACTIVE, CLEARS
;THE INPUT BUFFER AREA IF INPUT WERE ACTIVE, AND CLEARS THE 
;ITEM COUNTS OF BOTH INPUT AND OUTPUT HEADERS SERVING TO BOTH
;TERMINATE THE USE OF THE DEVICE AND SET THE I/O ROUTINES TO
;ACCEPT ANOTHER INPUT OR OUTPUT COMMAND IN A CLEAR STATE.
;IN THE CASE OF OUTPUT DEVICES, THE CLOSE ROUTINE OF THE DEVICE HANDL-
;ING ROUTINE IS CALLED IN CASE ANY SPECIAL HANDLING IS REQUIRED.
; CLOSE CODE - WAIT FOR IO TO FINISH, FLUSH BUFFERS

↑CLOSE1:
	PUSHJ PDP,WAIT1		; WAIT UNTIL DEVICE IS INACTIVE
	ANDCMI UUO,777774	;ZERO ALL BUT CLOSE-INHIBIT BITS IN RH OF UUO
	TRNN UUO,CLSIN		;SUPPRESS INPUT CLOSE?
	TLOE DEVDAT,ICLOSB	;NO. INPUT ALREADY BEEN CLOSED?
	JRST UCLS2		;YES
	LDB TAC,PIOMOD		;NO
	CAIN TAC,2
	POPJ PDP,		;SAVE MODE.
	CAIGE TAC,SD		;DUMP MODE?
	JRST UCLSBI		;NO. CLOSE BUFFERED INPUT.
UCLS5:	PUSHJ PDP,DCLI(DSER)	;YES. DISPATCH TO DEVICE DEP. ROUTINE
	JRST UCLS2		;MUST NOT DESTROY UUO,DEVDAT,DSER,UCHN
UCLSBI:	MOVE TAC,DEVMOD(DEVDAT)
	TLNE DEVDAT,INBFB+INPB	;WAS AN INPUT BUFFER SETUP?
	JRST UCLS4		;
	TLNE TAC,DVDSK!DVIMP	;NO.  CLOSING DISK OR IMP?
	JRST UCLS5		;YES. DO CLOSE
	JRST UCLS2		;NO.
UCLS4:	TLNE TAC,DVLNG
	PUSHJ PDP,DCLI(DSER)	;YES, CLOSE INPUT
	HRRZ TAC1,DEVBUF(DEVDAT)
	XCTR	XR,[HRRZ DAT,(TAC1)]	;PICK UP FIRST WORD OF BUFFER HEADER
	LDB AC3,PDVBLN		; PICK UP BUFFER LENGTH
	ADDI AC3,(DAT)		; ADD IN BUFFER ADDRESS
	XCTR	XRW,[MOVES (AC3)]	; ADDRESS CHECK BUFFER ADDRESS
	XCTR	XR,[HRR TAC1,(TAC1)]	; REMEMBER CURRENT BUFFER IN TAC1
	HRLZI TAC,IOUSE		;USED BOTH FOR HEADER AND EACH BUFFER
	JUMPE DAT,UCLS1		;HAS A RING BEEN SETUP?(NO IF 0)
	SETZM AC1
	LDB TEM,PDVBLN		; FIGURE OUT THE MAXIMUM NUMBER OF BUFFERS
	HLRZ AC3,PROG
	IDIVI AC3,(TEM)
	ADDI AC3,2		; AND THIS IS CERTAINLY A GOOD UPPER BOUND!
UCLS0:	XCTR	XR,[HRR DAT,(DAT)]	; ADVANCE CURRENT INPUT BUFFER ADDRESS
	CAIN AC1,(DAT)		;IS THIS THE SAME BUFFER AS LAST ONE?
	JRST UCLS1		;YES. BAD RING. LOOPING ON ITSELF.
	MOVEI AC1,(DAT)		;IS ADDRESS OK?
	XCTR	XRW,[ANDCAM TAC,(DAT)]; CLEAR USE BIT
	SOJL AC3,UCLS1
	CAME TAC1,DAT		;DONE?
	JRST UCLS0
; CLOSE CODE

UCLS1:	HRRZ DAT,DEVBUF(DEVDAT)
	XCTR XRW,[IORM TAC,(DAT)]	; FLAG AS VIRGIN BUFFER IN HEADER
	XCTR XW,[SETZM 2(DAT)]		; CLEAR INPUT ITEM COUNT
	MOVE IOS,[XWD IOEND,IODEND]
	ANDCAB IOS,DEVIOS(DEVDAT)
UCLS2:	TRNN UUO,CLSOUT		;SUPPRESS OUTPUT CLOSE?
	TLOE DEVDAT,OCLOSB	;NO. OUTPUT ALREADY CLOSED?
	JRST UCLS3		;YES
	LDB TAC,PIOMOD		;NO.
	CAIN TAC,2		;SAVE MODE?
	JRST UCLS3		;YES.
	CAIGE TAC,SD		;DUMP MODE?
	JRST UCLSBO		;NO. CLOSE BUFFERED OUTPUT
UCLS7:	PUSHJ PDP,DCL(DSER)	;YES. DISPATCH TO DEVICE DEP. ROUTINE
	JRST UCLS3
UCLSBO:	TLNN DEVDAT,OUTBFB+OUTPB	;WAS AN OUTPUT BUFFER SET UP?
	JRST UCLS6		;NO
	HLR DAT,DEVBUF(DEVDAT)	; RESTORE DAT NOW.
	XCTR XR,[SKIPG (DAT)]
	JRST UCLS6		; DO NOT CLOSE UNLESS DISK OR IMP
	HLRZ AC1,PROG		; PICK UP LENGTH OF LOWER
	LDB AC2,PSEGN
	HLRZ AC2,JBTADR(AC2)	; AND ADD IN LENGTH OF UPPER
	ADDI AC1,2(AC2)
	LDB AC2,PDVBLN
	ADDI AC2,2		; PICK UP SIZE OF BUFFER
	IDIVI AC1,(AC2)		; GET MAXIMUM NUMBER OF BUFFERS HE COULD HAVE
	PUSH P,AC1		; AND SAVE IT
UCLS2A:	MOVE DSER,DEVSER(DEVDAT)
	MOVE AC1,DEVOAD(DEVDAT)
	SOSL (P)		; DECREMENT MAXIMUM NUMBER OF BUFFERS WE WILL LOOK AT
	XCTR	XR,[SKIPL (AC1)]	; NO. HAS SERVICE ROUTINE WRITTEN
				;ITS NEXT BUFFER YET?
	JRST UCLS2B		;YES
				;NO. START OUTPUT DEVICE.
	TRZ	IOS,760000
	PUSH PDP,UUO		; SAVE UUO
	PUSHJ PDP,DOU(DSER)
	POP PDP,UUO		; RESTORE UUO
	PUSHJ	PDP,WAIT1	;WAIT TILL MOST BUFFERS FILLED
	TRNN	IOS,760000	;ERROR?
	JRST UCLS2A		;RETURN WHEN ALL EMPTIED
; CLOSE - CALL DEVICE DEPENDENT ROUTINE
				;OF SHUFFLING REQUIRED STOPS DEVICE

UCLS2B:	SUB P,[XWD 1,1]		; NORMALIZE STACK, THROW AWAY MAXIMUM BUFFER COUNT
	MOVE DSER,DEVSER(DEVDAT)
	PUSHJ PDP,DCL(DSER)	;CLOSE OUTPUT BUFFER
	HLRZ DAT,DEVBUF(DEVDAT)
	HRLZI TAC,IOUSE
	XCTR XRW,[IORM TAC,(DAT)]
	XCTR XW,[SETZM 2(DAT)]
	PUSHJ PDP,WAIT1
	TLO DEVDAT,OCLOSB	;SET OCLOSB AFTER OUTPUT IS COMPLETE
UCLS3:	HLLM DEVDAT,USRJDA(UCHN)
	POPJ PDP,		;EXIT THIS UUO

UCLS6:	MOVSI TAC,DVDSK!DVIMP	;ALWAYS CALL DEVICE ROUTINE FOR DISK AND IMP
	TDNE TAC,DEVMOD(DEVDAT)
	JRST UCLS7
	JRST UCLS3
; INBUF - CALLING SEQUENCE
;	INBUF D,N
;	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED
;CALLING SEQUENCE
;	OUTBUF D,N
;	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED
; SETS UP AN N BUFFER RING FOLLOWING THE USER'S PROGRAM FOR DEVICE
; D AND INITIALIZES THE JOB BUFFER AREA HEADER:
;	JBFADR0:=1,	JBFADR 1-17:=0
;	JBFADR 18-35:=ADDRESS OF FIRST BUFFER IN RING
;INPUT SETS DEVIAD:=ADDRESS OF FIRST BUFFER IN RING
;OUTPUT SET DEVOAD:=ADDRESS OF FIRST BUFFER IN RING
;BUFPNT IS RESTORED.
; SET UP BUFFERS OF USER-SPECIFIED LENGTH

UOUTBF:
	TLNN DEVDAT,OBUFB	; SEE IF THERE EXISTS AN OUTPUT BUFFER HEADER
	JRST ILLOBF		; NO HEADER, GIVE ERROR MESSAGE
	TLO DEVDAT,OUTBFB	; FLAG OUTBUF UUO DONE
	PUSH PDP,BUFPNT		;SAVE BUFPNT ON STACK
	PUSHJ PDP,BUFCLC	;SET UP BUFFER RING
UOBF2:	HLR TAC,DEVBUF(DEVDAT)	;TAC:=OUTPUT BUFFER AREA HEADER ADDRESS
	HRRM BUFPNT,DEVOAD(DEVDAT)	;DEVOAD:=ADDRESS OF FIRST BUFFER
				;IN RING
UOBF1:	XCTR XW,[MOVEM BUFPNT,(TAC)]
				;JBFADR:=IOUSE,ADDRESS OF FIRST BUFFER
				;IN RING
	LDB TAC,PUUOAC
	MOVEM DEVDAT,USRJDA(TAC)
	POP PDP,BUFPNT		;RESTORE BUFPNT FROM STACK
	POPJ PDP,		;EXIT THIS UUO

UINBF:
	TLNN DEVDAT,IBUFB	; IS THERE AN INPUT BUFFER HEADER?
	JRST ILLIBF		; NO, ERROR
	TLO DEVDAT,INBFB	; FLAG INBUF UUO DONE
	PUSH PDP,BUFPNT		;SAVE BUFPNT ON STACK
	PUSHJ PDP,BUFCLC	;SET UP BUFFER RING
UINBF1:	HRRM BUFPNT,DEVIAD(DEVDAT)	;DEVIAD:=ADDRESS OF FIRST BUFFER
				;IN RING
	HRR TAC,DEVBUF(DEVDAT)	;TAC:=INPUT BUFFER AREA HEADER ADDRESS
	JRST UOBF1
; UINBF - CALLING SEQUENCE . . .
;	UINBF D,ADR
; WHERE D IS CHANNEL NUMBER AND ADR IS ADDRESS OF TWO WORD BLOCK
; THE FIRST WORD OF WHICH IS THE NUMBER OF BUFFERS YOU WANT
; THE SECOND WORD IS THE LENGTH OF EACH BUFFER
; SAME FOR UOUTBF.

MINBF:	PUSHJ PDP,CHNSET	; GIVE ERROR IF IO TO UNASSIGNED CHANNEL
	   JFCL
	   JRST CHNERR
	TLNN DEVDAT,IBUFB	; IS THERE A BUFFER HEADER ADDRESS?
	JRST ILLIBF		; NO, GO COMPLAIN
	TLO DEVDAT,INBFB
	PUSH PDP,BUFPNT
	PUSHJ PDP,MBFSET	; DO ALL THE DIRTY
	JRST UINBF1

CHNERR:	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ/IO TO UNASSIGNED CHANNEL AFTER UUO LEVEL CHECK.
CALLED FROM MINFB OR MOUTBF. J=/]
	DISARG(DCP,<-20+J(P)>)
	[ASCIZ/  UUO=/]
	DISARG(OCT,<-21+UUO(P)>)
	[ASCIZ/
/]
	-1
	POPACS
	JSP DAT,UERROR

MOUTBF:	PUSHJ PDP,CHNSET
	   JFCL
	   JRST CHNERR
	TLNN DEVDAT,OBUFB
	JRST ILLOBF
	TLO DEVDAT,OUTBFB
	PUSH PDP,BUFPNT
	PUSHJ PDP,MBFSET
	JRST UOBF2

MBFSET:	MOVE AC1,UUO
	XCTR	XR,[HRR UUO,(AC1)]		;MAKE UUO LOOK LIKE NORMAL INBUF
	XCTR	XR,[MOVM TAC,1(AC1)]	;AND PICK UP BUFFER LENGTH
	JRST	BUFCLM			;NOW CLEAR OUT THAT MANY BUFFERS THAT BIG
;;ERROR MESSAGES FOR INBUF, OUTBUF, UINBF, AND UOUTBF UUOS

ILLOBF:	JSP TAC,ERRPTU		; PRINT A BIT, SET UP TTY DEVDAT
	ASCIZ /OUTPUT /
	PUSHJ PDP,ERNAM		; PRINT "DEVICE XXX"
	JSP TAC,UUOMES		; PRINT MESSAGE AND STOP JOB
	ASCIZ / HAS NO OUTPUT BUFFER HEADER, UUO/

ILLIBF:	JSP TAC,ERRPTU	; SET UP FOR ERROR PRINTOUT
	ASCIZ /INPUT /
	PUSHJ PDP,ERNAM		; PRINT "DEVICE XXX"
	JSP TAC,UUOMES
	ASCIZ / HAS NO INPUT BUFFER HEADER, UUO/
;OPEN UUO - PERFORMS SAME OPERATION AS INIT
;MAY BE USED EASILY BY REENTRANT PROGRAMS
;CALLING SEQUENCE FROM USER AREA
;	OPEN D,ADR
;	ERROR RETURN
;	DEVICE INITED

;LH(ADR)=0,RH(ADR)=DATA MODE THIS INIT
;LH(ADR+1)=OUTPUT BUFFER HEADER ADDRESS
;RH(ADR+1)=INPUT BUFFER HEADER ADDRESS
;C(ADR+2,...,ADR+5)=SAME AS LOOKUP OR ENTER


↑UOPEN:	XCTR	XR,[SKIP 2(UUO)]	; ADDRESS CHECK GOODIE TABLE
	MOVEI	DAT,1(UUO)	;SETUP REL ADR OF ARGUMENTS
	XCTR	XR,[HRR UUO,(UUO)]	;SET UP RH WITH DATA MODE TO LOOK LIKE INIT
	JRST	UINIT0
; INIT - CALLING SEQUENCE
;	INIT D,MODUS	D=JOB DEVICE CHANNEL
;			MODUS=IORDEL,IOCON,IOWC,MODE.
;	SIXBIT/NAME/	DEVICE NAME
;	XWD OBUF,IBUF	BUFFER AREA HEADER ADDRESSES
;	EXIT1		DEVICE NOT AVAILABLE
;	EXIT2		DEVICE PROPERLY ASSIGNED
;THE LEFT HALF OF NAME CONTAINS THE THREE LETTER DEVICE MNEMONIC,
;   THE RIGHT HALF IS EITHER ZERO (SYSTEM WILL ASSIGN AN ARBITRARY
;   UNIT) OR NON-ZERO TO REQUEST A SPECIFIC UNIT (LEFT JUSTIFIED).
;IF THE SELECTED DEVICE IS NOT AVAILABLE, CONTROL RETURNS TO EXIT1.
;OTHERWISE, THE DEVICE IS ASSIGNED TO THE USER AND ATTACHED TO HIS
;CHANNEL D.  THE DEVICE IS INITIALIZED IN THE FOLLOWING MANNER AFTER
;IOACT IS ZERO:
;	IOBEG:=1
;	DATA MODE:=BITS 32-35 OF AC UUO
;	IOCON:=BIT 31 OF AC UUO
;	IOWC:=BIT 30 OF AC UUO
;	IORDEL:=BIT 29 OF AC UUO
;	IOACT:=IODEND:=IOBKTL:=IODTER:=IODERR:=IOIMPM:=0
;	JBFADR:=JBFCTR:=0 FOR THE SPECIFIED BUFFERS.
;	DEVBUF:=OBUF,IBUF
; INIT CODE - FIRST FIND DEVICE AND TRY TO ASSIGN IT

↑UINIT:	MOVE DAT,UUOPC(ITEM)	;SETUP DAT WITH REL ADR OF ARGUMENTS TO INIT
	PUSHJ P,UINIT0		;DO THE INIT
	JRST .+2		;NOW SET UP KLUDGEY MULTIPLE SKIP RETURN
	AOS UUOPC(ITEM)		;(ONLY AFTER ALL THRU WAITING, ETC.)
	AOS UUOPC(ITEM)
	JRST CPOPJ1		;RETURN WITH ONE MORE SKIP

UINIT0:	PUSH PDP,DAT		; NOW SAVE POINTER TO ARGUEMENT LIST
UINITG:	SKIPE DEVDAT,USRJDA(UCHN)	;IS A DEVICE ALREADY ASSIGNED TO THIS CHAN>?
	CAMLE UCHN,USRHCU(PID)	;YES, IS THIS CHAN. LESS OR EQUAL TO HIGHEST
				;CHAN. FOR THIS USER?
	JRST UINITA		;NO, NO PREVIOUS DEVICE TO RELEASE
	PUSH PDP,UUO		;SAVE UUO
	PUSH PDP,DAT		;SAVE POINTER TO ARGS.
	PUSHJ PDP,RELEA0	;RELEASE PREVIOUS DEVICE ON THIS CHAN.
	POP PDP,DAT		;RESTORE REL. ADR. OF ARGS.
	POP PDP,UUO		;RESTORE UUO
UINITA:	XCTR XR,[MOVE TAC,(DAT)]	;GET DEVICE NAME FROM USER
UINITK:	MOVE J,JOB(PID)		;JOB NUMBER
	PUSHJ P,DEVSRC		;SEARCH FOR DEVICE NAME
				;(SET SYSDEV BIT IN LH OF
				;DEVDAT IF THIS IS SYSTEM TAPE)
	JRST UINXIT		; MUST POP DAT OFF THE STACK BEFORE LEAVING
	MOVE AC1,DEVCMR(DDB)
	TLNE AC1,DEVMAS		;SKIP IF OK TO INIT WITHOUT HAVING ASSIGNED OR INITED
	JRST UNITAC		;CHECK IF ASSIGNED
UNITAD:	MOVE TAC,DEVNAM(DDB)	;PHYSICAL DEVICE NAME
	CAME TAC,[SIXBIT /DSK/]	;NOT DISK?
	CAME TAC,SYSTAP		;SYSTEM TAPE DEVICE?
	JRST UINITB		;NO, DISK OR NOT SYSTEM TAPE
	AOSE STREQ		;SYSTEM TAPE, INCREMENT REQUEST COUNT
	PUSHJ PDP,STWAIT	;SYSTEM TAPE BUSY, PUT JOB IN WAIT
	MOVEM ITEM,STUSER	;SET THIS JOB AS ONLY USER OF SYSTEM TAPE
				;CONTROL C DOES NOT STOP JOB WHILE USING S. T.
UINITB:
	MOVEI TAC1,ASSPRG	;TRY TO ASSIGN IT BY PROGRAM
	PUSHJ PDP,ASSASG
	JRST UINITW		;NOT AVAILABLE, SEE IF HE WILL WAIT FOR IT
	PUSHJ P,SETMOD		;SET DDB IOS STATUS WORD
	JRST UINITR		;LOSE. ILLEGAL MODE.
	MOVSI IOS,IOBEG		;FLAG INIT JUST DONE
	IORB IOS,DEVIOS(DEVDAT)
				;FROM RT. HALF OF UUO
	MOVE TAC,DEVMOD(DDB)	;GET GOOD BITS
	TLNE TAC,DVTTY		;IS IT A TTY?
	TLNE TAC,TTYATC		;AND NOT HIS CONSOLE?
	JRST UINITL		;NO
	MOVSI IOS,TPMON
	ANDCAB IOS,DEVIOS(DDB)	;THEN NOT IN MONITOR MODE ANY MORE
UINITL:	SKIPGE USRHCU(PID)	; IS USRHCU SCREWED UP?(NEGATIVE?)
	SETZM USRHCU(PID)	; YES, ZERO IT
UINITM:	CAMG UCHN,USRHCU(PID)	; IS THIS CHANN. > HIGHEST CHANN. IN USE?
	JRST UINITC		;NO
	AOS TAC,USRHCU(PID)	;YES, BUMP HIGHEST SO FAR BY ONE
	SETZM USRJDA(TAC)	;AND CLEAR IT OUT
	JRST UINITM		;AND KEEP LOOKING

UNITAC:	PUSH P,DDB		;SAVE MODEL DDB
UNTAC1:	LDB AC1,PJOBN		;CHECK FOR ASSIGNED OR INITED ALREADY
	CAIN AC1,(J)
	JRST UNTAD1		;SAME JOB MEANS ASSIGNED OR INITED
	PUSHJ P,DEVLP2		;COME, LET US CONTINUE OUR SEARCH
	CAIA
	JRST UNTAC1		;GOT ANOTHER, KEEP CHECKING
	POP P,DDB
	JSP TAC,ERRPTU		;RAN OUT, HE LOSES
	ASCIZ /MUST ASSIGN /
	PUSHJ P,ERNAM		;TYPE "DEVICE MUMBLE"
	JRST EXCALP		;AT USER/EXEC XXX

UNTAD1:	POP P,(P)
	JRST UNITAD

; INIT - SET UP BUFFERS AND INITIALIZE THEM

UINITC:	POP PDP,DAT		;RESTORE POINTER TO ARGUMENT LIST
	TLO DEVDAT,INITB	;SET INIT UUO BIT
	XCTR XR,[HLRZ TAC1,1(DAT)]	;OUTPUT BUFFER HEADER FROM USER
	JUMPE TAC1,UINIT4	;WAS ONE SPECIFIED?
	HRLM TAC1,DEVBUF(DEVDAT);YES, SET DEVICE DATA BLOCK
	TLO DEVDAT,OBUFB	;SET OUTPUT BUFFER SPECIFIED BIT
	PUSHJ PDP,UINITZ	;INITIALIZE OUTPUT BUFFER HEADER
UINIT4:	XCTR XR,[HRRZ TAC1,1(DAT)]	;INPUT BUFFER HEADER FROM USER
	JUMPE TAC1,UINIT5	;WAS ONE SPECIFIED?
	HRRM TAC1,DEVBUF(DEVDAT);YES, SET DEVICE DATA BLOCK
	TLO DEVDAT,IBUFB	;SET INPUT BUFFER SPECIFIED BIT
	MOVSI IOS,IOEND		;CLEAR END OF FILE FLAG
	ANDCAB IOS,DEVIOS(DEVDAT);AND RETAIN IOS
	PUSHJ PDP,UINITZ	;INITIALIZE INPUT BUFFER HEADER
UINIT5:	MOVEM DEVDAT,USRJDA(UCHN);STORE UUO BITS AND  DEVICE
				;DATA BLOCK ADDRESS
	JRST CPOPJ1		;SUCCESSFUL RETURN

UINXIT:	POP	P,DAT		; RESTORE STACK LOSER EXIT.
	POPJ	P,

UINITR:	PUSH	P,DDB		;SAVE LOSER DDB
	JSP	TAC,ERRPTU
	ASCIZ	/ILLEGAL DATA MODE FOR /
	PUSHJ	P,ERNAM
	EXCH	DDB,(P)		;SAVE TTY DDB, GET LOSER DDB
	PUSHJ	P,RELEA7	;RELEASE DEVICE.
	POP	P,DDB		;RESTORE TTY DDB
	JRST	EXCALP		;SEND THE BEDBUG LETTER
; HERE WE ASK HIM IF HE IS WILLING TO WAIT FOR THE DEVICE
; PUT HIM IN DEVICE WAIT (DWQ) IF HE WANTS TO WAIT
; ROUTINE TO WAIT FOR DEVICE TO BECOME AVAILABLE FOR INIT

UINITW:	TRNE	UUO,400			;DOES HE WANT ERROR RETURN?
	JRST	UINXIT			;YES. GIVE IT NOW
	MOVE	TAC1,JBTPRV(J)
	TLNE	TAC1,LUPPRV		;LOCAL-USER?
	JRST	UINTW1			;YES BYPASS TEST FOR SPECIAL DEV
	MOVE	TAC1,DEVCMR(DDB)
	TLNE	TAC1,DEVLUP
	JRST	UINXIT
UINTW1:	HRRZM DDB,JBTDVW(J)	; SAVE THE DEVICE DATA BLOCK ADDRESS
	PUSH P,UUO
	PUSH P,UUOPC(J)
	PUSH P,UCHN
	TRNE UUO,IOPAR		; DO WE ASK HIM?
	JRST SETWAT		; NO, WAIT AUTOMATICALLY
SETIWT:	PUSHJ P,TTYFUW		; WAIT FOR OUTPUT, SET UP DAT AND DDB
	HRRZ TAC1,JBTDVW(J)
	MOVE TAC1,DEVNAM(TAC1)
	PUSHJ P,PRNAME
	PUSHJ P,TYPGO
	TYPE { IS BUSY, WILL YOU WAIT?}
	PUSHJ P,UCTEXT
	HRRZ DDB,JBTDVW(J)	; PICK UP DDB ADDRESS OF DESIRED DEVICE
	MOVE TAC,[XWD TTYATC,ASSCON!ASSPRG]
	TDNE TAC,DEVMOD(DDB)	; THE AND OF THESE FOR TTY
	JRST SETRC
	LDB TEM,PJOBN		; PICK UP JOB NUMBER
	JUMPE TEM,GOTIT		; NOT CLAIMED, WE CAN GET IT
SETRC:	CAME TAC1,[SIXBIT /Y/]
	CAMN TAC1,[SIXBIT /YES/]
	CAIA
	JRST SETNOW
SETWAT:	MOVEI TAC1,DWQ
	MOVNM TAC1,JOBQUE(J)
	PUSHJ P,WSCHED
	HRRZ	DDB,JBTDVW(J)
	MOVE	TAC,[XWD TTYATC,ASSCON+ASSPRG]
	TDNE	TAC,DEVMOD(DDB)
	JRST	SETWAT		;LOSE
	LDB	TEM,PJOBN
	JUMPE	TEM,GOTIT
	CAIE	TEM,(J)
	JRST	SETWAT
GOTIT:	TYPE {GOTCHA!}
	POP P,UCHN
	POP P,UUOPC(J)
	POP P,UUO
	MOVE DAT,(P)
	JRST UINITG
; DEVICE WAIT - CAN'T GET IT, SEE IF HE WANTS DISK

SETNOW:	TYPE {DIRECT IO TO DISK?}
	PUSHJ P,UCTEXT
	JUMPN TAC1,SETERY
SETERX:	POP P,UCHN
	POP P,UUOPC(J)
	POP P,UUO
	HRRZ DDB,JBTDVW(J)	;IN CASE WE NEED THIS ANYWAY (FOR ERR PRINT)
	JRST UINXIT
SETERY:	CAME TAC1,[SIXBIT /Y/]
	CAMN TAC1,[SIXBIT /YES/]
	CAIA
	JRST SETERX
	MOVSI TAC,'DSK'
	POP P,UCHN
	POP P,UUOPC(J)
	POP P,UUO
	JRST UINITK

UCTEXT:
	INCHWL JOBTM5		; INPUT A CHARACTER WHICH WE WILL THROW AWAY!
	MOVEI DAT,TTIBUF(DDB)	; SET UP ADDRESS OF DATA BUFFER
	PUSHJ P,CTEXT1
	PUSHJ P,SKPBRK		; MOVE OUT TO END OF LINE
	POPJ P,
;CALLING SEQUENCE
;	PUSHJ PDP,UINITZ
;	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED.
;SETS JBFADR:=JBFCTR:=0 FOR THE BUFFER AREA HEADER WHOSE ADDRESS
;IS IN AC TAC1.  ALSO,JBFPTR 0-5:=JBFPTR 12-17:=0,JBFPTR 6-11:=BYTE SIZE


UINITZ:	XCTR	XW,[SETZM (TAC1)]	; CLEAR FIRST WORD OF BUFFER HEADER
	XCTR	XW,[SETZM 2(TAC1)]	; AND LAST WORD OF BUFFER HEADER
	PUSH	P,TAC1
	PUSHJ	P,SETBYT	; SET BYTE SIZE ACCORDING TO MODE
	TLZ	TAC,770077
	POP	P,TAC1
	XCTR	XRW,[HLLM TAC,1(TAC1)]
	POPJ	P,		;RETURN
;LONG DISPATCH TABLE UUOS - GET HERE ONLY IF DEVICE HAS LONG
;DISPACTH TABLE
;DISPACTH TO DEVICE DEPENDENT SERVICE ROUTINE
;ENTER UUO - ENTER FILE NAME IN DIRECTORY



UDEN:	MOVEI TAC,CLSIN
	TLNN DDB,ENTRB		; HAS THIS FILE BEEN OPENED FOR WRITING?
	JRST UDEN1		; NO, SUPRESS CALL ON CLOSE CODE
	TLNN DEVDAT,OCLOSB	;FILE OPEN?
	PUSHJ PDP,UDLKC		;YES. CLOSE IT.
UDEN1:	TLO IOS,IOBEG
	TRZ IOS,776000
	MOVEM IOS,DEVIOS(DEVDAT)
	TLO DEVDAT,ENTRB
	TLZ DEVDAT,OCLOSB
	HLLM DEVDAT,USRJDA(UCHN)	;STORE UUO BITS
	JRST DEN(DSER)

;LOOKUP UUO - LOOKUP FILE NAME IN DIRECTORY



UDLK:	MOVEI TAC,CLSOUT
	TLNN DEVDAT,ICLOSB	;FILE OPEN?
	PUSHJ PDP,UDLKC		;YES. CLOSE IT
	TDZ IOS,[XWD IOEND,776000]
	MOVEM IOS,DEVIOS(DEVDAT)
	TLO DEVDAT,LOOKB
	TLZ DEVDAT,ICLOSB
	HLLM DEVDAT,USRJDA(UCHN)	;STORE UUO BITS
	JRST DLK(DSER)


↑UDLKC:	PUSH PDP,UUO
	HRRI	UUO,(TAC)
	PUSHJ PDP,CLOSE1
	POP PDP,UUO
	JRST	WAIT1
;RENAME UUO - HERE ON SHORT DISPATCH TABLE DEVICES TOO



URENAM:	MOVE TAC,DEVMOD(DEVDAT)	;IS THIS DEVICE A LONG DISPATCH TABLE?
	TLNE TAC,DVLNG
	JRST DRN(DSER)		;YES, DISPATCH TO SERVICE ROUT.
	JRST CPOPJ1		;NO. GIVE SKIP RETURN TO USER

;SETO UUO - SET NEXT OUTPUT BLOCK NUMBER(DECTAPE)

UDSO:	JRST DSO(DSER)

;SETI UUO - SET NEXT INPUT BLOCK NUMBER

UDSI:	JRST DSI(DSER)

;GETF UUO - GET NEXT FREE BLOCK

UDGF:	JRST DGF(DSER)

;MTAPE UUO - MAGTAPE OPERATIONS

UMTAPE:	JRST DMT(DSER)

;UTPCLR - CLEAR DECTAPE DIRECT.

UTPCLR:	MOVE TAC,DEVMOD(DEVDAT)	;IS THIS A LONG DISPATCH TABLE?
	TLNN TAC,DVLNG
	POPJ PDP,		;NO,RETURN
	JRST DCLR(DSER)		;YES, DISPATCH
;INPUT UUO

;1)  IF OUTPUT ACTIVE ON THIS CHANNEL, WAIT FOR IT TO COMPLETE.
;2)  IF DUMP MODE, WAIT FOR DEVICE INACTIVE, CALL SERVICE
;	ROUTINE TO START INPUT, WAIT TILL COMPLETE, THEN RETURN TO USER.
;3)  IF NO BUFFER RING SETUP, SET UP 2 RING BUFFER.
;4)  IF FIRST REFERENCE, START SERVICE ROUTINE, GO TO
;5)  FLAG CURRENT BUFFER AS FREE TO RECEIVE MORE INPUT
;	(USE BIT SET TO 0).
;	START SERVICE ROUTINE FILLING FIRST BUFFER WITH USE BIT 0
;	(NEXT BUFFER OR ONE AHEAD OF IT)
;	(SERVICE ROUTINE WILL SET USE BIT WHEN IT FINISHES FILLING
;	BUFFER).
;7)  IF NEXT INPUT BUFFER IS FULL OF DATA, GO TO 10).
;8)  PUT JOB IN IO WAIT TILL NEXT BUFFER FILLED.
;9)  IF NEXT INPUT BUFFER STILL NOT FILLED, CHECK FOR END
;	OF FILE OR ERROR BITS SET BY SERVICE ROUTINE.
;10) CONVERT WORD COUNT AS STORED BY SERVICE ROUTINE IN THIRD
;	WORD OF BUFFER TO ITEM COUNT AND STORE IN THIRD WORD
;	OF HEADER (ITEM COUNT) ALSO SET BYTE POINTER (SECOND
;	WORD OF HEADER) AND RETURN TO USER.

; HERE IF INPUT NEEDS LOOKUP. GET FILE NAME FROM LOSER.

SETFILE:TYPE {PLEASE TYPE FILE NAME.}
	INCHWL JOBTM5
	MOVEI DAT,TTIBUF(DDB)	;GODDAMN SYSTEM
	PUSHJ P,CTEXT1		; READ IN FILE NAME IF ANY
	JUMPN TAC1,NOCLR
CLRIN:	PUSHJ P,SKPBRK
	JRST SETFILE
NOCLR:	MOVEM TAC1,JOBTM1(PROG)
	PUSHJ P,CTEXT1
	HLLZM TAC1,JOBTM2(PROG)
	SETZM JOBTM3(PROG)
	PUSHJ P,PJPGNO
IFE FTDSKPPN,<MOVE AC2,PRJPRG(J)>
IFN FTDSKPPN,<	JRST	[SKIPN	AC2,DSKPPN(J)	;DA, WHICH WAY DID 'E GO BOSS
			MOVE	AC2,PRJPRG(J)
			JRST	.+1]>
	MOVEM	AC2,JOBTM4(PROG)
	PUSHJ	P,SKPBRK
	POPJ	P,


↑IN:	MOVE TAC,DEVMOD(DDB)
	TLNE TAC,DVDSK
	TLNE DDB,LOOKB		; DOES THIS DEVICE NEED A LOOKUP?
	JRST IN2		; NO, FORGET IT.
	PUSH P,UUO
	PUSH P,UUOPC(J)
	PUSH P,UCHN
	TYPE {LOOKUP NEEDED.}
IN4:	PUSHJ P,SETFILE
	MOVE UUO,[LOOKUP JOBTM1]
	MOVE UCHN,(P)
	DPB UCHN,PUUOAC
	XCT UUO
	CAIA
	JRST IN5
	TYPE {LOOKUP FAILED}
	JRST IN4
IN5:	POP P,UCHN
	POP P,UUOPC(J)
	POP P,UUO
	MOVE DDB,USRJDA(UCHN)
	HRRZ DSER,DEVSER(DDB)
	MOVE IOS,DEVIOS(DDB)
; INPUT UUO - HERE, WE ARE SATISFIED DEVICE IS PROPERLY LOOKED UP

IN2:	TLNE IOS,IO		;IS THIS DEVICE ALREADY DOING OUTPUT?
	PUSHJ PDP,WAIT1		;YES, WAIT TILL IT IS FINISHED.
	TLO DEVDAT,INPB		;FOR THIS DEVICE.
	TLZ DEVDAT,ICLOSB
	HLLM DEVDAT,USRJDA(UCHN)	;IN LH OF CURRENT JOB DEVICE CHANNEL
	LDB TAC,PIOMOD		;IO MODE
	CAIE TAC,2		;SAVE MODE?
	CAIL TAC,SD		;IT THE IO MODE DUMP(SD,D,DR)?
	JRST INDMP		;YES
	TLNN DEVDAT,IBUFB	;INPUT BUFFER HEADER SPECIFIED IN INIT?
	JRST ADRERR		;NO, FLUSH THE BASTARD!
IN1:	HRR	JBUF,DEVBUF(DDB);NO, GET ADDRESS OF BUFFER HEADER
	MOVSI	TAC,IOUSE	;BUFFER IN USE BIT
	MOVE	IOS,DEVIOS(DDB)	;GET A NEW COPY OF IOS
	XCTR	XR,[SKIPG (JBUF)]	;HAS A BUFFER RING BEEN SET UP (RH NON-ZERO)
				;WHICH HAS BEEN REFERENCED BY PREVIOUS INPUT (BIT0=0)
	JRST	INPUTF		;NO. GO SET UP BUFFER IF NECESSARY AND DO FIRST IO
	PUSHJ	P,BCHECK	;CHECK BUFFERS!
	JRST	ADRERR		;ADDRESS CHECK
	XCTR	XR,[MOVE TAC1,(JBUF)]
	MOVE	IOS,DEVIOS(DDB)		;DEC 3.16
	XCTR	XR,[TDNN TAC,(TAC1)]	;DEC 3.16
	JRST	INPT1			;DEC 3.16
	XCTR	XRW,[ANDCAB TAC,(TAC1)]
				;FLAG CURRENT BUFFER AS FREE TO
				;RECEIVE MORE INPUT, CLEAR USE BIT
				;AND GET POINTER TO NEXT BUFFER
	XCTR	XRW,[HRRM TAC,(JBUF)]	;SET WORD 1 IN 3 WORD HEADER TO NEXT BUFFER
	TRNE IOS,IOACT		;IS THE DEVICE ALREADY ACTIVE
	JRST INPT0C		;YES
	MOVE AC1,DEVMOD(DEVDAT)	;GET DEVICE CHARACTERISTIC WORD
	TLNN AC1,DVTTY		;IS IT A TTY?
	XCTR	XR,[HRR TAC,(TAC)]	;GET POINTER 1 BUFFER AHEAD OF NEXT BUFFER
				;IF NOT TTY.
	XCTR	XR,[SKIPL (TAC)]	;IS THE USE BIT SET?
	PUSHJ	P,CALIN		;NO, START SERVICE ROUTINE FILLING EMPTY BUFFER
; INPUT UUO CONT.

INPT0C:	XCTR	XR,[HRR TAC1,(TAC1)]	;GET USE BIT FOR NEXT BUFFER
INPT0A:	XCTR	XR,[SKIPGE (TAC1)]	;IS USE BIT SET YET?(BUFFER FILLED YET?)
	JRST	INPUT2		;YES, RETURN IMMEDIATELY TO USER
INPT2:				;DEC 3.16
	PUSHJ	P,WSYNC		;NO, PUT JOB IN IO WAIT TILL BUFFER FILLED.
	XCTR	XR,[SKIPL (TAC1)]	;RETURN WHEN BUFFER FILLED. CHECK TO MAKE SURE.
	JRST	INEOF		;NO, MUST BE EOF OR ERROR
INPUT2:	ADDI	TAC1,1		;YES, GET WORD COUNT AS SET BY IO SERVICE
	XCTR	XR,[HRRZ ITEM,(TAC1)];RH OF 3RD WORD(FIRST SO-CALLED DATA WORD)
	SOJA	TAC1,IOSETC	;SET ITEM COUNT AND BYTE POINTER
				;IN 3 WORD HEADER AND RETURN TO USER
INPT1:	TRNN	IOS,IOACT	;DEC 3.16
	PUSHJ	P,CALIN		;DEC 3.16
	JRST	INPT2		;DEC 3.16

INEOF:	TDNN	IOS,[XWD IOEND,IODEND!IODERR!IOBKTL!IODTER!IOIMPM]
				;EOF OR ERROR BIT SET BY SERVICE ROUTINE
	JRST	INEOFE		;NO,
	TLNE	IOS,IOEND	;IS THIS EOF?
	TRO	IOS,IODEND	;YES, SET USER EOF BIT.
	IORM	IOS,DEVIOS(DDB)
	POPJ	P,		;RETURN TO USER'S PROGRAM

INEOFE:	JSP	DAT,UERROR	;MONITOR ERROR AT UUO LEVEL
	POPJ	P,
;HERE ON FIRST INPUT AFTER INIT, INIT & LOOKUP, OR INIT & LOOKUP & INPUT
INPUTF:	XCTR	XRW,[ANDCAB TAC,(JBUF)]
				;MARK THAT BUFFERS HAVE BEEN REFER
				;BY CLEARING SIGN BIT OF 1ST WORD IN 3 WORD
				;IN 3 WORD BUFFER HEADER
	JUMPE	TAC,INPUT3	;HAS A RING BEEN SET UP YET?
	PUSHJ	P,BCHECK
	JRST	ADRERR		;ADDRESS CHECK
	XCTR	XR,[MOVE TAC1,(JBUF)]
	XCTR	XR,[SKIPG (TAC1)]
	JRST	INPUT2
	HRRM	TAC,DEVIAD(DDB)	;YES, STORE ADR. OF 2ND WORD OF
				;A BUFFER FOR SERVICE ROUTINE
	PUSHJ	P,CALIN		;YES. GO START IO SERVICE ROUTINE
				;FILLING BUFFER
	JRST	INPT0A

INPUT3:	HRRI	UUO,2		;BUFFERS NOT SETUP YET. - MAKE 2
	PUSHJ	P,UINBF
	HRRI	UUO,0		;CLEAR RIGHT HALF
	JRST	IN1


INDMP:	PUSHJ	P,DDI(DSER)	;CALL SERVICE ROUTINE
	JRST	WSYNC		;THEN WAIT TILL IO  FINISHED BEFORE
				;RETURNING TO USER.
				;*** NOTE: ADCSER THINKS IT CAN RETURN
				; TO USER WITHOUT WAITING BY
				; A 'JRST TPOPJ', THUS SKIPPING WSYNC
; CALL THE DEVICE INPUT ROUTIN

CALIN:	TLNE	IOS,IOEND
	POPJ	P,
	PUSH	P,TAC1
	PUSH	P,JBUF
	HRRZ	AC1,DEVIAD(DDB)	;IS FIRST ADR. ABOVE JOB DATA AREA?
	CAIG	AC1,JOBPFI
	JRST	ADRERR		;NO, PRINT ERROR AND STOP JOB
	XCTR	XR,[HLRZ AC2,(AC1)]	;GET LENGTH OF BUFFER
	TRZ	AC2,IOUSE	;CLEAR USE BIT IN CASE IT IS ON(TTY)
	ADD	AC1,AC2
	XCTR	XRW,[MOVES (AC1)]	; ADDRESS CHECK LAST ADDRESS OF BUFFER
	PUSHJ	P,DIN(DSER)	;DISPATCH TO IO SERVICE ROUTINE
	POP	P,JBUF
	POP	P,TAC1
	POPJ	P,

↑BCHECK:MOVEI	AC1,(JBUF)
	CAIG	AC1,JOBPFI	;CHECK PROTECTED PART THIS WAY
	POPJ	P,
	XCTR	XRW,[MOVES AC1,(AC1)]	;AND THE REST THIS WAY
	HRRZ	AC1,AC1
	CAIG	AC1,JOBPFI
	POPJ	P,
	XCTR	XRW,[MOVES (AC1)]
	JRST	CPOPJ1
; OUTPUT UUO - CALLING SEQUENCE
;     OUTPUT D,
;     EXIT
;OR
;     OUTPUT D, ADR
;     EXIT

;IF INPUT IS ACTIVE, WAIT FOR IT TO COMPLETE.
;IF DUMP MODE WAS SELECTED BY THE LAST INIT UUO OR SETSTS UUO
;   THE PROGRAM WAITS UNTIL THE DEVICE IN INACTIVE AND THEN
;   WRITES THE DUMPFILE AND RETURNS CONTROL TO THE USER'S PROGRAM
;   WHEN IO HAS COMPLETED.
;IF THE MODE IS NOT DUMP, THEN
;1) IF ADR IS NOT ZERO, WAIT FOR DEVICE TO BECOME INACTIVE THEN SET THE
;   CURRENT BUFFER ADDRESS EQUAL TO ADR AND AN INDICATOR (JBFADR0)
;   SPECIFYING THAT THIS BUFFER RING HAS NEVER BEEN REFERENCED FROM THE
;   USER'S PROGRAM BY AN INPUT OR AN OUTPUT UUO.  OTHERWISE, GO TO
;   2) DIRECTLY.

;2) IF THE BUFFER RING HAS NEVER BEEN REFERENCED (JBFADR0=1), THE
;   BUFFER IS CLEARED, IOUSE SET TO ZERO AND
;      IF THE CURRENT BUFFER ADDRESS IS ZERO, A TWO BUFFER RING IS SET UP.
;      THEN GO TO 8
;
;3) IF THE BUFFER RING HAS BEEN REFERENCED (JBFADR0=0	,THEN A CHECK IS
;   MADE TO DETERMINE IF THE WORD COUNT IS TO BE COMPUTED.
;      IF THE WORD COUNT IS TO BE COMPUTED (IOWC=0), IT IS SET EQUAL
;      TO THE ADDRESS FOR THE LAST DATA WORD MINUS THE ADDRESS OF THE
;      BUFFER MINUS ONE.

;4) IOUSE IS SET TO ONE, INDICATING THAT THE BUFFER IS FULL OR BEING
;   EMPTIED, AND THE CURRENT BUFFER ADDRESS IS ADVANCED.

;5) IF THE DEVICE IS NOT ACTIVE (IOACT=0), OUTPUT IS STARTED.
;6) IF THE CURRENT BUFFER IS FULL OR BEING EMPTIED (IOUSE=1),
;   THE PROGRAM WAITS UNTIL THE DEVICE FINISHES THE BUFFER
;   (THE OUTPUT SERVICE ROUTINE CLEARS THE USE BIT WHEN
;   IT FINISHES OUTPUTTING A BUFFER).
;7) THE CURRENT BUFFER IS CLEARED.
;8) THE ITEM POINTER IS INITIATED TO THE CURRENT BUFFER ADDRESS+1
;   AND THE ITEM COUNT IS SET TO THE PRODUCT OF THE BUFFER SIZE
;   MINUS ONE AND THE INTEGER PART OF 36/BYTE SIZE.
;9) RETURN TO THE USER'S PROGRAM
;HERE ON OUTPUT UUO


UOUT:	MOVE TAC,DEVMOD(DDB)
	TLNE TAC,DVDSK
	TLNE DDB,ENTRB
	JRST UOUT1
	PUSH P,UUO
	PUSH P,UUOPC(J)
	PUSH P,UCHN
	TYPE {ENTER NEEDED.}
OUT4:	PUSHJ P,SETFILE
	MOVE UUO,[LOOKUP JOBTM1]
	MOVE UCHN,(P)
	DPB UCHN,PUUOAC
	PUSH P,JOBTM4(PROG)	;LOOKUP CLOBBERS THIS.
	XCT UUO
	JRST OUT5		;DOESN'T EXIST OR ERROR WILL BE DETECTED BY ENTER
	POP P,JOBTM4(PROG)
	TYPE {FILE ALREADY EXISTS. DELETE?}
	INCHWL JOBTM5
	MOVEI DAT,TTIBUF(DDB)
	PUSHJ P,CTEXT1
	PUSHJ P,SKPBRK
	CAME TAC1,['Y     ']
	CAMN TAC1,['YES   ']
	JRST OURDN
	JRST OUT4
OUT5:	POP P,JOBTM4(PROG)	;RESTORE PPN
OURDN:	HLLZS JOBTM2(PROG)
	SETZM JOBTM3(PROG)
	MOVE UUO,[CLOSE]
	MOVE UCHN,(P)
	DPB UCHN,PUUOAC
	XCT UUO			;MAKE SURE WE DON'T GET INTO ALTER MODE
	MOVE UUO,[ENTER JOBTM1]
	MOVE UCHN,(P)
	DPB UCHN,PUUOAC
	XCT UUO
	CAIA
	JRST OUT3
	TYPE {ENTER FAILED}
	JRST OUT4
OUT3:	POP P,UCHN
	POP P,UUOPC(J)
	POP P,UUO
	MOVE DDB,USRJDA(UCHN)
	MOVE IOS,DEVIOS(DDB)
	HRRZ DSER,DEVSER(DDB)
; OUTPUT UUO - HERE WE ARE SATISFIED DEVICE HAS BEEN PROPERLY ENTERED

UOUT1:	TLO DEVDAT,OUTPB	;SET OUTPUT UUO BIT
	TLZ DEVDAT,OCLOSB	;CLEAR CLOSE OUTPUT BIT

;HERE FROM DEVICE SERVICE ROUTINES ON CLOSE UUO

↑OUT:	TLNN IOS,IO		;IS THIS DEVICE ALREADY DOING INPUT?
	PUSHJ PDP,WAIT1		;YES, WAIT TILL IT BECOMES INACTIVE
	HLLM DEVDAT,USRJDA(UCHN);SAVE NEW BIT SETTINGS.
	LDB TAC,PIOMOD		;GET DATA MODE SET BY INIT OR SETSTS.
	CAIE TAC,2		;SAVE MODE?
	CAIL TAC,SD		;IS IT DUMP MODE(SD,DR,D)?
	JRST OUTDMP		;YES.
	TLNN DDB,OBUFB		; IS THERE AN OUTPUT BUFFER HEADER?
	JRST ADRERR		; NO, ERROR
	PUSHJ PDP,OUTA		;NO, CHECK FOR NON-ZERO ADDRESS(USER
				;CHANGING RING)
	HLR JBUF,DEVBUF(DEVDAT)	;REL. ADDR. OF OUTPUT BUFFER HEADER
	XCTR XR,[SKIPG TAC1,(JBUF)]
				; CHECK FIRST WORD OF BUFFER HEADER
	JRST OUTF		;RING NOT SET UP OR FIRST REFERENCE TO RING
	PUSHJ P,BCHECK		;RING SET-UP, CHECK IT
	JRST ADRERR		;ADDRESS CHECK
	XCTR XR,[SKIPG (TAC1)]	;DID WE SOME HOW GET BACK TO HIM WITH NO FREE BUFFERS? RPH
	JRST OUTAGN		;YES, LET DEVICE WORRY ABOUT IT!  RPH
	AOS JBUF		;COMPUTE WORD COUNT FROM BYTE POINTER
	XCTR XR,[HRRZ TAC,(JBUF)]	;GET RH OF BYTE POINTER.
	ADDI TAC1,1		;REL. ADDR. OF 3RD WORD IN BUFFER.
	SKIPN TAC		;BYTE POINTER INITIALIZED ;DWP(JS)
	TDZA TAC,TAC		;NO. SET WORD COUNT = 0	  ;DWP(JS)
	SUB TAC,TAC1		;DISTANCE FILLED BY USER.
	TRNE IOS,IOWC		;DOES USER WANT SYSTEM TO COMPUTE WORD
				;COUNT FROM BYTE POINTER?
	JRST OUT2		;NO.
	HRRZ AC1,TAC1		;YES, PROCEED IF ADDR. OF WORD COUNT IN BOUNDS
	ADDI AC1,(TAC)		;CHECK ENDING ADDRESS.
	XCTR XRW,[MOVES (AC1)]
	SOJ TAC1,		; BACK UP POINTER TO LENGTH AND LINK WORD
	XCTR XLB,[LDB AC1,[POINT 17,(TAC1),17]]
	CAMLE TAC,AC1		; IS THERE MORE DATA THAN THERE IS BUFFER?
	JRST ADRERR		; YES, USER ERROR
	AOJ TAC1,		; RESET BUFFER WORD COUNT POINTER
	XCTR XRW,[HRRM TAC,(TAC1)]	;STORE WORD COUNT IN 3RD WORD OF BUFFER.
; OUTPUT UUO - HERE, WE ADVANCE BUFFER ADDRESS, START OUTPUT, AND WAIT FOR
; OUTPUT TO FINISH BEFORE RETURNING TO USER

OUT2:	SUBI JBUF,1		;REL. ADDR. OF 1ST WORD IN HEADER
				;(POINTER TO CURRENT BUFFER).
	SUBI TAC1,1			;REL. ADDR. OF 2ND WORD IN BUFFER
					;(LINK TO NEXT BUFFER).
	HRLZI TAC,IOUSE		;FLAG CURRENT BUFFER CONTAINS ACTIVE DATA.
	XCTR XRW,[IORB TAC,(TAC1)]
	XCTR XRW,[HRRM TAC,(JBUF)]	;ADVANCE CURRENT BUFFER ADDRESS
	XCTR XRW,[HLLZS 1(JBUF)]	; ZERO OUT RH OF BYTE PTR TO NOTE NOT YET INITIALIZED - DWP (JS) /JAM
OUTAGN:	XCTR XW,[SETZM 2(JBUF)]	;CAN'T USE NEXT BUFFER YET!!   RPH
	MOVE IOS,DEVIOS(DEVDAT)	;IS DEVICE ACTIVE?
	MOVSI AC1,DEVAOA	; CAN WE CALL THIS SERVICE ROUTINE IF IOACT IS ON?
	TDNN AC1,DEVCMR(DEVDAT)	; THIS BIT IN THIS WORD WILL TELL US
	TRNN IOS,IOACT
	PUSHJ PDP,DOU(DSER)	;NO,START OUTPUT.
	HLR JBUF,DEVBUF(DEVDAT)	;JBUF TO REL. ADDR. OF BUFFER HEADER
	XCTR XR,[MOVE TAC1,(JBUF)];TAC1 TO REL. ADDR. OF 2ND WORD OF BUFFER.
	XCTR XR,[SKIPL (TAC1)]	;HAS SERVICE ROUTINE EMPTIED NEXT BUFFER
	JRST OUTS		;YES, CLEAR AND RETURN
	TRNE IOS,740000		;ANY ERRORS TO SHOW LOSER?   RPH
	POPJ P,			;YES, LET HIM SEE THEM	     RPH
	PUSHJ P,WSYNC		;NO, WAIT.
	JRST OUTS		;CLEAR BUFFER AND RETURN TO LOSER, HOPING THAT THE BUFFER IS NOW REALLY FREE

OUTF:	XCTR XR,[SKIPE TAC1,(JBUF)]
	JRST OUTF1
	HRRI UUO,2
	PUSHJ PDP,UOUTBF
	HLR JBUF,DEVBUF(DEVDAT)
OUTF1:	PUSHJ P,BCHECK		;CHECK BUFFER ADDRESSES
	JRST ADRERR		;ADDRESS CHECK
	MOVSI	TAC,IOUSE
	XCTR XRW,[ANDCAB TAC,(JBUF)];IOUSE:=0
	HRRM TAC,DEVOAD(DEVDAT)
OUTS:	XCTR XR,[HRRZ TAC,(JBUF)]	;CLEAR NEXT OUTPUT BUFFER.
	PUSHJ	P,BUFCLR	;BEING CLEARED.
	JRST	ADRERR		;ADDRESS CHECK
	XCTR	XR,[HRR TAC1,(JBUF)]
	XCTR	XLB,[LDB ITEM,[POINT 17,(TAC1),17]]
	SOJA	ITEM,IOSETC
				;ADDRESS+1
				;JBFCTR:=(BUFFER SIZE-1)*[36/BYTE
				;SIZE]
				;RETURN TO USER'S PROGRAM

OUTDMP:	PUSHJ PDP,DDO(DSER)
				;NOTE THAT XGPSER (AND ADCSER) THINKS IT CAN RETURN
				;WITHOUT WAITING BY JRST TPOPJ
	JRST WSYNC		;WAIT BEFORE RETURNING TO USER
; SUBROUTINE FOR OUTPUT UUO
;CALLING SEQUENCE:
;	PUSHJ PDP,OUTA
;	EXIT		ALWAYS RETURNS HERE
;IF THE ADDRESS FIELD OF AC UUO IS ZERO,EXIT. OTHERWISE,CHECK IOACT.
;IF IOACT=1, WAIT FOR IOACT=0.
;SET JBFADR18-35:=ADDRESS FIELD OF AC UUO. JBFADR0:=1 AND EXIT.

↑OUTA:	TRNN	UUO,777774		;IS BUFFER ADDRESS SPECIFIED?
	POPJ	P,			;NO
	PUSHJ	P,WAIT1
	HLR	JBUF,DEVBUF(DDB)
	XCTR	XRW,[HRRM UUO,(JBUF)]
	HRRM	UUO,DEVOAD(DDB)
	MOVSI	TAC,IOUSE
	XCTR	XRW,[IORM TAC,(JBUF)]
	POPJ	P,			;RETURN
;RELEASE A DEVICE


RELEA0:
↑RELEA3:
	TRZ	UUO,-1		;CLOSE BOTH INPUT AND OUTPUT.  HERE FROM IORELS
↑RELEA1:			;ALLOW SUPPRESION ON RELEASE UUO
	PUSHJ	P,CLOSE1
	HRRZ	TAC,DEVSER(DDB)	;DISPATCH ADDRESS IS THE ONLY THING RELEVANT
	CAIN	TAC,(DSER)	;COMPARE
	JRST	RELE1A
	PUSHACS
	PUSH	P,(DDB)		;DEVICE NAME
	MOVE	TAC,DSER
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ	/ DSER CLOBBERED BY CLOSE1 AT RELEA1. /
	POP	P,TAC1
	PUSHJ	P,DISSIX
	PUSHJ	P,DISTAB
	PUSHJ	P,DISJOB
	PUSHJ	P,DISCRLF
	POPACS
	MOVE	DSER,DEVSER(DDB)
RELE1A:	PUSHJ	P,WAIT1		;WAIT FOR DEVICE TO BECOME INACTIVE
↑RELEA5:
	PUSHJ	P,DRL(DSER)		;DISPATCH TO DEVICE SERVICE ROUTINE
	MOVEI	IOS,IOACT		;CLEAR IO ACTIVE BIT
	ANDCAB	IOS,DEVIOS(DDB)		;AND RETURN WITH IOS SET
	SETZB	DAT,USRJDA(UCHN)	;CLEAR DEVICE ASSIGNMENT
	SKIPGE	TAC,USRHCU(PID)
	MOVEI	TAC,17
RELEA4:	HRRZ	TAC1,USRJDA(TAC)
	JUMPN	DAT,RELE4A		;NON-ZERO CHAN. ALREADY?
	MOVE	DAT,TAC1		;NO, SET DAT WHEN FIRST(HIGHEST) FOUND
	MOVEM	TAC,USRHCU(PID)		;STORE HIGHEST IN USE CHANNEL
RELE4A:	CAIE	TAC1,(DDB)		;IS THIS DEVICE SAME AS ONE BEING RELEASED?
	SOJGE	TAC,RELEA4
	JUMPGE	TAC,CPOPJ	;DON'T FLUSH THIS DDB IF OPEN ON ANOTHER CHANNEL
	HLLZS	DEVIAD(DDB)	;CLEAR INPUT BUFFER ADDRESS
	HLLZS	DEVOAD(DDB)	;AND OUTPUT BUFFER ADDRESS.

;CALLED FROM ERROR STOP ROUTINE(ESTOP)
↑RELEA9:
	MOVE	TAC,DEVNAM(DDB)		;IS THIS SYSTEM TAPE?
	CAME	TAC,[SIXBIT /DSK/]	;DSK IS NEVER QUEUED
	CAME	TAC,SYSTAP
	JRST	RELEA7			;IS DISK OR NOT SYSTEM TAPE
	MOVSI	TAC,777760		;PREPARE TO ZERO OUT MOST OF DEVIAD AND DEVOAD
	ANDCAM	TAC,DEVIAD(DDB)
	ANDCAM	TAC,DEVOAD(DDB)
	SKIPN	STUSER			;HAS COUNT ALREADY BEEN REDUCED AT ESTOP?
	JRST	RELEA7			;YES
	SETZM	STUSER			;YES, CLEAR SYSTEM USER NO.
	SOSL	STREQ			;YES, REDUCE COUNT
	SETOM	STAVAL			;SOMEONE IS WAITING, SET AVAILABLE FLAG/
RELEA7:	MOVEI	TAC1,ASSPRG		;CLEAR ASSIGNED BY PROGRAM BIT
↑RELEA6:
	ANDCAB	TAC1,DEVMOD(DDB)	;CALLED FROM DEASSIGN
	TRZ	TAC1,777		;CLEAR JOB NO. FIELD
	TDNE	TAC1,[XWD TTYATC,ASSCON+ASSPRG]
	POPJ	P,			;DEVICE ASSIGNED BY OTHER MEANS TOO
	DPB	TAC1,PJOBN		;CLEAR JOB NUMBER
	MOVE	TAC1,DEVCMR(DDB)
	TLNN	TAC1,DEVSHR		;SHARABLE DEV?
	JRST	RELDVW			;NO - WAKE UP WAITERS IF ANY
	PUSH P,DAT		; IF AT COMMAND LEVEL, SAVE TTY POINTER
	PUSH P,DDB		; AND DDB ADDRESS
	PUSH P,DSER
	HRRZ DSER,DEVSER(DDB)	;GET POINTER TO DEVICE DEPENDENT ROUTINES
	PUSHJ PDP,DGIVDD(DSER)	;RETURN DDB TO STORAGE
	POP P,DSER
	POP P,DDB
	POP P,DAT		; RESTORE COMMAND POINTER
	POPJ P,
; RELEAS CODE - SEE IF THERE IS ANYONE WAITING FOR THE DEVICE
; IF SO, WAKE HIM UP.

RELDVW:	PUSH P,DDB
	PUSH P,UUO
	PUSH P,DAT
	PUSH P,J		;SAVE OLD JOB NUMBER
	HRRZS DDB
	MOVEI DAT,DVWSCAN	; SCAN ALL JOBS IN DEVICE WAIT
	JSP UUO,QSCAN
	JRST RELDVX
	CAME DDB,JBTDVW(J)
	JRST (AC1)		; GO RESCAN
	MOVEI AC1,RUNQ
	MOVNM AC1,JOBQUE(J)	; WAKE HIM UP
	PUSHJ P,REQUE
RELDVX:	POP P,J
	POP P,DAT
	POP P,UUO
	POP P,DDB
	POPJ P,
; UUOS TO TEST IO STATUS WORD
;CALLING SEQUENCE
;	STATO D,MASK
;	EXIT1		ALL SELECTED BITS ARE 0
;	EXIT2		SOME SELECTED BITS ARE 1
;TESTS BITS OF I/O STATUS WORD OF DEVICE ON USER'S CHANNEL D WHICH
;ARE SELECTED BY MASK.


↑USTATO:
	TRNE IOS,(UUO)		; SKIP IF ANY INDICATED BITS ARE ONE
	AOS (PDP)
	POPJ PDP,		;RETURN TO USER
; MORE STATUS UUOS
;CALLING SEQUENCE
;	GETSTS D,ADR
;	EXIT		ALWAYS RETURNS HERE
;STORES I/O STATUS WORD OF DEVICE ON CHANNEL D IN LOCATION ADR.




↑USTATS:
	HRRZ TAC,IOS		; GET USER HALF OF IOS
	JRST STOTAC		;ADDRESS CHECK AND STORE IN USER AREA
; STILL MORE STATUS UUOS
;CALLING SEQUENCE
;	STATZ D,MASK
;	EXIT1		SOME SELECTED BITS ARE 1
;	EXIT2		ALL SELECTED BITS ARE 0

;TESTS BITS OF I/O STATUS WORD OF DEVICE ON USER'S
;CHANNEL D WHICH ARE SELECTED BY MASK.


↑USTATZ:
	TRNN IOS,(UUO)		; SKIP IF ALL INDICATED BITS ARE ZERO
	AOS (PDP)
	POPJ PDP,		;RETURN TO USER



;IN UUO - LIKE INPUT	SKIPS IF  EOF OR ERRORS


↑TIN:	PUSHJ PDP,IN		;DO INPUT UUO
	TRNE IOS,IOBKTL+IODTER+IODERR+IOIMPM+IODEND
	AOS (PDP)
	POPJ PDP,


;OUT UUO - LIKE OUTPUT  -  SKIPS IF ERRORS


↑TOUT:	PUSHJ PDP,UOUT		;DO OUTPUT UUO
	TRNE IOS,IOBKTL+IODTER+IODERR+IOIMPM
	AOS (PDP)
	POPJ PDP,


;SPACEWAR UUOS

SPCWGO:	MOVEI	UUO,(TAC)		;SETUP STARTING ADDRESS.
	HLLZ	UCHN,TAC		;MODE BITS IN UCHN LEFT
	HLR	UCHN,TAC		;TICKS IN UCHN RIGHT
	AND	UCHN,[740000,,17]	;FLUSH IRRELEVANT BITS
	JRST	SPCWG1

;UUO43 IS THE SPACEWAR UUO.  SEE SPWSER FOR MORE DETAILS - JS

USPCWAR:ANDI	UCHN,17		;TICKS ONLY
SPCWG1:	MOVE TAC,JBTPRV(J)
	TLNE TAC,LUPPRV
	JRST	SPWCON		;LET SPACE WAR SERVICE FIGURE OUT WHAT TO DO
	JRST	UUOERR		;ILLEGAL FOR REMOTE JOBS
	BEND	APRSER
