COMMENT ⊗   VALID 00087 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00006 00002	BEGIN TTYSER - SCANNER, KEYBOARD AND CONSOLE TELETYPE SERVICE ROUTINE
C00008 00003	DATA STRUCTURES AND PARAMETERS
C00011 00004	IOS BITS
C00014 00005	LINE BITS, LINE # DEFS
C00018 00006	AC'S, BYTE POINERS, CTLV
C00020 00007	LINBIT, TTYINI
C00025 00008	MORE TTYINI, SCNINI
C00028 00009	TTYCOM, TTYCM, CNTCOM, COMBCK
C00035 00010	TTYATI, TTYSUB
C00038 00011	TTYSUB TABLES
C00039 00012	FILL, ECHO, FULL, TABS, TIME, WHO
C00045 00013	TTYATT
C00048 00014	TTYDET, TRESCN, TRESCU
C00051 00015	TBYTEP
C00052 00016	TTYGET, TTYFNU, TTYFND, TTYFUW, TTYERP, TTYERR
C00055 00017	TTYSET, TTYSTC
C00056 00018	TTYSTR, TTYUSR
C00058 00019	TTYTLK
C00062 00020	TTYSRC, STLNAC
C00064 00021	GETDDB, LOG2LN
C00066 00022	DDBSRC, STDTBL
C00070 00023	SCNIN
C00072 00024	TTYSKL, TTYREL, TTYKIL
C00077 00025	MORE TTYKIL
C00081 00026	OUTCH6, OUTCHS, OUTCHR
C00085 00027	MORE OUTCHR  ADJHP
C00088 00028	PUTCHI, PUTCHO
C00092 00029	GETCHR, GETCHY
C00094 00030	GETCHA, GETCHO
C00096 00031	TSETBF, SETBFI, SETBF3, SETBFO
C00098 00032	SPCHEK, SPCACT
C00101 00033	SPCTAB
C00104 00034	TTYUUO, CLRBUF, INSKIP
C00107 00035	INCHSL, INCHRS, INCHWL, IWAIT, OUTSTR, INCHGT, INCHGB
C00111 00036	INCHRW, ONEOUT, GETLIN, SETLIN, SYNCHK, SYNCHA, SETACT
C00118 00037	OUTFIV, FIVOUT
C00121 00038	TTYMES
C00125 00039	TTREAD, TTYJNO, TTYJOB
C00128 00040	SNEAKS, SNEAKW, ACTCHR
C00131 00041	DDTIN
C00134 00042	DDTOUT, DDTWAT
C00136 00043	SCNDSP, TTYIN, TWSYNC, TTYSKP
C00139 00044	MONUSR
C00143 00045	TTYOUT
C00145 00046	USRMON
C00148 00047	SCNIN1, SCNTYP, KBDINT
C00151 00048	SHFTBL, CONVTB
C00153 00049	DKBINT
C00156 00050	DKBTBL
C00158 00051	SCNINT
C00159 00052	CTYINT
C00160 00053	RECINT, RECINA, RECINB, RECINC, RECIM3, NOESC, ESCRET
C00166 00054	RECIN3, RECIN4, UTYPET, TYPTST, TYPGO, TTINT
C00171 00055	ESCAPE BITS
C00172 00056	SETESC
C00175 00057	DOESC
C00177 00058	SPESC
C00178 00059	ESCAPES
C00180 00060	MORE ESCAPES	VDESET	VDECHK	VDVCHK
C00183 00061	ASSCN, ASESC, ESCB  AUDIO SWITCH SERVICE
C00191 00062	PKINT	PAGING INTERRUPT SERVICE ROUTINE
C00195 00063	ADSMAP, BEEP UUOS
C00207 00064	RECIML
C00208 00065	TYPX, COMSET
C00210 00066	TTEDIT
C00214 00067	TTIPUT, DUPLEX, DUPLX1, INBFUL
C00217 00068	CONTC, CONTOB, CONTO, CONTB, ALTMOD, TTYUNH
C00221 00069	RUBOUT, AOJDPX, CONTK, CONTL
C00223 00070	CONTI, CONTP
C00226 00071	CRLFEC, CRLF
C00228 00072	CNCTST, CNCMOD
C00230 00073	BSECHO, DCPUTR, DELETL
C00232 00074	DOTALK, NOTALK
C00238 00075	XMTINT, XMTIN1, DPYSTR, DPYDON
C00241 00076	XMTIN4, XMTIN2, LINDON, TTYPE
C00244 00077	TYP, TYPL, CTYP
C00246 00078	PTYGET, PTOCK, PTICHK, PTYCLR
C00250 00079	PTYUUO, LINMAP, PTOCNT, PTIFRE
C00253 00080	PTYREL, PTRD1S, PTRD1W, PTWAIT
C00256 00081	PTWR1S, PTLL3, PTWR1W, PTRDS, PTWRS7, PTWRS9
C00260 00082	PTJOBX
C00262 00083	PTJHLT, PTJCON, PTIWTS, PTCLRB
C00265 00084	PTDON, PTDOFF,PTLOGN,IMLOAD
C00268 00085	PHONE DIALER LIVES HERE
C00270 00086	DIAL UUO
C00276 00087	DIALER INTERRUPTS COME HERE
C00279 ENDMK
C⊗;
BEGIN TTYSER - SCANNER, KEYBOARD AND CONSOLE TELETYPE SERVICE ROUTINE
SUBTTL TTYSER - -DEC MOD D. POOLE MOD R. HELLIWELL




;SCNSER IS ORGANIZED(?) INTO THE FOLLOWING SECTIONS

;	I.	COMMENTARY ON OPERATION AND DATA STRUCTURES
;      II.	SYSTEM INITIALIZATION ROUTINE - SCNINI
;      III.	COMMAND LEVEL ROUTINES
;			A. TTYATT
;			B. TTYCOM
;			C. TTYDCM
;			D. TTYDET
;			E. TTYFND,TTYFNU
;			F. TTYKIL
;			G. TTYSET
;			H. TTYSRC
;			I. TTYSTR
;			J. TTYTLK
;			K. TTYUSR
;     IV.	UUO LEVEL ROUTINES
;			A. DDTIN
;			B. DDTOUT
;			C. TTYUUO
;			D. TTYIN
;			E. TTYOUT
;	V.	INTERRUPT SERVICE ROUTINES
;			A. CTYINT
;			B. SCNINT
;			C. RECINT - ALL LINES RECEIVER INTERRUPT
;				1. TTEDIT - EDITS AND ECHOS
;			D. XMTINT -  TRANSMIT INTERRUPT
;				1. GETCHR
;				2. TYP
;	VI.	PSUEDO-TELETYPE SERVICE ROUTINES
;			A. PTYGET
;			B. PTYCLR
;			C. PTYUUO
;DATA STRUCTURES AND PARAMETERS

;	DEFINED ON CONFIGURATION TAPE
;		SCNLIN=OCTAL NO. OF SCANNER LINES (0 THRU SCNLIN-1)

;	DEFINED BELOW
;		TRANSLATOR TABLE PARAMETERS
;		TTYLEN=SCNLIN+DPYNUM+1	LENGTH OF TTY TRANSLATOR TABLE (INCLUDING CTY)
;		TTYTAB:	BLOCK TTYLEN	TTY TRANSLATOR TABLE
;			SIGN BIT=1 IF COMMAND JUST TYPED
;			BIT 1 = 1  IF DELAYED COMMAND
;			BITS 3-10 = UNUSED
;			BITS 11-17=TALK RING LINE # (PTALK)
;			BITS 18-35=ADDR. OF DEVICE DATA BLOCK 
;				FOR THIS LINE.
;		DEVOPR:	0	SIXBIT PHYSICAL NAME OF OPERATORS
;				CONSOLE SET BY SCNIN0 TO FIRST
;				ACTIVE TTY.

;	DEFINED BELOW
;		LINE NUMBER PARAMETERS
;		TCONLN=SCNLIN	CTY LINE NUMBER
;		MTTYLN=-TTYLEN	-LENGTH OF TRANSLATOR TABLE
;		FSNCHN=SCNCHN*101	CHANNEL ASSIGNMENT FOR
;				FULL DUPLEX SCANNER
;		TTYLST=TTY0DB	FIRST TTY DEVICE DATA BLOCK

;TTY DEVICE DATA BLOCK FORMAT

;THE FOLLOWING ARE DEFINITIONS OF THE RELATIVE LOCATIONS OF THE
;BUFFER PARAMETER WORDS OF THE DEVICE DATA BLOCK FOR EACH BUFFER, WITH
;TTX'BUF AS THE BASE (DETAILED DESCRIPTIN IN SCNDDB COMMENTS):

	XP	BUF,0		;BUF(DAT) CONTAINS POINTER TO BEG. OF CURRENT BUFFER
	XP	↑PUTR,1		;PUTR(DAT)-PUTS CHARCTERS INTO BUFFER
	XP	PCTR,2		;NUMBER OF TIMES TO INCR. PUTR BEFORE REINITING
	XP	↑TAKR,3		;TAKER POINTER TO PICK UP CHARACTERS
	XP	TCTR,4		;COUNT OF NUMBER OF TIMES TAKR CAN BE INCREMENTED
	XP	↑FCTR,5		;COUNT OF FREE SPACES LEFT IN BUFFER
	XP	TSYNC,6		;LOCATION OF TISYNC RELATIVE TO DAT


;		DEVNAM:	PHYSICAL DEVICE NAME SET UP DYNAMICALLY
;			VIA SCNIN0.
;		DEVCHR:	LEFT HALF IS STANDARD
;			BITS 18-24=LINE NUMBER(BYTE POINTER=PUNIT)
;			BITS 25-35=MONITOR BUFFER SIZE + 1(BYTE POINTER=PDVBLN)
;IOS BITS
;		DEVIOS:	LEFT HALF
;			1,2,4,20,40 ARE STANDARD
			↑USRB←←100	;SET TTY TO USER MODE
					;WHEN OUTPUT FINISHES
					;TILL NEXT INPUT OR INIT (↑O).
			↑TPMON←←400	;TTY IS IN MONITOR
					;COMMAND MODE.
			DDTM←←1000	;DDT MODE
			↑↑TTYDTC←←2000	;TTY DDB IS DETACHED FROM LINE
			↑TOIP←←10000	;TYPE-OUT IN PROGRESS
					;TAKER IS BEHIND PUTR
			SYNC←←20000	;BREAK CHARACTER SEEN
					;SIGNAL TO INCREMENT SYNC COUNT
					;FOR BUFFER INVOLVED
			IMLTTY←←40000	;IMLAC IS IN TTY MODE FOR NEXT CHARACTER
			TTYHLD←←100000	;TYPEOUT HOLD (BO)
			SNKWAT←←200000	;SNEAK PREVIEW WAIT FLAG!
			TTYIOW←←400000	;TTY INPUT WAIT BIT

;		RIGHT HALF BITS (USER MODE)
			IOSUPR←←1000	;SUPPRESS ALL OUTPUT
			BKSP←←100	;FULL CHARACTER SET. PASS
					;ON ALL CHARACTERS EXCEPT ↑C
					;NO SPECIAL CHARACTER PROCESSING
			NOECHO←←200	;ECHO SUPPRESSION REQ BY PROG
			NOECHB←←400	;SUPPRESS ECHO OF CTRL BITS
			MERTP1←←2000	;DURING ERROR TYPEOUT THIS MEANS
					;THE INPUT BUFFER IS IN USE.
			MERTPO←←IOIMPM	;MONITOR ERROR TYPE-OUT
;		DEVSER:	STANDARD
;		DEVBUF:	STANDARD
;		DEVIAD:	BITS 6-12=HORIZONTAL POSITION (BYTE
;				POINTER = PHPOS).
;			BITS 13-35 ARE STANDARD.
;		DEVOAD:	BITS 0-8=NUMBER OF CHARACTERS TO FIT
;				;INTO OUTPUT BUFFER
;				(POINTER= PFITCH)
;			BITS 13-35 ARE STANDARD
IFNDEF FTDDTM,<FTDDTM←←-1>	;NON-ZERO TO INCLUDE CALLI DDTIN,OUT
;LINE BITS, LINE # DEFS
;DEFINITION OF LINE CHARACTERISTICS TABLE BITS
;LINTAB MADE BY SYSTEM BUILDER
;FOLLOWING IS FORMAT AS SET UP BY SCNINI
;	XWD BITS,LOGICAL LINE#

↑DISLIN←←400000			;THIS LINE IS TO A DISPLAY KEYBOARD
↑CTYLIN←←200000			;THIS "LINE" IS CONSOLE DEVICE "TTY"
TTYFIL←←100000			;THIS LINE IS IN "FILL" MODE
↑DDDLIN←←20000			;DATA DISK DISPLAY LINE
M37←←10000			;MODEL 37 TTY
↑PTYLIN←←4000	;PSEUDO-TTY.
IMLIN←←2000			;THIS IS AN IMLAC

APLINE←←12			;LINE # OF AP LINE
NYLINE←←13			;LINE # OF NY LINE
IMSSS←←7			;SUPPES

	;ABOVE ARE "PERMANENT" CHARACTERISTICS

↑TLKRNG←←1			;THIS LINE CURRENTLY IN A TALK RING
XON←←2				;↑Q TYPED, PAPER TAPE INPUT
FULTWX←←4			;SELF ECHOING FUL DUPLEX
TBXPND←←10			;EXPAND TABS (SOMETIMES PERMANENT SOMTIMES CHANGEABLE)
FCS←←20				;FULL CHAR SET MODE
ROBTPD←←40			;RUBOUT TYPED LAST (ECHO \ BEFORE NEXT CHAR.)
SPCBRK←←100	;SPECIAL ACTIVATION MODE... EVERYTHING EXCEPT LETTERS AND NUMBERS IS A  BREAK CHAR.
PTYUSE←←200	;;PTY LINE IN USE... DO NOT KILL DDB AT TTYKIL.
PTYWAK←←400		;SAYS PTY INPUT WAIT MAY BE TERMINATED BY TTY INPUT.
↑IMPBIT←←1000			; THE GUY ON THE OTHER END OF THIS PTY IS AN IMP
LERSEE←←40000	;USER WANTS TO SEE EVERYTHING TYPED TO
		; DPY LINE EDITOR DURING RE-EDITS. SEE LINED.


;ABOVE ARE TEMPORARY BITS, TURNED ON AND OFF BY VARIOUS MEANS
;(BY MONITOR, TYPE-IN COMMANDS, OR PROGRAM)

		;BITS BELOW CAN BE SET OR ZEROED BY PROGRAM
LGLSET←←TBXPND!TTYFIL!FCS!XON!SPCBRK!PTYWAK!IMPBIT!FULTWX!LERSEE
KILMSK←←ROBTPD!TLKRNG!XON!SPCBRK!PTYLIN!PTYWAK!IMPBIT!LERSEE	;CLEARED AT TTYKIL

; THESE ARE INSERTED HERE BECAUSE THEY AREN'T DEFINED ANYWHERE ELSE
; IN THIS SYSTEM

GLOBAL TTPLEN	;STUPID FAIL
MTTYLN←←-TTPLEN		; MINUS NUMBER OF TELETYPES, TOTAL
↑TCONLN←←SCNNUM+DPYNUM+DDNUM
↑PTYL0←←TCONLN+1		;FIRST PTY LINE NO.
↑DPYL0←←SCNNUM
↑DDL0←←DPYL0+DPYNUM
FSNCHN←←SCNCHN*101		; SCANNER PI CHANNEL ASSIGNMENTS

;AC'S, BYTE POINERS, CTLV
;ACCUMULATOR ASSIGNMENTS

	CHR←TEM		;AC FOR CHARACTER
	LINE←TAC1		;SCANNER LINE NUMBER
	HPOS←ITEM		;HORIZONTAL POSITION OF TTY.(0-71)


	;SPECIAL SYMBOLS

	SCNON←←1B25!1⊗(7-SCNCHN)
	SCNOFF←←1B26!1⊗(7-SCNCHN)

	IDLECH←←1		;DELAY CHAR FOR TABS, ETC.
				; SHOULD BE ↑V, BUT FOR 37'S


;BYTE POINTERS

PFITCH:	POINT 9,DEVOAD(DDB),8		;NR OF CHARACTERS TO FIT
PHPOS:	POINT 7,DEVIAD(DDB),12	;HORIZONTAL POSITION

IFN FTTALK,<
↑PTALK:	POINT PUNITS,TTYTAB(LINE),17	;POINTER TO ANOTHER TTY IN TALK RING
					;(SAME SIZE BYTE AS SYS UNIT #)
>


↑PLASTC:
	POINT 7,TTYPTR(DDB),35	; FOR ECHO CHECKING ON HDX LINES
↑PCOMIC:
	POINT 9,TTYPTR(DDB),19	; FOR RESCANNING COMMAND INPUT LINE
				;"COMMAND INPUT COUNTER" SAVES TITCTR
PLSTLC:	POINT 9,TTYPTR(DDB),28	;FOR ↑U DELETION

;TTYPTR CONTAINS THE FOLLOWING BYTES:
;
;	0-3	SPARE
;	4-10	PTYJOB, FOR NO. OF JOB OWNING THE PTY (IF ANY) USING THE DDB.
;	11-19	PCOMIC, FOR COMMAND RESCAN
;	20-28	PLSTLC, FOR ↑U
;	29-35	PLASTC, FOR ECHO CHECKING HALF DUPLEX LINES

↑CTLV1:	PUSHJ P,TTYFNU
	MOVEI IOS,NOECHO
	XORM IOS,DEVIOS(DDB)
	POPJ P,
;LINBIT, TTYINI
;SCNINI IS CALLED AT SYSTEM INITIALIZATION TIME FROM
;IOGO IN SYSINI VIA DISPATCH TABLE
;IT	1)CLEARS ALL RECEIVER FLAGS,
;	2)CLEARS THE PHYSICAL NAME (DEVNAM) OF ALL UNUSED
;	  (TTYUSE=0) TTY DEVICE DATA BLOCKS,
;	3)SETS DEVIOS TO XWD TPMON+IOFST,0  IN ALL TTY DEVICE
;	  DATA BLOCKS,
;	4)SETS TTYUSE=1 IN ALL TTY DDBS IN THE TRANSLATOR TABLE.

DEFINE BITS(X),<XWD X,.-LINBIT>

LINBIT:	
REPEAT 10,<BITS	TBXPND!FCS
>				;0-7 ARE MODEL 33
REPEAT 2,<BITS TBXPND!FCS
>				;10,11 DATAPHONES
REPEAT 3,<BITS	TBXPND!M37!FCS
>				;12-14 ARE MODEL 37
REPEAT 3,<BITS	IMLIN!FCS
>				;15-17 ARE IMLACS
REPEAT DPYNUM,<BITS	DISLIN!FCS
>
REPEAT DDNUM,<BITS DDDLIN!FCS>
	BITS	CTYLIN
REPEAT PTYNUM,<BITS 0>		;JUST IN CASE SOMEONE LOOKS HERE
;END OF BIT TABLE

↑TTYINI:
	PUSHJ	P,DWPINI		;LET JAM THROW AWAY THE DPY FREE STORAGE
					;BEFORE WE DO OUR BUGEY!
IFN DILNUM,<PUSHJ P,DILINI>		;INITIALIZE DIALER STUFF
	MOVSI	LINE,-TCONLN-1		;REAL TTY'S ONLY
SCN0:	MOVE	TAC,LINBIT(LINE)	;GET PERMANENT LINE CHARACTERISTICS
	HRRM	TAC,LINTAB(LINE)	;SET LOG. LINE NUMBERS
	IORB	TAC,LINTAB(LINE)	;SET SIGNIFICANT BITS
	TLZ	TAC,KILMSK		;ZAP INSIGNIFICANT BITS
	HLLM	TAC,LINTAB(LINE)	;LEAVING REST OF BITS AS THEY WERE
	AOBJN	LINE,SCN0

	CONO	CTY,3600!CTYCHN		; CLEAR	CTY, ASSIGN CHANNEL
	CONO	DKB,10!SCNCHN		; CLEAR DDD TTY SCANNER AND ASSIGN CHANNEL
	PUSHJ	P,SCNINI		;DEVICE DEPENDENT SCANNER INIT
	SETZM	TTYTAB
	SETZM	COMCNT			;NO COMMANDS TO PROCESS
	MOVE	TAC,[XWD TTYTAB,TTYTAB+1]
	BLT	TAC,TTYTAB+TTPLEN-1	;CLEAR ALL DDB ADDRESSES
	MOVE	TAC,[TCONLN,,TTYLST]	;INIT CTY TO USE DDB IN ALLDAT
	MOVEM	TAC,TTYTAB+TCONLN	;  BH 5/6/74
	SETZM	PAGNOW
	SETZM	ASBTAB			;CLEAR ALL BEEP DURATIONS
	MOVE	TAC,[ASBTAB,,ASBTAB+1]
	BLT	TAC,ASBTAB+DPYNUM+DDNUM-1
	SKIPL	TTYLOK
	SKIPE	MAINTM
	JRST	NOASIN			;DON'T INIT AUDIO SW IF SYS NOT FOR REAL
	SETZM	ASTAB
	MOVE	TAC,[ASTAB,,ASTAB+1]
 	BLT	TAC,ASTAB+DPYNUM+DDNUM-1
NOASIN:	HRRZS 	TTYLST+DEVSER		;CLEAR DDB CHAIN
	SETZB	IOS,TTYLST+DEVIOS	;SO DDB WILL GET FLUSHED
;	MOVEI	DDB,TTYLST		;2 LINES COMMENTED OUT BH 5/6/74
;	PUSHJ	P,TTYKIL		;HERE.
	MOVEI	ITEM,JOBN-1		;REGENERATE DDB'S FOR ALL LIVE JOBS
SCNC1:	MOVE	TAC,JBTSTS(ITEM)
	TLNN	TAC,JNA			;IS THIS A JOB
	JRST	SCNC3			;NO, IGNORE HIM.
	HRRE	LINE,JBTLIN(ITEM)	;GET LINE HE IS USING
	JUMPL	LINE,SCNC2		;DETACHED LINE
	PUSHJ	P,DDBSRC		;GET HIM A DDB
	JRST	SCNC3			;IF NO DDB AVAILABLE OR NO LINE OR DETACHED
	PUSHJ	P,TTYATI		;ATTACH JOB
	TLNE	LINE,PTYLIN
	SKIPE	PTYJOB-PTYL0(LINE)	;IS THIS PTY REALLY ATTACHED TO SOMEONE?
	JRST	SCNC3			;YES
	PUSHJ	P,TTYDET		;NO, DETACH HIM.
	JRST	SCNC3			;NEXT PLEASE
SCNC2:	TLNE	TAC,JSEG		;IS IT AN UPPER SEGMENT?
	JRST	SCNC3			;YES, NO DDB FOR HIM
	MOVNI	LINE,1			;YES, GET A DETACHED LINE
	PUSHJ	P,DDBSRC		;GET DDB
	JRST	SCNC3
	DPB	ITEM,PJOBN
SCNC3:	SOJG	ITEM,SCNC1
;MORE TTYINI, SCNINI
; HERE WE GET THE DDB'S FOR THE REST OF THE TTY'S (I.E., NOT
; THE ONES ATTATCHED TO JOBS ALREADY).

	MOVSI	LINE,-TTPLEN+PTYNUM		;SET DDB USE BITS FROM TRANSLATOR TABLE
SCN2:	MOVSI	IOS,600000
	ANDCAM	IOS,TTYTAB(LINE)		;NO COMMAND WAITING !
	HRRZ	TAC,LINE
	CAIGE	TAC,PTYL0			;PTY LINE?
	JRST	NOTPTY
	SKIPN	TTYTAB(LINE)			;DOES HE HAVE A DDB
	JRST	SCN6
	HRLI	TAC,PTYLIN!PTYUSE!XON		; MAGIC PTY BITS
	MOVEM	TAC,LINTAB(LINE)		; INITIALIZE THIS PTY
	JRST	SCN3				; STUFF IN 0'S
SCN6:	SETZM	PTYJOB-PTYL0(LINE)
	SETZM	LINTAB(LINE)		;CLEAR PTY BITS
	JRST	SCN3
NOTPTY:	SKIPE	TTYTAB(LINE)		; IS THERE A DDB ADDRESS THERE?
	JRST	SCN3
	SKIPE	TTYLOK
	CAIN	TAC,TCONLN
	CAIA
	JRST	SCN3
	PUSH	P,LINE
	HRRZ	LINE,LINE
	CAIL	LINE,DPYL0
	CAIL	LINE,DDL0+DDNUM
	CAIA
	JRST	SCN5			;FOR DPYS ONLY
	CAIE	LINE,IMSSS
	CAIN	LINE,APLINE
	JRST	.+5		;DON'T MAKE DDB (I.E. DON'T TYPE OUT) ON THESE LINES
	CAIN	LINE,NYLINE
	JRST	.+3
	PUSHJ	P,DDBSRC		;MAKE TTY DDB AND SET UP TTYTAB
	JFCL
	POP	P,LINE
SCN3:	AOBJN	LINE,SCN2
	SETZM LINSAV	;SO INIT. MESSAGE WILL GET TO EVERYONE.
	POPJ P,		;ALL DONE

SCN5:	POP	P,LINE
	JRST	SCN3

;DEVICE DEPENDENT PORTION OF INITIALIZATION CODE
;CALL:	MOVEI	TAC,CHANNEL NUMBER
;	PUSHJ	P,SCNINI

SCNINI:	MOVEI	TAC,100000
	CONO	DCSA,4010	;RELEASE XMITTER, RECEIVER
	CONSZ	DCSA, 1000
	CONO	DCSA, 4000
	CONSZ	DCSA, 10
	DATAI	DCSB, LINE
	SOJG	TAC,.-4
	CONO	DCSA,FSNCHN	;ASSIGN INTERRUPT CHANNELS
	POPJ	P,
;TTYCOM, TTYCM, CNTCOM, COMBCK
;ROUTINE TO SETUP AC DDB TO ADDRESS OF TTY WHICH HAS TYPED A COMMAND
;AC DAT TO BYTE POINTER TO OUTPUT BUFFER FOR COMMAND MESSAGES
;AC ITEM TO JOB NUMBER TTY IS ATTACHED TO
;CALL:	PUSHJ P,TTYCOM
;	NONE FOUND
;	AC'S SETUP
;CALLED FROM COMMAND

↑TTYCOM:
	SKIPGE	LINE,LINSAV
	JRST	TTYCM1			;GIVE SOMEONE ELSE A CHANCE
	MOVSI	LINE,MTTYLN
	SKIPL	TAC,TTYTAB(LINE)
TTYCM1:	AOBJN	LINE,.-1
	MOVEM	LINE,LINSAV
	JUMPG	LINE,CPOPJ
	HRRZ	DDB,TTYTAB(LINE)
	JUMPE	DDB,TTYCM2		;IT HAPPENS!!!!
	MOVE	DAT,DEVMOD(DDB)
	TLNN	DAT,TTYATC		;IS HE ATTACHED TO IT BY JOB?
	TRNN	DAT,ASSCON!ASSPRG	;NO, ASSIGNED OR INITED TTY'S CAN'T TYPE COMMANDS
	JRST	.+2
	JRST	TTYCM2			;(THIS CAN'T HAPPEN (IT SAYS SO IN COMSET))
	MOVEI	DAT,TTIBUF(DDB)		;SO GETCHR CAN BE CALLED FROM COMCON
	MOVE	LINE,TITCTR(DDB)
	DPB	LINE,PCOMIC		;SAVE COMMAND INPUT COUNTER
	LDB	LINE,PUNIT		;LINE NO.
	LDB	J,PJOBN			;JOB NO. TTY ATTACHED TO
	MOVSI	CHR,TTYATC
	TDNN	CHR,DEVMOD(DDB)
	MOVEI	J,0			;NO JOB ATTACHED TO THIS TTY
	TLNN	TAC,DLYBIT		;IS THIS A DELAYED COMMAND?
	JRST	CPOPJ1			;NO, RETURN TO SCAN IT
	MOVSI	TAC,DLYBIT		;INDICATE NO LONGER DELAYED COMMAND
	ANDCAM	TAC,TTYTAB(LINE)
	JRST	CPOPJ1			;RETURN TO COMMAND SCAN

↑TTYCM:	MOVE	LINE,LINSAV		;HERE WHEN COMMAND MUST BE DELAYED
	MOVSI	DDB,DLYBIT		;INDICATE DELAYED COMMAND
	IORB	DDB,TTYTAB(LINE)
	PUSHJ	P,TRESCN		;BACK UP TO START OF COMMAND
	MOVE	LINE,LINSAV		;TRESCN HAS CALLED STLNAC
	JRST	TTYCM1			;LOOK FOR OTHER COMMAND TO PROCESS

TTYCM2:	PUSHACS
	PUSH	P,DDB
	PUSH	P,LINE
	PUSHJ	P,DISMES
	ASCIZ	/COMMAND BIT SET AND NO DDB, OR TTY ASSIGNED: TTY /
	POP	P,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/, DDB= /
	POP	P,TAC	
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	POPACS
	MOVSI	DDB,COMBIT!DLYBIT	;CLEAR THESE BITS!
	SOS	COMCNT			;FIX COMCNT
	ANDCAM	DDB,TTYTAB(LINE)
IFN FTTTYBUG,<
	PUSHJ	P,COMBCK
	PUSHJ	P,CNTCOM	;MAKE SURE ALL IS OK
>
	JRST TTYCM1		;LET COMMAND FIGURE OUT THAT COMCNT IS MAYBE NOW ZERO

IFN FTTTYBUG,<
;WELL, WE FIXED THIS PROBLEM, I THINK. 12/1/73 

;THIS AWFUL KLUDGE IS TO HELP SOLVE THE COMCNT MYSTERY
;IF IT STAYS FOR MORE THAN TWO WEEKS, I SHOULD BE SHOT.  REG 10/5/73
↑CNTCOM:
	PUSH	P,TAC
	PUSH	P,TAC1
	CONI	PI,TAC1
	ANDI	TAC1,SCNOFF-1000	;SCANNER CHANNEL ACTIVE BIT
	PUSH	P,TAC1
	CONO	PI,SCNOFF		;TURN OFF THE SCANNER
	MOVEI	TAC1,0
	MOVSI	TAC,MTTYLN
	SKIPGE	TTYTAB(TAC)
	ADDI	TAC1,1
	AOBJN	TAC,.-2
	CAMN	TAC1,COMCNT
	JRST	CNTCM1
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/COMCNT & TTYTAB DISAGREE.  CALLER = /
	MOVE	TAC,-23(P)
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/ COMCNT= /
	MOVE	TAC,COMCNT
	PUSHJ	P,DISLOC
	PUSHJ	P,DISTAB
	MOVE	TAC,TAC1-17(P)
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	MOVE	TAC,TTCBCK
	PUSHJ	P,DISOCT
	PUSHJ	P,DISTAB
	MOVE	TAC,TTCBCK+1
	PUSHJ	P,DISOCT
	PUSHJ	P,DISTAB
	MOVE	TAC,TTCBCK+2
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
↑COMBUG:	JRST	.+3			;PATCH HERE TO STOP THE WORLD
	PUSHJ	P,DISFLUSH
	PUSHJ	P,DDTCALL
	POPACS
	MOVEM	TAC1,COMCNT		;FIX IT!
CNTCM1:	POP	P,TAC1
	CONO	PI,2000(TAC1)
	POP	P,TAC1
	POP	P,TAC
	POPJ	P,

;THE 23% OVERKILL, CALL IMMED AFTER IORM OR ANDCAM OF TTYTAB
↑COMBCK:	PUSH P,IOS
	PUSH P,TAC
	MOVE TAC,-2(P)
	MOVE IOS,-2(TAC)	;FETCH IORM OR ANDCAM
	POP P,TAC
	HRRI IOS,@IOS
	TLZ IOS,37
	PUSH P,IOS
	LDB IOS,[270400,,IOS]	;AC FIELD
	SKIPN IOS
	SKIPA IOS,-1(P)
	MOVE IOS,@IOS
	JUMPGE IOS,[	POP P,IOS	;NOT COM BIT
			POP P,IOS
			POPJ P,]
	POP P,IOS		;GET INSTRUCTION BACK
	PUSH P,TAC
	PUSH P,TAC1
	PUSH P,AC1
	TLNN IOS,020000		;IORM=436, ANDCAM=412 (SKIP IF IORM)
	TLZ IOS,400000		;INDICATE ANDCAM
	HRRZ TAC,IOS
	SUBI TAC,TTYTAB		;LINE NUMBER
	JUMPL	TAC,COMBCX
	CAIL	TAC,TTPLEN
	JRST	COMBCX
	IDIVI TAC,=36		;TAC←INDEX INTO TTCBCK, TAC1←SHIFT CNT
	MOVEI AC1,1
	LSH AC1,(TAC1)
	SKIPL IOS
	ANDCAM AC1,TTCBCK(TAC)
	SKIPGE IOS
	IORM AC1,TTCBCK(TAC)
COMBCY:	POP P,AC1
	POP P,TAC1
	POP P,TAC
	POP P,IOS
	POPJ P,
COMBCX:	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/AT COMBCK WITH INVALID INDEX = /
	MOVE	TAC,TAC-17(P)
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	JRST	COMBCY
>;END FTTTYBUG
;TTYATI, TTYSUB
;ROUTINE TO ATTACH TTY TO A JOB
;CALL:	MOVE DDB,ADDRESS OF TTY DEVICE DATA BLOCK
;	MOVE ITEM,JOB NUMBER
;	PUSHJ P,TTYATT
;	OK RETURN	;DDB, DAT AND TRANSLATOR TABLE SET

;CALLED FROM COMCON (ATTACH) AND COMCSS (JOBINI).
;ON OK RETURN	1)SETS TTYATC
;		3)PUTS ADDRESS OF ATTACHED DDB INTO DDB.
;		4)SETS PHYSICAL NAME TO SIXBIT /TTY LINE #/
;		  OR SIXBIT /CTY/,
;		5)SETS DEVOPR IF IT IS NON-ZERO.


IFE FTATTACH,<
↑TTYATT:
	>
;COME HERE TO ATTACH TTY IN DDB TO JOB IN ITEM.
↑TTYATI:
	PUSHJ	P,STLNAC		;SETUP LINE
	MOVEM	LINE,JBTLIN(ITEM)	;SET LINE # FOR JOB
	DPB	ITEM,PJOBN		;SET JOB NUMBER OF OWNER
	MOVSI	TAC,TTYATC		;MAKE IT ATTACHED TO JOB
	IORM	TAC,DEVMOD(DDB)
	MOVSI	IOS,TTYDTC		;MAKE DDB ATTACHED TO TTY
	ANDCAB	IOS,DEVIOS(DDB)
	POPJ	P,

;CLOCK LEVEL (CONSOLE) "TTY" COMMAND
↑TTYSUB:HRRZS (P)			;USE STACK AS FLAG
TTYSB1:	PUSHJ P,CTEXT1			;READ TTY COMMAND
	JUMPE TAC1,[CAIE TEM,"-"	;ALLOW - ALSO
		JRST NOTENF		;NOPE
		PUSHJ P,GETLCCHR	;YES, GOBBLE TO NEXT CHAR SO WE DON'T LOOP
		HRROS (P)		;FLAG -
		JRST TTYSB1]
	CAMN TAC1,['NO    ']
	JRST [	HRROS (P)		;FLAG 'NO' SEEN
		JRST TTYSB1]		;NOTE THAT REPEATED 'NO' IS OK, BUT DOESN'T COMPLEMENT
	MOVSI TAC,-TCOMLN
TCOMLP:	CAMLE TAC1,TCOMND(TAC)
	AOBJN TAC,.-1
	JUMPGE TAC,COMERA		;ERROR, COMMAND NOT FOUND
	CAMN TAC1,TCOMND(TAC)
	JRST TCMGOT
	MOVE AC2,TAC1
	SKIPA AC1,[770000,,0]
TCMMSK:	ASH AC1,-6
	ANDCM AC2,AC1
	JUMPN AC2,TCMMSK
	MOVE AC2,TCOMND(TAC)
	AND AC2,AC1
	CAME AC2,TAC1			;PARTIAL MATCH ON CURRENT WORD?
	JRST COMERA			;NO
	HLRE AC2,TAC
	AOJE AC2,TCMGOT			;ONLY COMMAND LEFT?
	AND AC1,TCOMND+1(TAC)
	CAMN AC1,TAC1
	JRST COMERA			;TOO MANY MATCHES
TCMGOT:	PUSHJ P,STLNAC
	JRST @TCOMDS(TAC)
;TTYSUB TABLES
;"TTY" COMMANDS, MUST BE IN ALPHABETICAL ORDER
DEFINE TNAMES
<
	.TMAC	ECHO,TTECHO
	.TMAC	FILL,FILTTY
	.TMAC	FULL,TTFULL
	.TMAC	TABS,TTTAB
	.TMAC	TIME,TTYTIM
	.TMAC	UPDATE,TTYUPD
	.TMAC	WHO,TTYWHO
>

DEFINE .TMAC(A,B)
<	SIXBIT/A/
>

XLIST
TCOMND:	TNAMES
TCOMLN←←.-TCOMND
LIST

DEFINE .TMAC(A,B)
<	B
>

XLIST
TCOMDS:	TNAMES
LIST
;FILL, ECHO, FULL, TABS, TIME, WHO
FILTTY:	TLNE LINE,DISLIN!DDDLIN		;THESE GUYS MAY SCREW UP
	POPJ P,
	SKIPGE (P)			;'NO' TYPED?
	TLZA LINE,TTYFIL		;YES, DO NOFILL
	TLO LINE,TTYFIL			;FILL CR'S
STOLIN:	HLLM LINE,LINTAB(LINE)
	POPJ P,

TTECHO:	SKIPGE (P)			;'NO' TYPED?
	TLOA LINE,FULTWX		;YES, SET AS FULL DUPLEX
	TLZ LINE,FULTWX			;CLEAR FULL DUPLEX
	JRST STOLIN

TTFULL:	SKIPGE (P)
	TLZA LINE,FCS
	TLO LINE,FCS
	JRST STOLIN

TTTAB:	SKIPGE (P)
	TLOA LINE,TBXPND		;EXPAND
	TLZ LINE,TBXPND			;DON'T EXPAND
	JRST STOLIN

TTYUPD:	JUMPE	J,CPOPJ			;IF NO JOB, NO XTIME
	MOVSI	TAC,400000		;THIS IS THE NO-UPDATE BIT IN XTIME
	SKIPGE	TAC1,(P)		;'NO' TYPED?
	ORM	TAC,XTIME(J)		;YES.  SET NO-UPDATE BIT.
	JUMPL	TAC1,.+2		;'NO' TYPED?
	ANDCAM	TAC,XTIME(J)		;NO.  CLEAR NO-UPDATE BIT.
	POPJ	P,

TTYTIM:	JUMPE	J,CPOPJ			;NO JOB, NO XTIME
	MOVSI	TAC,400000		;THE NO-UPDATE BIT IN XTIME
	SKIPL	TAC1,(P)		;'NO' TYPED?
	ADD	TAC,TTIME(J)		;NO.  UPDATE XTIME AND SET NO-UPDATE BIT
	MOVEM	TAC,XTIME(J)		;IF 'NO' TYPED, CLEAR XTIME AND SET NO-UPDATE.
	HRRZS	DSKOPS(J)		;MAKE ALL DISK OPERATIONS "RECENT"
	SETZ	TAC,			;ASSUME NO WAIT TIME
	JUMPL	TAC1,TTYTI1		;'NO' TYPED?
	HRLS	DSKOPS(J)		;NO.  MAKE NO DISK OPS RECENT
	SKIPGE	TAC,JBTWAT(J)		;GET WAIT TIME
	ADD	TAC,UPTIME		;MAKE IT HONEST
TTYTI1:	MOVEM	TAC,JB2WAT(J)		;SAVE CURRENT WAIT TIME
	POPJ	P,

TTYWHO:	SKIPL	(P)			;'NO' TYPED?
	JRST	UWHO			;NO NO.
TTWHSY:	MOVEI	AC3,COMWHO+2		;TYPE OUT SYSTEM WHO LINE
	JRST	UWHO1

UWHO:	PUSHJ	P,DECIN
	SKIPA	TAC1,J			;NO ARG, USE OUR JOB #
	JRST	COMERA			;LOSE
	JUMPE	TAC1,TTWHSY		;0 ARG, OR NO ARG & NOT LOGGED IN
	CAIL	TAC1,JOBN		;TOO BIG?
	JRST	NOTLOG			;YES
	MOVE	TAC,JBTSTS(TAC1)
	TLNN	TAC,JNA			;IS IT A JOB?
	JRST	NOTLOG			;NO
	PUSH	P,J			;SAVE J
	PUSH	P,DDB			;AND DDB ON STACK
	MOVE	J,TAC1
	MOVEI	AC1,TITLE		;USE WHO LINE MODEL
	SETZ	DDB,			;FLAG THAT IT IS TTY CALLING
	PUSHJ	P,WHOLIN
	POP	P,DDB			;RESTORE DDB
	POP	P,J			;AND J
	MOVEI	AC3,WTTYS		;START HERE
UWHO1:	SKIPN	AC2,(AC3)		;PICKUP WORD AND CHECK FOR END
	POPJ	P,			;DONE
	TRZN	AC2,1			;TEXT WORD?
	AOJA	AC3,UWHO1		;NO
	MOVE	AC1,[POINT 7,AC2]	;YES, MAKE BYTE POINTER
UWHO2:	TLNN	AC1,760000
	AOJA	AC3,UWHO1
	ILDB	TEM,AC1			;UNPACK THE CHARACTERS
	JUMPE	TEM,UWHO2
	PUSH	P,AC1
	PUSH	P,AC2
	PUSH	P,AC3
	XCT	TYO			;OUTPUT THE CHAR.
	POP	P,AC3
	POP	P,AC2
	POP	P,AC1
	JRST	UWHO2

↑WHOUUO:XCTR XR,[HRRZ UUO,(UCHN)]	;POINTER TO WHERE USER WANTS STRING
	HRLI UUO,(<POINT 7,0>)		;MAKE IT BYTE POINTER
	MOVEI AC3,COMWHO+2		;SKIP SOME SPACES
	XCTR XR,[HLRE TAC,(UCHN)]	;GET JOB NUMBER FIELD
	JUMPL TAC,WHOUU1		;IF -, JUST REPORT SYSTEM WHO LINE
	JUMPE TAC,.+2
	CAIL TAC,JOBN
	MOVE TAC,J			;ZERO OR >JOBN IS US
	MOVE TAC1,JBTSTS(J)
	TLNN TAC1,JNA			;JOB THERE?
	JRST WHOUU2			;NO, ZERO STRING
	PUSH P,J
	MOVE J,TAC
	MOVEI AC1,TITLE			;USE PROTOTYPE
	SETZ DDB,			;FLAG WHOSER NO TTY HERE
	PUSHJ P,WHOLIN
	POP P,J
	MOVEI AC3,WTTYS			;WHERE TO PICKUP STRING FROM
WHOUU1:	SKIPN AC2,(AC3)
	JRST WHOUU2			;FINISH OUT WORD WITH NULLS
	TRZN AC2,1			;TEXT WORD?
	AOJA AC3,WHOUU1			;NO, CHECK NEXT WORD
	MOVE AC1,[POINT 7,AC2]
WHOUU0:	TLNN AC1,760000
	AOJA AC3,WHOUU1
	ILDB TEM,AC1
	JUMPE TEM,WHOUU0
	XCTR XLB,[IDPB TEM,UUO]
	JRST WHOUU0

WHOUU2:	SETZ TEM,			;MAKE IT ASCIZ STRING
WHOUU3:	XCTR XLB,[IDPB TEM,UUO]
	TLNE UUO,760000
	JRST WHOUU3
	POPJ P,
;TTYATT
;COME HERE TO ATTACH TTY TO DDB THAT JOB IS ALREADY ATTACHED TO
;AND FLUSH OLD DDB IF NECESSARY.
IFN FTATTACH,<
↑TTYATT:
	PUSHJ	P,STLNAC		; GET LINE CHARACTERISTICS
	MOVEI	DDB,TTYLST		;SEARCH FOR DDB THAT IS ATTACHED
	JRST	.+2
TTYAT2:	HLRZ	DDB,DEVSER(DDB)
	JUMPE	DDB,CPOPJ		;HAVE ALL TTY DDB'S BEEN LOOKED AT?
	LDB	TAC,PJOBN		;NO, GET JOB NUMBER.
	HLL	TAC,DEVMOD(DDB)		;ATTACH AND USE BITS
	TLNN	TAC,DVTTY		;IS THIS STILL A TTY DDB?
	JRST	TTYAT2			;NO, THIS MUST BE IJOB.
	MOVE	IOS,DEVIOS(DDB)
	CAIN	ITEM,(TAC)		;JOB NUMBER THE ONE TO ATTACH?
	TLNN	TAC,TTYATC		;YES, IS DDB ATTACHED TO JOB?
	JRST	TTYAT2			;NO, KEEP LOOKING.
	TLNN	IOS,TTYDTC		;IS DDB DETACHED FROM LINE?
	POPJ	P,			;NO, ERROR RETURN WITH DDB SET
	PUSH	P,DDB			;SAVE NEW DDB ADDRESS.
	MOVE	DDB,TTYTAB(LINE)	;ZAP, CHANGE LINES
	LDB	TAC,PJOBN		;GET JOB # OF OLD DDB
	JUMPN	TAC,TTYAT3		;IF IT'S ZERO
	MOVSI	TAC,IO!TOIP		;THEN CLEAR THESE BITS
	ANDCAM	TAC,DEVIOS(DDB)		;SO DDB GETS KILLED BY TTYDET
TTYAT3:	PUSHJ	P,TTYDET		;DO YO STUFF
	POP	P,DDB			;GET BACK NEW GUY
	MOVEM	DDB,TTYTAB(LINE)	;TTYDET CLOBBERS THIS.
IFN FTTTYBUG,<	PUSHJ	P,CNTCOM	>;MAKE SURE THAT ALL IS WELL?
	DPB	LINE,PUNIT		;SET THIS LINE IN DDB
	PUSHJ	P,TTYATI		;SET UP NEW DDB
				;NOW, GO TO INTERUPT LEVEL TO SET DAT
				;AND CHECK IF TYPING NEEDS TO BE STARTED.
	PUSH	P,ITEM			;SAVE THIS
	PUSHJ	P,XMTIN1		;START TYPING
	POP	P,ITEM
	SETZ	TAC,
	JRST	SCNIN
>;FTATTACH
;TTYDET, TRESCN, TRESCU
IFN FTATTACH,<
;ROUTINE TO DETACH TTY FROM JOB
;CALL:	MOVE DDB,ADDRESS OF TTY DDB TO BE DETACHED
;	PUSHJ P,TTYDET

;CALLED FROM TTYATT AND COMCON (DETACH).
;CLEARS TTYATC AND TRANSLATOR TABLE ENTRY.
;SETS TTYDTC IN DEVIOS(DDB)


↑TTYDET:LDB	TAC,PJOBN	;GET JOB NO.
	SETOM	JBTLIN(TAC)	;FLAG LINE AS DETACHED.
	MOVSI	IOS,TTYDTC
	MOVE	TAC,DEVMOD(DDB)		;SET TTY DETACHED BIT
	TLNE	TAC,TTYATC		;WAS TTY ALREADY DETACHED?
	TDNE	IOS,DEVIOS(DDB)
	JRST	TTYKIL			;YES, MAKE TTY AVAIL. EXTRA DETACH COMMAND
	IORB	IOS,DEVIOS(DDB)
	CONO	PI,SCNOFF
	PUSHJ	P,TTYSKL
	CONO	PI,SCNON
	JRST	TTYKL1			;GO CLEAR TRANSLATOR TABLE
>

; ROUTINE TO RESET COUNTS AND BYTE POINTERS TO RESCAN THE LAST COMMAND LINE

↑TRESCN:
	LDB	TAC,PCOMIC		; GET OLD TITCTR
TRESC2:					;HERE TO SCAN BACK TO CURRENT INPUT.
	MOVEM	TAC,TITCTR(DDB)		;RESTORE IT
	PUSHJ	P,TBYTEP
	MOVEM	TAC,TITAKR(DDB)
TRESC1:	MOVE	TAC,TIPCTR(DDB)		;CALLED HERE FROM ↑U CODE
	CONO	PI,SCNOFF
	SUB	TAC,TITCTR(DDB)		; THIS IS NOW THE NEW CHR. COUNT TO END OF BUFFER
	SKIPG	TAC
	ADDI	TAC,TTICHR
	MOVEM	TAC,TIFCTR(DDB)
	CONO	PI,SCNON
	JRST	STLNAC

; ROUTINE TO RESCAN ALL COMMAND LINES IN BUFFER. CALLS TRESCN, THEN
; COUNTS NUMBER OF COMMAND LINES IN BUFFER, THEN CALLS TRESCN AGAIN

↑TRESCU:TLNE IOS,TPMON			;MONITOR MODE?
	POPJ P,				;OH WELL, LOSERS LOSE
	TRNN UUO,-1
	JRST TRESCA
	LDB TAC,PCOMIC
	SUB TAC,TITCTR(DDB)
	SKIPG TAC
	ADDI TAC,TTICHR
	XCTR	XW,[MOVEM TAC,(UUO)]
TRESCA:	PUSHJ	P,TRESCN		;RESCAN LINE
	JRST	SYNCHK			;RE-CALCULATE ACTIVATED CHAR. COUNT.
;TBYTEP
; ROUTINE TO MAKE A POINTER TO THE BUFFER OUT OF A COUNT OF CHARACTERS
; FROM THE START OF THE BUFFER.

	XWD 	441100,0
TLHBYT:	XWD	331100,0
	XWD	221100,0
	XWD	111100,0
	XWD	001100,0

TBYTEP:	PUSH	P,LINE		;SAVE LINE
	MOVNS	TAC
	ADDI	TAC,TTICHR
	IDIVI	TAC,4
	ADD	TAC,TTIBUF(DDB)
	HLL	TAC,TLHBYT(LINE)
	POP	P,LINE		;RESTORE LINE
	AOJA TAC,CPOPJ
;TTYGET, TTYFNU, TTYFND, TTYFUW, TTYERP, TTYERR
;ROUTINE TO FIND TTY FOR A JOB
;CALL:	MOVE ITEM,JOB NUMBER
;	PUSHJ P, TTYFND
;	RETURN WITH DDB SET TO ADR OF DDB
;	AND DAT SET TO BYTE POINTER TO MONITOR OUTPUT BUFFER

TTYGET:		

↑TTYFNU:
	MOVE	ITEM,JOB(PID)
↑TTYFND:
	PUSHJ	P,TTYSRC
TTYDAT:	MOVEI	DAT,TTOBUF(DDB)
	POPJ	P,


;PUT JOB IN IO WAIT IF TTY BUFFER NOT EMPTY
;CALLED BY NON ERROR MESSAGE ROUTINES AT UUO LEVEL

↑TTYFUW:
	JUMPE PID,TTYFU1
	PUSHACS
	CONSO APR,MAOFF
	JRST TTYFU2
	PUSHJ P,DISMES
	ASCIZ /ππPID CLOBBERED AT TTYFUW
/
	POPACS
	SETZ PID,
	JRST TTYFU1
TTYFU2:	PUSHJ P,DISMES
	ASCIZ /ππPDP-6 AT TTYFUW
/
	POPACS
	POPJ P,

TTYFU1:	PUSHJ	P,TTYFNU
	LDB	TAC,PJOBN	; GET JOB # OF DDB
	CAME	TAC,JOB		; IS THIS OURS?
	POPJ	P,		; NO, FORGET IT.
	MOVE	TAC,TOPUTR(DDB)
	CAMN	TAC,TOTAKR(DDB)
	POPJ	P,
	MOVEI	IOS,IOACT			;YES
	IORB	IOS,DEVIOS(DDB)
	JRST	WSYNC

;ROUTINE TO INDICATE MONITOR ERROR MESSAGE TO BE FORCED OUT
;WHEN NO MORE ROOM IN TTO BUFFER, TTI BUFFER WILL BE USED

↑TTYERP:		;ENTER HERE TO START ERROR TYPEOUT AND CLEAR INPUT
	PUSHJ	P,TTYERR
	JRST	SETBFI
↑TTYERR:				;COME HERE IF YOU NEED SPACE BUT
					;DON'T NECESSARILY NEED TO FLUSH INPUT
	PUSHJ	P,TTYSRC		; FIND TTY DDB
	MOVEI	IOS,MERTPO		;SET MONITOR ERROR PRINT OUT BIT
	IORB	IOS,DEVIOS(DDB)
	TLNE	IOS,TTYDTC		; LEAVE IF DETACHED LINE
	POPJ	P,
	PUSHJ	P,STLNAC
	TLNN	LINE,DISLIN!DDDLIN
	POPJ	P,
	PUSHACS
	HRRZ	DDB,LETAB-DPYL0(LINE)	;GET THE RIGHT SIDE ONLY
	JUMPE	DDB,TTYDX1		;NO LINE.
	HLRZ	DAT,PPCALL(DDB)
	TLNE	LINE,DDDLIN		;SKIP IF THIS IS III
	TLO	DDB,400000		;SET BIT IF DD
	HLL	DAT,DDB
	PUSHJ	P,PPCLR
TTYDX1:	POPACS
	POPJ P,
;TTYSET, TTYSTC
;ROUTINE TO SET TTY INTO USER MODE NOW.
;CALL:	MOVE DDB,ADDRESS OF DEVICE DATA BLOCK
;	PUSHJ P,TTYSET

;CALLED FROM RUNCSS (START1)
;CLEARS DDTM,IOSUPR,USRB,TTYIOW AND IOW


↑TTYSET:
	MOVE	IOS,[XWD DDTM+USRB+TTYIOW+IOW,IOSUPR]
	ANDCAB	IOS,DEVIOS(DDB)
	POPJ	P,0

;ROUTINE TO START TTY OUTPUT AFTER CLEARING USRB

↑TTYSTC:
	MOVSI	TAC,USRB		; CLEAR BIT IN MEMORY
	ANDCAM	TAC,DEVIOS(DDB)
	JRST	TTYSTR
;TTYSTR, TTYUSR
;ROUTINE TO START TTY OUTPUT
;CALL:	MOVE DAT,BYTE POINTER TO LAST OUTPUT ITEM
;	MOVE DDB,ADDRESS OF TTY DDB
;	MOVE ITEM,JOB NUMBER		;(MUST BE PRESERVED)
;	PUSHJ P,TTYSTR

;CALLED FROM COMINI
;INITIALIZED TTY FOR MONITOR OUTPUT AND STARTS OUTPUT

↑TTYSTR:
	MOVE	IOS,[XWD DDTM!IOBEG!IO!TPMON,IOSUPR!IOBKTL!IOACT]
	ANDCAB	IOS,DEVIOS(DDB)
	TLNE	IOS,TTYDTC		;DON'T START DETACHED LINES
	POPJ	P,
	PUSHJ	P,STLNAC		;GET LINE CHARACTERISTICS
	MOVSI	TAC,IO!TPMON
	TLNE	IOS,USRB		;GOING OUT OF MONITOR MODE?
	TLZ	TAC,TPMON		;YES, DON'T DIDLE THESE
	IORM	TAC,DEVIOS(DDB)
	MOVSI	TAC,USRB+TPMON
	TLNE	IOS,USRB
	ANDCAM	TAC,DEVIOS(DDB)
	MOVE	IOS,DEVIOS(DDB)		;GET CORRECT IOS
	SKIPLE	TISYNC(DDB)		;ANY TYPE AHEAD?
	PUSHJ	P,COMSET		;YES.
	JRST	UTYPET			;GO TYPE FIRST CHAR.

;ROUTINES TO SET SCANNER TO START UP JOB WHEN OUTPUT FINISHES
;CALL:	MOVE DDB,TTY DDB ADR.
;	PUSHJ P,TTYUSR
;	TTY WILL GO TO USER MODE WHEN TYPING OUT STOPS

↑TTYUSR:
	MOVSI	IOS,USRB		; SET BIT TO SWITCH TTY TO USER MODE
	IORM	IOS,DEVIOS(DDB)		; WHEN MONITOR OUTPUT FINISHES
	JRST	SETRUN			;GO FLAG JOB AS RUNABLE IMMEDIATELY
;TTYTLK
;ROUTINE TO ADD TTY TO TALK RING
;CALL:	ADR. OF DDB TO BE ADDED TO RING AT -3(P)
;	MOVE TAC,SIXBIT /TTYN/
;	PUSHJ P,TTYTLK
;	TTY IS BUSY RETURN OR NOT A TTY OR TOO BIG A LINE NO.
;	OK RETURN, TTY ADDED TO TALK RING

IFN FTTALK,<

↑TTYTLK:
	PUSHJ	P,GETDDB		; IN CASE NOT SET UP
	POPJ	P,			;NONE AVAIL. GIVE UP
IFN FTTKBG,<
	LDB	CHR,PUNIT		;BH 3/15/74 FOR BUG TRAP BELOW
>;FTTKBG
	MOVE	TAC,DEVMOD(DDB)
	TLNN	TAC,DVTTY
	POPJ	P,
	MOVE	IOS,DEVIOS(DDB)	;IS TTY IN MONITOR MODE AND LEFT HAND MARGIN?
	TLNE	IOS,TTYHLD	;EVIL THINGS MIGHT HAPPEN IF WE TRY TALKING
	POPJ	P,		;TO A LINE THAT'S HOLDING.
	MOVE	LINE,-3(P)		;TTY GIVING TALK COMMAND
	MOVE	LINE,DEVNAM(LINE)	;ITS NAME
	MOVE	TAC,DEVNAM(DDB)	;OPR IS NEVER TOO BUSY...
	CAMN	LINE,TAC		;IF THE SAME,
	POPJ	P,			;  NO SOAP
	CAME	LINE,DEVOPR		;EITHER ONE OPR?
	CAMN	TAC,DEVOPR
	JRST	TTYTK1
	MOVSI	TAC,TLKPRV
	TDNE	TAC,JBTPRV(J)	;CHECK PRIVILEGE
	JUMPN	J,TTYTK1	;JUMP IF PRIV SET
	TLNE	IOS,TPMON
	TLNN	IOS,IOFST
	POPJ	P,			;NO, HE IS BUSY.
TTYTK1:	CONO	PI,SCNOFF
IFN FTTKBG,<
	HRRZ	TAC,TTYTAB(CHR)		;BH 3/15/74
	JUMPE	TAC,TTYTK2		;  BUG TRAP: MAYBE NO OBJECT DDB HERE?
>;FTTKBG
	LDB	LINE,PUNIT		;LINE NUMBER IN RING.
	MOVSI	TAC,TLKRNG
	LDB	CHR,PTALK
	TDNN	TAC,LINTAB(LINE)
	HRRZ	CHR,LINE
	IORM	TAC,LINTAB(LINE)
	EXCH	DDB,-3(P)		;GET DDB OF TALKER
	LDB	LINE,PUNIT		;LINE NO. OF TALKER
	DPB	CHR,PTALK		;SET TO POINT INTO RING
	MOVSI	TAC,TLKRNG
	IORM	TAC,LINTAB(LINE)
	MOVEM	LINE,TAC		;SAVE LINE NO. OF TALKER
	EXCH	DDB,-3(P)		;RESTORE
	LDB	LINE,PUNIT		;LINE NO. IN RING AGAIN
	DPB	TAC,PTALK		;MAOE IT POINT TO TALKER
	CONO	PI,SCNON
	JRST	CPOPJ1			;OK RETURN

IFN FTTKBG,<
TTYTK2:	MOVE	TAC,-3(P)		;BH 3/15/74 BUG TRAP HERE TO PAGE END
	PUSHACS
	PUSH	P,DDB			;FORMER DDB OF TALKEE
	PUSH	P,CHR			;DEAD TALKEE
	PUSH	P,TAC			;TALKER'S DDB
	MOVE	DDB,TAC
	LDB	TAC,PUNIT		;TALKER
	PUSH	P,TAC
	PUSHJ	P,DISMES
	ASCIZ /ππππNO DDB FOR TALKEE AT TTYTK1!!
TALKER=/
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ /  DDB=/
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ /
TALKEE=/
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ /  DDB WAS AT /
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ /
FIND A WIZARD!  IF NONE, TYPE: POPJ 3,$X
/
	PUSHJ	P,DISFLU
	POPACS
	PUSHJ	P,DDTCAL
	CONO	PI,SCNON
	POPJ	P,
>;FTTKBG
>
;TTYSRC, STLNAC
;ROUTINE TO SEARCH TRANSLATOR TABLE FOR TTY
;CALL:	MOVE J,JOB NUMBER
;	PUSHJ P,TTYSRC
;	RETURN WITH ADDRESS OF DEVICE DATA BLOCK IN DDB.


↑↑TTYSRC:
	JUMPE	J,TTYF1			;SEARCH FOR OPER. TTY IF JOB NO. 0
	MOVSI	LINE,TTYATC
	MOVEI	DDB,TTYLST		;TTYDDBS START HERE
TTYSRA:	LDB	TAC,PJOBN		;JOB ATTACHED TO THIS DDB
	CAIE	TAC,(J)			;IS THIS THE ONE
	JRST	TTYF0
	TDNE	LINE,DEVMOD(DDB)	;IS HE ATTACHED TO IT?
	JRST	TTYF9			;YES.
TTYF0:	HLRZ	DDB,DEVSER(DDB)		;FOLLOW CHAIN
	JUMPN DDB,TTYSRA		;TO ITS END
TTYF1:	SKIPE TAC,DEVOPR
	JRST TTYF3
	MOVEI	LINE,TCONLN		;NO USE CTY.
	SKIPE	DDB,TTYTAB(LINE)	;DOES IT HAVE A DDB?
	JRST	TTYF9
	MOVSI	TAC,'CTY'		;NO
TTYF3:	PUSHJ	P,GETDDB		;GET A DDB FOR DEVOPR
	JRST	SCREW			;OH BOY HERE WE GO
TTYF9:	MOVE	IOS,DEVIOS(DDB)		;SET UP IOS

	SETZ	LINE,
	TLNE	IOS,TTYDTC
	POPJ	P,
↑STLNAC:
	LDB	LINE,PUNIT		; GET UNIT # FROM DDB
	HLL	LINE,LINTAB(LINE)		;AND LINE BITS
	POPJ	P,0			;RETURN

SCREW:	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISMES
	ASCIZ/LOSE BIG! SOMEONE IS TRY TO TYPE ON A VIRGIN TTY,
AND NO CORE AVAILABLE.
/]
	POPACS
	CONSZ PI,77400	;WHERE ARE WE
	POPJ P,		;CROSS FINGERS AND PRAY
	JSP DAT,UERROR	;UUO LEVEL, A WAY OUT.
;GETDDB, LOG2LN
;ROUTINE TO SETUP DDB FOR OUTPUT
;CALL	MOVE TAC,[SIXBIT /TTY#/
;	PUSHJ P,GETDDB
;	NONE AVAILABLE RETURN
;	RETURN WITH LINE AND DDB SETUP

↑GETDDB:
	PUSHJ P,LOG2LN		;CONVERT TO LINE NUMBER
	POPJ P,			;ILLEGAL
GETDBA:	CAIL LINE,TTPLEN	;LEGAL LINE NUMBER?
	POPJ P,			;NO
GETDB1:	SKIPE DDB,TTYTAB(LINE)		;DOES THIS LINE ALREADY HAVE A DDB?
	JRST CPOPJ1			;YES
	CAIL LINE,PTYL0
	POPJ P,			;ONLY DDBSRC WILL CREATE PTY DDB! (BH 3/18/74)
	PUSHJ P,DDBSRC		;NO. SEARCH FOR FREE DDB
	POPJ P,			;NONE AVAILABLE
	HLLZM IOS,DEVIOS(DDB)		;INITIALIZE STATE
	PUSH P,DEVNAM(DDB)
	MOVEI TAC,ASSCON+ASSPRG
	ANDCAM TAC,DEVMOD(DDB)
	JRST TPOPJ1

↑LOG2LN:MOVS TAC,TAC
	MOVEI LINE,TCONLN
	CAIN TAC,'CTY'
	JRST CPOPJ1
	TRC TAC,'TTY'
	TRNE TAC,-1
	POPJ P,			;NOT TTY#
↑SIX2LN:JUMPE TAC,CPOPJ		;JUST TTY
	MOVEI LINE,
LOG2LL:	ROT TAC,3
	TRZE TAC,2
	TRNE TAC,5
	POPJ P,			;NOT DIGIT
	ROTC TAC,3		;DIGIT → LINE
	JUMPN TAC,LOG2LL	;MORE?
	CAIGE LINE,TTPLEN	;NO, CHECK LEGALITY
	AOS (P)
	POPJ P,
;DDBSRC, STDTBL
;ROUTINE TO SEARCH FOR FREE TTY DEV DATA BLOCK
;CALL:	MOVE LINE,TTY LINE NO.
;	PUSHJ P,DDBSRC
;	NONE FOUND OR LINE NO. TOO BIG
;	RETURN DDB,LINE AND DEVNAM SET AND BITS TPMON,IOFST,IOACT,
;		TTYUSE,ASSCON SET.
;	IF CALLED WITH LINE SET TO -1 A DETTACHED
;	DDB IS CREATED AND GIVEN TO JOB IN ITEM.

↑DDBSRC:
	HRRE	TAC,LINE			; NUMBER OF LINE ONLY
	CAILE	TAC,TTPLEN		;IS LINE NO. TOO BIG
	POPJ	P,			;YES.
	HLL LINE,LINTAB(LINE)
	TLNN LINE,DDDLIN
	JRST DDBSR1
	MOVE AC3,AVLBIT
	CONSO PI,770000
	TDNE AC3,VDMAP-DDL0(LINE)	;NOT AT PI LEVEL - SEE IF COMPLETELY FREE
	SKIPE DDOFF			;ALSO SEE IF DD UP
	POPJ P,
DDBSR1:	MOVEI AC3,TTYFS
	PUSHJ P,SFSGET
	POPJ P,
	MOVEI	DDB,DDBSKW(AC1)
	HRLI	AC1,TTYLST-DDBSKW
	BLT	AC1,TTYPTR(DDB)	;COPY PART OF A REAL DDB INTO OUR NEW BLOCK
	SETZM	DEVIOS(DDB)
	SETZM	DEVLOG(DDB)
	SETZM	DEVNAM(DDB)
	SETZM	DEVBUF(DDB)
	SETZM	PTYPTR(DDB)
	SETZM	SAVDDB(DDB)
	MOVSI	AC1,TTICHR
	DPB	AC1,PJOBN	;CLEAR JOB NUMBER IN DEVCHR
	DPB	AC1,PUNIT	;UNIT NUMBER TOO  BH 5/6/74
	HRRI	AC1,TIBF-1(DDB)
	MOVEM	AC1,TTIBUF(DDB)
	MOVSI	AC1,TTOCHR
	HRRI	AC1,TOBF-1(DDB)
	MOVEM	AC1,TTOBUF(DDB)
	PUSHJ	P,TSETBF
	MOVSI TAC,STDTBL
	HRRI TAC,ACTBTS(DDB)
	BLT TAC,ACTMOD(DDB)
	MOVE	TAC,[XWD TTYUSE!TTYATC,ASSCON!ASSPRG]
	ANDCAM	TAC,DEVMOD(DDB)
	HRLZI	AC1,(DDB)
	HRR	AC1,DEVSER(DDB)
	CONO	PI,SCNOFF
	EXCH	AC1,TTYLST+DEVSER
	MOVEM	AC1,DEVSER(DDB)
	CONO	PI,SCNON
	MOVSI	TAC,PROG
	MOVEM	TAC,DEVIAD(DDB)		;CLEARS PHPOS
	MOVEM	TAC,DEVOAD(DDB)		;CLEARS PFITCH
	MOVE	IOS,[XWD TPMON+IOFST,IOACT]
	MOVEM	IOS,DEVIOS(DDB)		;MAKE SURE HE LOOKS LIKE A VIRGIN.
	PUSHJ	P,TSETBF		;INITIALIZE BUFFERS
	MOVE	TAC,[XWD TTYUSE,0]	;INITIALIZE DATA BLOCK.
	CAIE	LINE,-1		;IS SOME ONE GETTING A DETTACHED DDB?
	JRST [	TLNN LINE,DDDLIN!DISLIN
		JRST SCNIN		; NO, FINISH UP AND LEAVE
		PUSHJ P,DPYMAKE		; MAKE UP A DPY HEADER
		JRST TTYKL5		;LOSE - RELEASE THE DDB & LEAVE
		JRST SCNIN]
	TLO	TAC,TTYATC	;ATTACH JOB TO DDB
	IORM	TAC,DEVMOD(DDB)
	SETOM	JBTLIN(ITEM)	;YES, FLAG AS DETTACHED
	DPB	ITEM,PJOBN	;MAKE IT HIS;
	MOVSI	IOS,TTYDTC	;FLAG AS DETTACHED FROM LINE
	IORB	IOS,DEVIOS(DDB)
	JRST	CPOPJ1		;SKIP RETURN

;STANDARD SPECIAL ACTIVATION MODE BREAK TABLE
;BREAK ON ANYTHING BUT LETTER OR NUMBER
STDTBL:	777777777777
	777700037600
	000000374000
	000007600000
;SCNIN
;INITIALIZE TTY DEVICE DATA BLOCK(CALLED FROM TTYATT TOO)
;CALL:	MOVE TAC,BITS IN DEVMOD TO BE TURNED ON
;	MOVE DDB,ADDRESS OF DEVICE DATA BLOCK
;	PUSHJ P,SCNIN
;	SKIP RETURN ALWAYS

;	CALLED BY JRST FROM TTYATT
;	AND FALLS IN FROM DDBSRC ABOVE

;SETS PHYSICAL NAME TO SIXBIT /TTY#/ OR SIXBIT /CTY/
;	WHERE # IS THE LINE NUMBER.
;STORES LINE NUMBER IN DEVICE DATA BLOCK

SCNIN:	IORM TAC,DEVMOD(DDB)
	DPB LINE,PUNIT			;SET LINE NO. IN DDB.

IFN FTTALK,<
	DPB LINE,PTALK			;SETUP TALK RING TO CONTAIN
					;ONLY THIS TTY.
>
	MOVEI TAC,
	ANDI LINE,-1
SCNIN0:	ROTC TAC,-3
	HRRI TAC,2
	ROT TAC,-3
	JUMPN LINE,SCNIN0
	HRRI TAC,'TTY'
	MOVSM TAC,DEVNAM(DDB)
	PUSHJ	P,STLNAC
	HRRM DDB,TTYTAB(LINE)	;SET DDB ADR. IN TRANSLATOR TABLE.
	MOVSI TAC,'CTY'
	TLNE	LINE,CTYLIN		;IS THIS CONSOLE TTY?
	MOVEM TAC,DEVNAM(DDB)	;YES, SET NAME TO CTY.
	JRST CPOPJ1			;SUCCESSFUL RETURN.
;TTYSKL, TTYREL, TTYKIL
;CALL TO MAKE REQUEST TO DPYKIL.
;CONO PI,SCNOFF MUST HAVE BEEN DONE BEFORE THIS ROUTINE IS CALLED.
TTYSKL:	PUSHJ	P,STLNAC		;GET LINE CHARACTERISTICS..
	TLNE	LINE,DDDLIN!DISLIN
	SKIPN	AC2,LETAB-DPYL0(LINE)
	POPJ	P,
	MOVEI	AC1,-DPYL0(LINE)
	SETO	AC3,
	EXCH	AC3,LECLIN(AC2)
	JUMPL	AC3,CPOPJ
	SETZM	LEACT(AC2)		; SEE IF THE LINE EDITOR SAYS ANYTHING IN THIS TIME
	LSH	AC1,=12
	ADD	AC1,DPYKRQ		; MAKE IT APPROPRIATE LENGTH
	CONO	PI,PIOFF
	IDPB	AC1,CLOCK(PID)
	CONO	PI,PION
	POPJ	P,

↑TTYREL:
IFN DILNUM,<
	LDB LINE,PUNIT		;SETUP LINE
	PUSHJ P,DILTRL		;CHECK FOR DIALER RELEASE
>;DILNUM
	HLLZS TAC1,DEVIOS(DDB)	;CLEAR INITTED BITS IN IOS.
	MOVE TAC,DEVMOD(DDB)
	TLNE TAC,TTYATC		;THAT'S ALL IF IT'S HIS CONSOLE
	POPJ P,
	MOVSI IOS,TPMON		;NO, PUT HIM BACK IN MONITOR MODE
	IORB IOS,DEVIOS(DDB)
	TRNE TAC,ASSCON		;DON'T KILL IF ASSIGNED BY CONSOLE
	POPJ P,

;ROUTINE TO SET SCNSER TO RETURN TTY TO VIRGIN STATE
;CALL:	MOVE	DDB, ADDRESS OF DEVICE DATA BLOCK
;	PUSHJ	P,TTYKIL

;CALLED FROM COMCSS (JOBKIL).
;IF NOT OPERATOR CONSOLE, THEN
; 1)CLEAR PHYSICAL AND LOGICAL	NAMES,
; 2)CLEAR JOB NUMBER ASSIGNMENT
;	3)CLEAR	TTYUSE,TTYATC,ASSCON,ASSPRG,
;	4)CLEAR ENTRY IN TRANSLATOR TABLE.

↑TTYKIL:
	CONO	PI,SCNOFF			;LET'S DO IT RIGHT!
	TLNE	IOS,TTYDTC
	JRST	TTYKL5			;TAKE 3 GIANT STEPS IF YOU'RE DETACHED.
	PUSHJ	P,TTYSKL		;IF A DPY, MAKE IT AVAIL. (SETS LINE)
TTYKL7:	SKIPN	DDB,TTYTAB(LINE)	;DID SOMEONE ELSE GET IT?
	JRST	TYPT1			;YES.
	TRNN	DDB,-1			;IS THERE REALLY ONE HERE?
	JRST	[PUSHJ P,TTYKL9		;NO DDB, NO NOTHING!
IFN FTTTYBUG,<	PUSHJ P,CNTCOM		>
		JRST TYPT1]		;AND THEY'RE OFF
	MOVSI	IOS,TTYIOW!IOW!TTYDTC!DDTM	; CLEAR TTY INPUT AND OUTPUT
	ANDCAM	IOS,DEVIOS(DDB)		;WAIT BITS SO TTY WILL BE KILLED
					;PROPERLY AT INTER. LEVEL IF STILL OUTPUTING
	MOVE	TAC,[TTYATC,,ASSCON!ASSPRG]
	ANDCAM	TAC,DEVMOD(DDB)		;TTY IS NO LONGER A JOB'S CONSOLE.
	MOVSI	IOS,TPMON		;CLEAR JOB NUMBER
	DPB	IOS,PJOBN
	IORB	IOS,DEVIOS(DDB)		;TURN TPMON ON IN CASE TTY IS
					;STILL OUTPUTTING
	SKIPG	TTYTAB(LINE)		;REQUEST IN ALREADY?
	JRST	TYPT1			;LEAVE NOW!
	MOVE	TAC,TITCTR(DDB)		;TAKR COUNT
	CAMN	TAC,TIPCTR(DDB)		;COMPARE WITH PUTR
	JRST	NOTYPA			;NO TYPE AHEAD
	SKIPLE	TISYNC(DDB)		;ANY LINES TO TELL MONITOR ABOUT?
	PUSHJ	P,COMSET		;WAKE COMMAND DECODER
	JRST	TYPT1

NOTYPA:
	TLNN	LINE,PTYUSE		;DON'T KILL DDB FOR USED PTY'S.
	TLOE	IOS,IO+TOIP		;IS IT OUTPUTTING OR TALKING?
	JRST	TTYKL6
TTYKL5:	MOVEI	TAC,TTYLST		;DON'T KILL THIS GUY
	CAIE	TAC,(DDB)		;IS THIS THE FIRST DDB
	JRST	TTYKL2			;BLAST THE MOTHER
	HLLZS	DEVIOS(DDB)		;CLEAR INITTED STUFF IN IOS
	PUSHJ	P,LINCLR		;CLEAR LINE TABLE.
	SETZM	DEVLOG(DDB)		;CLEAR LOGICAL NAME
	JRST TYPT1			;ON CLYDE.

TTYKL6:	IORB	IOS,DEVIOS(DDB)		;MAKE SURE IT GETS KILLED AT INTERUPT LEVEL.
	JRST	TYPT1
;MORE TTYKIL
;THIS RETURNS A DDB TO FREE STORAGE.

TTYKL2:	MOVEI	AC1,TTYLST		;SEARCH CHAIN FOR POINTER TO DDB.
TTYKL3:	MOVE	TAC,AC1
	HLRZ	AC1,DEVSER(AC1)		;LINK
	CAIE	AC1,(DDB)		;IS THIS THE GUY THAT POINTS TO OURS
	JUMPN	AC1,TTYKL3
	JUMPE	AC1,TTYKL4
	MOVE	AC1,DEVSER(DDB)
	MOVEM	AC1,DEVSER(TAC)		;LINK HIM OUT
TTYKL8:	PUSHJ	P,LINCLR		;CLEAR LINTAB BITS
	TLNN	IOS,TTYDTC
	PUSHJ	P,TTYKL9
IFN FTTTYBUG,<	PUSHJ	P,CNTCOM	>
	CONO	PI,SCNON		;AND AWAY THEY GO!!
	MOVEI	AC1,-DDBSKW(DDB)
	PUSHJ	P,FSGIVE
	MOVEI	DDB,0
	POPJ	P,

LINCLR:	TLNE	IOS,TTYDTC		;NO LINE IF DETACHED
	POPJ	P,
	TLNN	LINE,PTYLIN		;PTY'S AREN'T IN THIS TABLE
	IOR	LINE,LINBIT(LINE)	;OR IN INITIALIZE BITS
	TLZ	LINE,KILMSK		;CLEAR BITS IN LINE TABLE
	HLLM	LINE,LINTAB(LINE)
	POPJ	P,

TTYKL1:	LDB	LINE,PUNIT		;LINE NO.
	SKIPGE	TTYTAB(LINE)
	SOS	COMCNT
	PUSHJ	P,TTYKL9		;CLEAR TRANSLATOR TABLE
IFN FTTTYBUG,<	PUSHJ	P,CNTCOM>
	SETZM	DEVNAM(DDB)
	JRST	TSETBF			;BLAST TYPE AHEAD AND OUTPUT.

TTYKL4:
	PUSHACS
	PUSH P,TAC
	PUSH P,DDB
	PUSHJ P,DISMES
	ASCIZ /πππDDB NOT FOUND IN LIST AT TTYKIL
DDB=/
	POP P,TAC
	PUSHJ P,DISOCT
	PUSHJ P,DISMES
	ASCIZ /
LAST LINK=/
	POP P,TAC
	PUSHJ P,DISOCT
	PUSHJ P,DISMES
	ASCIZ /
/
	POPACS
	JRST TTYKL8		;GIVE IT BACK ANYWAY

;ALL THE "PUSHJ P,TTYKL9"S ABOVE USED TO BE "SETZM TTYTAB(LINE)"
;IF LH OF TTYTAB ENTRY ≠ LINE THEN WE WERE IN A TALK RING AND
;THIS ROUTINE PATCHES THE RING UP TO LEAVE US OUT

TTYKL9:	LDB AC2,PTALK		;MY TALKRING POINTER
	MOVEI AC3,0
	EXCH AC3,TTYTAB(LINE)	;DON'T NEED TTYTAB ANYMORE
	JUMPE AC3,CPOPJ		;GRUMBLE, SOMEBODY CLOBBERED IT ALREADY
	CAIN AC2,(LINE)		;POINTS TO ME?
	POPJ P,			;YES, NO PROBLEM
	PUSH P,AC2		;SAVE NEXT GUY
	MOVE AC3,LINE		;MY LINE NUMBER
TTYK91:	MOVE LINE,AC2		;LOOP THROUGH TILL YOU FIND ME
	LDB AC2,PTALK
	CAIE AC2,(AC3)
	JRST TTYK91		;NOT ME YET
	POP P,AC2		;RETRIEVE MY POINTEE
	DPB AC2,PTALK		;MAKE PREV POINT TO NEXT
	CAIE AC2,(LINE)
	JRST TTYK92
	MOVSI AC2,TLKRNG
	ANDCAM AC2,LINTAB(LINE)	;TURN OFF THE FLAG IF ONLY ONE LEFT
TTYK92:	MOVE LINE,AC3		;FIX LINE
	POPJ P,
;OUTCH6, OUTCHS, OUTCHR
;MORE CHARACTER AND BUFFER HANDLING ROUTINES

;OUTCHR CALLED AT UUO LEVEL TO OUTPUT A CHARACTER
;DAT AND DDB MUST BE SET UP
;CHECK IS MADE FOR WHETHER SPECIAL ECHO IS REQUIRED
;RIGHT THINGS ARE DONE WITH PHPOS & HPOS(NEEDNT BE SET)
;CALL	MOVE	CHR,CHAR TO BE OUTPUT
;	PUSHJ	P,OUTCHR
;	ONLY RETURN, WITH CHAR. OR ITS SPECIAL ECHO PLACED IN OUT BUFFER

↑OUTCH6: ADDI CHR,40		;TYPE OUT SIXBIT.

↑OUTCHS:
	JUMPE PID,OUTC1S
	CONSO APR,MAOFF		;ARE WE REALLY THE TEN?
	JRST CTYTYO		;NO, JUST TYPE ON THE SIX'S CTY
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /ππPID CLOBBERED AT OUTCHS
PID=/
	MOVE TAC,PID
	PUSHJ P,DISOCT
	PUSHJ P,DISMES
	ASCIZ /
/
	POPACS
	SETZ	PID,		;MAKE IT RIGHT!!
OUTC1S:	PUSH	P,TAC
	PUSH	P,HPOS	;CALL OUTCHR ROUTINE
				; BUT SAVE ITEM AND TAC
	PUSHJ	P,OUTCH5
	POP	P,HPOS
	JRST	TPOPJ

OUTCHR:	MOVE	TAC,DEVIOS(DDB)	;GET IOS
	TLNE	TAC,TTYDTC
	POPJ P,
	ANDI TAC,16
	CAIN TAC,10		;MODE 10 OR 11?
	JRST	OUTCH2		;YES, NO CONVERSION
	MOVEI	AC3,20		;CHECK FREE SPACE
	CAML	AC3,TOFCTR(DDB)	; FOR EXPANDING CHARS
	JRST	GETCH1		;NOT ENOUGH ROOM
OUTCH5:	MOVE	TAC,DEVIOS(DDB)
	TLNE TAC,TTYDTC
	POPJ	P,
	ANDI TAC,16
	CAIN TAC,10		;MODE 10 OR 11?
	JRST OUTCH2		;YES, NO CONVERSION
	ANDI	CHR,177	;MASK ANY JUNK
	PUSH	P,LINE
	PUSHJ	P,STLNAC	;SET UP LINE
	LDB	HPOS,PHPOS	;GET HORIZONTAL POSITION
	MOVE	AC3,HPOS	;SAVE FOR TAB
	PUSHJ	P,ADJHP	;NEW HPOS AFTER CHAR OUTPUT
	JFCL
	TLNE	LINE,DISLIN!IMLIN!DDDLIN!PTYLIN
	JRST	OUTCHA		;PAGE PRINTER WILL HANDLE CRLF
	CAIL	HPOS,=72	;DID IT GO OVER LINE?
	PUSHJ	P,CRLFEC	;YES, OUTPUT CRLF
OUTCHA:	DPB	HPOS,PHPOS	;UPDATE IN CORE
	TLNN	TAC,SPOUT	;VT,FF,HT?
	JRST	OUTC1X		;NO.
	TLNE	LINE,PTYLIN	;IS THIS A PTY?
	TLNE	LINE,IMPBIT	;YES. IS IT AN IMP?
	JRST	OUTCH1		;NOT A PTY, OR AN ARPA-PTY. - EXPAND TABS, ETC.
OUTC1X:	POP	P,LINE
OUTCH2:	CONO	PI,SCNOFF	;PREVENT REENTRANT CALLS ON PUTCHO...
	PUSHJ	P,PUTCHO	;PUT OUT THE CHAR.
	CONO	PI,SCNON
	POPJ	P,
;MORE OUTCHR  ADJHP
;HERE ON UUO OUTPUT OF HT,FF,VT

OUTCH1:	MOVE	HPOS,AC3	;POS BEFORE THE TAB
	MOVE	TAC,CHR		;COPY THE CHARACTER
	CAIN	CHR,11		;IS IT A TAB
	TLNE	LINE,TBXPND	;ARE WE ALWAYS EXPANDING THEM?
	JRST	OUTC1Y		;EXPAND!
	TLNE	LINE,IMLIN!PTYLIN!DISLIN!DDDLIN	;NEED IDLE CHARS.?
	JRST	OUTC1X		;NO
OUTC1A:	POP	P,LINE		;HERE ON OUTPUT OF TAB TO SMART TTY
	ANDI	HPOS,7		;JUST LOW PART FOR INDEX
	XCT	(HPOS)[	MOVEI HPOS,6	;8 SPACES-2 IDLES
			MOVEI HPOS,7	;7 SPACES-1 IDLE
			MOVEI HPOS,7	;6 SPACES-1 IDLE
			MOVEI HPOS,7	;5 SPACES-1 IDLE
			MOVEI HPOS,7	;4 SPACES-1 IDLE
			JRST OUTCH2	;3 SPACES-0 IDLES
			JRST OUTCH2	;2 SPACES-0 IDLES
			JRST OUTC1Z]	;1 SPACE -CONVERT TO SPACE (OR CTY WILL MISS TAB STOP)
	PUSHJ	P,OUTCH2	;SEND THE REAL CHAR
	MOVEI	CHR,IDLECH	;A DELAY CHARACTER
	JRST	OUTC1C		;OUTPUT SLUFFS. COUNT WILL BE MODIFIED ON VT,FF

OUTC1Y:	POP	P,LINE		;HERE TO EXPAND CHARACTER.
OUTC1Z:	MOVEI	CHR,40		;STUPID TTY.
	CAIE	TAC,11		;H TAB?
	MOVEI	CHR,12		;NO. OUTPUT LF'S.
OUTC1C:	CAIN	TAC,14		;FF?
	MOVEI	HPOS,0		;YES. 8 LF'S.
	CAIN	TAC,13		;VT?
	MOVEI	HPOS,4		;YES. 4 LF'S.
OUTC1B:
	PUSHJ	P,OUTCH2	;OUTPUT THE PHONY CHAR
	ADDI	HPOS,1		;COUNT THE OUTPUTS
	TRNE	HPOS,7		;ENOUGH?
	JRST	OUTC1B		;NO. MORE.
	POPJ	P,		;NO MORE


			;CALLED AT UUO AND INT LEVEL
			;TO ADJUST HPOS FOR OUTPUT OF CHR
			;SKIPS IF SPCHECK SAYS SPECIAL CHAR

ADJHP:	PUSHJ	P,SPCHEK	;GET BITS FROM SPCTAB
	AOJA	HPOS,CPOPJ	;ORDINARY CHAR.
	CAIL	CHR,40	;WHICH SPECIALS?
	JRST	CPOPJ1		;HIGH ONES
	CAIN	CHR,15	;CARRIAGE RETURN?
	MOVEI	HPOS,0		;YES.
	CAIE	CHR,11	;TAB?
	JRST	CPOPJ1		;NO. NO HP MOD
	TRO	HPOS,7		;TAB. TO NEXT 8
	AOJA	HPOS,CPOPJ1
;PUTCHI, PUTCHO
;ROUTINE TO PUT A CHARACTER INTO A BUFFER (FOR INPUT,MERTPO, AND ONCE)
;CALL	MOVEI DAT,TTXBUF(DDB)		;TO SPECIFY BUFFER
;	PUSHJ	P,PUTCHI
;	ERROR RETURN, BUFFER "FULL"
;	SUCCESSFUL RETURN

PUTCHI:
	SOSG	FCTR(DAT)		; ANY FREE SPACES LEFT?
	JRST	PUTCI0			;NO
PUTCHA:	SOSLE	PCTR(DAT)		;LAST BYTE IN BUFFER FILLED?
	JRST	PUTCI1			;NO. GO AHEAD
	PUSH	P,TAC
	MOVE	TAC,BUF(DAT)		;GET ADR AND SIZE OF BUFFER
	HLRZM	TAC,PCTR(DAT)		;INITIAL COUNTER
	HRRM	TAC,PUTR(DAT)		;BYTE POINTER.
	POP	P,TAC			;RESTORE TAC
PUTCI1:	IDPB	CHR,PUTR(DAT)
	JRST	CPOPJ1

;ROUTINE TO STUFF MONITOR ERROR MESSAGE IN TTI BUFFER
;CALLED IN LINE FROM PUTCHO

TTIOUT:	MOVE	IOS,DEVIOS(DDB)
	AOS	TOFCTR(DDB)		;RE-ADJUST FREE CHAR COUNT
	TRNN	IOS,MERTPO		;MONITOR ERROR MESSAGE?
	JRST	GETCH1			;NO, ZERO CHR TO INDICATE
	TRON	IOS,MERTP1		;TEST FLAG AND SET IF NOT ON
	PUSHJ	P,SETBFI		;CLEAR INPUT
	MOVEM	IOS,DEVIOS(DDB)		;AND MAKE SURE FLAG GETS ON
	MOVEI	DAT,TTIBUF(DDB)		;YES, PUT REST IN TTI BUFFER
	PUSHJ	P,PUTCHI
	POPJ	P,			;ERROR RETURN
	POPJ	P,

;ROUTINE TO PLACE A CHARACTER INTO THE OUTPUT BUFFER
;CALLED AT INTERRUPT LEVEL 
;CALL	MOVE	CHR,CHARACTER TO PLACE INTO BUFFER
;	PUSHJ	P,PUTCHO
;	ONLY RETURN, WHETHER OR NOT CHARACTER WAS PLACED

PUTCHO:	PUSH	P,TAC
	LDB	TAC,PUNIT
	HLL	TAC,LINTAB(TAC)
	TLNE	TAC,TTYFIL		;FILLING THIS TTY?
	JRST	FILLCR
FILNCR:	TLNN	TAC,FCS
	JRST	PUTCNV			;NOT FULL CHAR SET - CONVERT LOWER TO UPPER
PUTNLC:	POP	P,TAC
PUTCRS:	SOSG	TOFCTR(DDB)		;RETURN IMMEDIATELY IF NO ROOM
	JRST	TTIOUT			;UNLESS MONITOR ERROR MESSAGE
	SOSLE	TOPCTR(DDB)		;LAST BYTE IN BUFFER?
	JRST	PUTCO1			;NO. GO ON.
	PUSH	P,TAC			;SAVE AN AC
	MOVE	TAC,TTOBUF(DDB)		;GET COUNT AND ADDRESS
	HLRZM	TAC,TOPCTR(DDB)		;INITIAL COUNTER
	HRRM	TAC,TOPUTR(DDB)		;INITIAL POINTER
	POP	P,TAC			;RESTORE AC
PUTCO1:	IDPB	CHR,TOPUTR(DDB)		;PUT CHARACTER INTO BUFFER
	POPJ	P,

FILLCR:	CAIE	CHR,15
	JRST	FILNCR
	LDB TAC,PIOMOD			;GET IO MODE
	CAIE TAC,10
	CAIN TAC,11
	JRST FILNCR			;DON'T FILL IN IMAGE MODE
	MOVEI	TAC,10
	EXCH	TAC,(P)
PUTCRX:	PUSHJ	P,PUTCRS
	JUMPE	CHR,CRFULL
	SOSLE	(P)			;DONE YET?
	JRST	PUTCRX			;NO
CRFULL:	POP	P,(P)
	POPJ	P,

PUTCNV:	CAIL	CHR,"a"
	CAILE	CHR,"z"
	JRST	PUTNLC
	ANDCMI	CHR,40			;CONVERT TO UPPER CASE
	JRST	PUTNLC
;GETCHR, GETCHY
;CHARACTER AND BUFFER HANDLING ROUTINES

;ROUTINE TO PICK UP A CHARACTER FROM ANY BUFFER
;CALL	MOVEI	DAT,TTXBUF(DDB)		;TO SPECIFY BUFFER
;	PUSHJ	P,GETCHR
;	ONLY RETURN			;CHARACTER OR ZERO IN CHR
;					;ZERO INDICATES BUFFER "EMPTY"(TAKR=PUTR)

↑GETCHR:PUSHJ P,GETCHY
	ANDI CHR,177		;THROW OUT CONTROL BITS.
	POPJ P,

GETCHY:	
	HLRZ CHR,BUF(DAT)		;CHARS IN BUFFER (THIS IS A BUG TRAP!!)
	CAIN CHR,TTICHR			;TTICHR FOR INPUT.
	JRST GETCHA
	PUSHACS
	PUSH P,LINE
	PUSHJ P,DISMES
	ASCIZ /TTY/
	POP P,TAC
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ / AT GETCHY FOR OUTPUT
/
	POPACS
	DEBCHECK
	JRST GETCHO
;GETCHA, GETCHO
; ROUTINE TO GET CHARACTER

GETCHA:	SOSGE	TSYNC(DAT)		;ALWAYS COME HERE FOR INPUT.
	SETZM TSYNC(DAT)		;DON'T LET IT GET NEGATIVE
	LDB	CHR,[POINT PUNITS,-TTIBUF+DEVCHR(DAT),35-PUNITP]
	CAIL	CHR,DPYL0
	CAILE	CHR,DPYL0+DPYNUM+DDNUM-1
	JRST	GETCHO
	HLRZ	CHR,LETAB-DPYL0(CHR)
	TRNN	CHR,WTFLAG
	JRST	GETCHO		; IF LINED NOT WAITING, JUST LEAVE WITH THE GOODS
	PUSHJ	P,GETCHO		; GET CHARACTER
	PUSHACS
	LDB	DAT,[POINT PUNITS,-TTIBUF+DEVCHR(DAT),35-PUNITP]
	PUSHJ	P,ACTIV3
	POPACS
	POPJ	P,

↑GETCHO:		;7 BIT BYTES ALREADY (OUTPUT)
GETCHX:	MOVE	CHR,TCTR(DAT)		; GET TAKR BUFFER
	CAMN	CHR,PCTR(DAT)		;IS IT SAME AS PUTR(BUFFER EMPTY)?
	JRST	GETCH1			;YES, LOAD CHR WITH ZERO AND EXIT
	SOSLE	TCTR(DAT)		;NO, ARE WE AT END OF BUFFER?
	JRST	GETCH2			;NO. GO ON.
	MOVE	CHR,BUF(DAT)		;YES. START AT TOP AGAIN
	HLRZM	CHR,TCTR(DAT)		;INITIAL COUNTER
	HRRM	CHR,TAKR(DAT)		;INITIAL POINTER
GETCH2:	ILDB	CHR,TAKR(DAT)		;GET CHARACTER
	AOS	FCTR(DAT)		;INCREMENT FREE CHAR. COUNT
	JUMPE	CHR,GETCHX		;SKIP NULLS
	POPJ	P,
GETCH1:	TDZA	CHR,CHR		;RETURN 0 INDICATING END OF BUFFER
PUTCI0:	AOS	FCTR(DAT)		;FIX FREE COUNTER
	POPJ	P,
;TSETBF, SETBFI, SETBF3, SETBFO
;ROUTINES TO SET UP BUFFERS

↑TSETBF:
	PUSHJ	P,SETBF2		; INIT TTO BUFFER

↑SETBFI:MOVE	DAT,J			; SAVE J
	LDB J,PJOBN			; GET JOB #
	JUMPE J,SETBF4
	MOVSI TAC,COMSNB
	PUSHJ P,CLRSIN			; CLEAR FROM SWAPIN LIST FOR COMMAND
SETBF4:	MOVE J,DAT			; RESTORE J
	MOVEI	DAT,1
	DPB	DAT,PCOMIC
	DPB	DAT,PLSTLC
	MOVEI	DAT,TTIBUF(DDB)		;SPECIFY USER MODE INPUT BUFFER
	SETZM	TISYNC(DDB)		;NO LINES IN BUFFER
	HRLI TAC,1100		;9 BIT BYTES IN INPUT BUFFER !!
	JRST	SETBF0			;INIT BUFFER
↑SETBF3:PUSHJ P,XMTIN4		;MAKE SURE GUY ISN'T HUNG ON OUTPUT.
SETBF2:	MOVEI	DAT,TTOBUF(DDB)		;SPECIFY OUTPUT BUFFER
↑SETBFO:HRLI TAC,700		;7 BIT BYTES IN OUTPUT BUFFER.
SETBF0:	HRR	TAC,BUF(DAT)
	MOVEM	TAC,TAKR(DAT)
	MOVEM	TAC,PUTR(DAT)
	MOVEI TAC,1
	MOVEM	TAC,TCTR(DAT)		;SO FIRST SOSG DOESNT SKIP
	MOVEM	TAC,PCTR(DAT)
	HLRZ	TAC,BUF(DAT)		;CHARACTER COUNT
	MOVEM	TAC,FCTR(DAT)		;UPDATE FREE CHARACTER COUNT
	POPJ	P,
;SPCHEK, SPCACT
;ROUTINE TO CHECK IF A CHARACTER IS SPECIAL(ASCII 0-37, 175-177)
;CALL	MOVE	CHR,CHAR. TO BE CHECKED
;	PUSHJ	P,SPCHEK
;	RETURN1 IF REGULAR ASCII CHAR (40-174), C(TAC)=0
;	RETURN2 IF SPECIAL CHAR., TAC LOADED WITH WORD FROM SPCTAB

↑SPCHEK:LDB TAC,[POINT 7,CHR,35]	;GET CODE WITHOUT CTRL BITS.
	SKIPE	TAC,SPCTAB(TAC)
	TLNN TAC,SPCBTS		;MAYBE A SPECIAL...
	POPJ P,	;NOT SPECIAL, AFTER ALL.
	JRST	CPOPJ1

;SPECIAL CHARACTER TABLE
;FORMAT	XWD BITS+CHAR,ADRESS OF ROUTINE
;HIGH ORDER BITS IN LH:

SPACTN←←400000		;SPECIAL ACTION TO BE TAKEN
ALLSPA←←200000		;ALWAYS CONTROL FUNCTIONS, NEVER BREAK CHARACTERS.
SPOUT←←100000		;SPECIAL HANDLING ON UUO OUTPUT
IMLCHR←←40000		;NOT SPECIAL ON IMLACS EVEN IF ALLSPA IS ON.
↑BREAKB←←20000		;BREAK CHARACTER
SPHPOS←←10000		;CHARACTER AFFECTS HORIZONTAL POSITION
FCSBRK←←4000		;BREAK CHARACTER IN FCS(100) MODE
ECHSUP←←2000		;SUPRESS ECHO OF CHAR ITSELF
SPBKDS←←1000		;PERFORM SPECIAL ACTION EVEN WITH CTRL. BITS.
LETTER←←400
NUMBER←←200
LNUMBT←←LETTER!NUMBER	;A LETTER OR DIGIT.

SPCBTS←←SPACTN!SPOUT!BREAKB!SPHPOS!FCSBRK

DEFINE SPC(U,L,X){FOR Z←U,L {X
			      }
		  }

SUPBTS←←1		;SUPRESS ACTIVATION ON CONTROL BITS.
SUPCCR←←2		;SUPRESS EFFECT OF CONTROL CR TO LINE EDITOR
SUPSCM←←4		;SUPRESS SUPBTS (ACTIVATE ANYWAY) IF CTRL-META

SPCACT:
	LDB TAC,[POINT 7,CHR,35]
	JUMPE TAC,CPOPJ		;ALWAYS ACTIVATE ON ↑C
	PUSH P,LINE
	IDIVI TAC,=36
	ADDI TAC,(DDB)
	MOVE TAC,ACTBTS(TAC)
	LSH TAC,(LINE)
	MOVE LINE,ACTMOD(DDB)
	TLNE TAC,400000
	JRST TTPOP
	TRNE LINE,SUPSCM
	CAIE UCHN,3
	TRNN LINE,SUPBTS
	JUMPG UCHN,TTPOP
	AOS -1(P)
TTPOP:	POP P,LINE
	POPJ P,
;SPCTAB
SPCTAB:	XWD	ALLSPA+SPACTN+ECHSUP+BREAKB+SPBKDS,CONTC	;↑C
	0					;↑A
	XWD	ALLSPA+SPACTN+ECHSUP+IMLCHR,CONTB	;↑B FULTWX&HOLD SW
	0					; β
	0					;↑D EOT
	0					;↑E WRU
0;	XWD	SPACTN+ECHSUP,CONTF		;↑F FCS SW
	0					;↑G (BELL)
	0					;↑H OR BACKSPACE KEY
	XWD	ALLSPA+SPACTN+SPHPOS+SPOUT+SPBKDS,CONTI	;↑I OR TAB
	XWD	BREAKB+SPBKDS,0			;↑J OR LINE FEED
	XWD	ALLSPA+SPACTN+SPOUT,CONTK	;↑K OR VERT TAB
	XWD	ALLSPA+SPACTN+SPOUT,CONTL	;↑L OR FORM FEED
	XWD	ALLSPA+SPACTN+SPHPOS+SPBKDS,CRLF;↑M OR CARRIAGE RETURN
	0					;↑N
	XWD	SPACTN,CONTO			;↑O SUPP OUTPUT
0;	XWD	SPACTN+ECHSUP,CONTP		;↑P T35 SW
	0					;↑Q XON (PAPERTAPE)
	0					;↑R TAPE PUNCH ON
	0					;↑S XOFF
	0					;↑T TAPE PUNCH OFF
	XWD	SPACTN,CONTU			;↑U DELETE LINE
	0					;↑V OR IDLE
	0					;↑W
	0					;↑X
	0					;↑Y
	XWD	ALLSPA+SPACTN+ECHSUP+IMLCHR,CONTZ	;↑Z TTY EOF
	0 					;ASCII 33 (OLD ALT-MODE)
	0					;ASCII 34
	0					;ASCII 35
	0					;ASCII 36
	0					;ASCII 37

SPC (" ","0"-1,0)
SPC ("0","9",<XWD NUMBER,0>)
SPC ("9"+1,"A"-1,0)
SPC ("A","Z",<XWD LETTER,0>)
SPC ("Z"+1,"a"-1,0)
SPC ("a","z",<XWD LETTER,0>)
SPC ("z"+1,174,0)

	XWD	ALLSPA+SPACTN+BREAKB+ECHSUP,ALTMOD	;OLD DEC ALTMODE 175
	0						;CLOSE CURLY BRACKET
	XWD	SPACTN+ECHSUP+FCSBRK+SPBKDS,RUBOUT	;177 RUBOUT

;TTYUUO, CLRBUF, INSKIP
;TTYUUO - QUANTITY IN AC FIELD DETERMINES ACTION OF UUO (051)

↑TTYUUO:
	CAIL	UCHN,TTUUOL		;TOO HIGH AC FIELD?
	POPJ	P,			;YES, NO-OP
	PUSHJ	P,TTYFNU
	HLRZ TAC,TTUUOT(UCHN)		;GET BITS
	TLNE	IOS,TTYDTC
	TRNE TAC,200000			;DO WE CALL ROUTINE IF DETACHED?
	CAIA				;YES
	POPJ	P,			;QUIT NOW
	SKIPG	TTUUOT(UCHN)		;IS IT AN INPUT TYPE ?
	PUSHJ	P,UNSUPR			;YES. TURN OFF CTRL. O.
	JRST	@TTUUOT(UCHN)		;DISPATCH TO UUO ROUTINES

DEFINE UUOS{FOR X IN(<INCHRW,600000>,<OUTCHR,,ONEOUT>,<INCHRS,600000>,<OUTSTR>
,<INCHWL,600000>,<INCHSL,600000>,GETLIN,<SETLIN>
,<RESCAN,,TRESCU>,<CLRBFI,,CLRBUF>,<CLRBFO,,SETBF3>,<INSKIP,600000>
,<INWAIT,600000,IWAIT>,SETACT,<TTREAD,200000>,OUTFIV)}

UUOMAC TTUUOT,TTYUUO
TTUUOL←←UUOCNT

CLRBUF:	TLNE	IOS,TPMON		;NOT ALLOWED IN MONITOR MODE!
	POPJ	P,			;JUST RETURN
	TLNE	LINE,IMLIN
	JRST	IMLCLR
	PUSHJ	P,SETBFI			;CLEAR INPUT BUFFER
	TLNE	LINE,DDDLIN!DISLIN	;THAT'S ALL FOR TTY'S
	SKIPL	TAC,LETAB-DPYL0(LINE)		;DOES HE HAVE A LINE EDITOR
	POPJ	P,				;NO, DONE
	MOVEI	CHR,10044			;GET A CLEAR
	SETZ	UCHN,				;WITH NO BITS
	JRST	PTLL3				;AND SEND IT DOWN THE TUBES

IMLCLR:	MOVE	CHR,[ASCID/π/]		;TELL IMLAC TO CLEAR ITS BUFFER.
	PUSHJ	P,FIVOUT
	PUSHJ	P,SETBFI		;CLEAR OURS
	MOVSI	IOS,IMLTTY
	ANDCAB	IOS,DEVIOS(DDB)		;AND THE BUCKY-BIT KLUDGE.
	POPJ	P,

INSKIP:	TRNE UUO,1
	SKIPLE TISYNC(DDB)		;INSKIP 1 WAITS FOR A WHOLE LINE
	TLNE	IOS,TTYDTC!TPMON
	POPJ	P,
	MOVE	TAC,TIPUTR(DDB)
	CAME	TAC,TITAKR(DDB)	;ANY CHARS. IN INPUT BUFFER ?
	JRST	CPOPJ1		;YES. SKIP RETURN.
	TLNN	LINE,DDDLIN!DISLIN	;THAT'S ALL UNLESS HE'S A DPY
	POPJ	P,
	SKIPGE	TAC,LETAB-DPYL0(LINE)	;ANYTHING IN LINE EDITOR
	SKIPG	CCPOS(TAC)		;I.E. CURSOR NOT AT LEFT
	POPJ	P,			;NO
	JRST	CPOPJ1			;YES, SKIP RETURN
;INCHSL, INCHRS, INCHWL, IWAIT, OUTSTR, INCHGT, INCHGB
;INPUT A CHARACTER AND SKIP---IF NONE TYPED, DON'T SKIP

INCHSL:	SKIPG	TISYNC(DDB)		;ANY LINES IN BUFFER?
	POPJ	P,			;NO, RETURN
INCHRS:
	TLNE	IOS,TPMON
	POPJ	P,
	PUSHJ	P,INCHGT		;GET ANY CHRS. FROM LINE EDITOR.
	MOVEI	DAT,TTIBUF(DDB)		;GET A CHARACTER
	PUSHJ	P,GETCHY		;FROM TTI BUFFER
	PUSHJ	P,PTICHK		;WAKE UP PTY WAITERS, IF ANY.
	JUMPE	CHR,CPOPJ		;RETURN IF NULL(EMPTY BUFFER)
	CAIN	CHR,600
	JRST	INCHSZ			;STORED ↑C
INCHSY:	XCTR	XW,[MOVEM CHR,(UUO)]	;MOVE INTO LOC. SPECIFIED BY UUO
	JRST	CPOPJ1			;AND SKIP RETURN

INCHSZ:	MOVE	CHR,DEVMOD(DDB)
	TLNN	CHR,TTYATC		;IF ATTACHED TO JOB
	TRNN	CHR,ASSCON!ASSPRG	;OR NOT ASSIGNED OR INITED
	JRST	MONUS6			;THEN PROCESS CONTROL-C
	JRST	INCHSY			;GIVE THE LOSER THE CONTROL-C

;INPUT CHARACTER AND WAIT, LINE MODE

INCHWL:	PUSHJ	P,INCHSL		;SEE IF ANY CHARS.
	JRST	.+2			;NO
	POPJ	P,0			;YES. GIVE IT TO USER
	TLNE	LINE,IMLIN		;BY BO - IMLACS HAVE A COMMAND
	JRST	IMCHWL			;FOR SPECIAL ACTIVATION.
IMCHW0:	MOVE	IOS,[XWD TTYIOW,IOACT]	;NONE. WAIT FOR IT
	IORM	IOS,DEVIOS(DDB)		;TTY TO IOW STATE
	MOVSI	IOS,DDTM		;JUST IN CASE
	ANDCAB	IOS,DEVIOS(DDB)		;CLEAR DDTMODE BREAK FLAG
	PUSHJ	P,TWSYNC		;WAIT FOR CHAR(INTPTI IF APPROPRIATE).
	PUSHJ	P,INCHSL		;REPEATED TESTING HERE SO
	JRST	IMCHW0			;IMLACS ONLY GET THE WORD-MODE
	POPJ	P,			;COMMAND ONCE.

IMCHWL:	TLNN	LINE,SPCBRK		;IMLAC: SPECIAL ACTIVATION MODE?
	JRST	IMCHW0
	MOVE	CHR,[ASCID/α/]		;YES.  TELL IT WE'RE WAITING.
	PUSHJ	P,FIVOUT
	JRST	IMCHW0

IWAIT:	LDB CHR,PLASTC		;GET LENGTH OF LAST RE-EDITED LINE.
	TRNE UUO,-1		;IS ADDRESS OF IWAIT 0 ?
	XCTR	XW,[MOVMM CHR,(UUO)]	;NO. USER WANTS GOOD NUMBER.
	SKIPLE	TISYNC(DDB)	;IS THERE A LINE PRESENT ?
	TLNE	IOS,TPMON	;NOTHING IN MONITOR MODE
	CAIA
	POPJ	P,
	MOVE	IOS,[XWD TTYIOW,IOACT]
	IORM	IOS,DEVIOS(DDB)
	MOVSI	IOS,DDTM
	ANDCAB	IOS,DEVIOS(DDB)
	PUSHJ	P,TWSYNC
	JRST	IWAIT

;OUTPUT A STRING--AT PRESENT LIKE DDTOUT

OUTSTR:	JRST	DDT5			;TO BE NEW ROUTINE

INCHGT:	TLNN	LINE,DISLIN!DDDLIN	; ONLY DPY'S
	POPJ	P,
	MOVE	TAC,TITAKR(DDB)
	CAME	TAC,TIPUTR(DDB)		;WILL HE GET A CHAR. WITHOUT ACTIVATING THE LINE EDITOR?
	POPJ	P,		;YES
INCHGB:	SKIPGE	TAC,LETAB-DPYL0(LINE)	;ANYTHING IN LINE EDITOR?
	SKIPG	CCPOS(TAC)		;IS POINTER INTO LINE?
	POPJ	P,			;NO
	JRST	LACTIV			;WILL TRANSFER SOME RIGHT NOW!
					;IF THERE ARE ANY!
;INCHRW, ONEOUT, GETLIN, SETLIN, SYNCHK, SYNCHA, SETACT
;MORE ROUTINES CALLED BY TTY UUO DISPATCHER

;INCHRW GOES INTO I/O WAIT IF NO CHARACTER HAS BEEN TYPED--NO SKIPS

INCHRW:	PUSHJ	P,INCHRS		;GET ACHAR IF ONE IS THERE
	JRST	.+2			;NONE THERE
	POPJ	P,			;CHAR. PICKED UP AND STORED
	TLNE	LINE,IMLIN		;BY BO - IMLACS HAVE FANCY
	JRST	IMCHRW			;COMMAND FOR THIS.
IMCHR0:	MOVE	IOS,[XWD TTYIOW+DDTM,IOACT]	;SETUP FOR IOWAITM
	IORB	IOS,DEVIOS(DDB)		;SPECIFICALLY FOR INPUT WAIT
	PUSHJ	P,TWSYNC		;WAIT FOR CHAR. TO BE TYPED
	JRST	INCHRW			;GO GET IT

IMCHRW:	MOVE	CHR,[ASCID/↓/]		;IMLAC COMMAND: SEND ONE CHAR.
	PUSHJ	P,FIVOUT
	JRST	IMCHR0

;ONEOUT OUTPUTS ONE CHARACTER

ONEOUT:	XCTR	XR,[MOVE CHR,(UUO)]	;PICK UP CHAR. FROM USER
	TRNE	IOS,IOSUPR		;IF ↑O MODE
	POPJ	P,0			;RETURN
	ANDI	CHR,177			;MASK ANY JUNK
	JUMPE	CHR,CPOPJ		;DONT STORE NULLS
	PUSHJ	P,OUTCHR		;PLACE IT IN TTO BUFFER
	JUMPN	CHR,TYPGO		;IF IT STORED, RETURN
	PUSHJ	P,TTOUWS		;BUFFER WAS FULL. TRY AGAIN LATER
	JRST	ONEOUT

;GETLIN PUTS LINE CHARACTERISTICS WORD INTO ADR. IN UUO ADR. FIELD

GETLIN:	XCTR	XR,[SKIPGE TAC,(UUO)]	;DOES USER WANT OWN LINE CHAR. WD.?
	JRST	GETLN1			;YES
	MOVEI	LINE,0			;NO, CHECK SIZE OF NUMBER
	CAIL	TAC,TTPLEN		;TOO HIGH?
	SOJL	LINE,GETLN3
	MOVE	LINE,LINTAB(TAC)	;NO, GET IT
	HRRI	LINE,(TAC)
GETLN1:	MOVE	TAC,LINE	;START WITH THIS LINE
	JRST	GETLN5		;JUMP IN
GETLN2:	TLNN	TAC,PTYLIN		;IS THIS A PTY?
	JRST	GETLN4
	MOVE	TAC,PTYJOB-PTYL0(TAC)	;OWNER OF THIS PTY
	MOVE	TAC,JBTLIN(TAC)		;HIS LINE CHARACTERISTICS
GETLN5:	CAME	TAC,[-1]		;THAT'S ALL IF WE FIND A DETACHED LINE
	JRST	GETLN2		;DOWN THE CHAIN
	JRST	GETLN3
GETLN4:	AND	TAC,[XWD DISLIN!DDDLIN,0]	;COPY THESE BITS
	TDO	LINE,TAC			;INTO LINE BITS, IN CASE WE ARE A PTY
GETLN3:	XCTR	XW,[MOVEM LINE,(UUO)]		;GIVE IT TO USER
	POPJ	P,

;ROUTINE TO SET LINE CHARACTERISTICS THAT ARE SETABLE

SETLIN:	MOVSI	TAC,LGLSET&¬IMPBIT	;MAKE MASK OF ALL OF THEM
	TLNE	LINE,DISLIN!DDDLIN!PTYLIN!IMLIN
	TLZ	TAC,TBXPND
	ANDCAM	TAC,LINTAB(LINE)	;SHUT OFF ALL SETABLE BITS
	TLO	TAC,IMPBIT		;THIS CAN BE TURNED ON BUT NOT OFF
	XCTR	XR,[AND TAC,(UUO)]	;SET ONLY THOSE BITS USER WANTS SET
	IORB	TAC,LINTAB(LINE)	;SET RESULTANT
	HLL	LINE,TAC		;NEW BITS TO LINE
SYNCHK:	MOVE	AC1,TITCTR(DDB)		;PREPARE TO SIMULATE GETCHY
	MOVE	AC2,TITAKR(DDB)	
	MOVEI	AC3,1			;ONE FOR FIRST CHAR.
	SETZM	TISYNC(DDB)		;IN CASE BUFFER EMPTY
SYNCH2:	CAMN	AC1,TIPCTR(DDB)		;IS THIS THE END?
	POPJ	P,			;YES, LEAVE
	SOJG	AC1,SYNCH3		;TEST FOR WRAP AROUND
	HRR	AC2,TTIBUF(DDB)		;RESET BYTE POINTER
	HLRZ	AC1,TTIBUF(DDB)		;AND TAKR COUNTER
SYNCH3:	ILDB	CHR,AC2			;PICK UP CHAR!
	TLNE IOS,TPMON			;MONITOR DOESN'T GET ANY OF THIS
	JRST SYNCH5
	TLNN LINE,SPCBRK		;ARE WE SPECIALLY ACTIVATING
	JRST SYNCH1			;NO
	LDB UCHN,[POINT 2,CHR,28]
	PUSHJ P,SPCACT
	JRST SYNCH4
	AOJA AC3,SYNCH2
SYNCH1:	TRNE CHR,600			;CONTROL BITS?
	JRST SYNCH4			;YES, ACTIVATE THESE SO FAR
SYNCH5:	PUSHJ P,SPCHEK
	AOJA	AC3,SYNCH2
	TLNE TAC,BREAKB!FCSBRK		;BREAK CHARACTER?
SYNCH4:	MOVEM	AC3,TISYNC(DDB)		;UPDATE TISYNC WITH # OF CHARS SCANNED SO FAR
	AOJA	AC3,SYNCH2

SYNCHA:	MOVN	AC1,FCTR(DAT)		;UNUSED SPACE IN BUFFER.
	ADDI	AC1,TTICHR		;SIZE OF BUFFER
	MOVEM	AC1,TSYNC(DAT)		;SET TISYNC
	POPJ	P,


;SETACT		SET A BREAK TABLE
;CALL
;TTYUUO 15,ADDR
;RIGHT HALF CONTAINS ADDRESS OF TABLE TO BE BLT'ED IN (NO NEW TABLE IF 0)
;LEFT HALF CONTAINS ADDRESS OF WHERE TO STORE COPY OF OLD TABLE(NO STORE IF 0)

SETACT:	XCTR	XR,[MOVS TAC,(UUO)]	;GET POINTER WORD
	TRNN	TAC,-1
	JRST	STACT1			;HE DOESN'T WANT TO KNOW WHAT HE HAD
	MOVE	TAC1,ACTBTS(DDB)	;GIVE HIM A COPY OF THE TABLE
	XCTR	XW,[MOVEM TAC1,(TAC)]
	MOVE	TAC1,ACTBTS+1(DDB)
	XCTR	XW,[MOVEM TAC1,1(TAC)]
	MOVE	TAC1,ACTBTS+2(DDB)
	XCTR	XW,[MOVEM TAC1,2(TAC)]
	MOVE	TAC1,ACTMOD(DDB)
	XCTR	XW,[MOVEM TAC1,3(TAC)]
STACT1:	HLRZ	TAC1,TAC
	JUMPE	TAC1,CPOPJ
	XCTR	XR,[MOVE TAC,(TAC1)]	;GET HIS NEW TABLE
	MOVEM	TAC,ACTBTS(DDB)
	XCTR	XR,[MOVE TAC,1(TAC1)]
	MOVEM	TAC,ACTBTS+1(DDB)
	XCTR	XR,[MOVE TAC,2(TAC1)]
	MOVEM	TAC,ACTBTS+2(DDB)
	XCTR	XR,[MOVE TAC,3(TAC1)]
	MOVEM	TAC,ACTMOD(DDB)
	POPJ	P,
;OUTFIV, FIVOUT
;FIVOUT		ADDED BY BO FOR GIVING COMMANDS TO IMLACS
;	TTYUUO 17,ADR
;ADR: 5 LEFT-JUSTIFIED ASCII CHARACTERS.
;PUTS THESE CHARACTERS, UP TO THE FIRST NULL, INTO THE OUTPUT BUFFER.
;IF BIT 35 IS A ONE, PREFIXES THESE CHARS WITH A RUBOUT.
;GUARANTEES THAT THESE CHARS WILL BE SENT AS AN INDIVISIBLE BLOCK.

OUTFIV:	XCTR	XR,[MOVE CHR,(UUO)]	;TTYUUO 17 comes here,
	PUSHJ	P,FIVOUT		;other places in TTYSER go there.
	POPJ P,

FIVOU2:	CONO PI,SCNON
FIVOU1:	PUSHJ P,TTOUWS		;Not enough room in buffer, so wait.
	CAIA

FIVOUT:	PUSH P,CHR		;Make a temp cell for the data.
	MOVEI AC3,6		;Check for enough buffer space.
	CAML AC3,TOFCTR(DDB)
	JRST FIVOU1

	CONO PI,SCNOFF		;Got room.  Turn off channel 5.
	TLNE IOS,TTYDTC		;Detached output gets flushed...
	JRST TYPT1		;...Ch. 5 back on.

	CAML AC3,TOFCTR(DDB)	;Check again for room, this time with
	JRST FIVOU2		;the interrupt disabled.

	PUSHJ P,UNSUPR		;You can't ↑O a command by God!
	MOVSI TAC,(<POINT 7,(P),-1>)	;Byte pointer into data.

	TRNN CHR,1		;If bit 35 is on,
	JRST FIVOU3
	MOVEI CHR,177		;give out with a rubout.
	PUSHJ P,PUTCHO

FIVOU3:	ILDB CHR,TAC		;Fetch next char,
	JUMPE CHR,FIVOU4	;terminate on a null.
	PUSHJ P,PUTCHO		;Stuff into buff.
	TLNE TAC,760000		;5th chr in wrd?
	JRST FIVOU3		;No.  Do it again.

FIVOU4:	CONO PI,SCNON		;It's done like you wanted, Massa.
	POP P,(P)		;Chan. 5 is back, so is the stack.
	JRST TYPGO
;TTYMES
;A UUO TO SEND A MESSAGE TO ANOTHER TTY
;FROM 1,2 TO ANYONE OR FROM ANYONE TO THE CTY OR FROM ANYONE
;TO AN UNUSED TTY.
↑TTYMES:
	MOVE	UUO,TAC			;SAVE POINTER
	XCTR	XR,[MOVE TAC,(UUO)]	;PICK UP TTYNN OR LINE NUMBER
	TLNN	TAC,770000		;IS IT SIXBIT
	JRST	TTYMS1			;NO
	CAMN	TAC,['TTY   ']		;GETTING HIS OWN?
	JRST	[PUSHJ P,TTYFND		;GET HIS TTY
		JRST TTYMS0]		;AND SKIP THE REST
	PUSHJ	P,GETDDB		;FIND DDB FOR IT BY SIXBIT TTY NAME
	POPJ	P,
	JRST	TTYMS0

TTYMS1:	MOVE	LINE,TAC		;FOR GETDBA
	PUSHJ	P,GETDBA		;FIND DDB BY TTY LINE NUMBER
	POPJ	P,			;NO DDB OR ERROR
TTYMS0:	XCTR	XR,[MOVE UUO,1(UUO)]	;PICK UP POINTER
	TLNN	UUO,770000		;ALREADY GOT P FIELD?
	TLO	UUO,440000		;NO, MAKE IT PICK UP FIRST BYTE OF WORD
	HLRZ	TAC,UUO
	ANDI	TAC,7777		;GET COUNT FIELD
	TLZ	UUO,7777
	TLO	UUO,700			;SET TO 7 BIT BYTES
	JUMPN	TAC,.+2			;IS THERE A COUNT?
	MOVEI	TAC,777777		;NO, USE LARGE COUNT
	XCTR	XW,[MOVEM TAC,JOBTM2]	;SAVE COUNT IN USER CORE
	MOVEI	DAT,TTOBUF(DDB)		;SET-UP DAT
	MOVE	IOS,DEVIOS(DDB)		;MAKE SURE IOS IS SET UP.
	AOS	(P)			;SKIP RETURN FROM HERE
	PUSHJ	P,STLNAC		;GET LINE CHARACTERISTICS. REG 7/20/73
	TLNE	LINE,CTYLIN		;IS THIS THE CTY THAT WE'RE TYPING ON?
	JRST	TTYMS9			;YES.  USE DISASTER SERVICE FOR CTY.
TTYMS3:	XCTR	XRW,[SOSL CHR,JOBTM2]	;COUNT OUT YET?
	XCTR	XLB,[ILDB CHR,UUO]	;NO. GET A CHAR.
	JUMPLE	CHR,TYPGO		;QUIT ON NULL, OR COUNT EXHAUSTED.
	MOVNI	TAC,10			;TRY THIS MANY TIMES ON EACH CHAR.
	XCTR	XW,[MOVEM TAC,JOBTM1]
TTYMS4:	MOVE	IOS,DEVIOS(DDB)		;GET IOS
	TDNE	IOS,[XWD TTYDTC,IOSUPR]	;DID SOMETHING HAPPEN?
	POPJ	P,			;YES, FLUSH THE REST!
	PUSHJ	P,OUTCHR
	JUMPN	CHR,TTYMS3		;LOOP IF CHAR PLACED
	XCTR	XRW,[AOSLE JOBTM1]	;COUNT DOWN LOSSAGE
	JRST	TTYMS8			;COUNT OUT, LOSE ON THIS CHAR
	PUSHJ	P,TYPTST		;NO, TRY TO GET HIM GOING
	LDB	TAC,PJOBN		;PICK UP JOB NUMBER
	MOVE	J,JOB(PID)		;NEED THIS FOR SLEEP
	CAMN	TAC,J			;DIFFERENT?
	JRST	TTYMSW			;WAITING FOR OURSELVES IS SIMPLE
	MOVEI	TAC,20
	PUSHJ	P,SLEEPT		;SLEEP 20 TIC'S
TTYMSD:	PUSHJ	P,STLNAC		;SLEEP CLOBBERS THIS
	XCTR	XLB,[LDB CHR,UUO]	;GET CHAR. BACK
	JRST	TTYMS4			;TRY AGAIN

TTYMSW:	PUSHJ	P,DDTWAT
	JRST	TTYMSD

TTYMS8:	SOS	(P)			;HUNG TTY, GIVE LOSSAGE RETURN
	POPJ	P,

;HERE FOR SPECIAL CASE OF TYPING ON CTY.  REG 7/20/73
TTYMS9:	XCTR	XRW,[SOSL CHR,JOBTM2]	;COUNT OUT YET?
	XCTR	XLB,[ILDB CHR,UUO]	;NO. GET A CHAR.
	JUMPLE	CHR,CPOPJ		;QUIT ON NULL, OR NEGATIVE COUNT.
	PUSHJ	P,DISTYO		;SEND CHARACTERS VIA DISASTER SERVICE
	JRST	TTYMS9
;TTREAD, TTYJNO, TTYJOB
;READ MICROSWITCH KEYBOARD USING SPCWAR MODE FEATURE
;CALL
;	TTYUUO 16,ADDR
;WHERE ADDR CONTAINS LINE NUMBER YOU WISH TO READ
;IF LINE IS ILLEGAL YOURS IS USED
;IF IT IS NOT ON THE KEYBOARD SCANNER THIS IS A NO-OP
TTREAD:	XCTR	XR,[SKIPL TAC,(UUO)]	;PICK UP LINE HE WANTS
	CAIL TAC,TTPLEN		;HIGHER THAN HIGHEST?
	HRRZ TAC,LINE		;YES
	SUBI TAC,DPYL0		;NORMALIZE IT
	JUMPL TAC,CPOPJ		;NO-OP IF NOT ON KBD SCANNER
	CAIL TAC,DPYNUM+DDNUM
	POPJ P,
	TRO TAC,100		;SET SPW BIT
	MOVEI AC3,20		;TRY THIS MANY TIMES
TTRED1:	DATAO DKB,TAC
	DATAI DKB,AC1		;READ KBD
	TRNN AC1,1B22		;SHOULD HAVE SPW BIT ON
	SOJG AC3,TTRED1		;NO, TRY AGAIN
	HLRZ AC2,AC1
	CAIE AC2,-100(TAC)	;DID WE GET THE RIGHT LINE?
	SOJG AC3,TTRED1		;NO
TTRED3:	XCTR	XW,[MOVEM AC1,(UUO)]	;STORE RESULT
	POPJ P,

;TTYJOB
;CALL:
;	MOVEI AC,<LINE #>
;	TTYJOB AC,
;	<# OF JOB OWNING TTY IN AC>
;IF LINE # IS NOT TTY LINE, RETURN JOB CONTROLLING IF PTY
↑TTYJNO:XCTR XR,[MOVE LINE,(UCHN)];GET ARG
	JUMPL LINE,PTYJNO
	CAIGE LINE,TTPLEN	;LEGAL TTY LINE #?
	SKIPN DDB,TTYTAB(LINE)	;GET DDB POINTER
	JRST TTYJN1		;NONE
	LDB TAC,PJOBN		;GET JOB NUMBER
	MOVE AC1,DEVMOD(DDB)	;CHECK IF CONTROLLING JOB
	TLNN AC1,TTYATC		;JOBS CONSOLE?
	TLO TAC,400000		;NO, SET BIT TO INDICATE JUST OWNED
	CAIA
TTYJN1:	SETZ TAC,		;FLAG NO JOB
TTYJN0:	XCTR XW,[MOVEM TAC,(UCHN)];STORE ANSWER
	POPJ P,

PTYJNO:	MOVM LINE,LINE
	CAIGE LINE,TTPLEN
	CAIGE LINE,PTYL0
	JRST .+2
	JRST PTYJN1
	HRRE LINE,JBTLIN(J)	;JOBS TTY
	JUMPL LINE,TTYJN1	;RETURN 0 IF NONE
PTYJN1:	HLL LINE,LINTAB(LINE)	;GET LINE CHARACTERISTICS
	TLNN LINE,PTYLIN	;IS IT A PTY?
	JRST TTYJN1		;NO, NO CONTROLLING JOB
	MOVE TAC,PTYJOB-PTYL0(LINE);CONTROLLING JOB
	JRST TTYJN0
;SNEAKS, SNEAKW, ACTCHR
;TWO UUO'S TO SEE THE NEXT CHAR. YOU WILL INPUT.
;ONE (SNEAKS) WHICH SKIPS IF A CHAR IS WAITING
;THE OTHER (SNEAKW) WAITS FOR A CHAR.
;BOTH RETURN THE CHAR. IN THE AC.

↑SNEAKS:
	PUSHJ P,TTYFNU		;FIND USERS TTY
	TLNE IOS,TPMON!TTYDTC	;DETACHED?
	POPJ P,			;CAN'T GET ANYTHING IF DETACHED
	MOVE AC2,TITAKR(DDB)
	CAME AC2,TIPUTR(DDB)	;ANYTHING IN TTY BUFFER
	JRST SNLOAD		;YES, RETURN IT
	TLNE LINE,DISLIN!DDDLIN
	SKIPL AC1,LETAB-DPYL0(LINE)
	POPJ P,			;NOT DISPLAY, OR NOT ACTIVE
	TLNE AC1,WTFLAG		;IF TRANSFER IN PROGRESS, LOSE
	JRST SNEAKX
	SKIPG CCPOS(AC1)	;CAN WE GET ANYTHING
	POPJ P,			;NO
	MOVE AC2,[POINT 7,LEBUF]
	ADDI AC2,(AC1)		;POINT TO BEGINNING OF LOSER EDITOR BUFFER
	ILDB TAC,AC2
	JUMPE TAC,.-1		;LOOP FOR CHAR.
	JRST SNLD1
SNLOAD:	MOVE TAC,TITCTR(DDB)
	CAIG TAC,1
	HRR AC2,TTIBUF+BUF(DDB)	;WRAP AROUND BUFFER
	ILDB TAC,AC2
SNLD1:	XCTR	XW,[MOVEM TAC,(UCHN)]	;STORE RESULT
	JRST CPOPJ1		;RETURN

SNEAKX:	PUSHJ P,WSCHED		;WAIT ONE TIC
	JRST SNEAKS		;THEN LOOK AGAIN

↑SNEAKW:
	PUSHJ P,SNEAKS
	CAIA
	POPJ P,			;SUCCESS
	MOVE IOS,[XWD TTYIOW!SNKWAT,IOACT]
	IORB IOS,DEVIOS(DDB)
	MOVSI IOS,DDTM
	ANDCAB IOS,DEVIOS(DDB)
	PUSHJ P,TWSYNC		;WAIT FOR CHAR.
	JRST SNEAKW		;TRY AGAIN

;WAITS FOR ACTIVATION AND RETURNS THE CHAR WHICH ACTIVATED IT BUT
;ONLY ON RE-EDITED LINES

↑ACTCHR:PUSHJ P,TTYFNU		;FIND USER'S TTY
	CAME LINE,[-1]		;DETACHED?
	TLNN LINE,DDDLIN!DISLIN	;ONLY DPY'S HAVE ACT. CHAR.
	JRST RTZERO		;RETURN 0 (UUO NOT CLOBBERED YET)
	MOVEI UUO,0		;RPH & FW'S FAULT (NO STORE IN IWAIT)
	PUSHJ P,IWAIT		;WAIT FOR A LINE
	MOVE CHR,LETAB-DPYL0(LINE)
	LDB CHR,[POINT 9,GWORD(CHR),35]
	XCTR	XW,[MOVEM CHR,(UCHN)]
	POPJ P,
;DDTIN
IFN FTDDTM,<

;INPUT TO DDT
;CALL AC,[SIXBIT /DDTIN/]	AC CONTAINS POINTER TO BUFFER AREA
;BUFFER AREA MUST BE 21 WORDS LONG


↑DDTIN:	PUSHJ	P,TTYFNU		; SET UP DDB,LINE
DDTINA:	MOVE	IOS,[XWD TTYIOW+DDTM,IOACT]
	IORB	IOS,DEVIOS(DDB)		;PUT INTO I/O WAIT
	TLNN	IOS,TPMON		; NOTHING THERE I IN MONITOR MODE.
	JRST	DDTINB
	PUSHJ	P,TWSYNC
	JRST	DDTINA
DDTINB:	TLNE	LINE,DDDLIN!DISLIN
	PUSHJ	P,INCHGB		;ACTIVATE LINE EDITOR, THEN WAIT ONE TIC IF NESCESARY.
	PUSHJ P,PTICHK		;CHECK FOR PTY LINKAGE.
	MOVE	TAC,TIPUTR(DDB)
	CAMN	TAC,TITAKR(DDB)		;ANYTHING IN BUFFER?
	PUSHJ	P,TWSYNC		;NO, WAIT FOR SOME
DDTIW:	MOVE	IOS,[XWD TTYIOW+DDTM,IOACT]
	ANDCAB	IOS,DEVIOS(DDB)
	MOVSI	TAC,IOFST
	IORM	TAC,DEVIOS(DDB)	;STOP ALL IO
	MOVSI	AC2,440700
	HRR	AC2,@UUO	;GET CONTENTS OF USER AC.
	MOVE	LINE,TIPUTR(DDB)
	MOVEI	DAT,TTIBUF(DDB)
	MOVEI	AC1,<21*5>-1		;NUMBER OF CHARACTERS ALLOWED
XFRIN:	PUSHJ	P,GETCHY		;TRANSFER INTO USER'S AREA
XFRIN1:	CAIN	CHR,600			;PRESTORED CONTROL C?
	JRST	XFRIN0			;YES, GO INTO MONITOR MODE
	XCTR	XDB,[IDPB CHR,AC2]
	CAME	LINE,TITAKR(DDB)	;PICKED UP ALL CHARACTERS YET?
	SOJG	AC1,XFRIN		;LOOP TILL DONE
XFRIN2:	MOVEI	CHR,0			;TERMINATE STRING
	XCTR	XDB,[IDPB CHR,AC2]
UNSUPR:	MOVEI	IOS,IOSUPR		;MAKE SURE IO NO LONGER SUPR.
	ANDCAB	IOS,DEVIOS(DDB)
	POPJ	P,

XFRIN0:	MOVE	CHR,DEVMOD(DDB)		;GET SOME GOOD BITS
	TLNN	CHR,TTYATC
	TRNN	CHR,ASSCON!ASSPRG	;THESE GUYS CAN'T TYPE COMMANDS
	JRST	DDTCNC
	JRST	XFRIN

DDTCNC:	PUSHJ	P,STLNAC		;GET LINE CHARACTERISTICS
	PUSHJ P,XFRIN2
	JRST	MONUS6			;GO PROCESS ↑C
>
;DDTOUT, DDTWAT
IFN FTDDTM,<
;OUTPUT FROM DDT
;CALL AC,[SIXBIT /DDTOUT/]	AC HAS POINTER TO DDT OUTPUT BUFFER

↑DDTOUT:
	PUSHJ	P,TTYFNU
	MOVE	UUO,@UUO
>

DDT5:	HRLI UUO,440700
DDT3:	MOVE IOS,DEVIOS(DDB)		;GET IOS
	TDNE IOS,[XWD TTYDTC,IOSUPR]	;DID SOMETHING HAPPEN?
	POPJ P,				;YES, FLUSH THE REST!
	XCTR XLB,[ILDB CHR,UUO]
	JUMPE CHR,TYPGO			;DONE, START OUTPUT
	PUSHJ P,OUTCHR			;PLACE CHAR IN OUTPUT BUFFER
	JUMPN CHR,DDT3			;LOOP IF CHARACTER WAS PLACED
	ADD UUO,[XWD 070000,0]		;BACK UP POINTER
	PUSHJ P,TYPGO
	PUSHJ P,DDTWAT
	JRST DDT3

↑DDTWAT:MOVEI TAC,TTOCHR		;SPECIFY TO WAIT TILL BUFFER IS EMPTY
	DPB TAC,PFITCH			;IF DDT TYPE-OUT IS TOO LONG
	MOVSI TAC,TTYIOW
	ANDCAM TAC,DEVIOS(DDB)		;MAKE SURE WE LOOK LIKE WE'RE IN OUTPUT WAIT!
	MOVEI IOS,IOACT			;WAIT UNTIL MONITOR BUFFER EMPTY
	IORB IOS,DEVIOS(DDB)
	JRST WSYNC
;SCNDSP, TTYIN, TWSYNC, TTYSKP
;DEVICE DEPENDENT PART OF IO UUOS.

;DISPATCH TABLE

	JRST	TTYINI		;INITIALIZATION
	JRST	CPOPJ1		;NO DO NOTHING
↑SCNDSP:
	JRST	TTYREL		; RELEASE
	JRST	OUT		;CLOSE
	JRST	TTYOUT		;OUTPUT

TTYIN:	MOVE	IOS,[XWD TTYIOW,IOACT]	;INDICATE INPUT WAIT
	IORB	IOS,DEVIOS(DDB)
	TLNE	IOS,TTYDTC
	JRST	TTYIN2
	MOVSI	TAC,TTYATC
	TDNE	TAC,DEVMOD(DDB)
	TLNN	IOS,TPMON
	JRST	TTYIN3
TTYIN2:	PUSHJ	P,TWSYNC
	JRST	TTYIN

TTYIN3:	PUSHJ	P,PTICHK		;CHECK PTY WAITERS.
	MOVSI	IOS,DDTM+TPMON
	ANDCAB	IOS,DEVIOS(DDB)
	PUSHJ	P,STLNAC	;GET LINE CHARACTERISTICS
TTYIN1:	SKIPG	TISYNC(DDB)
	PUSHJ	P,TWSYNC
	PUSHJ	P,MONUSR
	MOVE	IOS,[XWD TTYIOW!DDTM,IOSUPR!MERTPO!MERTP1!IOACT]
T0POPJ:	ANDCAB	IOS,DEVIOS(DDB)
	POPJ	P,

;TTYSKP, SKIPS IF NEXT INPUT ON CHN WON'T HANG (MUST BE TTY)
↑TTYSKP:CAMG UCHN,USRHCU
	SKIPN DDB,USRJDA(UCHN)
	JRST IOIERR
	MOVE TAC,DEVMOD(DDB)
	TLNN TAC,DVTTY		;IS IT A TTY?
	POPJ P,			;NO, GIVE HANG RETURN
	MOVE IOS,DEVIOS(DDB)
	TLNN IOS,TTYDTC		;IF DETACHED,
	SKIPG TISYNC(DDB)	;OR NOTHING TO COME IN YET
	POPJ P,			;WILL HANG
	TLNE TAC,TTYATC		;IF NOT USER CONSOLE,
	TLNN IOS,TPMON		;OR NOT IN MONITOR MODE
	AOS (P)			;WON'T HANG
	POPJ P,

;TWSYNC IS CALLED FOR INPUT IO WAIT

TWSYNC:	TLNN LINE,PTYLIN	; NO, IS IT A PTY?
	JRST TWSYN1		; NO, JUST GO INTO WAIT
	PUSH P,J
	MOVE J,PTYJOB-PTYL0(LINE)
	MOVSI AC1,INTPTI
	TDNE AC1,JBTIEN(J)
	PUSHJ P,TTINT
	POP P,J
	MOVE CHR,DEVIOS(DDB)
	TLNN CHR,TTYIOW		;DID THE LOSER TYPE SOMETHING TO US AT INTERUPT LEVEL?
	JRST TWS2
TWSYN1:	PUSHJ P,WSYNC			;WAIT FOR INPUT
TWS2:	MOVE IOS,[XWD TTYIOW+DDTM,IOACT]
	ANDCAB IOS,DEVIOS(DDB)
	POPJ P,

;MONUSR
;ROUTINE TO MOVE A LINE OR STRING FROM TTY INPUT BUFFER TO USER'S INPUT BUFFER
;CALLED ONLY FROM UUO LEVEL,FROM INPUT UUO ONLY

MONUSR:	HRRZ	TAC,DEVIAD(DDB)		;ADDRESS OF BUFFER IN USER AREA
	PUSHJ	P,BUFCLR		;CLEAR WHOLE BUFFER
	JRST	ADRERR			;ADDRESS CHECK RETURN
	PUSHJ	P,STLNAC		;SETUP LINE
	MOVEI	AC2,TTICHR		;MAX NR OF CHARACTERS
	HRRZ	AC1,DEVIAD(DDB)		;ADRESS OF USR BUFFER-1
	ADD	AC1,[XWD 10700,1]	;MAKE BYTE POINTER POINT RIGHT
	MOVEI	DAT,TTIBUF(DDB)		;SPECIFY USER MODE INPUT BUFFER

MONUS1:	PUSHJ	P,GETCHY		;GET A CHAR. FROM IT
	LDB	TAC,[POINT 7,CHR,35]	;NO CTRL BITS
	MOVE	TAC,SPCTAB(TAC)		;GET GOOD BITS
	JUMPE	CHR,MONUS3		;ZERO IMPLIES EMPTY BFR
	CAIE	CHR,3B28!12		;↑Z? (END OF FILE FOR TTY).
	JRST	MONUS9
	MOVSI	IOS,IOEND	;YES, SIGNIFY SO
	IORB	IOS,DEVIOS(DDB)
	JRST	MONUS3

MONUS9:	XCTR	XDB,[IDPB CHR,AC1]	;PLACE CHAR. IN USER BUFFER
	TLNN	TAC,FCSBRK!BREAKB	;IS IT A SYNC CHAR. ?
MONUS2:	SOJG	AC2,MONUS1		;NO, USER BUFFER FULL?
	CAIN	CHR,600			;STORED CONTROL C?
	JRST	MONUS7			;YES, HANDLE IT

MONUS3:	HRRZ	AC2,DEVIAD(DDB)		;BREAK CHAR OR COUNTED OUT, INPUT UUO DONE
	SUBI	AC1,1(AC2)		;CALCULATE NUMBER OF WORDS
	XCTR	XRW,[HRRM AC1,1(AC2)]	;STORE IN 3RD BUFFER WORD

MONUS4:	PUSHJ	P,ADVBFF		;INPUT UUO DONE,NEXT BUFFER FULL?
	JRST	MONUS5			;YES, INPUT REALLY IS DONE
	JUMPG	AC2,MONUS5		;IF WE GAVE HIM A WHOLE LINE THEN WE ARE DONE.
	SKIPLE	TISYNC(DDB)		;NO, DO WE HAVE MORE LINES FOR IT?
	JRST	MONUS8			;YES, GIVE USER NEXT LINE, TOO

MONUS5:	MOVSI	IOS,IOFST
	IORB	IOS,DEVIOS(DDB)
	TLZE	IOS,TTYIOW		;TTY IN INPUT WAIT?
	PUSHJ	P,SETIOD		;YES, TAKE IT OUT OF IT
	POPJ	P,0

MONUS6:	PUSHJ	P,CNCMOD		;CONTROL C MODE
	MOVSI	TAC,110000		;DECREMENT TAKR POINTER
	ADDM	TAC,TITAKR(DDB)		;SO NEXT ILDB WILL GET ↑C
	AOS	TITCTR(DDB)		;ADJUST COUNTER
	SOS	TIFCTR(DDB)		;ADJUST FREE CHAR. COUNT
	PUSHJ	P,SYNCHK		;FIX UP ACTIVATED COUNT
	PUSHJ	P,COMSET		;WAKE UP COMMAND DECODER
	JRST	WSYNC			;AND WAIT FOR INTERPRETATION

MONUS7:	MOVE	CHR,DEVMOD(DDB)
	TLNN	CHR,TTYATC
	TRNN	CHR,ASSCON!ASSPRG	;THESE LOSERS CAN'T TYPE COMMANDS
	CAIA
	JRST	MONUS3			;SEND IT IN TO HIM
	MOVE	IOS,[XWD TTYIOW,IOACT]
	IORB	IOS,DEVIOS(DDB)		;PUT JOB BACK IN IOWAIT
	PUSHJ	P,MONUS6
	JRST	TTYIN			;RESTART INPUT UUO

MONUS8:	TLNN	IOS,IOEND		;ROOM FOR ANOTHER BUFFER. ↑Z SEEN?
	JRST	MONUSR			;NO. GO PASS ANOTHER LINE
	POPJ	P,			;YES. LET UUOCON HANDLE EOF
;TTYOUT
;OUTPUT UUO

TTYOUT:	MOVSI	IOS,IOBEG
	TDNE	IOS,DEVIOS(DDB)
	TRO	IOS,IOSUPR		;KILL ↑O ON FIRST OUTPUT
	IOR	IOS,[XWD DDTM,MERTPO!MERTP1!IOACT]
	ANDCAM	IOS,DEVIOS(DDB)
	MOVSI	IOS,IO+IOFST
	IORB	IOS,DEVIOS(DDB)


	TLNN	IOS,TTYDTC
	PUSHJ	P,STLNAC		;GET LINE CHARACTERISTICS
	PUSH	P,LINE		;SAVE INFO
	TDNN	IOS,[XWD TTYDTC,IOSUPR]	;CONTROL O?
	PUSHJ	P,USRMON		;NO, MOVE USER'S BUFFER TO TTO BUFFER
	PUSHJ	P,ADVBFE		;ADVANCE USER'S HEADERS
	SKIPA
	TDZA IOS,IOS		;MORE BUFFERS. DON'T CLEAR IOACT.
	MOVEI	IOS,IOACT		;NO MORE BUFFERS
	ANDCAB	IOS,DEVIOS(DDB)		;CLEAR ACTIVE IN IOS
	POP	P,LINE		;RESTORE LINE INFO
	PUSHJ P,TYPGO		;GO START OUTPUT, IF NECESSARY.
	TRNE IOS,IOACT		;ARE WE DONE ?
	JRST TTYOUT		;NO. DO SOME MORE. 
	POPJ P,

;USRMON
;ROUTINE TO MOVE USER OUTPUT BUFFER TO MON. OUTPUT BUFFER
;CALLED ONLY AT UUO LEVEL,BY OUTPUT UUO

USRMON:	HRRZ	AC2,DEVOAD(DDB)		;ADDRESS OF 2ND BUFFER WORD
	XCTR	XR,[HRRZ AC2,1(AC2)]	;NUMBER OF WORDS TO OUTPUT
	IMULI	AC2,5			;NR OF CHARACTERS

USRMN1:	HRRZ	AC1,DEVOAD(DDB)		;ADDRESS OF BUFFER
	ADD	AC1,[XWD 10700,1]	;MAKE POINTER.

USRMN2:	XCTR	XLB,[ILDB CHR,AC1]	;PICK UP CHARACTER
USRMN4:	JUMPE	CHR,USRMN5		;IF NULL, IGNORE
	PUSHJ	P,OUTCHR		;PLACE IN OUTPUT BUFFER
	JUMPE	CHR,USRMN3		;IF NO MORE ROOM IN MON. BUFFER

USRMN5:	SOJG	AC2,USRMN2		;LOOP AS LONG AS THERE ARE CHAR'S.
	DPB	AC2,PFITCH		;NO CHARACTERS TO FIT
	POPJ	P,			;DONE

USRMN3:	PUSH	P,AC2
	CAILE	AC2,777			;GREATER THAN MAX? (9 BIT FIELD)
	MOVEI	AC2,777			;YES, USE MAX
	DPB	AC2,PFITCH		;NUMBER OF CHARACTERS TO GO
	PUSH	P,AC1			;SAVE RELOCATABLE POINTER
	MOVE	LINE,-3(P)		;GET SAVED LINE CHAR WORD
	PUSHJ	P,TTOUWS		;WAIT FOR IO
	POP	P,AC1			;RESTORE POINTER
	POP	P,AC2			;GET BACK CHR COUNT
	MOVE	IOS,DEVIOS(DDB)		;RESTORE IOS
	XCTR	XLB,[LDB CHR,AC1]	;GET LAST CHARACTER
	TRNN	IOS,IOSUPR		;USER TYPED ↑O?
	JRST	USRMN4			;RETURN TO OUT LOOP
	POPJ	P,			;YES, CONSIDER BUFFER MOVED

TTOUWS:	MOVEI	IOS,IOACT	;SET DEVICE ACTIVE (TTY)
	IORB	IOS,DEVIOS(DDB)
	PUSHJ	P,TYPGO		;START TYPING IF NEEDED
	JRST	WSYNC			;WAIT TILL ROOM IN BUFFER
;SCNIN1, SCNTYP, KBDINT
;COMMON PARTS OF CTY AND SCANNER INTERRUPT SERVICE ROUTINES.


SCNIN1:
	DATAI	DCSA,LINE	;GET LINE NO. FROM FULL DUPLEX.
	CONO	DCSA,4000+FSNCHN
				; RELEASE XMITTER SCANNER
	JRST	XMTINT		;IN SCNSER OR TTYSER
;ROUTINE TO OUTPUT A CHARACTER ON A LINE
;CALLED FROM TYP OR TYPL IN SCNSER

SCNTYP:	CONO PI,SCNOFF		;TURN SCANNER PI OFF IN CASE AT USER LEVEL
				;SO NO INTERRUPTS BETWEEN CONO, AND DATAO
	CONO DCSB,(LINE)	;NO
	DATAO DCSA,CHR
	CONO PI,SCNON		;TURN SCANNER PI BACK ON
	SKIPE	DDB
	DPB CHR,PLASTC	;SAVE CHAR FOR FULL DUPLEX
	POPJ P,


IFN FTOIKB,	{
↑KBDINT:
	JSR SCNSAV		; SAVE AC'S, SET UP P
	DATAI KBD,CHR
	LDB LINE,[POINT 4,CHR,17]
	LDB UCHN,[POINT 2,CHR,9]	;GET CONTROL BITS.
	TLZ CHR,777577
	CAIN CHR,2	;CHECK FOR LOST CHR
	POPJ P,
	ADDI LINE,DPYL0
	CAIN CHR,1	;USE BLANK KEY FOR ALTMODE
	MOVEI CHR,174
	CAIN CHR,177	;IS IT A BACKSPACE ?
	MOVEI CHR,136	;YES. PRETEND HARDWARE CODE IS 136.
	HRRZ DSER,CHR		;PRESERVE UNSHIFTED CHAR.
	TLZE CHR,200
	HRRZ CHR,SHFTBL(CHR)
	HRRZ CHR,CONVTB(CHR)
	CAIE CHR,600
	DPB UCHN,[POINT 2,CHR,28]	;PUT IN THE CTRL. BITS.
KBDIN1:	CAIN CHR,213			;<CTRL1>VT?
	MOVEI CHR,10042
	CAIN CHR,212			;<CTRL1>LF?
	MOVEI CHR,10044
	CAIN CHR,412			;<CTRL2>LF?
	MOVEI CHR,10000			;PATCH FOR ↑O
	JRST RECINA

;SHFTBL, CONVTB
SHFTBL:	0↔ 174 ↔0↔0↔22↔177↔0↔0
	0↔11↔12↔13↔14↔15↔0↔0
	0↔20↔0↔0↔0↔0↔24↔0
	32↔0↔0↔0↔0↔0↔0↔23
	40↔1↔0↔0↔0↔0↔0↔0
	173↔175↔0↔176↔77↔25↔46↔17
	2↔3↔6↔7↔10↔44↔52↔100
	42↔47↔33↔134↔34↔36↔35↔0
	REPEAT 30,<0>	;100-127
	0↔0↔0↔31↔16↔27↔136↔43
	45			;140
XXZ←←101
	REPEAT 32,<XXZ
XXZ←←XXZ+1>
	0↔174↔0↔0↔136

↑CONVTB:	XWD 0,600
	XXZ←←1
	REPEAT 27,<XWD XXZ,XXZ
	XXZ←←XXZ+1>
	XWD 137,137
	XWD 31,31
	XWD 134,136
	XXZ←←33
	REPEAT 45,<XWD XXZ,XXZ
	XXZ←←XXZ+1>
	XWD 140,140
	XXZ←←101
	REPEAT 33,<XWD XXZ,XXZ
	XXZ←←XXZ+1>
	XWD 177,32	;134
	XWD 135,135
	XWD 32,177	;136 IS HARDWARE FORM OF DELETE THESE DAYS.
	XWD 30,30
	XWD 100,100
	XXZ←←141
	REPEAT 33,<XWD XXZ,XXZ
	XXZ←←XXZ+1>
	XWD 176,175	;174 IS HARDWARE ALTMODE.
	XWD 174,176	; 
	XWD 175,174
	XWD 136,134		}
;DKBINT

↑DKBINT:MOVEM	CHR,DKBCHR	;SAVE ONE AC WHILE WE THINK ABOUT THIS CHAR
	DATAI	DKB,CHR
	TRNE	CHR,1B23	;INVALID?
	TRNE	CHR,1B22	;SPW?
	JRST	DKBLUZ		;IGNORE
	EXCH	CHR,DKBCHR	;STORE CHARACTER WHERE WE'LL SEE IT LATER
	JSR	SCNSAV
IFN FTHG,	<	PUSHJ P,HG	>
	DATAI	CHR
	JUMPGE	CHR,.+2
	DATAO	PI,DKBCHR	;DISPLAY IN LIGHTS IF DATA SWITCH 0 SET
	MOVE	CHR,DKBCHR	;GET BACK CHAR
	HLRZ	LINE,CHR
	ANDI	CHR,1777	;MASK UNWANTED BITS
	CAIL LINE,DPYNUM+DDNUM
	POPJ P,
	ADDI LINE,DPYL0
	TRC	CHR,1700		;MAKE SENSE OF THESE BITS RIGHT
	MOVEI AC2,(CHR)
	LDB	TAC,[POINT 2,CHR,29]	;SHIFT-TOP
	LDB	UCHN,[POINT 2,CHR,27]	;CTRL-META
	ANDI	CHR,77			;JUST THESE FOR INDEX
	CAIE	CHR,41			;BREAK?
	CAIN	CHR,42			;ESCAPE?
	JRST	DKBSPC			;SPECIAL CHARACTER
	CAIN	CHR,44			;CLEAR?
	JRST	DKBSPC
	LDB	DAT,DKBBYT(TAC)
	ANDCMI	TAC,1			;TOP ONLY
	LDB	DSER,DKBBYT(TAC)	;UNSHIFTED CHAR.
	MOVEI	CHR,(DAT)		;GET BACK SAVED CHAR.
	CAIE	CHR,600			;EXCEPT FOR ↑C
	DPB	UCHN,[POINT 2,CHR,28]	;GET BACK CONTROL BITS
	TRZA	DSER,600		;NO CONTROL BITS HERE
DKBSPC:	TRO	CHR,10000		;MAKE IT SPECIAL
	JRST	RECINA

DKBLUZ:	EXCH	CHR,DKBCHR	;RESTORE CHR, LEAVE CHARACTER WHERE WE CAN SEE IT
	DATAO	PI,DKBCHR	;DISPLAY LOSING LINE NUMBER (AND CHAR) IN LITES
	JRST	12,@CH5		;DISMISS INTERRUPT


DKBBYT:	POINT 9,DKBTBL(CHR),8
	POINT 9,DKBTBL(CHR),17
	POINT 9,DKBTBL(CHR),26
	POINT 9,DKBTBL(CHR),35
;DKBTBL
DEFINE DKBCHR(A,B)<
BYTE(9)<"A">+40,<"A">,<"B">,<"B">
>


;FORMAT IS   BYTE(9)CHAR	SHIFT CHAR	TOP CHAR	TOP SHIFT CHAR

DKBTBL:	0
	DKBCHR	A,≤
	DKBCHR	B,π
	DKBCHR	C,ε
	BYTE(9)	"d","D",74,74
	BYTE(9)	"e","E",100,100
	BYTE(9)	"f","F",76,76
	DKBCHR	G,≠
	DKBCHR	H,=
	DKBCHR	I,'
	BYTE(9)	"j","J",137,137
	DKBCHR	K,<→>
	DKBCHR	L,<↔>
	DKBCHR	M,∃
	DKBCHR	N,∀
	BYTE(9)	"o","O",173,173
	BYTE(9)	"p","P",176,176
	DKBCHR	Q,∧
	DKBCHR	R,#
	DKBCHR	S,≥
	DKBCHR	T,&
	BYTE(9)	"u","U",140,140
	DKBCHR	V,λ
	DKBCHR	W,∨
	DKBCHR	X,β
	BYTE(9)	<"y">,<"Y">,42,42
	DKBCHR	Z,α

DEFINE DKBCHR(A,B)<
BYTE(9)<"A">,<"A">,<"B">,<"B">
>

	BYTE(9)	15,15,15,15
	DKBCHR	<\>,∞
	BYTE(9)	12,12,12,12
	0					;36
	0					;37 FUCK
	BYTE(9)	40,40,40,40			;40
	0					;41 BREAK
	0					;42 ESC
	BYTE(9)	600,600,600,600			;43 ↑C
	0					;44 CLEAR
	BYTE(9)	11,11,11,11
	BYTE(9)	14,14,14,14
	BYTE(9)	13,13,13,13
	DKBCHR	<(>,[
	DKBCHR	<)>,<]>
	DKBCHR	*,⊗
	DKBCHR	+,|
	DKBCHR	<,>,!
	DKBCHR	-,¬
	DKBCHR	.,?
	DKBCHR	/,∂
	DKBCHR	0,0
	DKBCHR	1,≡
	DKBCHR	2,∩
	DKBCHR	3,∪
	DKBCHR	4,⊂
	DKBCHR	5,⊃
	DKBCHR	6,$
	DKBCHR	7,%
	BYTE(9)	<"8">,<"8">,32,32
	BYTE(9)	<"9">,<"9">,30,30
	DKBCHR	:,↓
	DKBCHR	<;>,↑
	BYTE(9)	177,177,177,177
	BYTE(9)	175,175,175,175
	0
	0
;SCNINT
;SCANNER INTERRUPT SERVICE ROUTINE.

↑SCNINT:
	JSR	SCNSAV
	CONSO	DCSA,10		;RECEIVER FLAG?
	JRST	SCNIN1		;NO,XMITTER FLAG
	CONI	DCSB,LINE	;SCANNER INPUT.
	DATAI	DCSB, CHR
	CAIL	LINE,SCNNUM	;ARE WE ENABLED FOR THIS LINE NUMBER?
	POPJ	P,		;NO, DISMISS INTERRUPT
	CAIN	LINE,APLINE
	LSH	CHR,-2		;PUT AP STUFF IN RIGHT PLACE
	CAIN	LINE,NYLINE
	LSH	CHR,-3		;FIX NY STUFF (CRETINOUS 5 LEVEL BAUDOT)
	JRST	RECINT		;RECEIVER INT. HANDLER
;CTYINT
;CTY INTERRUPT SERVICE ROUTINE

↑CTYINT:
	JSR	SCNSAV			;YES, SAVE AC'S
	MOVEI	LINE,TCONLN		;LOAD LINE WITH PROPER
	CONSO	TTY,40			;YES. TTI FLAG?
	JRST	CTYOU1			;NO.
	DATAI	TTY,CHR
IFE 0,<
	JRST	RECINT			;RECEIVER INTERRUPT HANDLER
>
IFN 0,<
	MOVEI	LINE,26
	ANDI	CHR,177
	CAIN	CHR,1
	JRST	CTYFOO
	MOVE	UCHN,CTYFO1#
	SETZM	CTYFO1
	MOVE	DSER,CHR
	DPB	UCHN,[POINT 2,CHR,28]
	JRST	KBDIN1

CTYFOO:	AOS	CTYFO1
	POPJ	P,
>

CTYOU1:	CONO	TTY,200+SCNCHN		; CLEAR TTO FLAG
	JRST	XMTINT			;COMMON TRANSMIT INTERRUPT HANDLER

;SCANNER INTERRUPT SERVICE ROUTINE IS IN SEPARATE DEVICE DEPENDENT SECTION

;RECINT, RECINA, RECINB, RECINC, RECIM3, NOESC, ESCRET

;COMMON RECEIVER INTERRUPT FOR ALL KEYBOARD DEVICES

↑RECINT:
	MOVEI UCHN,0	;NO CONTROL BITS FROM MOST KEYBOARDS.
RECINA:	HLL LINE,LINTAB(LINE)
	MOVE TAC,LINTAB(LINE)		;TTYLOK TEST WAS HERE (SEE BELOW) (ME+BH)
PTYREC:	JUMPE CHR,CPOPJ		;PTY output routines enter here (at uuo level).
	TRNE CHR,10000
	JRST SETESC
NOESC:	TRNE TAC,REGESC+SPCESC
	JRST DOESC

ESCRET:	HLL	LINE,LINTAB(LINE)	;TTYLOK TEST MOVED DOWN TO ALLOW SOME ESCS
	TLNN	LINE,CTYLIN		;ALWAYS LET CTY BY
	SKIPN	TTYLOK			;ARE WE IN LOCKOUT MODE
	JRST	NOLOCK			;NO
	MOVSI	DDB,400000		;MAKE A TEST BIT
	MOVNI	LINE,(LINE)
	LSH	DDB,(LINE)
	DATAI	APR,LINE		;READ CONSOLE SWITCHES
	TDNN	DDB,LINE		;DOES THIS GUY GET BY?
	POPJ	P,			;NO
NOLOCK:	LDB	LINE,[PUNITS⊗6,,TAC]
	SKIPE	DDB,TTYTAB(LINE)	;IS THERE A DDB FOR THIS LINE?
	JRST	RECIN1			;YES, GO ON
	CAIE	LINE,IMSSS
	CAIN	LINE,APLINE		;FLUSH AP LINE OR IMSSS IF NO DDB
	POPJ	P,
	PUSH	P,AC1
	PUSHJ	P,DDBSRC		;NO, FIND ONE
	JRST	TYPX
	POP	P,AC1
RECIN1:	HLL	LINE,LINTAB(LINE)
RECIN8:
IFN FTTALK,<	CAIN	CHR,10044	;DID HE TYPE CLEAR?
		JRST	RECINZ		;YES, LET POOR FELLOW FLUSH HIS LINED
		TLNE	LINE,TLKRNG	;IN A TALK RING?
		JRST	DOTALK		;YES, GO TALK
RECINZ:
>
	MOVE	IOS,DEVIOS(DDB)		;SET UP IOS
	TLNE	LINE,DDDLIN!DISLIN
	JRST	KBDED		; IF A DPY, GO TO SMART EDITOR
RECIN2:	TLNE	LINE,IMLIN	;IMLAC LINE?
	JRST	RECIML		;YES, SPECIAL INTERRUPT RECEIVER FOR IMLACS
RECIM2:	ANDI	CHR,177		;7-BIT ASCII ONLY
;*** BEGIN RPH HACK TO RUN DATAPHONES AS DATA DEVICES
	TLNE	IOS,TPMON	;MONITOR HEAL THY SELF
	JRST	NOSPMD		;NO SPECIAL MODE (IN CASE THIS IS HIS CONSOLE)
	LDB	TAC,PIOMOD	;PICK UP IO MODE
	CAIE	TAC,10		;SPECIAL "IMAGE" MODE?
	CAIN	TAC,11		;ANOTHER SPECIAL MODE FOR AP WIRE
	JRST [	TLZ	IOS,IMLTTY	;**BO MOD TO TURN OFF IMLAC CONTROL FLAG**
		TLNE	IOS,TTYHLD
		PUSHJ	P,TTYUNH	;ALSO DON'T ALLOW HOLDING.
		MOVEI	DAT,TTIBUF(DDB)
		PUSHJ	P,PUTCHI	;PUT CHARACTER DIRECTLY INTO INPUT BUFFER
		JFCL			;IGNORE FAILURE
		MOVE	DAT,FCTR(DAT)
		CAIE	TAC,10		;INTERRUPT EVERY CHAR?
		CAIG	DAT,TTICHR/2	;NO, HALF FULL YET?
		TLOA	IOS,DDTM	;YES, ACTIVATE IT NOW
		JRST	SNKTST		;DON'T ACTIVATE YET
		JRST	RECIN4]		;ACTIVATE, BUT NOT COMMAND DECODER
NOSPMD:
;*** END RPH HACK
	CAIE CHR,0
RECINC:	CAIN	CHR,3			;CONTROL C?
RECINB:	PUSHJ	P,CNCTST		;YES, SEE IF 2ND CONTROL C
	TLNE LINE,IMLIN
	JRST RECIM3		;IMLAC'S SEND ALL THE RIGHT CODES.
	TLNN LINE,PTYLIN	;PTY'S WILL BE SENDING RIGHT CURLY BRACKET
	CAIE CHR,176
	CAIN CHR,33		;CONVERT OLD LOSING ALTMODES INTO NEW.
	MOVEI CHR,175
RECIM3:	LDB	HPOS,PHPOS		;PICK UP HORIZONTAL POSITION OF OUTPUT CHAR.
	MOVEI	DAT,TTIBUF(DDB)		;USER MODE INPUT BUFFER
	PUSHJ	P,TTEDIT		;GO EDIT (AND ECHO) CHARACTER
	TLNN	IOS,TPMON		;NOT IN MONITOR MODE
	TLNN	LINE,PTYLIN
	JRST	RECIN5			;ONLY SPECIAL CHECK FOR PTYS
	JUMPE	UCHN,RECIN5
	MOVE	TAC,ACTMOD(DDB)
	TRNE	TAC,SUPSCM
	CAIE	UCHN,3
	TRNN	TAC,SUPBTS
	TLO	IOS,SYNC		;ACTIVATE PTY ON CTRL META
RECIN5:	TRNN	IOS,NOECHO		;IF WE ECHOED IT,
	DPB	HPOS,PHPOS		;STORE HORIZONTAL POSITION
	TLNE	IOS,TTYHLD		;IF TYPEOUT IS HOLDING
	CAMN	TAC,SPCTAB+2		;AND THE CHAR WASN'T ↑B...
	CAIA
	PUSHJ	P,TTYUNH		;THEN UNHOLD.
	HLLM	LINE,LINTAB(LINE)	;UPDATE LINE TABLE
	MOVE	TAC,TIFCTR(DDB)		;FREE SPACES LEFT
	CAIG	TAC,12			;ONLY 10 LEFT?
	JRST	RWARN			;YES. GO OUTPUT XOFF
	TLNN	IOS,SYNC!DDTM		;WAS A BREAK CHARACTER TYPED?
	JRST	SNKTST			;NO, GO SEE IF ECHO NEED BE TYPED
	TLNN	IOS,SYNC		;DON'T CRANK UP CH7 UNLESS SYNC CHAR.
	JRST	RECIN4
;RECIN3, RECIN4, UTYPET, TYPTST, TYPGO, TTINT

RECIN3:	MOVSI	TAC,COMBIT		;IS IT IN COMMAND WAIT NOW?
	TDNN	TAC,TTYTAB(LINE)	;..
	PUSHJ	P,COMSET		;NO, WAKE UP COMMAND DECODER NOW
RECIN4:	MOVEI	DAT,TTIBUF(DDB)		;SET FOR SYNCHA
	TLZE	IOS,SYNC!DDTM		;ACTIVATION CHAR.?
	PUSHJ	P,SYNCHA		;UPDATE ACTIVATED CHAR. COUNT
					;CLEAR SYNC IN CORE
	MOVEM	IOS,DEVIOS(DDB)		; ..
	MOVE	TAC,TIPCTR(DDB)		;UPDATE COUNTER FOR ↑U
	DPB	TAC,PLSTLC
	TLNE	IOS,TPMON		;NO INTERRUPTS IN MONITOR MODE.
	JRST	TYPTST
	LDB	J,PJOBN			; PICK UP JOB NUMBER
	MOVSI	AC1,INTTTY		; GIVE HIM A TTY INTERRUPT IF DESIRED
	TDNE	AC1,JBTIEN(J)		; IS HE ENABLED FOR IT?
	PUSHJ	P,TTINT			; YES, DO IT.
	TLZN	IOS,TTYIOW		;IN TELETYPE INPUT WAIT?
	JRST	TYPTST			;NO, GO ECHO
SNKWAK:	PUSHJ	P,STTIOD		;YES, SET IO DONE(OUT OF TTY IOW)
	PUSHJ	P,STXTIM		;UPDATE INTERACTION RUN TIME (XTIME)
	MOVSI	IOS,IOW!TTYIOW!SNKWAT
	ANDCAB	IOS,DEVIOS(DDB)		;CLEAR WAIT BITS
↑UTYPET:
TYPTST:	TLNE	IOS,TTYDTC
	JRST	TYPT1
	PUSHJ	P,STLNAC		;CLOBBERED BY STTIOD
	TLNE LINE,PTYLIN		;IS THIS A PTY
	JRST PTOCK			;YES, JUST GO CHECK PTY STUFF
	MOVSI	IOS,TOIP
	CONO	PI,SCNOFF
	TDNE	IOS,DEVIOS(DDB)		;TYPE OUT HAPPENNING?
	JRST	TYPT1
	IORB	IOS,DEVIOS(DDB)		;NO, BUT THERE IS NOW
	CONO	PI,SCNON
	TLNN IOS,TTYDTC		;DON'T TYPE IF HE'S DETACHED...
	JRST	XMTIN1			;START OUTPUT
TYPT1:	CONO	PI,SCNON
	POPJ	P,

SNKTST:	TLNN IOS,SNKWAT			;IS LOSER IN SNEAK WAIT?
	JRST TYPTST			;NO, PROCEED NORMALLY
	JRST SNKWAK

↑TYPGO:	MOVE	IOS,DEVIOS(DDB)
	TDNE	IOS,[XWD TTYDTC,IOSUPR]
	JRST	TYPT1			;FLUSH OUTPUT
	PUSHJ P,STLNAC
	MOVSI	IOS,IO
	TLNN LINE,PTYLIN
	CONO	PI,SCNOFF		;MAKE SURE OF NO RACE!
	IORB	IOS,DEVIOS(DDB)
	JRST	TYPTST

RWARN:	TLO	IOS,DDTM		;ACTIVATE EVERYTHING SO FAR
	TLNE	LINE,FULTWX!PTYLIN!DISLIN!IMLIN	;CAN LINE BE STOPPED?
	JRST	RECIN3			;NO. WAKE JOB AND CROSS FINGERS.
	MOVEI	CHR,23			;YES. SEND AN XOFF.
	PUSHJ	P,PUTCHO		; ..
	MOVEI	CHR,IDLECH		;AND AN IDLE FOR TTY TO THINK ON.
	PUSHJ	P,PUTCHO		;OUTPUT IT.
	JRST	RECIN3			;GO WAKE JOB.

TTINT:	IORM AC1,JBTIRQ(J)
	SETOM INTREQ(PID)
	HLLOS CLKFLG(PID)
	CONO PI,1B24!1⊗(7-CLKCHN)
	POPJ P,

STXTIM:	LDB	J,PJOBN			;GET JOB NUMBER
↑STXTM2:				;ENTRY POINT FROM RUN-JOB CODE
	JUMPE	J,CPOPJ			;IF NO JOB, NO XTIME
	SKIPGE	XTIME(J)		;IS NO-UPDATE BIT ON?
	POPJ	P,			;YES.  DONT DO ANYTHING!
	MOVE	TAC,TTIME(J)		;PICK UP CURRENT RUN TIME
	MOVEM	TAC,XTIME(J)		;UPDATE INTERACTION RUN TIME
	SKIPGE	TAC,JBTWAT(J)		;PICK UP WAIT TIME
	ADD	TAC,UPTIME		;MAKE IT HONEST
	MOVEM	TAC,JB2WAT(J)		;AND SAVE IT
	HRLS	DSKOPS(J)		;SAVE CURRENT NUMBER OF DISK OPERATIONS
	POPJ	P,
;ESCAPE BITS
;DEFINITIONS FOR ESCAPE PROCESSOR
;ALL THIS STUFF GOES IN RH(LINTAB)

REGESC←←400000	;NORMAL ESCAPE TYPED
SPCESC←←200000	;SPECIAL
ESCNEG←←100000	;NEGATION FLAG (BREAK, ETC.)

ESCTYP←←200200			;BYTE PNTR FOR TYPE BITS
ESCARG←←PUNITS⊗14+<17-PUNITS>⊗6	;EVERYTHING ELSE IS ARG
ESCFLD←←PUNITS⊗14+<22-PUNITS>⊗6	;WHOLE ESCAPE FLD
ESCNUL←←ESCNEG⊗-PUNITS-1		;MAX VAL USED FOR NULL (ZERO SOMETIMES LEGAL)
ESCMAX←←ESCNUL-1		;MAX LEGAL VALUE
;SETESC
;HERE ON <ESC>,<BREAK>, OR <CLEAR> (ALSO FUNNY CHARS FROM PTYS)
;ESCAPE CODE BITS ARE SET UP FOR NEXT TIME

SETESC:	CAIN CHR,10044
	JRST NOESC		;<CLEAR> ISN'T REALLY AN ESC CHR
	MOVEI AC3,
	CAIN CHR,10042
	MOVEI AC3,REGESC⊗-PUNITS+ESCNUL
	CAIN CHR,10041
	JRST [	CAIE UCHN,1	;WATCH OUT FOR CTRL-BRK
		MOVEI AC3,<REGESC+ESCNEG>⊗-PUNITS+ESCNUL
		JRST .+1]
	CAIN AC2,1641
	MOVEI AC3,SPCESC⊗-PUNITS+ESCNUL
	DPB AC3,[ESCFLD,,LINTAB(LINE)]
	JUMPN AC3,CPOPJ		;EXIT IF ESC CHR
	HLRE AC1,CHR
	JUMPLE AC1,.+2
	ANDI AC1,ESCNUL
	JUMPN AC1,.+2
	MOVEI AC1,ESCNUL	;ELSE MAP 10XXX→<ESC>XXX, 14XXX→<BRK>XXX
	TRNE CHR,4000		;(EASIER FORM FOR PTYUUO'S)
	MOVN AC1,AC1
STDESC:	CAIN DSER,"a"
	JRST VDESCA
	CAIN DSER,"d"
	JRST VDESCD
	CAIN DSER,"s"
	JRST VDESCS
	CAIN DSER,"t"
	JRST VDESCT
	CAIN DSER,"u"
	JRST ASESC	;AUDIO SWITCH CHANNEL SELECT
	CAIN DSER,"b"
	JRST ESCB	;AUDIO SWITCH UNBEEPER
STDES2:	TRO CHR,10000	;PASS IT ON TO LINED
	CAIN AC1,ESCNUL	;WITH ARG IN SIGN-MAGNITUDE FORM
	MOVEI AC1,
	JUMPGE AC1,ESCRET
	MOVN AC1,AC1
	CAIN AC1,ESCNUL
	MOVEI AC1,
	HRLI AC1,400000
	JRST ESCRET

;REMEMBER THAT ARG WE READ IN IN DECIMAL? WELL, WE REALLY WANTED
;TO READ IT IN OCTAL, SEE, SO . . .

ESCOCS:	AOS (P)
ESCOCT:	IDIVI AC1,=100
	IDIVI AC2,=10
	LSH AC2,3
	ADD AC2,AC3
	LSH AC1,6
	ADD AC1,AC2
	POPJ P,
;DOESC
;HERE ON NEXT CHAR AFTER ESCAPE. ANY ARG IS ACCUMULATED LEAVING ESC BITS SET.
;OTHER CHARS CLEAR BITS (LEAVING ESCAPE MODE) AND DISPATCH TO APPROP HANDLER

DOESC:	LDB AC1,[ESCARG,,TAC]
	LDB AC2,[ESCTYP,,TAC]
	CAIE AC2,1
	JRST .+3
	CAIE UCHN,3
	SOJA AC2,ESCXIT
	CAIL DSER,"0"
	CAILE DSER,"9"
	JRST DOESC1
	CAIN AC1,ESCNUL
	TDZA AC1,AC1
	IMULI AC1,12
	ADDI AC1,-"0"(DSER)
	CAILE AC1,ESCMAX
	MOVEI AC1,ESCMAX
	DPB AC1,[ESCARG,,LINTAB(LINE)]
	POPJ P,

DOESC1:	CAIN DSER,"-"
	JRST DOESCN
	TRNE TAC,ESCNEG
	MOVN AC1,AC1
ESCXIT:	ANDI TAC,1⊗PUNITS-1
	HRRM TAC,LINTAB(LINE)
	JRST @ESCDSP(AC2)	;NOTE AC2>0 OR WE WOULDN'T BE HERE

ESCDSP:	ESCRET
	SPESC
	STDESC

DOESCN:	MOVEI TAC,ESCNEG
	XORM TAC,LINTAB(LINE)
	POPJ P,
;SPESC
SPESC:	TLO TAC,200000
IFN FTDDT,<
	CAIN CHR,600
	CAIE UCHN,3
	CAIA
	JRST DDTCAL
>;FTDDT
	CAIE CHR,600-40(DSER)
	JRST ESCRET
	CAIN CHR,600+"L"
	JRST SPESCL
	CAIE CHR,600+"M"
	JRST STDESC
	PUSHJ P,ESCOCT
	CAIL AC1,TTPLEN
	MOVEI AC1,(LINE)
	HRRM AC1,LINTAB(LINE)
	POPJ P,

SPESCL:	MOVE TAC,LINE
	MOVE AC2,LINTAB(TAC)
	TLNN AC2,DDDLIN
	POPJ P,
	SUBI TAC,DDL0
	PUSHJ P,ESCOCT
	CAIL AC1,DDL0
	CAIL AC1,DDL0+DDNUM
	POPJ P,
	SKIPN AC2,LETAB-DPYL0(AC1)
	SKIPA AC3,VDMAP-DDL0(AC1)
	MOVE AC3,VDTMP(AC2)
	PUSHJ P,VDSTR
	MOVEM AC3,VDTMP(AC2)
	JRST VDOUT
;ESCAPES

;ADD CHANNEL TO MAPPING
VDESCA:	PUSHJ P,VDESTV
	PUSHJ P,VDECHK
	PUSHJ P,VDVCHK
	DPB AC1,[400,,VDTMP(AC2)]
	PUSHJ P,VDSTRB
	IORM AC3,VDTMP(AC2)
	JRST VDOUT

;NORMALIZE SWITCH FOR THIS CHANNEL
VDESCN:	PUSHJ P,VDNORM
	JRST VDOUT

;DELETE CHANNEL FROM MAPPING
VDESCD:	PUSHJ P,VDESET
	POPJ P,
	PUSHJ P,VDBIT
	CAIL AC1,40
	MOVEI AC3,17	;ANY HIGH # CLEARS ANALOG SELECT
	PUSHJ P,VDSTR
	ANDCAM AC3,VDTMP(AC2)
	JRST VDOUT

;SELECT SINGLE CHANNEL INTO MAPPING
VDESCS:	PUSHJ P,VDESTV		;<ESC>S
	PUSHJ P,VDECHK
	PUSHJ P,VDVCHK
	MOVEM AC1,VDTMP(AC2)
	PUSHJ P,VDSTRB
	MOVEM AC3,VDTMP(AC2)
	JRST VDOUT

;SELECT SINGLE CHANNEL TEMPORARILY
VDESCT:	PUSHJ P,VDESTV
	PUSHJ P,VDECHK
	TRZN AC1,-40
	JRST VDESC2
	ANDI AC1,7
	SKIPA AC3,VDSYNC(AC1)
VDESC2:	PUSHJ P,VDBIT
	SKIPE AC2,LETAB+DPYNUM(TAC)
	MOVEM AC3,VDTMP(AC2)
	JRST VDOUT

VDESTV:	JUMPGE AC1,CPOPJ	;<ESC>S OR <ESC>T OR <ESC>A
	CAME AC1,[-ESCNUL]	;SKIP IF <BRK>
	POPJ P,
	PUSH P,AC1
	PUSH P,TAC
	HRRZI AC1,ASTVC		;TV AUDIO CHANNEL
	PUSHJ P,ASESC		;SIMULATE ESC # U WHERE # = ASTVC
	POP P,TAC
	POP P,AC1
	POPJ P,
;MORE ESCAPES	VDESET	VDECHK	VDVCHK
;SET UP ARGS FOR VD CMDS, SKIP IF LEGAL.
;NO ARG => MY CHAN. + ARG => DD CHAN #. - ARG => CHAN FOR TTY #.
VDESET:	HRRI TAC,-DDL0(LINE)
	MOVE AC2,LINTAB+DDL0(TAC)
	TLNN AC2,DDDLIN
	JRST VDEST4
	JUMPL AC1,VDEST3
	CAIE AC1,ESCNUL
	JRST ESCOCS
	MOVEI AC1,-DDL0(AC2)
	TLO TAC,200000
VDEST2:	SKIPN AC2,LETAB+DPYNUM(AC1)
	SKIPA AC1,AVLCHN
	HLRZ AC1,PRGNUM(AC2)
	JRST CPOPJ1

VDEST3:	MOVN AC1,AC1
	CAIN AC1,ESCNUL
	JRST VDEST1
	PUSHJ P,ESCOCT
	SUBI AC1,DDL0
	CAIGE AC1,DDNUM
	JUMPGE AC1,VDEST2
	POPJ P,

VDEST1:	MOVEI AC1,45		;<BRK> WITH NO ARG IS ALWAYS TV CHANNEL
	JRST CPOPJ1		;RPH OCT-27-72

VDEST4:	TLNE AC2,DISLIN		;NOT DD, SEE IF III
	SKIPN LETAB+DPYNUM(TAC)
	POPJ P,			;NOT III OR NO DPY HEADER MEANS ILLEGAL
	JUMPL AC1,CPOPJ
	HRROI TAC,(TAC)		;(THANK YOU MR. FROST - REG) SET SIGN FOR VDSTRI
	CAIN AC1,ESCNUL
	SKIPA AC1,[-4,,]	;NULL ARG MEANS ALL P OF G'S
	PUSHJ P,ESCOCT
	TRNN AC1,-20
	AOS (P)			;SKIP IF LEGAL P OF G #
	POPJ P,

;SET UP ARGS & CHECK PRIVACY. RETURNS UPLEVEL ON LOSSAGE
VDECHK:	PUSHJ P,VDESET
	JRST TPOPJ
	TLNE TAC,200000
	POPJ P,
	CAIGE AC1,40
	SKIPL DDTAB(AC1)
	POPJ P,
	MOVEI AC3,(TAC)
	MOVEI J,
	PUSHJ P,VDCCHK
	SUB P,[1,,1]
	POPJ P,

;CHECK IF CHANNEL IS REALLY ANALOG, AND HANDLE SPECIALLY
VDVCHK:	TRZN AC1,-40
	JRST CPOPJ1
	ANDI AC1,7
	IOR AC1,VDSYNC(AC1)
	PUSHJ P,VDSTR
	XCT @-1(P)
	SUB P,[1,,1]
	JRST VDOUT
;ASSCN, ASESC, ESCB  AUDIO SWITCH SERVICE

;ASBTAB HAS DURATION OF BEEP IN 1/4 SEC UNITS
;IF NON-ZERO, INDICATES BEEP IS HAPPENING

;ASTAB BITS
;RH HAS TIME REMAINING IN TEMP SELECTION IN 1/4 SEC UNITS
;	ZERO MEANS INFINITE
;BITS	  FUNCTION
;0     => UUO IS HANGING UNTIL TEMPORARY SELECTION TIMES OUT
	ASHANG←←400000
	ASHGBP←←430100
;1     => CURRENT SELECTION IS TEMPORARY
	ASTEMP←←200000
;2     => PAGING NOW
	ASPAGN←←100000
;3     => BEEP WHEN TEMPORARY SELECTION TIMES OUT
	ASDBEP←←40000
;4     => PERMANENT CHANNEL NOT PAGE INTERRUPTIBLE
	ASPPUN←←20000
	ASPPUP←←370100
;5     => PERMANENT CHANNEL NOT BEEP INTERRUPTIBLE
	ASPBUN←←10000
	ASPBUP←←360100
;6-7   => TEMPORARY CHANNEL BEEPING DISPOSITION
	ASBPDP←←340200
;8-9   => TEMPORARY CHANNEL PAGING DISPOSTION
	ASPGDP←←320200
;10-13 => TEMPORARY CHANNEL NUMBER
	ASTMPP←←260400
	ASTMPM←←360
;14-17 => PERMANENT CHANNEL NUMBER
	ASPRMP←←220400
	ASPRMM←←17	;MASK

;DISPOSITION CODES
	;0: INTERRUPTIBLE
	;1: NON-INTERRUPTIBLE
	;2: INTERRUPTIBLE, BUT EXTEND DURATION OF TEMP CH
	;3: POSTPONE BEEP UNTIL TEMP SELECTION TIMES OUT

;NOTE: 3 IS APPLICABLE ONLY TO BEEP DISPOSITION

ASPAGC←←0			;AUDIO SWITCH PAGING CHANNEL
ASTVC←←1			;AUDIO SWITCH TV CHANNEL
ASBEPC←←5			;AUDIO SWITCH BEEP CHANNEL
ASBPTM←←3			;3/4 SEC FOR BEEP

;AUDIO SWITCH CHANNEL PERMANENT SELECTION
ASESC:	HRREI TAC,-DPYL0(LINE)
	JUMPL TAC,CPOPJ		;NOT A DPY
	CAIL TAC,DPYNUM+DDNUM
	POPJ P,
	MOVEI DSER,0
	JUMPGE AC1,ASESC1	;JUMP IF PAGE INTERRUPTIBLE PERM SELECTION ESC U
	MOVN AC1,AC1		;BRK#U MAKE PAGE UNINT.PERMANENT SELECTION
	MOVEI DSER,ASPPUN	;PERM PAGE UNINTERRUPTIBLE
ASESC1:	CAIN AC1,ESCNUL
	MOVEI AC1,ASPAGC⊗-3*=10+ASPAGC&7	;FAKE OUT ESCOCT
	PUSHJ P,ESCOCT		;ASSUME TYPEIN WAS OCTAL
ASSEL:	LDB AC3,[ASHGBP,,ASTAB(TAC)]	;UUO HANG BIT
	IORI AC1,(DSER)		;PERM SELECTION AND MAYBE PPUN BIT
	HRLZM AC1,ASTAB(TAC)	;CLEAR ALL OTHER BITS
	SETZM ASBTAB(TAC)	;CLEAR BEEP DURATION
	HRLI AC1,(TAC)
	DATAO AS,AC1		;DO SELECTION NOW
	JUMPN AC3,ASUNHG	;UNHANG POOR UUO
	POPJ P,


↑ASSCN:	CONO PK,0		;MAKE SURE WE DON'T RUN PAGING INT CODE
	MOVSI TAC,-<DPYNUM+DDNUM>
	MOVEI TAC1,-1
ASSCNL:	TDNE TAC1,ASBTAB(TAC)	;CHECK FOR BEEPING GOING ON
	JRST ASSCB
	TDNN TAC1,ASTAB(TAC)	;SKIP IF NON-INFINITE TEMP SELECTION
	JRST ASSCLN
	MOVE AC1,ASTAB(TAC)
	LDB AC2,[ASPGDP,,AC1]		;TEMP PAGE DISPOSITION
	TLNN AC1,ASPAGN
	JRST ASSCN1		;NOT PAGING NOW
	CAIN AC2,2
	JRST ASSCLN		;PAGING AND EXTEND, SO DON'T COUNT TEMP DURATION
ASSCN1:	SOS AC1,ASTAB(TAC)	;DECREASE ITS COUNT
	TRNN AC1,-1		;SKIP IF NOT TIME YET
	JRST ASSCTO		;TIMED OUT, SET BACK TO PERMANENT
ASSCLN:	AOBJN TAC,ASSCNL
	CONO PK,PKCHN
	POPJ P,

;IN MIDDLE OF BEEP (CAN'T BE IN A PAGE -- SEE PKINT)
ASSCB:	SOS AC1,ASBTAB(TAC)	;DECREMENT BEEP DURATION
	MOVE AC2,ASTAB(TAC)
	TLNN AC2,ASTEMP		;SKIP IF BEEP INTERRUPTED TEMP SEL
	JRST ASSCB1		;BEEP IS DURING PERM SEL
	LDB AC2,[ASBPDP,,AC2]	;TEMP BEEP DISPOSITION
	TDNE TAC1,ASTAB(TAC)	;IF TEMP SEL IS INFINITE OR ...
	CAIN AC2,2
	JRST ASSCB1		;IF EXTEND, THEN DON'T COUNT TEMP DURATION
	SOS AC2,ASTAB(TAC)
	TRNN AC2,-1		;IF TEMP RUNS OUT DURING BEEP, ...
	TLZ AC2,ASTEMP		;MAKE IT LOOK LIKE INTERRUPTED PERM
	MOVEM AC2,ASTAB(TAC)
ASSCB1:	TRNE AC1,-1
	JRST ASSCLN		;BEEP NOT DONE, CONTINUE SCAN
ASRVRT:	MOVE AC1,ASTAB(TAC)
	TLZE AC1,ASDBEP
	JRST ASRVR1		;GO AND BEEP
	TLNE AC1,ASTEMP		;SKIP IF GOING BACK TO PERM
	JRST ASRVR3		;GOING BACK TO TEMP
	TLNE AC1,ASHANG		;SKIP IF UUO NOT HUNG
	PUSHJ P,ASUNHG		;UNHANG UUO
	LDB AC2,[ASPRMP,,AC1]	;PERM SEL
ASRVR2:	HRLI AC2,(TAC)
	DATAO AS,AC2
	JRST ASSCLN		;CONTINUE SCAN

ASRVR3:	LDB AC2,[ASTMPP,,AC1]	;TEMP SEL
	JRST ASRVR2

ASRVR1:	MOVEM AC1,ASTAB(TAC)	;STORE BACK WITH BEEP BIT OFF
	MOVEI AC2,ASBPTM
	MOVEM AC2,ASBTAB(TAC)	;SET UP BEEP DURATION
	MOVEI AC2,ASBEPC
	JRST ASRVR2		;SELECT BEEP CHANNEL AND CONTINUE SCAN

ASSCTO:	TLZ AC1,ASTEMP		;TEMP SEL TIMED OUT, CLEAR TEMP BIT
	TLNE AC1,ASPAGN
	JRST ASSCT2		;PAGING NOW
	TLZE AC1,ASDBEP
	JRST ASRVR1		;DO DELAYED BEEP
	MOVEM AC1,ASTAB(TAC)
	TLNE AC1,ASHANG
	PUSHJ P,ASUNHG		;UNHANG UUO
ASSCT1:	LDB AC2,[ASPRMP,,AC1]
	JRST ASRVR2		;SELECT PERM AND CONTINUE SCAN

ASSCT2:	MOVEM AC1,ASTAB(TAC)	;JUST CLEAR TEMP BIT AND
	JRST ASSCLN		;CONTINUE SCAN

;UNHANG UUO THAT WAS WAITING FOR TEMP SEL TO FINISH
ASUNHG:	PUSH P,DDB
	PUSH P,J
	MOVSI J,ASHANG
	ANDCAM J,ASTAB(TAC)	;CLEAR UUO HANG BIT
	HRRZ DDB,TTYTAB+DPYL0(TAC)
	JUMPE DDB,ASUNHR	;NO DDB, DONE
	MOVSI J,TTYATC
	TDNN J,DEVMOD(DDB)
	JRST ASUNHR		;NOT CONSOLE, DONE
	LDB J,PJOBN		;JOB NUMBER
	MOVM DDB,JOBQUE(J)
	CAIE DDB,IOWQ
	JRST ASUNHR		;NOT IN IOWQ NOW
	MOVEI DDB,RUNQ		;GRONK INTO RUNQ
	MOVNM DDB,JOBQUE(J)
	PUSHJ P,REQUE
ASUNHR:	POP P,J
	POP P,DDB
	POPJ P,

ESCB:	HRREI AC2,-DPYL0(LINE)
	JUMPL AC2,CPOPJ
	CAIL AC2,DDNUM+DPYNUM
	POPJ P,			;NOT A DPY
	MOVSI TAC,ASPBUN
	JUMPL AC1,ESCB1
	ANDCAM TAC,ASTAB(AC2)	;ESC B MAKES YOU BEEP INTERRUPTIBLE
	POPJ P,

ESCB1:	IORM TAC,ASTAB(AC2)	;BRK B MAKES YOU BEEP UNINTERRUPTIBLE
	POPJ P,
;PKINT	PAGING INTERRUPT SERVICE ROUTINE

↑PKCHN←←5			;PI CHANNEL FOR PAGING KLUDGE
↑PKINTB←←10			;INTERRUPT BIT IN CONI
↑PKPAGE←←20			;PAGING BIT IN CONI
↑PKSET←←10
↑PKCLR←←20

↑PKINT:	JSR PKSAV		;SAVES ACS AND PUSHJS TO .+1
	CONO PK,PKCLR!PKCHN
	MOVSI TAC,-<DPYNUM+DDNUM>
	CONSO PK,PKPAGE		;SKIP IF PAGING JUST BEGINNING
	JRST PKINND		;PAGING FINISHED
	SETOM PAGNOW		;INDICATE PAGING NOW IN PROGRESS
	MOVEI TAC1,-1
PKINL:	MOVEI DSER,0		;-1 => BEEPING
	TDNE TAC1,ASBTAB(TAC)
	MOVNI DSER,1		;BEEPING NOW
	MOVE AC1,ASTAB(TAC)
	TLNN AC1,ASTEMP		;SKIP IF TEMP SELECTION NOW IN FORCE
	JRST PKINP		;PERM
	LDB AC2,[ASPGDP,,AC1]
	CAIN AC2,1
	JRST PKINLA		;NOT PAGE INTERRUPTIBLE
PKINLB:	JUMPE DSER,PKINL1	;NOT BEEPING, JUST DO IT
	HLLZM ASBTAB(TAC)	;FLUSH BEEP
	TLO AC1,ASDBEP		;SET DELAYED BEEP BIT
PKINL1:	TLO AC1,ASPAGN		;PAGING NOW
	MOVEM AC1,ASTAB(TAC)
	MOVEI AC2,ASPAGC
	HRLI AC2,(TAC)
	DATAO AS,AC2
PKINLA:	AOBJN TAC,PKINL
	POPJ P,

;PERMANENT SELECTION IS NOW IN FORCE
PKINP:	TLNE AC1,ASPPUN		;SKIP IF PAGE INTERRUPTIBLE
	JRST PKINLA		;CONTINUE SCAN
	JRST PKINLB

;HERE IF PAGING INTERRUPT BUT PAGING BIT IS OFF
PKINND:	SETZM PAGNOW
	MOVE AC1,ASTAB(TAC)
	TLZN AC1,ASPAGN		;SKIP IF HAS BEEN INTERRUPTED FOR PAGING
	JRST PKINNA		;DON'T HAVE TO MUNG HIM
	TLZN AC1,ASDBEP		;SKIP IF HAVE TO DO BEEP NOW
	JRST PKINN1
	MOVEI AC2,ASBPTM
	MOVEM AC2,ASBTAB(TAC)	;SET UP BEEP DURATION
	MOVEI AC2,ASBEPC	;SELECT BEEP CHANNEL AND CONTINUE SCAN
PKINN2:	MOVEM AC1,ASTAB(TAC)
	HRLI AC2,(TAC)
	DATAO AS,AC2
PKINNA:	AOBJN TAC,PKINND
	POPJ P,

;DELAYED BEEP BIT WAS OFF
PKINN1:	TLNN AC1,ASTEMP		;SKIP IF GOING BACK TO TEMP SEL
	JRST PKINNP
	LDB AC2,[ASTMPP,,AC1]	;TEMP CHANNEL SELECTION
	JRST PKINN2

;GOING BACK TO PERMANENT SELECTION
PKINNP:	TLZE AC1,ASHANG		;SKIP IF UUO NOT HANGING
	PUSHJ P,ASUNHG		;UNHANG THE UUO
	LDB AC2,[ASPRMP,,AC1]	;PERMANENT CHANNEL SELECTION
	JRST PKINN2
;ADSMAP, BEEP UUOS

;ADSMAP AC, (EFFECTIVE ONLY FROM A JOB THAT IS ATTACHED TO ITS CONSOLE)
;AC BITS
;0	1 => TEMPORARY, 0=> PERMANENT
;1	1 => SET SELECTION, 0 => READ
;2	1 => MAKE THE SELECTION IMMEDIATELY (IF TEMP SEL)
;3	1 => DON'T HANG UNTIL PREVIOUS TEMP SEL IS COMPLETE
;4	1 => DON'T HANG UNTIL THIS TEMP SEL IS COMPLETE
;5-6	PAGING DISPOSITION
;7-8	BEEPING DISPOSITION
;14-17	NEW SELECTION (AS CHANNEL NUMBER)
;RH	DURATION FOR TEMP SEL IN 1/4 SEC UNITS

;THE FOLLOWING ADDITIONAL BITS ARE RETURNED ON A READ STATUS:
;9	1 => THERE IS AN ACTIVE TEMP MAP FOR THIS LINE
;10	1 => THERE IS A PAGE IN PROGRESS (WHETHER OR NOT ON THIS LINE)
;11	1 => THERE IS A PAGE IN PROGRESS AND ENABLED ON THIS LINE
;12	1 => THERE IS A BEEP IN PROGRESS ON THIS LINE
;13	1 => THERE IS A DELAYED BEEP PENDING FOR THIS LINE

;IF THE AC CONTAINS -1, THE MAP IS RESET TO ITS PERMANENT STATUS

;IF TRYING TO MAKE A TEMP SEL WITHOUT WAITING FOR THE PREVIOUS TEMP
;SEL TO FINISH, THE UUO WILL BE IGNORED IF THE PREV TEMP SEL HAS NOT
;COMPLETED AND BIT 2 IS ZERO

;IF PERMANENT THEN ONLY LOW BIT OF DISPOSITION FIELD IS LOOKED AT

;DISPOSITIONS
;0	INTERRUPTIBLE
;1	NON-INTERRUPTIBLE
;2	INTERRUPTIBLE, BUT EXTEND DURATION OF TEMP CH
;3	POSTPONE BEEP UNTIL TEMP SELECTION TIMES OUT

;NOTE: 3 IS APPLICABLE ONLY TO BEEP DISPOSITION

↑ADSMAP:	HRRE AC1,JBTLIN(J)
	JUMPL AC1,CPOPJ		;DETACHED
	SUBI AC1,DPYL0
	JUMPL AC1,CPOPJ		;NOT DD OR DPY
	CAIL AC1,DPYNUM+DDNUM
	POPJ P,			;NOT DD OR DPY
	MOVE AC2,TAC
	AOJE AC2,ADSRE2		;TAC=-1 MEANS RESET TO PERM
	TLNN TAC,200000		;SKIP IF SETTING SELECTION
	JRST ADSMRD		;READ SELECTION
	CONO PI,SCNOFF
	TLNN TAC,140000		;SKIP IF DON'T HAVE TO WAIT FOR PREV TEMP SEL
	PUSHJ P,ADSMWT		;WAIT FOR PREV (TURNS SCNOFF)
	JUMPL TAC,ADSMT		;MAKE TEMP SEL
ADSRE1:	HLRZ TAC,TAC		;GET NEW CH # IN LOW 4 BITS
	MOVEI AC2,0
	DPB TAC,[ASPRMP,,AC2]	;PERM CH #
	MOVSI AC3,ASDBEP
	TDNE AC3,ASTAB(AC1)
	IOR AC2,AC3		;SET DELAYED BEEP BIT IF ALREADY SET
	LDB AC3,[000400,,TAC]	;CHANNEL TO SELECT TO
	TRNN TAC,4000		;SKIP IF PAGE UNINTERRUPTIBLE
	JRST [	PUSHJ P,ADSMP1
		JRST .+2]
	TLO AC2,ASPPUN		;SET PERM PAGE UNINTERRUPTIBLE BIT
	TRNN TAC,1000		;SKIP IF BEEP UNINTERRUPTIBLE
	JRST [	PUSHJ P,ADSMP2
		JRST ADSMP4]
	TLO AC2,ASPBUN		;SET PERM BEEP UNINTERRUPTIBLE BIT
	TLZ AC2,ASDBEP		;CLEAR DELAYED BEEP BIT IF NOT INTERRUPTIBLE
	SETZM ASBTAB(AC1)	;FLUSH BEEPS
ADSMP4:	MOVEM AC2,ASTAB(AC1)
	HRLI AC3,(AC1)
	DATAO AS,AC3		;MAKE SELECTION NOW
	TRNN TAC,400000
	JRST ADSSCZ		;MAKING PERM SEL, SO DON'T WAIT
	TRNN TAC,20000
	PUSHJ P,ADSMWT		;WAIT FOR TEMP SEL TO FINISH
ADSSCZ:	CONO PI,SCNON
	POPJ P,

;PAGE INTERRUPTIBLE, SO CHECK FOR PAGING GOING ON
ADSMP1:	SKIPN PAGNOW
	POPJ P,
	TLO AC2,ASPAGN		;SET PAGING NOW BIT
	MOVEI AC3,ASPAGC	;SELECT PAGING CHANNEL
	HRRZ DSER,ASBTAB(AC1)
	JUMPE DSER,CPOPJ	;NOT BEEP IN PROGRESS
	TLO AC2,ASDBEP		;SET DELAYED BEEP BIT
	SETZM ASBTAB(AC1)	;FLUSH BEEP
	POPJ P,

;BEEP INTERRUPTIBLE, SO CHECK FOR DELAYED BEEP OR BEEP IN PROGRESS
ADSMP2:	TLNE AC2,ASDBEP		;SKIP IF NO DELAYED BEEP
	JRST ADSMP5
	HRRZ DSER,ASBTAB(AC1)
	JUMPE DSER,CPOPJ	;NO BEEP IN PROGRESS EITHER
	MOVEI AC3,ASBEPC	;CONTINUE WITH BEEP
	POPJ P,
ADSMP5:	TLNE AC2,ASPAGN
	POPJ P,			;PAGING TAKES PRECEDENCE
	TLZ AC2,ASDBEP		;CLEAR DELAYED BEEP BIT
	MOVEI AC3,ASBPTM
	MOVEM AC3,ASBTAB(AC1)	;START UP BEEP
	MOVEI AC3,ASBEPC
	POPJ P,

;MAKE TEMP SEL (SCNOFF)
ADSMT:	MOVE AC2,ASTAB(AC1)
	TRNE AC2,-1		;SKIP IF NO TEMP SEL IN PROG OR INF TEMP SEL IS
	TLNE TAC,100000		;SKIP IF GRONK IS OFF
	JRST ADSMT1		;OK TO MAKE NEW TEMP SEL NOW
	JRST ADSSCZ		;TEMP SEL IN PROG, DON'T GRONK, DON'T WAIT (NOOP)
ADSMT1:	MOVS TAC,TAC		;NEW CH # IN LOW 4 BITS, DURATION IN LH
	LDB AC3,[000400,,TAC]	;NEW CHAN SELECTION
	DPB AC3,[ASTMPP,,AC2]
	LDB TAC1,[130200,,TAC]	;NEW PAGING DISPOSITION
	CAIN TAC1,3
	MOVEI TAC1,1		;CHANGE 3 INTO 1
	DPB TAC1,[ASPGDP,,AC2]	;SET PAGE DISP
	LDB TAC1,[110200,,TAC]	;NEW BEEP DISPOSITION
	DPB TAC1,[ASBPDP,,AC2]	;SET BEEP DISP
	TRNN TAC,400		;SKIP IF NOT PAGE INTERRUPTIBLE
	PUSHJ P,ADSMP1
ADSMT3:	CAIN TAC1,3
	JRST ADSMT4		;DELAY BEEP
	CAIE TAC1,1		;SKIP IF BEEP UNINTERRUPTIBLE
	JRST [	PUSHJ P,ADSMP2
		JRST ADSMT6]
	TLZ AC2,ASDBEP
	SETZM ASBTAB(AC1)
ADSMT6:	HLR AC2,TAC		;DURATION
	TLO AC2,ASTEMP		;SET TEMP SEL BIT
	JRST ADSMP4

;DELAY BEEP MODE
ADSMT4:	HRRZ DSER,ASBTAB(AC1)
	JUMPE DSER,ADSMT6
	TLO AC2,ASDBEP		;SET DELAYED BEEP BIT
	SETZM ASBTAB(AC1)	;FLUSH BEEP NOW
	JRST ADSMT6

;WAIT UNTIL TEMP SELECTION IS DONE (RETURNS WITH SCNOFF)
ADSMWT:	CONO PI,SCNOFF
	MOVE AC2,ASTAB(AC1)
	TLNE AC2,ASHANG
	JRST ADSMW1
	MOVEI AC3,-1
	TDNN AC3,ASBTAB(AC1)	;SKIP IF BEEPING NOW
	TLNE AC2,ASPAGN		;SKIP IF NOT PAGING NOW
	JRST ADSMW1		;BEEP OR TEMP SEL - WAIT
	TRNN AC2,-1		;NOT BEEPING OR PAGING,TEST FOR TEMP SEL TO WAIT FOR
	POPJ P,			;NOTHING TO WAIT FOR
ADSMW1:	TLO AC2,ASHANG
	MOVEM AC2,ASTAB(AC1)
	MOVEI AC2,IOWQ
	MOVNM AC2,JOBQUE(J)
	CONO PI,SCNON
	PUSHJ P,WSCHED		;GO INTO IOWQ
	JRST ADSMWT

;READ AS STATUS INTO AC
ADSMRD:	CONO PI,SCNOFF		;PREVENT CHANGING OUT FROM UNDER US
	MOVE AC2,PAGNOW
	HRRZ AC3,ASBTAB(AC1)
	MOVE TAC1,ASTAB(AC1)
	CONO PI,SCNON
	HRR TAC,TAC1		;READ BACK DURATION
	TLZ TAC,177777
	TLNE TAC1,ASTEMP
	TLO TAC,400		;TEMP MAP IN EFFECT NOW
	JUMPE AC2,.+2
	TLO TAC,200		;THERE'S A PAGE GOING ON
	TLNE TAC1,ASPAGN
	TLO TAC,100		;WE'RE PAGING ON THIS LINE
	JUMPE AC3,.+2
	TLO TAC,40		;WE'RE BEEPING THIS LINE NOW
	TLNE TAC1,ASDBEP
	TLO TAC,20		;WE'RE GOING TO BEEP IT LATER
	JUMPGE TAC,ADSMR1	;JUMP IF READING PERM
	LDB AC2,[ASTMPP,,TAC1]	;TEMP CHAN SEL
	LDB AC3,[ASBPDP,,TAC1]	;TEMP BEEP DISP
	LDB TAC1,[ASPGDP,,TAC1]	;TEMP PAGE DISP
ADSMR2:	LSH TAC1,2
	IOR TAC1,AC3
	LSH TAC1,9
	IORI TAC1,200000(AC2)
	TSO TAC,TAC1
	JRST STOTAC

ADSMR1:	LDB AC2,[ASPRMP,,TAC1]	;PERM CHAN SEL
	LDB AC3,[ASPBUP,,TAC1]	;PERM BEEP UNINTERRUPTIBLE BIT
	LDB TAC1,[ASPPUP,,TAC1]	;PERM PAGE UNINTERRUPTIBLE BIT
	JRST ADSMR2

;BEEP AC,
;AC HAS TTY NUMBER TO BEEP OR -1 FOR YOURSELF
↑BEEP:	JUMPGE TAC,BEEP1
	HRRE TAC,JBTLIN(J)
	JUMPL TAC,CPOPJ		;DETACHED
BEEP1:	ANDI TAC,177
	SUBI TAC,DPYL0
	JUMPL TAC,BEEPND	;NOT A DPY, TRY ↑G
	CAIL TAC,DPYNUM+DDNUM
	JRST BEEPND
	CONO PI,SCNOFF
	MOVE AC1,ASTAB(TAC)
	LDB AC2,[ASBPDP,,AC1]	;GET TEMP BEEP DISP
	TLNN AC1,ASTEMP		;SKIP IF TEMP
	LDB AC2,[ASPBUP,,AC1]	;PERM BEEP DISP
	TRNE AC2,1		;SKIP IF INTERRUPTIBLE
	JRST BEEPU
	TLNN AC1,ASPAGN		;SKIP IF PAGING NOW
	JRST BEEPNP
BEEPDX:	TLO AC1,ASDBEP		;SET DELAYED BEEP
	MOVEM AC1,ASTAB(TAC)
BEEPX:	CONO PI,SCNON
	POPJ P,

BEEPNP:	MOVEI AC2,ASBPTM
	MOVEM AC2,ASBTAB(TAC)
	MOVEI AC3,ASBEPC
	HRLI AC3,(TAC)
	DATAO AS,AC3
	JRST BEEPX

BEEPU:	TLNE AC1,ASTEMP		;SKIP IF PERM
	CAIN AC2,1
	JRST BEEPX		;NOT INTERRUPTIBLE, SORRY
	JRST BEEPDX		;TEMP SEL (INF OR OTHERWISE), SET DELAYED BEEP

BEEPND:	MOVEI LINE,DPYL0(TAC)	;BEEP ADDRESSED TO NON-DPY:
	PUSHJ P,GETDBA		;FIND OR CREATE DDB
	POPJ P,			;NO SUCH TTY OR NO DDBS AVAILABLE
	MOVEI CHR,7		;GOBBLE A BELL
	PUSHJ P,OUTCHR		;SOCK IT TO HIM!
	JRST TYPTST

;RESET AUDIO SWITCH MAP TO PERMANENT SETTING
;CALLED BY ADSMAP WITH AC=-1 AND BY RESET
↑ADSRES:	HRRE AC1,JBTLIN(J)	;RESET JOB TO PERMANENT ADS MAP
	JUMPL AC1,CPOPJ		;DETACHED
	SUBI AC1,DPYL0
	JUMPL AC1,CPOPJ		;NOT DD OR DPY
	CAIL AC1,DPYNUM+DDNUM
	POPJ P,			;NOT DD OR DPY
ADSRE2:	MOVEI TAC,0
	CONO PI,SCNOFF
	LDB AC2,[ASPPUP,,ASTAB(AC1)]
	DPB AC2,[POINT 1,TAC,6]
	LDB AC2,[ASPBUP,,ASTAB(AC1)]
	DPB AC2,[POINT 1,TAC,8]
	LDB AC2,[ASPRMP,,ASTAB(AC1)]
	DPB AC2,[POINT 4,TAC,17]
	TLO TAC,360000
	JRST ADSRE1
;RECIML
;SPECIAL CODE FOR IMLACS (JHS CODE REPLACED BY BO)

RECIML:	TLZE IOS,IMLTTY		;Flag left from preceding char?
	JRST RECIM1		;Yes.  Add the bucky bits.

	TRNN CHR,200		;No.  Test the 8th bit.
	JRST RECIM2		;Off.  Just plain data.

	TLO IOS,IMLTTY		;On.  Flag it as extra special.
	CAIL CHR,241		;Is it a prefix meaning bucky bits?
	CAILE CHR,243
	JRST RECIM2		;No.

	DPB CHR,[POINT 2,IMLHAC(DDB),34];Save the bucky bits and
	MOVEM IOS,DEVIOS(DDB)	;set the IMLTTY flag for the next char
	POPJ P,			;and get out fast.

RECIM1:	LDB UCHN,[POINT 2,IMLHAC(DDB),34]
	JRST RECIM2
;TYPX, COMSET
;ROUTINE TO TYPE X IF LINE CANNOT GET INTO SYSTEM

TYPX:	SUB	P,[1,,1]
	ANDI	CHR,177
	CAIN	CHR,"X"		;CHAR. RECEIVED AN "X"
	POPJ	P,			;YES, MAY BE ECHO, DISMISS INT.
	MOVEI	CHR,"X"
	JRST	TYPL			;TYPE OUT "X"

;ROUTINE TO WAKE UP COMMAND DECODER IF TPMON IS SET

↑COMSET:TLNN	IOS,TTYDTC		;DTACHED GUYS CAN'T SAY ANYTHING!
	TLNN	IOS,TPMON		;MONITOR MODE?
	POPJ	P,			;NO, NOT MONITOR COMMAND
	MOVE	TAC,DEVMOD(DDB)		;GET SOME GOOD BITS
	TLNN	TAC,TTYATC		;IF NOT A CONSOLE
	TRNN	TAC,ASSCON!ASSPRG	;AND ASSIGNED BY PROGRAM OR CONSOLE
	JRST	.+2
	POPJ	P,			;THEN HE CAN'T TYPE COMMANDS
	MOVSI	IOS,IOFST
	IORB	IOS,DEVIOS(DDB)
	MOVSI	TAC,COMBIT		;SET SIGN BIT
	TDNN	TAC,TTYTAB(LINE)	;SKIP IF COMMAND BIT IS ON
	AOS	COMCNT			;COUNT ANOTHER COMMAND WE HAVE
	IORM	TAC,TTYTAB(LINE)	;IN TTY TRANSLATOR TABLE
IFN FTTTYBUG,<
	PUSHJ	P,COMBCK
	PUSHJ	P,CNTCOM		;CALL THE DRD
>
	POPJ	P,
;TTEDIT
;TTY KEYBOARD EDITOR ROUTINE
;UPON RECEIPT OF A CHARACTER, THIS ROUTINE DETERMINES WHAT TO DO
;WITH IT: WHETHER IT'S A SPECIAL CHARACTER NEEDING SPECIAL ECHOING,
;WHETHER SOME OTHER CHARACTER IS TO BE STORED IN ITS PLACE, WHETHER
;IT IS A BREAK CHARACTER (LINE TERMINATOR), OR WHETHER THE CHARACTER
;TYPED IS A SIGNAL TO UNDERTAKE SOME SPECIAL ACTION.
;IN ANY CASE, ALL SPECIAL ACTION, INCLUDING DUPLEXING TAKES PLACE ON
;THE LEVEL OF THIS ROUTINE.
;	THIS ROUTINE CALLS SPCHEK, WHICH MAKES USE OF THE  SPECIAL
;CHARACTER TABLE, SPCTAB. TO MAKE ANY CHANGES IN THE ACTION GENERATED
;BY SPECIFIC CHARACTERS MAKE THE ALTERATIONS REQUIRED BY THE
;COMMENTS DESCRIBING SPCTAB.  NOTE THAT IF A CHARACTER IS TO DISPATCH
;TO A "SPECIAL ACTION ROUTINE" OR A SPECIAL ECHO ROUTINE, THE LEFT
;HALF OF THE CORRESPONDING CHARACTER-WORD MUST HAVE SPACTN
;SET  AND THE ADDRESS OF THE SPECIAL ROUTINE MUST BE
;ASSEMBLED INTO THE RIGHT HALF OF THE WORD.
;CALL	HAVE 7-BIT ASCII CHARACTER IN CHR
;	LDB	HPOS,PHPOS
;	MOVEI	DAT,TTIBUF(DDB)
;	PUSHJ	P,TTEDIT
;	RETURN WITH ACTION DONE, SYNC (LH IOS) SET IF BREAK CHAR. STORED

TTEDIT:	PUSHJ	P,ADJHP		;ADJUST HP AND CHECK SPECIAL
	JFCL
	TLNE LINE,IMLIN			;IF AN IMLAC,
	JRST [	TLZE IOS,IMLTTY		;TEST CONTROL FLAG.
		JRST TTEDT0		;NO SPECIAL ACTIVATION IF ON.
		CAIN CHR,177		;LEAVE SPACTN FOR RUBOUT.
		JUMPE UCHN,TTEDT2	;EXCEPT WITH BUCKY BITS
		TLNN TAC,IMLCHR		;PREVENT SPACTN ON ~ AND α
		TLNN TAC,ALLSPA		;AND ANYTHING ELSE THAT'S NOT
		TLZ TAC,ALLSPA!SPACTN!ECHSUP!SPHPOS	;ALWAYS SPECIAL.
		JRST TTEDT2]
TTEDT2:	TLNE	LINE,SPCBRK		;SPECIAL ACTIVATION MODE?
	TLNE IOS,TPMON
	JRST TTEDT0
	PUSH	P,TAC
	PUSHJ	P,SPCACT
	TLO	IOS,SYNC
	POP	P,TAC
	TLNN	TAC,ALLSPA
	TLNN	IOS,SYNC
	CAIA
	TLZ	TAC,SPACTN		;INHIBIT ANY SPECIAL ACTION IF A BREAK
	JRST	TTEDT1
TTEDT0:	TLNE	TAC,BREAKB!FCSBRK
	TLO	IOS,SYNC	;IT'S A BREAK CHAR.
TTEDT1:	MOVEM	IOS,DEVIOS(DDB)		;SET SYNC
	JUMPL	TAC,(TAC)		;JUMP IF CHARACTER HAS SPECIAL DISPATCH
TIPACK:	CAIG	CHR,"z"
	CAIGE	CHR,"a"		;LOWER CASE LETTER?
	JRST	TTIPUT			;NO
;TTIPUT, DUPLEX, DUPLX1, INBFUL
;	TLNN IOS,TPMON			;ALWAYS GIVE MONITOR UPPER CASE.
	TLNN	LINE,FCS		;YES. IS THIS TTY IN 37 MODE?
	TRZ	CHR,40			;NO. MAKE CHAR UPPER CASE
TTIPUT:	TLZE	LINE,ROBTPD		;HAVE WE BEEN DELETING?
	PUSHJ	P,BSECHO		;YES. OUTPUT A BACKSLASH
TTIPT1:	DPB UCHN,[POINT 2,CHR,28]	;PUT IN CTRL. BITS.
TTPT2:	PUSHJ	P,PUTCHI		;PUT CHAR IN INPUT BUFFER
	JRST	INBFUL			;IT DIDNT FIT
	TLNN	TAC,ECHSUP		;SHOULD THIS CHAR BE ECHOED?
DUPLEX:	TLNE	LINE,FULTWX		;IS THIS LINE ECHOING ITSELF?
	JUMPE	UCHN,CPOPJ		;DON'T ECHO UNLESS CTRL BITS ON.
DUPLX1:	TLNN	IOS,TPMON		;SHOULD ECHO IF IN MONITOR MODE
	TRNN	IOS,NOECHO		;AND UNLESS USER SAYS NO, IN USER MODE
	JRST	DUPIML			;SO ECHO IT.
	POPJ	P,0			;DONT ECHO IF REQUESTED NOT TO BY USER

INBFUL:	CAIN	CHR,600			;CHAR WONT FIT. WAS IT ↑C?
	JRST	CNCTS1			;YES. PANIC OUT OF THIS BIND
	MOVEI	CHR,7			;NO. JUST ECHO BELL TO SHOW LOSS
	JRST PUTCHO			;OUTPUT BELL, IF NOT  DPY.

DUPIML:	JUMPE UCHN,PUTCHO		;IF BUCKY BITS OFF
	TRNN IOS,NOECHB			;OR NOT TO BE ECHOED
	TLNN LINE,IMLIN			;OR NOT AN IMLAC,
	JRST PUTCHO			;JUST ECHO THE CHAR.
	PUSH P,CHR
	TRNN UCHN,1			;<CTL> BIT...
	JRST DUPIM2
	MOVEI CHR,177			;ECHO [BS] [VT].
	PUSHJ P,PUTCHO
	MOVEI CHR,13
	PUSHJ P,PUTCHO
	TRNN UCHN,2			;<META>...
	JRST DUPIM3
DUPIM2:	MOVEI CHR,177			;ECHO [BS] [FF].
	PUSHJ P,PUTCHO
	MOVEI CHR,14
	PUSHJ P,PUTCHO
DUPIM3:	POP P,CHR			;NOW ECHO THE CHAR.
	JRST PUTCHO
;CONTC, CONTOB, CONTO, CONTB, ALTMOD, TTYUNH
;CALLED WITH A JUMPL TAC,(TAC), WHERE TAC IS LOADED FROM SPCTAB
;SPECIAL CHARACTER HANDLING ROUTINES


CONTC:	PUSHJ	P,DELETL		;SINCE PEOPLE WANT FREE ↑U
	TLNN	LINE,DDDLIN!DISLIN	; IF THIS IS A DPY
	JRST	.+3
	JUMPG	UCHN,.+2		;AND IF NO CTRL BITS ARE ON,
	PUSHJ	P,CNCTS1		;PROCESS CONTROL C IMMEDIATELY.
	MOVE	TAC,SPCTAB		;SINCE DELETL CLOBBERS TAC
	PUSHJ	P,TTPT2			;PLACE IN BUFFER.
	MOVEI	CHR,3
	PUSHJ	P,CNTLEC
	JRST	CRLFEC

CONTZ:	PUSHJ	P,CNTLEC		;OUTPUT ↑C OR ↑Z
	PUSHJ	P,CRLFEC		;OUTPUT A CRLF
	MOVEI	CHR,3B28!12		;CHANGE TO INTERNAL CODE.
	TLO	IOS,SYNC
	JRST	TTPT2			;ACTIVATE BUT DON'T STORE

CONTOB:	MOVEI CHR,"O"-100		;INVENT A ↑O.
CONTO:	PUSHJ	P,SETBF2		;CLEAR THE OUTPUT BUFFER
	MOVEI	IOS,IOSUPR		;SET TO JUNK FURTHER OUTPUT
	XORB	IOS,DEVIOS(DDB)
	JRST	CONTU1			;ECHO, ETC.

CONTU:	TLNE	IOS,DDTM		;IN DDTMODE,
	JRST	TTIPUT			; PASS THIS CHARACTER
	TLZ	LINE,ROBTPD		;NO MORE BACKSLASH
	PUSHJ	P,DELETL		;↑U DELETES INPUT LINE
CONTU1:	PUSHJ	P,CNTLEC		;ECHO ↑O OR ↑U
	JRST	CRLFEC			;OUTPUT A CRLF AND RETURN WITHOUT
					; STORING THE ↑O OR ↑U

ALTMOD:	
	HRRI	TAC,(CHR)		;SAVE WHICH KIND OF ALTMOD
	TLNN	LINE,IMLIN
	MOVEI	CHR,44			;ECHO A $ EXCEPT ON IMLACS.
	PUSHJ	P,AOJDPX
	MOVEI	CHR,(TAC)		;RESTORE THE CHARACTER
	JRST	TTIPUT			;STORE THE CHARACTER

;FOLLOWING CHANGE BY BO ON RPH'S ADVICE
;CONTF:	TLCA	LINE,FCS		;COMPLEMENT FCS ON ↑F
;CONTB:	TLC	LINE,FULTWX		;COMPLEMENT FULTWX ON ↑B
;	POPJ	P,0			;AND RETURN WITHOUT STORING THESE

CONTB1:	TLCA	LINE,FULTWX
CONTF:	TLC 	LINE,FCS
	POPJ	P,

CONTB:	TLNE	LINE,DISLIN!DDDLIN!PTYLIN
	JRST	CONTB1
	TLNE	LINE,TLKRNG		;DON'T ALLOW HOLDING IF TALKING.
	POPJ	P,			;TALKING
TTYUNH:	TLCE	IOS,TTYHLD		;Toggle the hold flag.
	TLZ	IOS,TOIP		;If it was on, turn off TOIP.  The
	MOVEM	IOS,DEVIOS(DDB)		;STO IOS BACK
	POPJ	P,			;next call to TYPTST will restart
					;the output.
;END BO
;RUBOUT, AOJDPX, CONTK, CONTL
RUBOU4:	MOVSI	IOS,SYNC		;IF PAPER TAPE, NO BREAK
	JRST	T0POPJ			;OR STORE. RETURN.
RUBOUT:

RUBOU3:	TLNE	IOS,TPMON		;IN MONITOR MODE, NOT A BREAK CHAR
	JRST	RUBOU2
	TDNE	IOS,[XWD DDTM,BKSP]
	JRST	TTIPT1			;STORE RUBOUT IF DDT OR FCS
RUBOU2:	PUSHJ	P,RUBOU4		;NOT A BREAK AFTER ALL
	LDB	CHR,PUTR(DAT)		;GET LAST CHAR IN
	PUSHJ	P,DCPUTR		;BACK UP TIPUTR
	JRST	RUBOU1			;IT'S EMPTY ALREADY
	TLON	LINE,ROBTPD		;MARK IN RUBOUT SEQUENCE
	PUSHJ	P,BSECHO		;AND OUTPUT BACKSLASH IF FIRST
AOJDPX:	AOJA	HPOS,DUPLX1		;OUTPUT AND COUNT HPOS

RUBOU1:	TLZE	LINE,ROBTPD		;END OF INPUT STREAM REACHED
	PUSHJ	P,BSECHO		;OUTPUT A BACKSLASH
	JRST	CRLFEC			;AND A CR LF

CONTK:	HRRI	TAC,4			;HERE ON V TAB
	SKIPA
CONTL:	HRRI	TAC,10			;HERE ON FORMFEED
	TLNN	LINE,PTYLIN		;THIS TTY HAVE VERT MECHANICS?
	JRST	SIMFF			;NO. SIMULATE IT
; FOR SOME REASON THE FOLLOWING INSTRUCTION WAS A PUSHJ P,TTIPUT, WHICH
; CAUSED PTYS TO GET  10 26'S (⊗) UPON TYPING ↑L. - JAM (5-21-72)
	JRST	TTIPUT			;PUT CHAR IN BUFFER AND ECHO IT
CONTI1:	MOVEI	CHR,1			;SYNCHRONOUS IDLE CHARACTERS
SIMFF1:	PUSHJ	P,DUPLX1		;OUTPUT ECHO OF LF OR IDL
	TRNE	TAC,17			;DONE YET?
	SOJA	TAC,.-2			;NO. OUTPUT MORE
	POPJ	P,0			;DONE

;CONTI, CONTP
SIMFF:	TLO	TAC,ECHSUP		;DON'T OUTPUT FF OR VT TO A 33
	PUSHJ	P,TTIPUT		;PUT IT IN BUFFER
	MOVEI	CHR,12		;SIMULATE WITH LF'S
	JRST	SIMFF1

CONTI:	TLNE	LINE,DISLIN!PTYLIN!DDDLIN!IMLIN
	JRST	TTIPUT			;ECHO AND RETURN FOR DISPLAYS
	LDB	HPOS,PHPOS
	ANDI	HPOS,7
	CAIE	HPOS,7			;IF ONLY 1, WE WILL CONVERT TO SPACE
	TLNE	LINE,TBXPND		;FORCING TAB EXPANSION?
	TLO	TAC,ECHSUP		;YES. DON'T OUTPUT TAB TO 33
	PUSHJ	P,TTIPUT		;PUT IN BUFFER AND MAYBE ECHO
	TLNE	LINE,TBXPND		;EXPANDING TABS?
	JRST	CONTI2			;YES
	LDB	CHR,PHPOS		;WHERE WAS TTY BEFORE TAB
	ANDI	CHR,7		;JUST LOW PART FOR INDEX
	MOVEI	TAC,1		;ASSUME 1
	XCT	(CHR)[	AOJA TAC,CONTI1	;8 SPACES-2 IDLES
			JRST CONTI1	;7 SPACES-1 IDLE
			JRST CONTI1	;6 SPACES-1 IDLE
			JRST CONTI1	;5 SPACES-1 IDLE
			JRST CONTI1	;4 SPACES-1 IDLE
			POPJ P,		;3 SPACES-0 IDLES
			POPJ P,		;2 SPACES-0 IDLES
			JFCL	]	;1 SPACE -CONVERT TO SPACE (OR CTY WILL MISS TAB STOP)
CONTI2:	MOVEI	CHR,40		;SPACES FOR THE 33'S
	LDB	HPOS,PHPOS		;WHERE WAS I BEFORE TAB?
	PUSHJ	P,AOJDPX		;OUTPUT A SPACE
	TRNE	HPOS,7			;AT A TAB STOP?
	JRST	.-2			;NO. MORE SPACES.
	POPJ	P,0			;RETURN FROM TTEDIT

CONTP:	MOVE	TAC,LINBIT(LINE)	;GET HIS INITIAL LINE BITS
	TLNE	TAC,TBXPND		;CAN ONLY TOGGLE IF HE HAS HARDWARE TABS!!!
	JRST	NCONTP			;NO CAN DO
	TLC	LINE,TBXPND		;INVERT STATE OF TABS!
	POPJ	P,

NCONTP:	SETZ TAC,			;MAKE SURE IT ECHOS!
	JRST	TTIPUT			;AND BACK TO THE MAIN STREAM
;CRLFEC, CRLF
CRLFEC:	MOVEI	HPOS,0			;ECHO A CR LF, SAVING CHR
	PUSH	P,CHR
	MOVEI	CHR,15			;CARRIAGE RETURN
	PUSHJ	P,DUPLX1		;OUTPUT IT
	MOVEI	CHR,12			;LINE FEED
	PUSHJ	P,DUPLX1		;OUTPUT THAT TOO
CHPOPJ:	POP	P,CHR			;RESTORE CHR
	POPJ	P,0

CNTLEC:	
	HRRI	TAC,100(CHR)		;SAVE UN-CNTL CHARACTER
	MOVEI	CHR,"↑"
	PUSHJ	P,AOJDPX
	MOVEI	CHR,(TAC)		;TYPE ↑ CHAR
	PUSHJ	P,AOJDPX
	TRZ	CHR,100			;RESTORE IT TO A CNTL CHAR
	POPJ	P,0

CRLF:	MOVEI	HPOS,0			;HERE ON INPUT OF A CARRIAGE RETURN
	TLNE	LINE,PTYLIN		; IS THIS A PTY
	JRST	CRLFIP			; YES, TEST XON ALWAYS
	TLNE	IOS,TPMON		; ALWAYS GIVE LF AFTER CR IN MON. MODE
	JRST	CRLFMM
CRLFIP:	TLNE	LINE,XON		;IF PAPER TAPE, NO FREE LF
	JRST	TTIPUT			;JUST STORE THE CR
CRLFMM:	PUSHJ	P,TTIPUT		;ORDINARILY, STORE AND GO ON HERE
	MOVEI	CHR,12			;BY ADDING A LF
	MOVSI	IOS,SYNC		;WHICH IS AN ACTIVATOR
	IORB	IOS,DEVIOS(DDB)
	TLNN	LINE,FULTWX		;IF NOT SELF ECHOING,
	JRST	TTIPUT			;THIS WILL GIVE LF ECHO
	PUSHJ	P,TTIPUT		;OTHERWISE, THIS WONT
	JRST 	DUPLX1			;BUT THIS WILL
;CNCTST, CNCMOD
CNCTST:
	TLNE LINE,IMLIN
	TLZE IOS,IMLTTY		;Char code 3 from an IMLAC needs
	CAIA
	POPJ P,			;IMLTTY on to be a ↑C.
	MOVEI CHR,600	;INVENT INTERNAL CODE FOR ↑C.
IFN FTLOGIN,<

	LDB	TAC,PJOBN
	MOVE	TAC,JBTSTS(TAC)

	TLNE	TAC,JACCT		;REG 11/26/73 NO REASON TO LET PTYS THROUGH
	MOVEI	CHR,33			;SEND ALTMODE INSTEAD

;	TLNN	TAC,JACCT
;	JRST	CNCTSA
;	TLNE	LINE,PTYLIN		;DON'T HOLD UP PTY'S
;	CAIA
;	MOVEI	CHR,33
;CNCTSA:
>
	LDB	TAC,TIPUTR(DDB)
	CAIE	TAC,600
	POPJ	P,
CNCTS1:	PUSHJ	P,SETBFI		;CLEAR INPUT BUFFER.

CNCMOD:	MOVE	IOS,[XWD DDTM!IO!USRB,IOSUPR!MERTPO!MERTP1]
	ANDCAM	IOS,DEVIOS(DDB)
	MOVSI	IOS,TPMON+IOFST
	IORB	IOS,DEVIOS(DDB)
	POPJ	P,
;BSECHO, DCPUTR, DELETL
;ROUTINE TO ECHO BACK-SLASH

BSECHO:	PUSH	P,CHR		;*
	MOVEI	CHR,"\"
	PUSHJ	P,AOJDPX
	JRST	CHPOPJ

;ROUTINE TO DECREMENT PUTR

↑DCPUTR:
	LDB	TAC,PLSTLC		; CHECK FOR NONE TO DELETE
	CAMN	TAC,PCTR(DAT)
	POPJ	P,

	MOVSI	TAC,110000
	ADD	TAC,PUTR(DAT)		;*
	TLNE	TAC,400000
	ADD	TAC,[XWD 337777,-1]
	MOVEM	TAC,PUTR(DAT)
	AOS	FCTR(DAT)
	AOS	TAC,PCTR(DAT)
	CAIG	TAC,TTICHR		;*
	JRST	CPOPJ1			;*
	SUBI	TAC,TTICHR		;*
	MOVEM	TAC,PCTR(DAT)
	MOVEI	TAC,STTIBF
	ADDM	TAC,PUTR(DAT)		;*
	JRST	CPOPJ1

;ROUTINE TO DELETE CURRENT LINE (↑U)

DELETL:	LDB	TAC,PLSTLC		;WHERE WAS LAST BREAK?
	MOVEM	TAC,TIPCTR(DDB)		;STORE COUNT
	PUSHJ	P,TBYTEP		;CONVERT TO A BYTE POINTER
	MOVEM	TAC,TIPUTR(DDB)		;SAVE POINTER
	JRST	TRESC1			;GO COMPUTE TIFCTR
;DOTALK, NOTALK
IFN FTTALK,<
DOTALK:	ANDI	CHR,177
	SKIPN	DDB,TTYTAB(LINE)
	POPJ	P,0
IFN FTTKBG,<
	HLRZ	TAC,DDB		;BH 3/15/74 BUG TRAP FOR INCOMPLETE LOOP
	ANDI	TAC,177		;BH JUST THE LINE NUMBER
	SKIPN	TTYTAB(TAC)	;BH TAC IS LINE # TALKER LINKED TO
	JRST	DOTALX		;BH HIS DDB GONE ALTOGETHER (CAN'T HAPPEN...)
	HLRZ	HPOS,TTYTAB(TAC);BH ELSE GET HIS LINK
	ANDI	HPOS,177	;BH JUST THE LINE NUMBER
	CAIN	HPOS,(LINE)	;BH OK IF WE'RE ALL THE SAME
	JRST	DOTALY		;BH
	CAIN	HPOS,(TAC)	;BH COMPARE TO HIMSELF
	JRST	DOTALX		;BH OOPS, THEY'RE THE SAME!
>;FTTKBG
DOTALY:	CAIE	CHR,0
	CAIN	CHR,3
	JRST	NOTALK
	MOVE UUO,LINTAB(LINE)	;SAVE TALKER'S XON BIT
	TLZ	LINE,-1		;NO BITS PLEASE
	PUSH	P,LINE
DOTAL1:	LDB	LINE,PTALK
	HRRZ	DDB,TTYTAB(LINE)
	CAMN LINE,(P)		;BACK TO OURSELVES YET?
	JRST DOTAL2		;YES, WE ARE SPECIAL
	JUMPE	DDB,DOTAL1	;SKIP GUYS WITHOUT DDBS
	PUSH	P,CHR
	PUSHJ	P,PUTCHO
	MOVE CHR,(P)		;GET CHAR
	TLNN UUO,XON		;IF TALKER HAS XON OR
	CAIE CHR,15		;IF NOT CR,
	JRST DOTAL3		;THEN NO LF
	MOVEI CHR,12
	PUSHJ	P,PUTCHO	;YES, SEND IT
DOTAL3:	MOVE	IOS,DEVIOS(DDB)
	PUSHJ	P,TYPTST
	POP	P,CHR
	JRST DOTAL1

DOTAL2:	HLL LINE,LINTAB(LINE)	;GET OUR CHARACTERISTICS
	MOVEM CHR,(P)		;REPLACE SAVED LINE WITH CHR
	TLNN LINE,FULTWX
	PUSHJ P,PUTCHO
	POP P,CHR
	CAIN CHR,15		;NEED LF?
	TLNE LINE,XON		;MAYBE
	JRST TYPTST		;NO
	MOVEI CHR,12
	PUSHJ P,PUTCHO
	JRST TYPTST

;IF I TYPE A ↑C IN TALK RING, THEN
;ASSUME NEXT←ME←PREV
;SET NEXT←PREV
;IF NEXT=PREV, CLEAR ITS TLKRNG BIT
;SET ME←ME
;CLEAR TLKRNG BIT IN LINTAB(ME)

NOTALK:	MOVEI	HPOS,0(LINE)		;ME
	TLNE	LINE,CTYLIN		;CTY?
	JRST	NOTLKB			;YES, CLEAR EVERYONE IN THIS RING
	LDB	CHR,PTALK		;NEXT
NOTAL1:	LDB	UUO,PTALK
	CAMN	UUO,HPOS		;ME←?
	JRST	NOTAL2			;YES. LINE=PREV
	MOVE	LINE,UUO		;NO. FIND PREV
	JRST	NOTAL1
NOTAL2:	DPB	CHR,PTALK		;MAKE NEXT←PREV
	CAIE	CHR,(HPOS)		;NO ↑←N BREAKING SOLITAIRE TALK
	CAIE	CHR,(LINE)		;RING NOW EMPTY?
	JRST	NOTAL3			;NO
NOTLKA:	MOVSI	CHR,TLKRNG		;YES. CLR HIS BIT
	ANDCAM	CHR,LINTAB(LINE)
	MOVE	DDB,TTYTAB(LINE)	;AND TELL HIM ABOUT IT BY GOLLY!!!
	PUSH	P,HPOS
FOR X ε {↑←N}	{
	MOVEI	CHR,"X"
	PUSHJ	P,PUTCHO
}					;USING ANSI STANDARD TEXT 87
	MOVE	IOS,DEVIOS(DDB)
	PUSHJ	P,TYPTST
	POP	P,HPOS
	MOVE	DDB,TTYTAB(HPOS)	;RESTORE DDB
	MOVE	LINE,UUO
	CAIE	LINE,(HPOS)		;IN WHICH CASE IT HAS NEXT IN RING
	JRST	NOTLKC			;WHICH MAY BE ME ANYWAY
NOTAL3:	MOVSI	CHR,TLKRNG
	MOVE	LINE,HPOS		;ME
	DPB	HPOS,PTALK		;ME←ME
	ANDCAM	CHR,LINTAB(LINE)	;CLR MY BIT
	MOVEI	CHR,600			;GET A ↑C AGAIN
	DPB	CHR,TIPUTR(DDB)		;LOOK LIKE 2 OF THEM
	HLL	LINE,LINTAB(LINE)	;GET GOOD BITS!
	TLNN	LINE,DDDLIN!DISLIN	;FOR THESE GUYS, LEAVE IT ⊗00
	MOVEI	CHR,3			;EVERYBODY ELSE GETS THIS
	JRST	RECINA			;AND PROCESS IT FROM THE TOP

NOTLKB:	LDB	LINE,PTALK		;CTY: GET NEXT GUY
	CAIN	LINE,(HPOS)		;IF ONLY ME,
	JRST	NOTAL3			;  JUST CLEAR ME QUIETLY
NOTLKC:	LDB	UUO,PTALK		;SAVE HIS NEXT
	DPB	LINE,PTALK		;CLEAR HIM OUT
	JRST	NOTLKA			;AND TELL HIM

IFN FTTKBG,<
DOTALX:	PUSHACS				;BH 3/15/74 BUG TRAP TO END OF PAGE
	PUSH	P,TAC			;OFFENDING TALKEE
	PUSH	P,DDB			;TALKER'S TTYTAB
	ANDI	LINE,177		;TALKER'S NUMBER
	PUSH	P,LINE
	PUSHJ	P,DISMES
	ASCIZ /INCOMPLETE LOOP AT DOTALK!!
TALKER=/
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ /  DDB=/
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ /
TALKING TO /
	MOVE	TAC,(P)
	PUSHJ	P,DISOCT
	POP	P,TAC
	SKIPE	TTYTAB(TAC)
	JRST	DOTLX1
	PUSHJ	P,DISMES
	ASCIZ /  WHO HAS NO DDB/
	JRST	DOTLX2
DOTLX1:	PUSHJ	P,DISMES
	ASCIZ /  WHO IS LINKED TO HIMSELF/
DOTLX2:	PUSHJ	P,DISMES
	ASCIZ /
FIND A WIZARD, OR TYPE POPJ 3,$X
/
	PUSHJ	P,DISFLU
	POPACS
	PUSHJ	P,DDTCAL
	DPB	LINE,PTALK		;NOW FIX IT UP
	JRST	NOTALK			;SMASH DOPEY RING!
>;FTTKBG
>
;XMTINT, XMTIN1, DPYSTR, DPYDON
;COMMON TRANSMITTER INTERRUPT FOR SCANNER AND CTY(TTY)

↑XMTINT:
	HLL	LINE,LINTAB(LINE)	; GET LINE CHAR.
	SKIPN	DDB,TTYTAB(LINE)	;GET DDB ADDRESS
	POPJ	P,			;IF NONE, X BEING TYPED
	MOVE	IOS,DEVIOS(DDB)		;GET IO STATUS

XMTIN1:
	LDB	DAT,PDVTIM		;RESET HUNG COUNT
	DPB	DAT,PDVCNT
	MOVEI	DAT,TTOBUF(DDB)		;GET PTR. FOR OUTPUT BUFFER.
	TLNE	LINE,DISLIN!DDDLIN
	JRST	DPYSTR			; IF A DISPLAY, GO TO OUR OWN STARTUP ROUTINE
XMTI1A:	CONO	PI,SCNOFF		;KEEP TOIP AND PUTR/TAKR EQUAL
	MOVE	TAC,TAKR(DAT)		;IS OUTPUT BUFFER EMPTY?
	CAME	TAC,PUTR(DAT)		;(I.E.,HAS TAKR CAUGHT UP WITH PUTR?)
	JRST	XMTIN2			;NO, TYPING STILL IN PROGRESS

	TRNE	IOS,MERTP1		;MONITOR ERROR MESSAGE?
	CAIE	DAT,TTOBUF(DDB)		;OUTPUT BUFFER?
	JRST	XMTIN4			;NO, MUST REALLY BE DONE
	MOVEI	DAT,TTIBUF(DDB)		;YES, NOW EMPTY OUT TTI BUFFER
	JRST	XMTI1A

DPYSTR:	  ;;INITIATE TYPEOUT ON A DISPLAY CONSOLE.
	HRLI	DAT,DPYTYP		;MAKE INTO CLOCK REQUEST ON DPYTYP(IN DPYSER),
	HRRI	DAT,(LINE)		;PASS HIM THE LINE NUMBER
	JRST	DPYTIM			;AND ENTER IN DPY CLOCK QUEUE.

↑DPYDON:MOVE	IOS,DEVIOS(DSER)	;HERE FROM DPYTYP (IN DPYSER) WHEN OUTPUT BUFFER EMPTY.
	HRRZ	DDB,DSER		; DPYSER SAVES DDB ADDRESS IN DSER
	PUSHJ	P,STLNAC		;SET UP AC LINE.
	TRNN	IOS,MERTP1		;ERROR MESSAGE TYPEOUT ?
	JRST	XMTIN4			; NO, GO FINISH UP
	CAIN	DSER,-TTOBUF(DAT)	;YES. MUST WE STILL TYPE OUT THE INPUT BUFFER ?
	JRST	DPYERT			;YES. GO TYPE REST OF ERROR MESSAGE FROM INPUT BUFFER.
		;; FALL INTO XMTIN4.
;XMTIN4, XMTIN2, LINDON, TTYPE
;HERE WHEN OUTPUT BUFFER(S) EMPTIED.

XMTIN4:	MOVE	IOS,[XWD TOIP,MERTPO!MERTP1]
	ANDCAB	IOS,DEVIOS(DDB)
	CONO	PI,SCNON
	MOVEI	CHR,0
	LDB	HPOS,PJOBN		;JOB NUMBER DDB IS ATTACHED TO
	TLNN	IOS,IO
	JRST	LINDON
	MOVSI	IOS,IO
	ANDCAB	IOS,DEVIOS(DDB)
	TLNE	LINE,TLKRNG		;KEEP DDB IF TALKING .
	JRST	LINDON			;YES
	JUMPN	HPOS,LINDON		;LINE DONE IF DDB IS A JOB.
	JRST	TTYKIL			;KILL TTY DDB

XMTIN2:	CONO	PI,SCNON
	TLNE	IOS,TTYHLD		;IF HOLDING OUTPUT, RETURN.
	POPJ	P,
	PUSHJ	P,GETCHO		;NO, GET NEXT CHAR. IN BUFFER
	JUMPE	CHR,XMTIN1		;IGNORE NULLS
	JUMPL	IOS,TTYPE		;KEEP TYPING IF INPUT I/O WAIT
	TRNN	IOS,IOACT		;ARE WE IN I/O WAIT?
	JRST	TTYPE			;NOT IN IO WAIT
	LDB	HPOS,PFITCH		;YES, CHECK TO FIT INTO TTO BUFFER 
	CAIL	HPOS,TTOCHR-50		;ENOUGH ROOM TO ADD 8?
	MOVEI	HPOS,TTOCHR-50		;MAKE LINE BE NEARLY OUT
	CAML	HPOS,FCTR(DAT)		;IS THERE ROOM ENOUGH NOW?
	JRST	TTYPE			;NO, KEEP TYPING

LINDON:	TLNE	IOS,IOW			;IN IO WAIT?
	TLNE	IOS,TTYIOW		;YES, TTY INPUT WAIT?
	JRST	TTYPE			;NO, GO TTYPE CHAR.
	PUSH	P,LINE			;SAVE LINE
	PUSHJ	P,SETIOD		;YES, SET IO DONE (OUT OF WSYNC)
	POP	P,LINE			;RESTORE LINE
	MOVE	IOS,[XWD IOW,IOACT]	;INDICATE NO IO ACTIVE OR WAIT
	ANDCAB	IOS,DEVIOS(DDB)

TTYPE:	TLNN LINE,PTYLIN	;DON'T TYPE IF THIS IS A PSEUDO-TTY.
	JUMPN	CHR,TYPL		;IS TYPING STILL TO BE IN PROGRESS?
	POPJ P,			;NO.
;TYP, TYPL, CTYP
;ROUTINE TO TYPE CHAR
;CALL	MOVE LINE,LINE NO.
;	MOVE CHR,CHARACTER
;	PUSHJ P,TYP

TYP:
↑TYPL:	TLNE LINE,DISLIN!DDDLIN
	POPJ P,				;DON'T DO THIS ON DPYS (MAINLY TYPX)
	MOVE TAC,CHR			;GENERATE PARITY BIT IN CASE THIS IS A
					;MODEL 37
	IMULI TAC,200401		;FORM 3 COPIES OF 8 BIT CHAS.
					;ASSUME PARITY BIT IS 0
	AND TAC,[ 11111111]		;FORM 8 COPIES OF ORIGINAL BITS
	IMUL TAC,[ 11111111]		;ADD 8 BITS TOGETHER
	TLNE TAC,10			;TEST PARITY OF SUM
	TRO CHR,200			;PARITY IS ODD, MAKE IT EVEN
	TLNN LINE,CTYLIN		;NO,CONSOLE TTY?
	JRST	SCNTYP			;TYPE CHAR.
CTYP:	DATAO TTY,CHR
	DPB	CHR,PLASTC
	POPJ P,
;PTYGET, PTOCK, PTICHK, PTYCLR
PTYGET:	;CREATE A PTY LINE NO.
	SKIPE TTYLOK		;NO PTY'S UNDER TTYLOK
	POPJ P,
	MOVSI LINE,-PTYNUM	;HOW MANY ARE AVAIABLE ?
	MOVSI TAC,PTYLIN
	TDNE TAC,LINTAB+PTYL0(LINE)
	AOBJN LINE,.-1
	JUMPG LINE,CPOPJ
	ADDI LINE,PTYL0
	PUSHJ P,DDBSRC		;GET A DDB
	POPJ P,			;NONE AVAILABLE
	HRLI LINE,PTYLIN!PTYUSE!XON!FCS	;DON'T EXPAND TABS OR INVENT LF'S (XON).
					;ALSO FULL CHARACTER SET MODE
	MOVEM LINE,LINTAB(LINE)
	MOVEM ITEM,PTYJOB-PTYL0(LINE)	;RECORD WHICH JOB OWNS THIS PTY.
	XCTR	XW,[MOVEM LINE,(UUO)]	;RETURN PTY LINE NO. TO LOSER.
	JRST CPOPJ1		;GIVE SKIP RETURN

PTOCK:    ;COME HERE WHEN A PTY OUTPUTS ANYTHING, TO WAKE UP JOBS WAITING FOR IT.
	MOVE AC1,TOTAKR(DDB)
	CAME AC1,TOPUTR(DDB)	;IS THERE REALLY ANYTHING IN PTY'S OUTPUT BUF ?
	TLNN LINE,PTYUSE	;IS PTY STILL IN USE ?
	JRST SETBF3	;NO. FLUSH THE OUTPUT BUFFER.
	SKIPLE TAC,PTYPTR(DDB)	;IS SOMEONE WAITING FOR OUR OUTPUT ?
	JRST PTCHK2
	PUSH P,J
	MOVE J,PTYJOB-PTYL0(LINE)
	MOVSI AC1,INTPTO	; GIVE PTY OUTPUT INTERRUPT
	TDNE AC1,JBTIEN(J)
	PUSHJ P,TTINT
	POP P,J
	POPJ P,

PTICHK:	SKIPL TAC,PTYPTR(DDB)
	POPJ P,
PTCHK2:	SETZM PTYPTR(DDB)
	EXCH TAC,DDB
	PUSHJ P,SETIOD
	MOVSI AC1,IOW+TTYIOW
	ANDCAM AC1,DEVIOS(DDB)
	EXCH TAC,DDB
	PUSHJ P,STLNAC
	LDB J,PJOBN		;SETIOD HAS CLOBBERED THIS, AND APRSER MAY CARE
	POPJ P,

↑PTYCLR:HRRE LINE,JBTLIN(ITEM)
	JUMPL LINE,PTYCL2
	MOVSI TAC,SPCBRK!XON!LERSEE
	HLL LINE,LINTAB(LINE)		; GET LINE BITS BACK
	TLNE LINE,PTYLIN		; IST DAS EINE PTY?
	TLZ TAC,XON			; YES, GIVE HIM BACK HIS LFS
	ANDCAM TAC,LINTAB(LINE)
	ANDCAM TAC,JBTLIN(ITEM)
	PUSHJ P,TTYSRC			;FIND HIS TTY DDB
	MOVSI TAC,STDTBL		;AND SET HIS BREAK TABLE TO STANDARD.
	HRRI TAC,ACTBTS(DDB)
	BLT TAC,ACTMOD(DDB)
	MOVEI TAC,NOECHO!NOECHB
	ANDCAM TAC,DEVIOS(DDB)		;TURN ECHOING BACK ON!
PTYCL2:	MOVEI LINE,PTYL0	;PREPARE TO SEARCH ALL PTY'S.
PTYCL1:	CAIL LINE,PTYL0+PTYNUM	;DONE ?
	POPJ P,
	PUSH P,LINE		;GOD ONLY KNOWS.......
	PUSH P,ITEM
	PUSHJ P,PTYRL2			;YES. RELEASE IT FOR HIM.
	POP P,ITEM
	POP P,LINE
	AOJA LINE,PTYCL1
;PTYUUO, LINMAP, PTOCNT, PTIFRE
↑PTYUUO:
	JUMPE UCHN,PTYGET
	XCTR XR,[HRRZ TAC,(UUO)]
	TRZE TAC,400000		;USE THIS TO MAP REAL LINES
	JRST LINMAP
	CAIG TAC,TTPLEN
	CAILE UCHN,PTYXNO
	JRST UUOERR
	JUMPN TAC,PTYUU3
	HRRE TAC,JBTLIN(ITEM)	;IF HE ASKS FOR LINE 0,
	JUMPL TAC,CPOPJ	;NOT IF DETACHED.
	JRST PTYUU2		; GIVE HIM HIS OWN TTY.
PTYUU3:	CAIL TAC,PTYL0	;IS IT A PTY ?
	CAME ITEM,PTYJOB-PTYL0(TAC)	;YES. DOES HE OWN IT ?
	CAIN UCHN,PTRLCD	;NO. AN ERROR UNLESS HE IS MERELY RELEASING IT.
PTYUU2:	SKIPA LINE,LINTAB(TAC)
	JRST UUOERR		;SORRY, THE LINE YOU HAVE REQUESTED IS NOT YOURS AT THIS TIME.
	HRRI LINE,(TAC)
	ADDI UUO,1
	HRLI UUO,(<POINT 36,0,35>)	;MAKE FULL-WORD BYTE PTR. IN UUO.
	SKIPE DDB,TTYTAB(LINE)	;GET LOC. OF HIS DDB.
	JRST PTYUU4
	PUSHJ P,DDBSRC		;NO DDB, SO GET HIM ONE.
	JRST UUOERR		;NONE AVAILABLE.
PTYUU4:	SKIPG PTYDIS(UCHN)	;LEGAL FOR TTY'S?
	TLNE LINE,PTYLIN	;OR PTY?
	JRST @PTYDIS(UCHN)
	JRST UUOERR		;SOMETIMES YOU HAVE TO BE A PTY TO DO A PTY-UUO!

LINMAP:	CAILE TAC,TTPLEN
	JRST UUOERR
	MOVE AC1,JBTPRV(J)
	TLNE AC1,MESPRV
	JRST PTYUU2		;ALL OK NOW
	SKIPN DDB,TTYTAB(TAC)
	JRST UUOERR
	LDB AC1,PJOBN
	CAMN AC1,J
	JRST PTYUU2
	JRST UUOERR

DEFINE UUOS{FOR X IN(PTYGET,<PTYREL,PTRLCD←←.-PTYDIS>,PTIFRE,<PTOCNT>
,<PTRD1S,400000>,<PTRD1W,400000>,PTWR1S,<PTWR1W>
,<PTRDS,400000>,PTWRS7,PTWRS9,<PTGETL,,GETLN1>
,<PTSETL,,SETLIN>,<PTLOAD,,PTLLED>,PTJOBX)}

UUOMAC PTYDIS,PTYUUO
PTYXNO←←UUOCNT-1

PTOCNT:	SKIPA CHR,TOFCTR(DDB)
PTIFRE:	SKIPA CHR,TIFCTR(DDB)
	SUBI CHR,TTOCHR-1	;GET -(NO. OF CHRS. IN BUFFER).
	SUBI CHR,1		;COUNT CAN ONLY GO TO 1 NOT 0.
PTSTOR:	XCTR XW,[MOVMM CHR,(UUO)]
	POPJ P,
;PTYREL, PTRD1S, PTRD1W, PTWAIT
PTYREL:	TLNE LINE,PTYLIN	;RELEASE THE PTY, IF IT REALLY IS ONE.
PTYRL2:	CAME ITEM,PTYJOB-PTYL0(LINE)	;DOES THIS JOB OWN THIS PTY ?
	POPJ P,
	SKIPN DDB,TTYTAB(LINE)	;THIS IS NEEDED IF WE CAME FROM PTYCLR.
	JRST LINCLR		;CLEAR LINE BITS AND RETURN.
	PUSHJ P,XMTIN4		;FINISH OUTPUT.
	PUSHJ P,TSETBF		;CLEAR BOTH ITS BUFFERS.
	SETZM PTYJOB-PTYL0(LINE)	;CLEAR OWNERSHIP FLAG.
	MOVSI TAC,PTYUSE	;MARK PTY AS NO LONGER USED, SO DDB WILL BE
	ANDCAM TAC,LINTAB(LINE)	;KILLED BY TTYKIL.
	LDB J,PJOBN		;GET JOB ON THIS PTY
	JUMPE J,.+2		;IF ANY
	PUSHJ P,INTKILL		;NOW KEEP HIM FROM FUTZING AROUND
	MOVE UUO,[BYTE(7)3,3,"K",12,0]
	XCTR	XW,[MOVEM UUO,JOBTM1]	;PUT IT IN USER CORE.
	MOVE UUO,[POINT 7,JOBTM1]	;THIS WILL BE RELOCATED.
	PUSHJ P,PTWR2			;SEND JOB ↑C ↑C K<LF>.
	POPJ P,

PTRD1S:	MOVE IOS,DEVIOS(DDB)	;GET STATUS WORD.
	PUSHJ P,XMTIN1
	XCTR	XDB,[DPB CHR,UUO]		;GIVE CHAR. TO LOSER.
	JUMPE CHR,CPOPJ
	JRST CPOPJ1

PTRD1W:	PUSHJ P,PTRD1S
	SKIPA UCHN,DDB
	POPJ P,
	PUSHJ P,TTYGET
	HRRZM DDB,PTYPTR(UCHN)
	MOVSI IOS,IOW!TTYIOW!DDTM
	TLNE LINE,PTYWAK	;DO WE WANT TO HEAR TTY INPUT ?
	IORM IOS,DEVIOS(DDB)
	PUSHJ P,PTWAIT
	SETZM PTYPTR(DDB)
	PUSHJ P,PTRD1S
	POPJ P,
	POPJ P,

PTWAIT:	MOVEI TAC,IOWQ
	MOVNM TAC,JOBQUE(J)
	MOVE DDB,UCHN	;RECOVER DDB FOR PTY.
	PUSHJ P,STLNAC			;RESTORE LINE (CLOBBERED BY TTYGET).
	JRST WSCHED
;PTWR1S, PTLL3, PTWR1W, PTRDS, PTWRS7, PTWRS9
PTWR1S:	MOVEI CHR,1
	CAML CHR,TIFCTR(DDB)		;IS THERE ROOM (>1 NOT 0).
	POPJ P,
	AOS (P)				;THERE IS ROOM FOR THE CHR., SO WE WILL SKIP.
	XCTR XLB,[LDB CHR,UUO]
	LDB UCHN,[POINT 2,CHR,28]
PTLL3:	LDB DSER,[POINT 7,CHR,35]	;SIMULATE KBDINT, IN CASE THIS PTY IS REALLY A DPY.
	CAIL DSER,"A"
	CAILE DSER,"Z"
	JRST .+2
	TRO DSER,40
	MOVEI AC2,
	PUSHJ P,STLNAC		;IN CASE KBDED IS AROUND CLOBBERING THINGS.
	MOVE TAC,LINTAB(LINE)	;SET UP ESCAPE BITS
	DPB LINE,[PUNITS⊗6,,TAC];BUT NULLIFY MAPPING
	CONO PI,SCNOFF
	PUSHJ P,PTYREC		;PRETEND CHR. HAS JUST BEEN TYPED IN.
	JRST TYPT1		;TURN ON PI AND POPJ.

PTWR1W:	TLNE LINE,IMLIN		;IMLAC FORWARD-SPACE KLUDGE
	JRST IMWR1W
IMWR10:	PUSHJ P,PTWR1S		;WRITE A CHAR.
	SKIPA UCHN,DDB		;DIDN'T GO. LET'S WAIT A WHILE.
	POPJ P,			;ALL DONE.
	PUSHJ P,TTYGET
	HRROM DDB,PTYPTR(UCHN)
	PUSHJ P,PTWAIT
	JRST PTWR1W

IMWR1W:	XCTR XLB,[LDB CHR,UUO]	;IMLAC...
	CAIN CHR,211		;<CONTROL>TAB?
	JRST IMWR11
	CAIE CHR,240		;<CONTROL>SPACE?
	JRST IMWR10		;NEITHER.  BACK TO OLD CODE.
	MOVE CHR,[ASCID/ε↓/]	;CTL-SPACE.  COMMAND TO MOVE FORWARD 1.
	CAIA
IMWR11:	MOVE CHR,[ASCID/ε}/]	;CTL-TAB.  MOVE FORWARD A BUNCH.
	PUSHJ P,TTYFNU
	JRST FIVOUT		;SEND THE COMMAND.

; PTRDS, PTWRS7, PTWRS9 CHANGED 3-30-71 TO USE LH (ADR+1) AS BYTE
; POINTER SPEC IF NON-ZERO ------ DCS

PTRDS:	XCTR	XR,[MOVE UUO,(UUO)]	;GET ADDRESS OF BUFFER IN LOSER CORE.
	TLZN	UUO,7777	;CLEAR SIZE FIELD, CHECK FOR BP THERE --DCS
	HRLI	UUO,440700	;NONE, GIVE 7-BIT PTR TO FIRST CHAR --DCS
	TLO	UUO,700		;ASSURE CORRECT SIZE FIELD, AT LEAST--DCS
	IBP	UUO		;STUPID SAIL!
PTRDSA:	PUSHJ P,PTRD1W	;WAIT FOR AT LEAST ONE CHAR. TO APPEAR.
PTRDS2:	IBP UUO
	PUSHJ P,PTRD1S	;GET ANY FURTHER CHARS.
	POPJ P,		;NO MORE.
	JRST PTRDS2	;MAYBE MORE.

PTWRS7:	TLCA UUO,444300	;MAKE 7-BIT PTR. ...
PTWRS9:	TLC UUO,445500	;MAKE 9-BIT PTR.
	HLR	CHR,UUO	;SAVE BP SPEC FOR FIRST CHAR--DCS
	XCTR	XR,[MOVE UUO,(UUO)]	;GET ADDRESS OF BUFFER IN LOSER CORE.
	TLZN	UUO,7777	;CLEAR SIZE AND INDEX, CHECK--DCS
	HRL	UUO,CHR		;ZERO, PROVIDE CORRECT PTR --DCS
	DPB	CHR,[POINT 12,UUO,17];ASSURE CORRECT SIZE FIELD--DCS
PTWR2:	XCTR	XLB,[ILDB CHR,UUO]
	JUMPE CHR,STLNAC	;DONE IF NULL
	PUSHJ P,PTWR1W	;GIVE NEXT CHAR. TO PTY.
	JRST PTWR2	;LOOP UNTIL WE SEE A NULL.

;PTJOBX
PTJOBX:	LDB TAC,PJOBN		;GET JOB WHICH IS ON THIS PTY
	XCTR XR,[MOVE TAC1,(UUO)]	;GET COMMAND
	TLNN TAC1,770000	;IS IT SIXBIT OR DIRECT INDEX?
	JRST PTJDIR		;DIRECT
	MOVEI AC1,PTJLEN	;LENGTH OF TABLE
	CAME TAC1,PTJTAB-1(AC1)	;MATCH?
	SOJG AC1,.-1
	MOVE TAC1,AC1
PTJDIR:	JUMPLE TAC1,UUOERR
	CAILE TAC1,PTJLEN	;IS IT IN TABLE?
	JRST UUOERR		;NO
	HRRZ TAC1,PTJDIS-1(TAC1)	;GET DISPATCH
	JRST (TAC1)		;AND DISPATCH

DEFINE NAMES
<	C	HALT,PTJHLT,0
	C	CONT,PTJCON,0
	C	DOFF,PTDOFF,0
	C	DON,PTDON,0
	C	LOGIN,PTLOGN,0
	C	IWAITS,PTIWTS,0
	C	CLRBFI,PTCLRB,0
>
DEFINE C(A,B,BITS)
<	XWD BITS,B
>
PTJDIS:	
XLIST
	NAMES
LIST
PTJLEN←←.-PTJDIS
DEFINE C(A,B,BITS)
<	SIXBIT/A/
>
PTJTAB:	
XLIST
NAMES
LIST
;PTJHLT, PTJCON, PTIWTS, PTCLRB
;HALT JOB RUNNING ON THIS PTY
PTJHLT:	JUMPE TAC,CPOPJ
	PUSH P,J		;SAVE OURSELVES FIRST.
	MOVE J,TAC		;NOW DO IT TO HIM
	CAMN J,STUSER		;SYSTEM TAPE USER?
	JRST HLTOK0
	PUSHJ P,STOPCK	;NO, OK TO STOP?
	CAIA
	JRST HLTOK	;YES
NOTOK:	POP P,J
	PUSHJ P,WSCHED	;WAIT A WHILE
	JRST PTJHLT
HLTOK0:	SKIPN JBTADR(J)
	JRST HLTOK1
	PUSHJ P,ANYACT
	JRST NOTOK
HLTOK1:	PUSHJ P,ESTOP
	POP P,J
	JRST CPOPJ1		;SUCCESS RETURN
HLTOK:	PUSHJ P,STOP1
	POP P,J
	JRST CPOPJ1		;SUCCESS RETURN

;CONTINUE THE JOB RUNNING ON THIS PTY

PTJCON:	JUMPE TAC,CPOPJ
	PUSH P,J
	MOVE J,TAC
	MOVM TAC,JOBQUE(J)
	CAIE TAC,STOPQ		;THIS IS ONLY PLACE YOU CAN CONTINUE FROM
	JRST NOCONT
	MOVE TAC,JBTSTS(J)
	TLNE TAC,JERR
	JRST NOCONT
	MOVNI TAC,RUNQ
	MOVEM TAC,JOBQUE(J)
	PUSHJ P,SETRUN
	AOS -1(P)		;SUCCESS RETURN
NOCONT:	POP P,J
	JRST CPOPJ1		;SUCCESS RETURN

;SKIP IF PTY IS WAITING FOR INPUT

PTIWTS:	MOVE IOS,DEVIOS(DDB)
	TLNE IOS,TPMON		;MONMODE OR USRMODE?
	JRST PTIWT1
	JUMPL IOS,CPOPJ1	;USER MODE, CHECK TTYIOW BIT
	POPJ P,			;IT WAS OFF

PTIWT1:	LDB LINE,PUNIT		;GRUMBLE, GRUMBLE, PTJOBX MUNGS "TAC1"!!
	MOVE TAC,TTYTAB(LINE)	;MONITOR MODE, GOBBLE TTYTAB
	TLNN TAC,COMBIT!DLYBIT
	AOS (P)
	POPJ P,

;PTJOBX [N ↔ SIXBIT /CLRBFI/] -- DO CLRBFI FOR TTYN
PTCLRB:	JRST SETBFI		;YES, I KNOW THIS WASTES A CELL AND A CYCLE
;PTDON, PTDOFF,PTLOGN,IMLOAD
; ROUTINES TO SET DUPLEXING OF PTY

PTDON:	MOVEI IOS,NOECHO
	ANDCAB IOS,DEVIOS(DDB)
	POPJ P,

PTDOFF:	MOVEI IOS,NOECHO
	ORB IOS,DEVIOS(DDB)
	POPJ P,

;START A NEW JOB ON A PTY.  USES FORK CODE.

PTLOGN:	JUMPN TAC,PTLGN1	;LOSE IF THERE'S A JOB ALREADY
	HRLM J,(P)		;SAVE OUR JOBNUM
	PUSHJ P,INIJOB		;GOBBLE A NEW JOB
	JRST PTLGN0		;SORRY, NO JOBS
	JRST PTLGN0		;THIS CAN'T HAPPEN (IT SAYS HERE)
	PUSHJ P,FORKC		;THIS COPIES THE OLD JOB'S STUFF
	MOVEI TAC,(J)		;TO RETURN IT TO LOSER
	AOSA	(P)
PTLGN0:	MOVEI	TAC,0
PTLGN1:	XCTR	XW,[MOVEM TAC,(UUO)]
	POPJ	P,

;DO A PTLOAD TO AN IMLAC

IMLOAD:	PUSHJ P,TTYFNU
	XCTR	XR,[MOVE UUO,(UUO)]	;GET GUY'S PTR.
	TLNN	UUO,-1			;IS IT ALREADY (PRESUMABLY) A BYTE PTR. ?
	HRLI	UUO,440700		;NO. MAKE IT ONE.
IMLOD0:	MOVE CHR,[ASCID/0/]		;Load command is "0"+no. of chars.
	MOVE TAC,[POINT 7,CHR,6]
IMLOD1:	XCTR	XLB,[ILDB AC3,UUO]	;Get a char,
	JUMPE AC3,IMLOD2		;end on a null.
	ADD CHR,[BYTE (7)1]		;Count the chars.
	IDPB AC3,TAC			;Stuff char into the command.
	TLNE TAC,760000			;Full word (4 chars)?
	JRST IMLOD1			;No.  Do it again.
	PUSHJ P,FIVOUT			;Send those 4 to the IMLAC
	JRST IMLOD0			;and keep going.
IMLOD2:	CAME CHR,[ASCID/0/]		;Done.  Put out the last few chars.
	PUSHJ P,FIVOUT
	MOVE CHR,[ASCID/¬/]		;Command to move to beginning of
	JRST FIVOUT			;line and return to normal.
;PHONE DIALER LIVES HERE
IFE DILNUM,<DIAL:JRST UUOERR>;IF NO DIALER, UUOERR
IFN DILNUM,<
;DIALER BITS AND DEFINITIONS
DIL0TT←←11		;TTY11 IS DIALER 0

;CONI BITS
DILDS1←←4000		;DATASET ANSWERED OR DIALED END OF NUMBER CODE
DILDS0←←2000		;DATASET HUNG-UP
DILBSY←←1000		;DIALER BUSY
DILOK←←400		;DIALER OK (NOT TIMED OUT)
DILDSS←←200		;CONNECTED
DILVMD←←100		;IN VOICE MODE
DILPWR←←40		;POWER FAIL

;CONO BITS
DILCLR←←40		;CLEAR INTERRUPT CONDITION
DILHUP←←20		;HANG UP
DILENB←←10		;ENABLE INTERRUPT

;DATAO BITS (LEFT HALF)
DAREA←←4000		;DIAL AREA CODE
DVOICE←←2000		;GO TO VOICE MODE ON DSS←1

;DIALER INITIALIZE ROUTINE
DILINI:	CONO DIL,DILCLR!DILHUP!DILENB!DILCHN	;INIT HARDWARE
	SETZM DILZBG			;BEGIN ZERO OF DIALER DATA
	MOVE TAC,[DILZBG,,DILZBG+1]
	BLT TAC,DILZND			;AND ZERO TO END
	POPJ P,

DILTRL:	MOVSI AC1,-DILNUM
DILTR1:	HRRZ TAC,DILTTY(AC1)
	CAIE TAC,(LINE)
	AOBJN AC1,DILTR1
	JUMPGE AC1,CPOPJ
	PUSH P,LINE
	HRRZ LINE,AC1
	SKIPE DILJOB(LINE)
	PUSHJ P,RELDIL	;RELEASE DIALER
	POP P,LINE
	POPJ P,
;DIAL UUO
;CALL
;	MOVEI AC,ADDR
;	DIAL AC,
;	<ERROR RETURN, AC CONTAINS STATUS BITS>
;	<SUCCESS, AC CONTAINS ANY DATA RETURNED>
;
;ADDR:	DIALER #,,FUNCTION CODE
;	SEE INDIVIDUAL CALL FOR REST OF DATA

DILER0:	JSP TAC,DILERR
DILER1:	JSP TAC,DILERR
DILER2:	JSP TAC,DILERR
DILER3:	JSP TAC,DILERR
DILER4:	JSP TAC,DILERR

DILERR:	SUBI TAC,DILER0+1
	HRRZ TAC,TAC
DILSTT:	XCTR XW,[MOVEM TAC,(UCHN)]	;STORE ERROR CODE BACK IN AC
	POPJ P,

;ERROR CODES FOR ALL DIAL UUO'S
;ERROR 0 -- ILLEGAL DIALER #
;ERROR 1 -- DON'T OWN DIALER
;ERROR 2 -- DON'T MEET DILOWN CONDITIONS
;ERROR 3 -- DIALER BUSY
;ERROR 4 -- DIALING FAILURE

↑DIAL:	XCTR XR,[HRRZ UUO,(UCHN)]	;FETCH POINTER TO ARG BLOCK
	XCTR XR,[HLRZ LINE,(UUO)]	;GET DIALER NUMBER
	CAIL LINE,DILNUM		;LEGAL?
	JRST DILER0			;NO, ERROR 0
	XCTR XR,[HRRZ DSER,(UUO)]	;GET FUNCTION CODE
	CAIL DSER,MXDLCD		;LEGAL FUNCTION CODE?
	JRST UUOERR			;NO
	CAME J,DILJOB(LINE)		;HIS?
	JUMPN DSER,DILER1		;NO, ERROR 1 (UNLESS DILGET)
	JRST @DILDIS(DSER)		;YES, CALL ROUTINE

DILDIS:	DILGET				;0 GET DIALER
	DILSTA				;1 GET DIALER STATUS
	DILDIL				;2 DIAL A NUMBER
	DILHNG				;3 HANG UP
	DILREL				;4 RELEASE
MXDLCD←←.-DILDIS

;CODE 0	GET DIALER
DILGET:	CAMN J,DILJOB(LINE)		;DOES HE OWN IT?
	JRST CPOPJ1			;ALREADY HAS IT, SUCCESS
	SKIPE DILJOB(LINE)		;DOES ANYONE OWN IT?
	JRST DILER1			;YES, DON'T OWN ERROR
	XCT DILOWN(LINE)		;CHECK OTHER CONDITIONS
	JRST DILER2			;LOSE
	MOVEM J,DILJOB(LINE)		;CLAIM IT
	JRST CPOPJ1

DILTTY:	400000,,DIL0TT			;TTY NUMBER FOR THIS DIALER (SIGN BIT MEANS CONNECTED TO AD/DA)

DILOWN:	PUSHJ P,DIL0CK			;CHECK ROUTINE FOR DIALER 0

DIL0CK:	MOVE DDB,DILTTY(LINE)
	SKIPN DDB,TTYTAB(DDB)		;CHECK TTY FOR DIALER
	POPJ P,				;NO TTY THERE AT ALL
	LDB TAC,PJOBN
	CAME TAC,J			;IS IT HIS?
	POPJ P,				;NO
	MOVE TAC,DEVMOD(DDB)
	TRNE TAC,ASSPRG			;DOES HE HAVE IT INITED?
	AOS (P)				;YES, SUCCESS
	POPJ P,

;CODE 1 GET STATUS
DILSTA:	CONI DIL,TAC			;GET CURRENT STATUS
	HRL TAC,DILCNI(LINE)		;LAST I-LEVEL CONI IN LEFT HALF
	AOS (P)				;ALWAYS SUCCESSFUL HERE
	JRST DILSTT			;RETURN STATUS BITS IN AC

;CODE 2 DIAL A NUMBER
DILDIL:	CONSZ DIL,DILBSY
	JRST DILER3			;DIALER BUSY
	CONSZ DIL,DILPWR		;IS DIALER POWER OK?
	JRST DILER4			;NO, GIVE HIM AN ERROR RIGHT AWAY
	XCTR XR,[MOVE TAC,2(UUO)]	;PICKUP DATAO WORD
IFN 0,<;ENABLE WHEN AD/DA CONNECTED
	TLNE TAC,DVOICE			;ATTEMPTING VOICE MODE?
	SKIPL DILTTY(LINE)		;CONNECTED TO AD/DA?
	JRST DILNM1
;CHECK AD/DA OWNERSHIP HERE
DILNM1:
>;IFN 0
	XCTR XR,[MOVE AC1,1(UUO)]	;PICKUP CONO WORD
	ANDI AC1,777700			;JUST AREA CODE
	CAIN AC1,4B21!1B25!5B29		;AREA 415?
	TLZ TAC,DAREA			;YES, DON'T DIAL AREA CODE
	CONO PI,DILOFF			;DISABLE DIALER CHANNEL
	CONO DIL,DILCLR!DILENB!DILCHN(AC1)	;SETUP
	DATAO DIL,TAC			;AND GO
DILWAT:	MOVNI TAC,IOWQ
	MOVEM TAC,JOBQUE(J)
	PUSHJ P,REQUE
	MOVE AC1,[JRST DILING]		;DISPATCH FOR I-LEVEL
	MOVEM AC1,DILIDS(LINE)
	SETZM DILCNI(LINE)		;CLEAR CONI BITS FOR CHECK
	CONO PI,DILON
	PUSHJ P,WSCHED			;WAIT FOR DIALER
	CONO PI,DILOFF			;INTERLOCK
	SKIPN TAC,DILCNI(LINE)		;GET CONI BITS
	JRST DILWAT
	CONO PI,DILON
	TRC TAC,DILDS1!DILOK!DILDSS	;ALL THESE SHOULD BE ON
	TRCN TAC,DILDS1!DILOK!DILDSS
	TRNE TAC,DILDS0!DILPWR		;THESE SHOULD BE OFF
	CAIA
	JRST DILSTAT			;OK, RETURN STATUS
	CONO DIL,DILHUP!DILENB!DILCHN	;HANG IT IN YOUR EAR
	JRST DILER4			;DIALER ERROR

;CODE 3 HANG UP
DILHNG:	CONO DIL,DILHUP!DILENB!DILCHN	;HANG IT IN YOUR EAR
	JRST DILSTAT			;RETURN STATUS

;CODE 4 RELEASE DIALER
DILREL:	PUSHJ P,RELDIL
	JRST DILSTAT			;RETURN STATUS

RELDIL:	SETZM DILIDS(LINE)		;CLEAR I-LEVEL DISPATCH
	CONO DIL,DILHUP!DILENB!DILCHN	;HANG IT IN YOUR EAR
	SETZM DILJOB(LINE)
	POPJ P,
;DIALER INTERRUPTS COME HERE
↑DILINT:MOVEM LINE,DILLIN
	MOVEI LINE,0			;ONLY ONE LINE FOR NOW
	MOVEM TAC,DILTAC
	CONI DIL,TAC			;GET STATUS BITS
	MOVEM TAC,DILCNI(LINE)		;LATEST CONI BITS
	SKIPE DILIDS(LINE)		;THIS DIALER ACTIVE?
	XCT DILIDS(LINE)		;DISPATCH TO DIALER ROUTINE OR EXIT
DILXIT:	CONSO DIL,DILBSY		;DIALER BUSY?
	JRST DILXT1			;NO, DON'T CHECK FOR HANGUP
	CONSO DIL,DILOK			;IF NOT OK
	CONO DIL,DILHUP			;HANG UP
DILXT1:	CONO DIL,DILCLR!DILENB!DILCHN	;CLEAR INTERRUPT, ENABLE, SET CHANNEL
	MOVE TAC,DILTAC
	MOVE LINE,DILLIN
	JEN @DILCHL

DILING:	TRNE TAC,DILDS1			;SHOULD HAVE JUST CONNECTED
	TRNN TAC,DILDSS			;AND STILL BE CONNECTED
	TDZA TAC,TAC			;NOT CONNECTED, IDLE STATE
	MOVE TAC,[JRST DILACT]		;CONNECTED, SET TO ACTIVE STATE
	MOVEM TAC,DILIDS(LINE)		;SET DISPATCH
	MOVEM J,DILJ
	MOVE J,DILJOB(LINE)
	MOVM TAC,JOBQUE(J)
	CAIE TAC,IOWQ			;STILL WAITING FOR US?
	JRST DILIN1
	MOVNI TAC,RUNQ
	MOVEM TAC,JOBQUE(J)
	MOVEI TAC,QJOB(J)
	CONO PI,PIOFF
	SKIPE (TAC)
	JRST DILIN0
	EXCH TAC,QJOB
	HRROM TAC,@QJOB
DILIN0:	CONO PI,PION
DILIN1:	MOVE J,DILJ
	JRST DILXIT

DILACT:	TRNE TAC,DILOK			;IF NOT OK,
	TRNE TAC,DILDS0!DILPWR		;OR ANY ERRORS
	XCT DILERP(LINE)		;THEN REPORT ERROR
	JRST DILXIT			;I WONDER WHAT WAS WRONG?

DILERP:	JRST DILERT			;REPORT TO TTY

DILERT:	MOVE TAC,DILTTY(LINE)
	SKIPN TAC,TTYTAB(TAC)		;JUST IN CASE
	JRST DILXIT			;FOO
	MOVEM J,DILJ
	MOVSI J,IODERR
	IORM J,DEVIOS(TAC)		;FLAG ERROR TO TTY
	MOVE J,DILJ
	JRST DILXIT
>;IFN DILNUM
