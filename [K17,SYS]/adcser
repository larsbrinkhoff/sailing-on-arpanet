COMMENT ⊗   VALID 00024 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	BEGIN	ADCSER	↔SUBTTL NEW AD/DA SERVICE ROUTINE
C00006 00003	 UUO DISPATCH TABLE FOR ADC
C00007 00004	 ADC MTAPE UUO. SETS PARAMETERS.
C00010 00005	 ADC DUMP MODE INPUT ROUTINE
C00013 00006	 ADC HUNG TIMEOUT, ADHUNG, ADC INITIALIZE CODE, ADCINI, ADC RELEASE, ADCREL
C00015 00007	 ADCP2 - PDP-6'S CLK LEVEL ROUTINE FOR THE ADC
C00017 00008	 ADCP2 CONT - STARTUP CODE, SET 'RUN' FLAG, CHECK FOR IO SYNC
C00019 00009	 ADCP1 - PDP-10'S CLOCK ROUTINES FOR THE ADC
C00021 00010	 ADC INTERRUPT ROUTINES, ADCIST FOR SPURIOUS, ADCINT FOR NORMAL
C00024 00011	 ADC INTERRUPT ROUTINES, ADCRCY FOR RECYCLING INPUT
C00025 00012	 ADC INTERRUPT ROUTINES - ADCSMD, SWITCH MODES FROM CYCLE TO NORMAL
C00028 00013	 ADC INTERRUPT ROUTINES - ADCILA, ADCW, ADCWK, ADCILI, END OF XFR
C00031 00014	 UUO DISPATCH TABLE FOR DAC
C00032 00015	 DAC MTAPE UUO. SETS PARAMETERS.
C00034 00016	 DAC DUMP MODE OUTPUT ROUTINE
C00037 00017	 DAC HUNG ROUTINE, DAHUNG, DAC INITIALIZE ROUTINE, DACINI, RELEASE, DACREL
C00038 00018	 DACP2 - PDP-6'S CLK LEVEL ROUTINE FOR THE DAC
C00041 00019	 DACP1 - PDP-10'S CLOCK ROUTINES FOR THE DAC
C00042 00020	 DAC INTERRUPT ROUTINES, DACIST FOR SPURIOUS, DACINT FOR NORMAL
C00044 00021	 DAC INTERRUPT ROUTINES - WAKEUP AND 'RUN' FLAG BUSINESS
C00046 00022	 ROUTINE MAKES UP A CONO WORD FROM MTAPE SPECS
C00049 00023	 ADRCHK - ROUTINE TO ADDRESS CHECK AN IOWD, CHKUUO - CHECKS UUO ADDR
C00051 00024	 END OF IT ALL
C00052 ENDMK
C⊗;
BEGIN	ADCSER	↔SUBTTL NEW AD/DA SERVICE ROUTINE
;JAM 2-10-74

; IOS BITS, RH

CYCDON←←20	; CIRCULATION DONE
IOSYNC←←40	; SYNCHRONIZE AD AND DA AT STARTUP
CONT←←100	; CONTINUOUS MODE (NO WAIT AFTER DMP MODE COMMAND)
CYCLE←←200	; CIRCULATE INPUT MODE
LOST←←2000	; LOST. MEANS DATA MISSED.
IOAFT←←4000	; IOSYNC∧CYCLE∧IOAFT ⊃ START OUTPUT AFTER
		;    RECYCLE DONE, NOT BEFORE.
ERRMSK←←IOIMPM!IODTER!IODERR!IOBKTL

; CONO BITS

FILT←←200000	; 2-BIT FILTER NUMBER GOES HERE
RUNB←←100000
MPX←←040000	; ALTERNATE INPUT (ADC ONLY)
FLOAT←←040000	; 9-BIT FLOATING INCREMENTAL MODE (DAC ONLY)
.16BIT←←020000	; HALFWORD MODE (LEFT ADJUSTED)
.12BIT←←010000	; COMPATIBILITY MODE
SPEED←←100	; 3-BIT SPEED NUMBER GOES HERE
QUAD←←40
STEREO←←20
MONO←←10

; CONI BITS - ADC

DATARQ←←40
BUFFUL←←20
ADLOST←←10

; CONI BITS - DAC

BUFRDY←←4000
INTRQ←←2000
DALOST←←1000

; CODES THAT GO IN P2 CELLS (ADCP2L, DACP2L)

STCODE←←1	; STARTUP. IOWD IN XXXNBK
KLCODE←←2	; CLEAR.

; CODES THAT GO IN P1 CELLS (ADCP1L, DACP1L)

WKCODE←←1	; WAKE UP JOB
ERCODE←←2	; ERROR. (ADDRESS CHECK)
; UUO DISPATCH TABLE FOR ADC

	JRST ADCINI	; SYSTEM STARTUP
	JRST ADHUNG	; HUNG TIME OUT
↑ADCDSP:JRST ADCREL	; RELEASE
	POPJ P,		; CLOSE OUTPUT
	JRST UUOERR	; BUFFERED OUTPUT
	JRST ILLINP	; BUFFERED INPUT
	JRST CPOPJ1	; ENTER
	JRST CPOPJ1	; LOOKUP
	JRST UUOERR	; DMP MODE OUTPUT
	JRST ADCIN	; DMP MODE INPUT
	POPJ P,		; USETO
	POPJ P,		; USETI
	POPJ P,		; UGETF
	JRST CPOPJ1	; RENAME
	POPJ P,		; CLOSE INPUT
	POPJ P,		; UTPCLR
	JRST ADCMTP	; MTAPE
; ADC MTAPE UUO. SETS PARAMETERS.
; EFFECTIVE ADDRESS POINTS TO THREE WORD BLOCK
; FIRST WORD (RH SAME AS DAC)
;  	<RECYCLE END THRESHHOLD>,,SPEED*1000+PACK*100+NCHANS
;       <R.E. THRESH> IS LEFT ADJUSTED, 12 OR 16 BIT 2'S COMP NUMBER
;		WHEN INPUT SAMPLE EXCEEDS THAT, WE END RECYCLING
;	SPEED = 0	6.4 KC		IS PER CHANNEL RATE
;		1	12.8 KC
;		2	25.6 KC
;		3	51.2 KC		MAX FOR ADC. DAC GOES ON UP.
; SECOND WORD (SAME AS DAC)
;	<ADDR FOR ERR CODES>,,<ADDR FOR 'RUN' FLAG>
;	<'RUN' FLAG IS 'SETOM'ED WHILE ADC IS RUNNING AND ZEROED WHEN
; 		ADC IS SHUT OFF
; THIRD WORD (NOT USED IN DAC)
;	<INPUT SELECT>,,<ADDR TO PUT RECYCLE IOWD>
;	<INPUT SELECT> IS CURRENTLY ONE BIT, THE SIGN BIT. MEANS 'MPX'
;	<ADDR . . .> IS WHERE WE PUT THE RECYCLE IOWD WHEN
;		THE INPUT SAMPLE HAS EXCEEDED THE THRESHHOLD AND WE
;		THUS SWITCH BUFFERS

ADCMTP:	TLZN IOS,IOBEG		; FIRST UUO?
	JRST ADCFST
	MOVEM IOS,ADCIOS
	PUSHJ P,ADCINI		; CLEAR OUT DDB
ADCFST:	PUSHJ P,CHKUUO		; ADDRESS CHECK EFFECTIVE ADDR OF UUO
				; LEAVES LAST WD OF CORE IMAGE IN AC1,
				; RH OF UUO IN AC2
	ADDI AC2,2		; DO SO WITH END OF TABLE TOO
	CAILE AC2,(AC1)
	JRST ADRERR
	MOVE TAC,@UUO		; PICK UP THRESH,,PARAMS
	HLLZM TAC,ADCTHR	; SET THRESHHOLD
	PUSHJ P,SETCNO		; SET UP CONO WORD IN TAC1
	MOVEM AC2,ADCWPS	; SAVE # WORDS PER SECOND
	TRNE TAC1,4*SPEED	; IS SPEED>3
	JRST ILLSPD		; YES, IS ERROR.
	TRNE TAC1,MPX		; FLOAT MODE FOR ADC?
	JRST ILLMOD		; IS ERROR
	ADDI UUO,1		; BUMP TO ERR CODE WORD
	MOVE AC1,@UUO
	HLRZM AC1,ADCERA	; SET ERROR CODE ADDRESS
	HRLI AC1,PROG		; SET PROG IN INDEX FIELD
	MOVEM AC1,ADCRUN	; RUN FLAG ADDRESS
	HLLM AC1,ADCERA
	ADDI UUO,1
	SKIPGE @UUO		; IS MPX BIT ON?
	ORI TAC1,MPX		; YES
	MOVEM TAC1,ADCCNO	; STORE CONO WORD
	POPJ P,			; ALL DONE
; ADC DUMP MODE INPUT ROUTINE

ADCUW:	TRNE IOS,ERRMSK
	POPJ P,			; LEAVE ON ERRORS
	PUSHJ P,WSYNC		; SINCE IOACT IS ON, WILL WAIT
ADCIN:	TLZN IOS,IOBEG		; FIRST UUO?
	JRST ADCNFS
	MOVEM IOS,ADCIOS
	PUSHJ P,ADCINI		; CLEAR OUT DDB
ADCNFS:	SKIPE ADCNBK		; IS THERE ANOTHER BLOCK?
	JRST ADCUW		; YES, WAIT FOR IT TO END
	PUSHJ P,CHKUUO		; ADDRESS CHECK RH OF UUO
	SKIPE TAC,@UUO		; PICK UP IOWD
	TLNN TAC,777777		; ANY WORD COUNT?
	JRST ADCXIT		; NOTHING THERE. GO HOME.
	PUSHJ P,ADRCHK		; ADDRESS CHECKS IOWD IN TAC
	JRST ADRERR		; ILLEGAL. STOP JOB AND DIE
	MOVEI IOS,IOACT
	PSYNC ADCCSC
	ORB IOS,ADCIOS		; LOCK US IN CORE
	XSYNC ADCCSC
	ADDI TAC,(PROG)		; RELOCATE IT NOW
	MOVEM TAC,ADCNBK
	HLRO AC1,TAC		; PICK UP -WC
	MOVN AC1,AC1		; MAKE IT POSITIVE
	IDIV AC1,ADCWPS		; GET # SECONDS
	ADDI AC1,5		; A FEW EXTRA FOR GOOD MEASURE
	CAILE AC1,77		; SATURATE AT 6 BITS
	MOVEI AC1,77
	DPB AC1,PDVTIM		; MAKE THIS THE NEW HUNG TIME
	SKIPE ADCBKI		; IS THERE AN XFR IN PROGRESS?
	JRST ADCXIT		; YES. LEAVE NOW
	TRNE IOS,IOSYNC		; ARE WE SYNCHRONIZING?
	SKIPE DACBKO		; YES, IS XFR RUNNING THERE?
	JRST ADCSTR		; NOT SYNC OR XFR ALREADY RUNNING ON DAC
	SKIPN DACNBK		; IS THERE AN XFR QUEUED?
	JRST ADCSHT		; NO, PUT US DOWN AND HANG. SET HUNG TIME.
ADCSTR:	MOVEI TAC,STCODE	; NO, START ADC AND LEAVE
	MOVEM TAC,ADCP2L	; PLACE WHERE P2 WILL SEE IT
ADCXIT:	TRNE IOS,CONT		; CONTINUOUS MODE?
	SUB P,[XWD 1,1]		; YES, RETURN UPLEVEL ONE
	POPJ P,

ADCSHT:	MOVEI TAC,77		; SET HUNG TIME TO MAXIMUM
	DPB TAC,PDVTIM
	JRST ADCXIT
; ADC HUNG TIMEOUT, ADHUNG, ADC INITIALIZE CODE, ADCINI, ADC RELEASE, ADCREL

ADHUNG:	SKIPN ADCNOH		; IF DEBUGGING, DON'T RE-INITIALIZE YET
ADCREL:	PUSHJ P,ADCCLR
	MOVEI DDB,ADCDDB
HUNG:	MOVEI IOS,IOACT
	PSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	ANDCAB IOS,DEVIOS(DDB)
	XSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	TLNN IOS,IOW
	JRST HFTST
	MOVSI IOS,IOW
	PSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	ANDCAB IOS,DEVIOS(DDB)
	XSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	LDB J,PJOBN
	PUSHJ P,STTIOD		; BRING HIM OUT OF IO WAIT
HFTST:	SKIPE ADCNOH		; ARE WE IN NO-HANG (DEBUGGING) MODE?
	AOS (P)			; SKIP RETURN MEANS NO KILL
	POPJ P,

ADCCLR:	MOVEI TAC,KLCODE
	MOVEM TAC,ADCP2L	; TELL P2 TO CLEAR ADC
	JRST ADCJST
; ADCP2 - PDP-6'S CLK LEVEL ROUTINE FOR THE ADC

↑ADCP2:	SKIPN TAC,ADCP2L
	POPJ P,			; SOMEBODY SCREWED UP!
	SETZM ADCP2L
	JRST @P2LDSP-1(TAC)

P2LDSP:	ADCST		; STARTUP
	ADCKL		; KILL

ADCKL:	CONO ADC,0	; THIS IS EASY ENOUGH
ADCINI:	SETZM ADCZB
	MOVE TAC,[XWD ADCZB,ADCZB+1]
	BLT TAC,ADCZND-1
ADCJST:	MOVEI TAC,ADCIST
	HRRM TAC,ADCJMP
	POPJ P,

ADCST:	MOVEI DDB,ADCDDB
	CONO DCB,200000		; KILL OLD AD IF RUNNING
	CONO AD,4000		; OTHERWISE, WILL LOOP IN P2CH1
	MOVSI TAC,(<JFCL>)
	HLLM TAC,ADJMP		; KILL JUMP TO OLD AD ROUTINES
	MOVE TAC,[JSR ADCCHL]	; MAKE SURE CHAN LOC IS SET UP RIGHT
	MOVEM TAC,40+<ADCCHN*2>
	CONO PI,ADCON
	SKIPN TAC,ADCNBK
	JRST ADCKL
	LDB TAC1,PDVTIM		; SET TIME COUNT
	DPB TAC1,PDVCNT
	MOVEM TAC,ADCBKI
	SETZM ADCNBK
	MOVEI TAC1,ADCINT	; PRETEND IT IS A NORMAL INTERRUPT
	MOVE IOS,ADCIOS
	TRNE IOS,CYCLE
	TRNE IOS,CYCDON
	JRST ADCSCN
	MOVEI TAC1,ADCRCY	; SET TO RECYCLE
	MOVEM TAC,ADCRCB	; STORE IOWD HERE ALSO FOR RECYCLING
ADCSCN:	HRRM TAC1,ADCJMP	; SET JUMP LOCATION
; ADCP2 CONT - STARTUP CODE, SET 'RUN' FLAG, CHECK FOR IO SYNC

	MOVEI TAC,WKCODE	; WAKE UP JOB IF PENDING ALREADY
	MOVEM TAC,ADCP1L
	HRRZ TAC,ADCRUN		; MUST SET THIS IF TIME TO GO
	JUMPE TAC,ADCTSS
	LDB J,PJOBN
	SKIPN PROG,JBTADR(J)
	JRST ADCACK		; ADDRESS CHECK. GIVE ERROR.
	HLRZ AC1,PROG
	CAIG TAC,(AC1)
	CAIG TAC,JOBPFI
	JRST ADCACK
	SETOM @ADCRUN		; SET 'RUN' FLAG
ADCTSS:	TRNE IOS,IOSYNC		; ARE WE TRYING TO SYNCHRONIZE?
	SKIPE DACBKO		; YES, IS THE OTHER GUY RUNNING?
	JRST ADCTCN		; NOT SYNCHRO OR IS RUNNING
	TRNE IOS,IOAFT		; SYNC AFTER CYCLE?
	TRNN IOS,CYCLE		; YES, IS HE CYCLING?
	JRST ADCDCS
	TRNN IOS,CYCDON		; YES, IS CYCLING DONE?
	JRST ADCTCN		; NO, START US UP, BUT SAVE DAC FOR LATER
ADCDCS:	SKIPN DACNBK		; WELL, IS HE PENDING? (BETTER BE)
	PUSHJ P,DACST		; YES, START HIM UP
				; UNDEFINED STATE HERE OF NOT PENDING
				; PROBABLY SHOULD BE SOME KIND OF ERROR
ADCTCN:	CONO ADC,@ADCCNO	; START IT UP
	POPJ P,

ADCACK:	MOVEI TAC,ERCODE	; PROPAGATE ADDRESS CHECK BACK TO HIM
	MOVEM TAC,ADCP1L
	JRST ADCKL
; ADCP1 - PDP-10'S CLOCK ROUTINES FOR THE ADC

↑ADCP1:	SKIPN TAC,ADCP1L
	POPJ P,
	SETZM ADCP1L
	MOVEI DDB,ADCDDB
	JRST @ADCP1D-1(TAC)

ADCP1D:	WKM
	ADCERM

WKM:	MOVE IOS,DEVIOS(DDB)
	LDB J,PJOBN
	TLNN IOS,IOW		; IS HE WAITING?
	POPJ P,			; NO, FORGET IT
	MOVSI IOS,IOW
	PSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	ANDCAB IOS,DEVIOS(DDB)	; CLEAR WAIT BIT
	XSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	JRST STTIOD

ADCERM:	SETZM ADCBKI		; KILL ANY WAITING XFR
ERM:	LDB J,PJOBN
	MOVEI IOS,IOACT
	PSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	ANDCAB IOS,DEVIOS(DDB)
	XSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	PUSHJ P,TTYERP
	PUSHJ P,INLMES
	ASCIZ /
ILLEGAL ADDRESS FOR ADC-DAC
↑C
./
	PUSHJ P,TTYSTC
	JRST ESTOP		; STOP HIM PERMANANTLY
; ADC INTERRUPT ROUTINES, ADCIST FOR SPURIOUS, ADCINT FOR NORMAL

↑ADCIST:CONO ADC,0
	AOS ADCSTI		; COUNT NUMBER OF SPURIOUS INTERRUPTS
	JEN @ADCCHL		; DISMISS INTERRUPT

↑ADCINT:BLKI ADC,ADCBKI		; BRING IN NEXT WORD
	JRST ADCDON		; COUNT OVERFLOW
	JEN @ADCCHL		; GO BACK FOR MORE

ADCDON:	JSR ADCSAV		; GET US SOME ACS
ADCSTU:	MOVEI DDB,ADCDDB
	CONSO ADC,ADLOST	; DATA MISSED?
	JRST ADCNDM
	MOVEI IOS,LOST
	PSYNC ADCCSC		; YES, SET LOST BIT (NOT REALLY AN ERROR)
	ORB IOS,ADCIOS
	XSYNC ADCCSC
ADCNDM:	SKIPN TAC,ADCNBK	; IS THERE ANOTHER XFR WAITING?
	JRST ADCWK		; NO MORE, STOP ADC
	MOVEM TAC,ADCBKI
	PUSHJ P,ADCICH		; ANY WORDS?
	LDB TAC,PDVTIM		; PICK UP HUNG TIME
	DPB TAC,PDVCNT		; USE THIS AS HUNG COUNT
	SETZM ADCNBK
	SKIPN ADCBKI
	JRST ADCSTU		; ALL DONE (???) GO THROUGH AGAIN
	JRST ADCW		; WAKE HIM UP AND LEAVE

ADCICH:	CONSO ADC,DATARQ
	POPJ P,
	BLKI ADC,ADCBKI		; BRING IN NEXT WORD
	JRST [SETZM ADCBKI	; COUNT OVERFLOW
	      POPJ P,]
	JRST ADCICH		; OK, CHECK FOR ANOTHER ONE
; ADC INTERRUPT ROUTINES, ADCRCY FOR RECYCLING INPUT

↑ADCRCY:MOVEM TAC,ADCTAC
	BLKI ADC,ADCBKI		; GET NEXT WORD
	JRST ADCRDN		; COUNT OVERFLOW
	MOVE TAC,ADCBKI
	MOVM TAC,(TAC)		; PICK UP WORD WE JUST READ IN
	CAMLE TAC,ADCTHR	; IS IT GREATER THAN THRESHHOLD?
	JRST ADCSMD		; YES, SWITCH MODES INTO NORMAL
	MOVE TAC,ADCTAC
	JEN @ADCCHL		; NO, GO ON

ADCRDN:	SKIPN TAC,ADCRCB	; PICK UP IOWD
	JRST ADCILI		; NOTHING THERE, HELP!
	MOVEM TAC,ADCBKI
	LDB TAC,[POINT 6,ADCDDB+DEVCHR,17]	; PDVTIM
	DPB TAC,[POINT 6,ADCDDB+DEVCHR,11]	; PDVCNT
	MOVE TAC,ADCTAC
	JEN @ADCCHL
; ADC INTERRUPT ROUTINES - ADCSMD, SWITCH MODES FROM CYCLE TO NORMAL

ADCSMD:	MOVE TAC,ADCTAC
	JSR ADCSAV		; GET US SOME ACS
	MOVEI DDB,ADCDDB
	LDB J,PJOBN
	MOVE PROG,JBTADR(J)	; PICK UP HIS PROT-RELOC
	MOVEI TAC,ADCINT	; SET TO GO TO REGULAR PLACE ON INTERRUPT
	HRRM TAC,ADCJMP
	SKIPE ADCNBK		; IF THERE IS ANOTHER BLKI WD, THEN
	PUSHJ P,ADCCHK		; CHECK FOR NEXT WORD READY
	MOVEI IOS,CYCDON	; NOTE RECYCLING DONE
	CONSZ ADC,ADLOST	; DATA MISSED?
	ORI IOS,LOST		; YES, SET BIT
	PSYNC ADCCSC
	ORB IOS,ADCIOS
	XSYNC ADCCSC
	HRLZ AC1,PROG		; SET AC1 TO POINT TO END OF CORE IMAGE
	SKIPE ADCNBK		; IF THERE IS ANOTHER BLKI WD, THEN
	PUSHJ P,ADCCHK		; CHECK FOR NEXT WORD READY
	HRRZ TAC,ADCRCW		; IS THERE A PLACE TO PUT THE RECYCLE WD?
	JUMPE TAC,ADCISH	; NO, GO ON WITH REGULAR XFR
	CAIL TAC,JOBPFI
	CAILE TAC,(AC1)
	JRST ADCILA		; ADDRESS CHECK.
	MOVE TAC,ADCBKI
	SUBI TAC,(PROG)
	MOVEM TAC,@ADCRCW	; GIVE USER THE BLKI POINTER
	SKIPE ADCNBK		; IF THERE IS ANOTHER BLKO WD, THEN
	PUSHJ P,ADCCHK		; CHECK FOR NEXT WORD READY
ADCISH:	TRNE IOS,IOSYNC		; ARE WE SYNCHRONIZING IO?
	TRNN IOS,IOAFT		; IF SO, IS IT AFTER RECYCLE DONE?
	JRST ADCSTU		; NO, JUST GO ON WITHOUT COMMENT
	SKIPE DACNBK		; IS THERE A WAITING TRANSFER?
	SKIPE DACBKO		; AND NO CURRENT TRANSFER?
	JRST ADCSTU
	SKIPE ADCNBK		; CHECK FOR WORD READY
	PUSHJ P,ADCCHK		; READ IT IN IF READY
	PUSHJ P,DACST		; CALL DAC STARTUP CODE
	SKIPE ADCNBK		; CHECK FOR WORD READY
	PUSHJ P,ADCCHK		; READ IT IN IF READY
	JRST ADCSTU

ADCCHK:	CONSO ADC,DATARQ	; DOES IT HAVE A WORD FOR US?
	POPJ P,			; NO, FORGET IT
	BLKI ADC,ADCNBK		; YES, BRING IT IN VIA NEXT PTR
	JRST [SETZM ADCNBK	; NO MORE, NOTE EMPTY IOWD
	      POPJ P,]
	JRST ADCCHK		; GO BACK AND CHECK FOR MORE
; ADC INTERRUPT ROUTINES - ADCILA, ADCW, ADCWK, ADCILI, END OF XFR

ADCW:	MOVEI TAC,WKCODE	; DURING XFR TO JUST WAKE UP JOB
	JRST ADCSTC

ADCWK:	MOVEI TAC,WKCODE	; HERE AT END OF XFR TO KILL ADC AND WAKE JOB
	JRST ADCZ

ADCILI:	MOVE TAC,ADCTAC		; RESTORE SAVED AC
	JSR ADCSAV		; GET US SOME ACS
ADCILA:	MOVEI TAC,ERCODE
	PSYNC ADCCSC
	MOVEI IOS,IODERR	; MAKE SURE NO FURTHER TRANSFERS
	ORM IOS,ADCIOS
	XSYNC ADCCSC
ADCZ:	SETZM ADCBKI		; ABORT NEXT TRANSFERS
	SETZM ADCNBK
	CONO ADC,0
	MOVEI TAC1,ADCIST	; MAKE SURE STRAY INTERRUPTS GET TRAPPED
	HRRM TAC1,ADCJMP
	HRRZ TAC1,ADCRUN	; DOES HE WANT TO KNOW ABOUT THIS?
	JUMPE TAC1,ADCCIA	; NO, FORGET IT
	LDB J,PJOBN		; PICK UP JOB NUMBER
	SKIPN PROG,JBTADR(J)	; AND PROT-RELOC FOR JOB
	JRST ADCCHI		; NONE THERE. OOPS!
	HLRZ AC1,PROG
	CAIL TAC1,JOBPFI
	CAILE TAC1,(AC1)
	JRST ADCCHI
	SETZM @ADCRUN		; CLEAR HIS RUNNING FLAG
ADCCIA:	MOVEI IOS,IOACT		; UNLOCK HIM FROM CORE
	PSYNC ADCCSC		; DO THIS AFTER ADDRESS CHECK
	ANDCAB IOS,ADCIOS	; ON THE OFF CHANCE THAT HE MIGHT
	XSYNC ADCCSC		; HAVE DISSAPEARED IN THE INTERIM
ADCSTC:	MOVEM TAC,ADCP1L
	POPJ P,

ADCCHI:	MOVE IOS,ADCIOS
	SETZM ADCRUN		; MAKE SURE WE DON'T LOOP
	TLNE IOS,ERRMSK
	JRST ADCSTC		; JUST GET ON WITH IT
	JRST ADCILA		; NO ERRORS YET, GIVE HIM ADDRESS CHECKD
; UUO DISPATCH TABLE FOR DAC

	JRST DACINI	; SYSTEM STARTUP
	JRST DAHUNG	; HUNG TIME OUT
↑DACDSP:JRST DACREL	; RELEASE
	POPJ P,		; CLOSE OUTPUT
	JRST UUOERR	; BUFFERED OUTPUT
	JRST ILLINP	; BUFFERED INPUT
	JRST CPOPJ1	; ENTER
	JRST CPOPJ1	; LOOKUP
	JRST DACOUT	; DMP MODE OUTPUT
	JRST ILLINP	; DMP MODE INPUT
	POPJ P,		; USETO
	POPJ P,		; USETI
	POPJ P,		; UGETF
	JRST CPOPJ1	; RENAME
	POPJ P,		; CLOSE INPUT
	POPJ P,		; UTPCLR
	JRST DACMTP	; MTAPE
; DAC MTAPE UUO. SETS PARAMETERS.
; EFFECTIVE ADDRESS POINTS TO TWO WORD BLOCK
; FIRST WORD (RH SAME AS ADC)
;  	0,,SPEED*1000+PACK*100+NCHANS
;	SPEED = 0	6.4 KC		IS PER CHANNEL RATE
;		1	12.8 KC
;		2	25.6 KC
;		3	51.2 KC
;		4	102.4 KC
;		5	204.8 KC
; SECOND WORD (SAME AS ADC)
;	<ADDR FOR ERR CODES>,,<ADDR FOR 'RUN' FLAG>
;	<'RUN' FLAG IS 'SETOM'ED WHILE DAC IS RUNNING AND ZEROED WHEN
; 		DAC IS SHUT OFF

DACMTP:	TLZN IOS,IOBEG		; FIRST UUO?
	JRST DACNFS
	MOVEM IOS,DACIOS	; NOT BUSY BY DEFINITION (OR BUG!)
	PUSHJ P,DACINI		; CLEAR OUT IMPORTANT STUFF
DACNFS:	PUSHJ P,CHKUUO		; ADDRESS CHECK EFFECT. ADDR. OF UUO
	ADDI AC2,1		; CHECK END OF TABLE TOO
	CAILE AC2,(AC1)
	JRST ADRERR
	MOVE TAC,@UUO		; PICK UP 0,,PARAMS
	PUSHJ P,SETCNO		; SET UP CONO WORD IN TAC1
	MOVEM AC2,DACWPS	; SAVE # WORDS PER SECOND
	MOVEM TAC1,DACCNO	; STORE CONO WORD
	ADDI UUO,1		; BUMP TO ERR CODE WORD
	MOVE AC1,@UUO
	HLRZM AC1,DACERA	; SET ERROR CODE ADDRESS
	HRLI AC1,PROG		; SET PROG IN INDEX FIELD
	MOVEM AC1,DACRUN	; RUN FLAG ADDRESS
	HLLM AC1,DACERA
	POPJ P,			; ALL DONE
; DAC DUMP MODE OUTPUT ROUTINE

DACW:	TRNE IOS,ERRMSK
	POPJ P,			; LEAVE ON ERRORS
	PUSHJ P,WSYNC		; WAIT FOR NEXT XFR DONE
DACOUT:	TLZN IOS,IOBEG		; FIRST UUO?
	JRST DACNOF
	MOVEM IOS,DACIOS
	PUSHJ P,DACINI
DACNOF:	SKIPE DACNBK		; IS THERE ANOTHER BLOCK WAITING?
	JRST DACW		; YES, GO WAIT FOR IT
	PUSHJ P,CHKUUO		; ADDR CHECK
	SKIPE TAC,@UUO		; PICK UP IOWD
	TLNN TAC,777777		; ANYTHING THERE?
	JRST ADCXIT		; NO, EXIT NOW
	PUSHJ P,ADRCHK		; ADDRESS CHECK THE IOWD
	JRST ADRERR		; ILLEGAL. STOP JOB AND PRINT MESSAGE
	MOVE IOS,[IO,,IOACT]
	PSYNC DACCSC
	ORB IOS,DACIOS
	XSYNC DACCSC
	ADDI TAC,(PROG)
	MOVEM TAC,DACNBK
	HLRO AC1,TAC		; PICK UP -WC
	MOVN AC1,AC1		; MAKE IT POSITIVE
	IDIV AC1,DACWPS		; MAKE INTO # SECONDS
	ADDI AC1,5		; 5 MORE FOR GOOD MEASURE
	CAILE AC1,77		; SATURATE AT 6 BITS
	MOVEI AC1,77
	DPB AC1,PDVTIM		; AND THIS IS THE NEW HUNG TIME
	SKIPE DACBKO		; IS THERE AN XFR IN PROGRESS?
	JRST ADCXIT		; YES, WE CAN LEAVE NOW
	TRNE IOS,IOSYNC		; ARE WE SYNCHRONIZING?
	SKIPE ADCBKI		; YES, IS ADC ALREADY RUNNING?
	JRST DACSTR		; NOT SYNC OR XFR ALREADY RUNNING
	SKIPN ADCNBK		; NOT RUNNING, XFR QUEUED?
	JRST ADCSHT		; NOT QUEUED, WAIT FOR IT. SET HUNG TIME TO MAX.
DACSTR:	MOVEI TAC,STCODE	; START DAC AND LEAVE
	MOVEM TAC,DACP2L	; PLACE WHERE P2 WILL SEE IT
	JRST ADCXIT		; LEAVE, WAIT OR NO
; DAC HUNG ROUTINE, DAHUNG, DAC INITIALIZE ROUTINE, DACINI, RELEASE, DACREL

DAHUNG:	SKIPN ADCNOH		; IF DEBUGGING, DON'T CLEAR OUT DAC YET
DACREL:	PUSHJ P,DACCLR
	MOVEI DDB,DACDDB
	JRST HUNG		; COMMON ROUTINE FOR ADC-DAC

DACCLR:	MOVEI TAC,KLCODE
	MOVEM TAC,DACP2L	; TELL P2 TO CLEAR DAC
	JRST DACJST
; DACP2 - PDP-6'S CLK LEVEL ROUTINE FOR THE DAC

↑DACP2:	SKIPN TAC,DACP2L
	POPJ P,
	SETZM DACP2L
	JRST @P2DDSP-1(TAC)

P2DDSP:	DACST		; STARTUP
	DACKL		; KILL

DACKL:	CONO DAC,0
DACINI:	SETZM DACZB
	MOVE TAC,[XWD DACZB,DACZB+1]
	BLT TAC,DACZND-1
DACJST:	MOVEI TAC,DACIST
	HRRM TAC,DACJMP
	POPJ P,

DACST:	MOVEI DDB,DACDDB
	CONO DCB,200000		; KILL OLD AD IF RUNNING
	CONO AD,4000		; OTHERWISE, WILL LOOP IN P2CH1
	MOVSI TAC,(<JFCL>)
	HLLM TAC,ADJMP		; KILL JUMP TO OLD AD ROUTINES
	MOVE TAC,[JSR DACCHL]	; MAKE SURE CHAN LOC IS SET UP RIGHT
	MOVEM TAC,40+<DACCHN*2>
	CONO PI,DACON		; MAKE SURE SOMEBODY'S LISTNING
	SKIPN TAC,DACNBK
	JRST DACKL
	LDB TAC1,PDVTIM		; START COUNTING NOW
	DPB TAC1,PDVCNT
	MOVEM TAC,DACBKO	; THIS SET PREVENTS LOOPING THROUGH ADCST
	SETZM DACNBK
	MOVEI TAC,DACINT	; IT IS A NORMAL INTERRUPT
	MOVE IOS,DACIOS
	HRRM TAC,DACJMP		; SET JUMP LOCATION
	MOVEI TAC,WKCODE	; WAKE UP JOB IF PENDING ALREADY
	MOVEM TAC,DACP1L
	HRRZ TAC,DACRUN		; SEE IF HE WANTS US TO FLAG HIM
	JUMPE TAC,DACTSS	; NO, PROCEED
	LDB J,PJOBN
	SKIPN PROG,JBTADR(J)
	JRST DACACK		; ADDRESS CHECK. GIVE ERROR.
	HLRZ AC1,PROG
	CAIG TAC,(AC1)
	CAIG TAC,JOBPFI
	JRST DACACK
	SETOM @DACRUN		; SET 'RUN' FLAG
DACTSS:	TRNE IOS,IOSYNC		; ARE WE TRYING TO SYNCHRONIZE?
	SKIPE ADCBKI		; YES, IS THE OTHER GUY RUNNING?
	JRST DACTCN		; NOT SYNCHRO OR IS RUNNING
	SKIPN ADCNBK		; WELL, IS HE PENDING? (BETTER BE)
	PUSHJ P,ADCST		; YES, START HIM UP
				; UNDEFINED STATE HERE OF NOT PENDING
				; PROBABLY SHOULD BE SOME KIND OF ERROR
DACTCN:	CONO DAC,@DACCNO	; START IT UP
	POPJ P,

DACACK:	MOVEI TAC,ERCODE	; SEND HIM BACK AN ADDRESS CHECK
	MOVEM TAC,DACP1L
	JRST DACKL
; DACP1 - PDP-10'S CLOCK ROUTINES FOR THE DAC

↑DACP1:	SKIPN TAC,DACP1L
	POPJ P,			; SHOULDN'T HAPPEN
	SETZM DACP1L
	MOVEI DDB,DACDDB
	JRST @DACP1D-1(TAC)

DACP1D:	WKM
	DACERM

DACERM:	SETZM DACBKO		; KILL WAITING XFR
	JRST ERM
; DAC INTERRUPT ROUTINES, DACIST FOR SPURIOUS, DACINT FOR NORMAL

↑DACIST:CONO DAC,0
	AOS DACSTI		; COUNT NUMBER OF SPURIOUS INTERRUPTS
	JEN @DACCHL

DACINT:	BLKO DAC,DACBKO		; SEND OUT NEXT WORD
	JRST DACDON		; COUNT OVERFLOW
	JEN @DACCHL		; GO BACK FOR MORE

DACDON:	JSR DACSAV
	MOVEI DDB,DACDDB
	CONSO DAC,DALOST	; DATA MISSED?
	JRST DACNDM
	MOVEI IOS,LOST
	PSYNC DACCSC
	ORB IOS,DACIOS
	XSYNC DACCSC
DACNDM:	SKIPN TAC,DACNBK	; ANOTHER ONE WAITING?
	JRST DACWK		; NO MORE. WAKE UP USER AND LEAVE.
	MOVEM TAC,DACBKO
	PUSHJ P,DACCHK
	LDB TAC,PDVTIM
	DPB TAC,PDVCNT		; RESET HUNG TIME
	SETZM DACNBK
	SKIPN DACBKO
	JRST DACWK		; IF OVERFLOWED IN MEANTIME, FLUSH XFR NOW
	MOVEI TAC,WKCODE	; SET TO WAKE HIM UP (CHECKS IOW IN P1)
	JRST DACSTC

DACCHK:	CONSO DAC,INTRQ		; REQUESTING INTERRUPT?
	POPJ P,			; NO, FORGET IT
	BLKO DAC,DACBKO		; YES, SEND OUT NEXT WORD
	JRST [SETZM DACBKO	; FLAG OVERFLOW
	      POPJ P,]
	JRST DACCHK		; SUCCESS, LOOP BACK FOR NEXT WORD
; DAC INTERRUPT ROUTINES - WAKEUP AND 'RUN' FLAG BUSINESS

DACWK:	MOVEI TAC,WKCODE
DACZ:	SETZM DACBKO
	SETZM DACNBK
	CONO DAC,0
	MOVEI TAC1,DACIST
	HRRM TAC1,DACJMP
	HRRZ TAC1,DACRUN
	JUMPE TAC1,DACCIA
	LDB J,PJOBN		; PICK UP JOB NUMBER
	SKIPN PROG,JBTADR(J)	; AND PROT-RELOC OF JOB
	JRST DACCIA		; NONE THERE!! OOPS!
	HLRZ AC1,PROG
	CAIL TAC1,JOBPFI
	CAILE TAC1,(AC1)
	JRST DACCHI
	SETZM @DACRUN
DACCIA:	MOVEI IOS,IOACT		; UNLOCK JOB
	PSYNC DACCSC
	ANDCAB IOS,DACIOS
	XSYNC DACCSC
DACSTC:	MOVEM TAC,DACP1L
	POPJ P,

DACCHI:	MOVE IOS,DACIOS
	SETZM DACRUN
	TLNE IOS,ERRMSK
	JRST DACSTC
	MOVEI TAC,ERCODE
	PSYNC DACCSC
	MOVEI IOS,IODERR
	ORM IOS,DACIOS
	XSYNC DACCSC
	JRST DACZ
; ROUTINE MAKES UP A CONO WORD FROM MTAPE SPECS
; SPECS ARE IN RH TAC
; RETURNS CONO WORD IN TAC1
; USES AC1, AC3 AS TEMP
; RETURNS WORDS PER SECOND IN AC2
; = SPEED*1000+PACK*100+NCHANS
; NCHANS = 1 FOR MONO	(2-BIT NUMBER)
;	 = 2 FOR STEREO
;	 = 0,3 FOR QUAD
; PACK = 0,3 FOR 12 BIT  (2-BIT NUMBER)
;      = 1 FOR 16 BIT (HALFWORD MODE)
;      = 2 FOR FLOATING PT. INCREMENTAL
; SPEED = 0 FOR 6.4 KC	(3-BIT NUMBER)
;       = 1 FOR 12.8 KC
;       = 2 FOR 25.6 KC
;       = 3 FOR 51.2 KC
;       = 4 FOR 102.4 KC
;       = 5 FOR 204.8 KC

SETCNO:	MOVEI TAC1,QUAD!RUNB!ADCCHN	; ADC AND DAC RUN ON SAME CHANNEL
	LDB AC1,[POINT 2,TAC,35]
	CAIN AC1,1
	XORI TAC1,MONO!QUAD
	CAIN AC1,2
	XORI TAC1,STEREO!QUAD
	LDB AC1,[POINT 2,TAC,29]
	MOVE AC3,SAMPW(AC1)	; PICK UP # SAMPS PER WD
	ORI TAC1,.12BIT
	CAIN AC1,1
	XORI TAC1,.12BIT!.16BIT
	CAIN AC1,2
	XORI TAC1,.12BIT!FLOAT
	LDB AC1,[POINT 3,TAC,26]
	CAIN AC1,1
	ORI TAC1,1*FILT
	CAIN AC1,2
	ORI TAC1,2*FILT
	CAIL AC1,3
	ORI TAC1,3*FILT
	TRNE TAC1,STEREO
	ADDI AC1,1
	TRNE TAC1,QUAD
	ADDI AC1,2
	CAILE AC1,5
	JRST ILLSPD
	MOVE AC2,SPTAB(AC1)	; PICK UP SPEED IN SAMPLES/SEC
	IDIVI AC2,(AC3)		; GET WDS/SEC IN AC2
	DPB AC1,[POINT 3,TAC1,29]
	POPJ P,

ILLSPD:	JSP TAC,UUOMES
	ASCIZ /
ILLEGAL SPEED PARAMETER FOR AD-DA
UUO/

SAMPW:	3 ↔ 2 ↔ 4 ↔ 3
SPTAB:	=6400 ↔ =12800 ↔ =25600 ↔ =51200 ↔ =102400 ↔ =204800
; ADRCHK - ROUTINE TO ADDRESS CHECK AN IOWD, CHKUUO - CHECKS UUO ADDR
; CALL WITH IOWD IN TAC
; SKIPS IF OK
; PROG MUST BE SET UP
; USES TAC1 AND AC1

ADRCHK:	MOVEI TAC1,(TAC)
	HLRZ AC1,PROG
	CAIL TAC1,JOBPFI	; MUST BE ABOVE PROTECTED AREA
	CAILE TAC1,(AC1)
	POPJ P,			; OUT OF BOUNDS, GIVE ERROR RETURN
	HLRO TAC1,TAC
	MOVNS TAC1		; MAKE IT POSITIVE
	ADDI TAC1,(TAC)
	CAIL TAC1,JOBPFI
	CAILE TAC1,(AC1)
	POPJ P,
	JRST CPOPJ1

; CHKUUO
; DOESN'T RETURN IF BAD
; PROG MUST BE SET UP
; PUTS RH OF UUO IN AC2
; PUTS LAST WD IN CORE IMAGE ADDRESS IN AC1

CHKUUO:	HLRZ AC1,PROG
	MOVEI AC2,(UUO)
	CAIG AC2,(AC1)
	CAIG AC2,JOBPFI
	JRST ADRERR
	POPJ P,
; END OF IT ALL

BEND ADCSER
