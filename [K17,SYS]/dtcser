COMMENT ⊗   VALID 00029 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	BEGIN DTCSER - DECTAPE SERVICE ROUTINE
C00006 00003	DECTAPE DISPATCH TABLE
C00008 00004	RENAME UUO ROUTINE
C00013 00005	ROUTINE TO MOVE 4 WORD DIRECTORY ENTRY FROM USER
C00014 00006	ROUTINE TO SEARCH DIRECTORY FOR ENTER AND LOOKUP
C00016 00007	DUMP OUTPUT UUO ROUTINE
C00017 00008	DUMP INPUT UUO ROUTINE
C00020 00009	OUTPUT UUO ROUTINE -BUFFERED
C00023 00010	WRITE BLOCK 1 - COPY USER BUFFER INTO EXEC DIRECTORY CORE BUFFER
C00024 00011	INPUT UUO ROUTINE - RING BUFFERED
C00027 00012	ILLEGAL BLOCK NO.
C00029 00013	COMMON ROUTINE TO CHECK INTERLOCK, INITIALIZE
C00031 00014	ROUTINE TO CHECK IF DIRECTORY IN CORE
C00033 00015	CLOSE UUO
C00034 00016	UTPCLR UUO - CLEAR DECTAPE DIRECTORY
C00037 00017	USETI UUO - SET NEXT INPUT BLOCK NO TO READ
C00039 00018	UGETF UUO - GET NEXT FREE BLOCK NO.
C00040 00019	READ BLOCK NOS.
C00043 00020	HERE WHEN BLOCK NO.FOUND FOR DUMP OUTPUT
C00045 00021	HERE WHEN BLOCK NUMBER FOUND FOR BUFFERED WRITING
C00046 00022	HERE WHEN BLOCK NUMBER FOUND FOR BUFFERED INPUT
C00048 00023	WRITE 1 BLOCK IN REVERSE DIRECTION
C00049 00024	↑ENPT0:	JSR ENPT1
C00051 00025	HERE ON INTERRUPTS ON DECTAPE CONTROL AFTER DATA TRANSMITTED
C00055 00026	STOP TAPE AND DESELECT THIS UNIT BEFORE GOING TO ANOTHER UNIT
C00058 00027	INTERRUPT ON DT CHANNEL WHILE READING BLOCK NOS. ON DC CHANNEL
C00060 00028	HERE ON EACH OF 5 TYPES OF HARDWARE DETECTED ERRORS
C00062 00029	DTREDO:	SKIPE TAC,ERRFLG	CLEAR ERROR COUNT,DID DC MISS DATA?
C00065 ENDMK
C⊗;
BEGIN DTCSER - DECTAPE SERVICE ROUTINE
SUBTTL DTCSER	8 SEPT 67

;SPECIAL I/O STATUS BITS

RBNTRY←←20	;NUMBER OF TIMES HE CAN

UDIREN←←200	;DIRECTORY HAS BEEN ENTERED INTO BY ENTER UUO
UNWFRE←←400	;FREE BLOCK POINTER HAS BEEN CHANGED IN CORE
ULINKF←←1000	;LAST OUTPUT BLOCK LINKED TO FREE STORAGE
UDMPO←←2000	;DUMP OUTPUT AS OPPOSED TO BUFFERED OUTPUT
UDMPI←←4000	;DUMP INPUT AS OPPOSED TO BUFFERED INPUT
UREV←←10000	;UNIT LAST WENT IN REVERSE DIRECTION
URDIR←←20000	;READING DIRECTORY(BLOCK 1)
UDSD←←100	;SUPPRESS DIRECTORY HANDLING (RH IOS). SET BY
		;INIT OR SETSTS. CLEARED BY SETSTS OR RELEASE.

;CONO BITS FOR UTC

SL←←220000	;TURN ON, SELECT UNIT
DTR←←3000	;START/STOP DELAY (300 MS)
DT←←2000	;TURN AROUND DELAY (160 MS)
RDS←←1000	;RESELECT DELAY (20 MS)
RD←←300		;READ DATA
WD←←700		;WRITE DATA
RB←←200		;READ BLOCK NOS.
GR←←10000	;GO IN REVERSE DIRECTION(BACKWARDS)
JDE←←40000	;JOB DONE ENABLE
EE←←100000	;ENABLE END FLAG
TFE←←4000	;TIME FLAG ENABLE

DCIN←←4010+DCTCHN
DCOUT←←3410+DCTCHN
;DECTAPE DISPATCH TABLE



	JRST DTCINI	;INITILIZE
	JRST DTC1	;DEVICE HUNG TIME OUT, STOP TAPE, AND JOB
↑DTCDSP:
	JRST UTPREL	;RELEASE
	JRST UTPCLS	;CLOSE
	JRST UOUT	;OUTPUT - BUFFERED
	JRST UIN	;INPUT - BUFFERED
	JRST UENTER	;ENTER FILE NAME IN DIRECTORY
	JRST ULOOK	;LOOKUP FILE NAME IN DIRECTORY
	JRST UOUTD	;OUTPUT - DUMP MODE
	JRST UIND	;INPUT - DUMP MODE
	JRST SETO	;USETO - SET NEXT OUTPUT BLOCK NO.
	JRST SETI	;USETI - SET NEXT INPUT BLOCK NO.
	JRST GETF	;UGETF - GET NEXT FREE BLOCK NO.
	JRST DTCREN	;RENAME - CALL NEW ROUTINE - RPH
	POPJ PDP,	;CLOSE - INPUT
	JRST UTPCLR	;UTPCLR - CLEAR DIRECTORY (CALL [SIXBIT /UTPCLR/]
	POPJ PDP,	;MTAPE - IGNORE ON DECTAPE

;INITIALIZE DECTAPE


DTCINI:	CONO DTC,0	;CLEAR CONTROL
	HLLZS DTCCON	;CLEAR CONSO FLAGS
	CONO DC,0	;CLEAR DATA CONTROL
IFE MTCNUM,<		; IF MAG TAPES IN SYSTEM, THEY
			; WILL SET UP DCLOC AND DCLOC1
	MOVEI TAC,40+DCTCHN*2
	CONSZ APR,MAOFF
	ADDI TAC,100
	MOVEM TAC,DCLOC
	ADDI TAC,1
	MOVEM TAC,DCLOC1
>
	POPJ PDP,
;RENAME UUO ROUTINE

DTCREN:	TRNE IOS,UDSD		;SUPPRESSING DIRECTORY?
	JRST CPOPJ1		;YES, GIVE SUCCESS RETURN
	SKIPE TAC,CURENT(DDB)	;PICK UP CURRENT ENTRY POINTER AND CHECK
	SKIPN (TAC)		;AND MAKE SURE ITS THERE
	POPJ P,			;ERROR RETURN
	MOVSI IOS,UDIREN	;MAKE SURE DIRECTORY GETS OUT
	IORB IOS,DEVIOS(DDB)
	XCTR	XR,[SKIPN (UUO)]	;DELETING?
	JRST	DTCDEL			;YES
	XCTR	XR,[MOVE TAC1,(UUO)]
	MOVEM	TAC1,(TAC)
	XCTR	XR,[MOVE TAC1,1(UUO)]
	HLLM	TAC1,1(TAC)
	XCTR	XR,[MOVE TAC1,2(UUO)]
	MOVEM	TAC1,2(TAC)
	XCTR	XR,[MOVE TAC1,3(UUO)]
	MOVEM	TAC1,3(TAC)
	JRST	CPOPJ1

DTCDEL:	SETZM CURENT(DDB)		;CLEAR CURRENT ENTRY POINTER SINCE WE ARE DELETING IT
	HRLI TAC,4(TAC)		;PREPARE TO BLT DOWN OVER THIS ENTRY
	HRRZ TAC1,UDIR(DDB)	;ADDR OF DIRECTORY
	BLT TAC,177(TAC1)	;BLT DIR DOWN
	SETZM 177(TAC1)		;CLEAR END IN CASE WASN'T 0
	SETZM 176(TAC1)
	SETZM 175(TAC1)
	SETZM 174(TAC1)
	JRST CPOPJ1

;LOOKUP UUO ROUTINE

;CALL:	LOOKUP D,E
;	NOT FOUND IN DIRECTORY RETURN
;	FOUND

;C(E)=LEFT JUSTIFIED SIXBIT FILE NAME
;C(E+1)=LH=LEFT JUSTIFIED 3 CHAR. SIXBIT FILE NAME EXTENSION
;  RH=FIRST BLOCK NO. IN FILE
;C(E+2)=RIGHT 12 BITS=DATE FILE WAS CREATED
;C(E+3)=BLKI POINTER FOR DUMPE SAVE-GET FILES



ULOOK:	TRNE IOS,UDSD		;SUPPRESSING DIRECTORY?
	JRST CPOPJ1		;YES.
	SETZM CURENT(DDB)		;CLEAR CURRENT ENTRY POINTER
	PUSHJ PDP,UDIRSH	;NO. SEARCH DIRECTORY
	POPJ PDP,		;NOT FOUND ERROR RETURN
	HRR DAT,1(TAC)		;FIRST BLOCK OF FILE
	HRRZM TAC,CURENT(DDB)	;SAVE REL ADDR OF CURRENT ENTRY
	HRRM DAT,DTNEXT(DEVDAT)	;SET NEXT INPUT BLOCK NO.
	TLZ TAC,-1		;CLEAR INDEX FIELD, DIRECTORY IS ABSOLUTE
	MOVE DAT,UUO		;SETUP DESTINATION POINTER
	JRST BLTENT		;BLOCK TRANSFER 4 WORD ENTRY


;ENTER UUO ROUTINE

UENTER:	TRNE IOS,UDSD		;SUPPRESSING DIRECTORY?
	JRST CPOPJ1		;YES. GIVE SUCCESSFUL RETURN
	SETZM CURENT(DDB)		;CLEAR CURRENT ENTRY POINTER
	SKIPN @UUO		;NO. NULL NAME?
	POPJ PDP,		;YES. ERROR
	PUSHJ PDP,UDIRSH	;NO. SEARCH DIRECTORY.
	JRST UENTE1		;NOT IN DIRECTORY.
	SKIPL 3(TAC)		;IN DIRECTORY. IS IT A DUMP FILE?
	JRST UENTE1		;NO
	ADDI UUO,3		;YES, GET NEW BLKO POINTER
	MOVE TAC1,@UUO
	SUBI UUO,3
	JUMPGE TAC1,UENTE1	;IS THIS A LEGITIMATE BLKO POINTER?
	CAMGE TAC1,3(TAC)	;YES. IS NEW FILE SHORTER THAN OLD.
	JRST UENTE1		;NO.IT'S LONGER. PUT IT AT END OF TAPE
	HRRZ DAT,1(TAC)		;YES. RE-SAVE AT SAME SPOT ON TAPE
	CAME TAC1,3(TAC)	;SAME SIZE BLOCK?
	TLO IOS,UDIREN		;NO. SET UDIREN SO DIRECTORY WILL BE
				;WRITTEN ON RELEASE.
	JRST UENTE2
UENTE1:	TLO IOS,UNWFRE+ULINKF+UDIREN	;FILE GOES AT END OF TAPE
	AOS DAT,UFREE(DEVDAT)	;GET FIRST FREE BLOCK
UENTE2:	AOS UUO			;POINT TO SECOND DIRECTORY WORD IN USER AREA
	HRRZM TAC,CURENT(DDB)	;SAVE CURRENT ENTRY POINTER
	HRRM DAT,@UUO		;STORE FIRST BLOCK NO. OF FILE
	HRLM DAT,DTNEXT(DEVDAT)	;STORE NEXT BLOCK TO WRITE
	HRRZ DAT,TAC		;SET DESTINATION IN CORE DIRECTORY AREA
	SOS TAC,UUO		;SET SOURCE TO USER AREA
	MOVEM IOS,DEVIOS(DEVDAT)

;ROUTINE TO MOVE 4 WORD DIRECTORY ENTRY FROM USER
;AREA TO MONITOR OR VICE VERSA
;SOURCE IN AC TAC, DESTINATION IN AC DAT

BLTENT:	NOSHUFFLE		;PREVENT CORE SHUFFLING DURING BLT
	MOVSI TAC1,@TAC		;SETUP ABS. SOURCE POINTER
	HRRI TAC1,@DAT		;SETUP ABS. DESTINATION POINTER
	MOVEI DAT,@DAT	;ABS. STOP ADDRESS
	BLT TAC1,3(DAT)
	MOVEI TAC,@TAC		;ABS. SOURCE ADDR.
	LDB TAC1,[POINT 12,2(TAC),35]	;GET SOURCE DATE
	JUMPN TAC1,BLTEN1	;IS IT ALREADY SET?
	MOVE TAC1,THSDAT	;NO, USE TODAYS DATE
	DPB TAC1,[POINT 12,2(DAT),35]	;AND SET DESTINATION DATE
BLTEN1:	SHUFFLE		;ALLOW SHUFFLING AGAIN
	JRST CPOPJ1		;SKIP RETURN TO USER
;ROUTINE TO SEARCH DIRECTORY FOR ENTER AND LOOKUP
;CALL:	PUSHJ PDP,UDIRSH
;	NOT IN DIRECTORY RETURN
;	NORMAL RETURN WHEN ENTRY IS FOUND
;	NEVER RETURNS IF DIRECTORY FULL



UDIRSH:	MOVEI AC1,3(UUO)	;IS LAST WORD IF ENTRY IN BOUNDS?
	PUSHJ PDP,UADCK1	;NEVER RETURN IF OUT OF BOUNDS
	PUSHJ PDP,DIRCHK	;CHECK IF DIRECTORY IN CORE
	HRRZ TAC,UDIR(DEVDAT)	;LOC. OF DIRECTORY
	HRRZ TAC1,(TAC)		;REL. ADR. OF 1ST ENTRY
	HRLI TAC,-=129+4(TAC1)	;ENTRY COUNTER
	ADDM TAC1,TAC		;START OF FIRST ENTRY
UDIR2:	SKIPN TAC1,(TAC)	;FIRST WORD OF NEXT ENTRY
	POPJ PDP,		;FILE NOT IN DIRECTORY RETURN
	CAMN TAC1,@UUO		;CHECK IF EQUAL TO USER AREA
	AOJA UUO,UDIR4		;IS IS CHECK FILE EXTENSION
UDIR3:	ADD TAC,[XWD 4,4]
	JUMPL TAC,UDIR2		;FINISHED YET?
	JRST TPOPJ		;YES ERROR RETURN TO USER(POP,POPJ)

UDIR4:	HLRZ TAC1,@UUO
	SOS UUO
;	JUMPE TAC1,CPOPJ1	;MATCH IF USER EXT. IS ZERO
	HLRZ DAT,1(TAC)		;EXTENSION IN DIRECTORY
	CAIE DAT,(TAC1)		;EXTENSION MATCH?
	JRST UDIR3		;NO, KEEP LOOKING
	JRST CPOPJ1		;YES, SETUP RETURN
;DUMP OUTPUT UUO ROUTINE
;CALL:	OUTPUT D,ADR
;WHERE ADR IS START OF A COMMAND LIST OF FOLLOWING FORM:
;	IOWD N,LOC	;ARBITRARY NO OF THESE
;	XWD 0,LOC1	;ARBITRARYNO OF THESE
;	0



UOUTD:	TLO IOS,IO+UDMPO	;FLAG OUTPUT AND DUMP-OUTPUT
	MOVEI TAC,DWRITE	;DISPATCH ADR. WHEN BLOCK NO. FOUND
	PUSHJ PDP,UINTER	;CHECK INTERLOCK AND INITIALIZE
	HLRZ TAC,DTNEXT(DEVDAT)	;NEXT OUTPUT BLOCK NO.
	TRNN IOS,UDSD		;SUPPRESSING DIRECTORY?
	CAILE TAC,1		;TRYING TO WRITE BLOCK 0 OR BLOCK 1
	JRST DFILL		;NO.
	JRST UTBERR		;YES, STOP TAPE AND PRINT ERROR MESSAGE
;DUMP INPUT UUO ROUTINE
;CALL:	INPUT D,ADR

UIND:	TLZ IOS,IO		;FLAG INPUT IN PROGRESS
	TLO IOS,UDMPI		;AND INPUT DUMP
	MOVEI TAC,DREAD		;DISPATCH ADR. WHEN BLOCK NO. FOUND
	PUSHJ PDP,UINTER	;CHECK INTERLOCK
	HRRZ TAC,DTNEXT(DEVDAT)	;BLOCK NO. TO BE READ

DFILL:	HRRM TAC,UBKN		;STORE FIRST BLOCK NO(LAST WILL BE CHECKED)
	MOVE TAC1,[JSR DMPADV]
	MOVEM TAC1,@DCLOC1	;WHERE TO GO WHEN BLKO/BLKI FINISHED
	MOVEI TAC1,16		;SET ERROR FLAGS(ALL EXCEPT INCOMPLETE BLOCK)
	HRRM TAC1,CONSZ1
	HRRZM PROG,UDPROG	;STORE JUST USER RELOCATION(FOR DMPADV)
	PUSHJ PDP,COMCHK	;CHECK ENTIRE DUMP COMMAND LIST
	JRST ADRER		;ADDRESS CHECK
	SKIPN @UUO		;IS COMMAND LIST EMPTY?
	JRST DTC1		;YES, STOP TAPE AND RETURN
	SOS DAT
	ASH DAT,-7		;CONVERT TO BLOCK COUNT-1
	ADDI DAT,@UBKN		;ADD FIRST BLOCKNO.
	TRNE IOS,UDSD		;NON-STANDARD TAPE?
	JRST .+3		;YES, DON'T CHECK BLOCK NO.
	CAILE DAT,1101		;LAST BLOCK TOO HIGH?
	JRST UTBERR		;YES
	TLNN IOS,IO		;OUTPUT?
	AOJA DAT,UMPIN		;NO, SET DAT TO NEXT BLOCK AFTER FILE
	HRRZ TAC,UFREE(DEVDAT)
	CAMGE DAT,TAC		;YES, GREATER THAN CURRENT FREE BLOCK?
	JRST IMPOT		;NO
	HRRM DAT,UFREE(DEVDAT)	;YES, SET LAST BLOCK USED
	AOS DAT			;SET DAT TO BLOCK NO. AFTER FILE
	HRLM DAT,DTNEXT(DEVDAT)	;SET NEXT BLOCK TO WRITE(AFTER THIS)
	TLOA IOS,UNWFRE		;FLAG AS MODIFIED
UMPIN:	HRRM DAT,DTNEXT(DEVDAT)	;SET NEXT BLOCK TO READ
IMPOT:	MOVEM IOS,DEVIOS(DEVDAT)
	MOVEI TAC,@UUO		;ABS. ADR. OF FIRST COMMAND
	MOVEM TAC,DMPLST	;STORE
	MOVE TAC,@DMPLST	;GET FIRST BLK POINTER
	ADDI TAC,(PROG)		;RELOCATE IOWD ADDRESS
	MOVEM TAC,DMPPTR	;SET DUMP BLKI/BLKO POINTER
	JRST FILL1		;GO START TAPE(FIRST BLOCK NO ALREADY STORED)

ADRER:	PUSHJ PDP,DTC1		;GO RELEASE TAPE
	JRST ADRERR		;STOP JOB AND PRINT ADDRESS CHECK MESSAGE
;OUTPUT UUO ROUTINE -BUFFERED


UOUT:	NOSHUFFLE
	MOVEI TAC,@DEVOAD(DEVDAT)
	SKIPN 1(TAC)		;WORD COUNT ZERO?
	JRST DTNOPO		;YES.
	SHUFFLE
	TLZ IOS,UDMPO+ULINKF	;CLEAR OUTPUT DUMP BIT
				;AND LINKED TO FREE STORAGE
	TLO IOS,IO		;FLAG THAT OUTPUT IS BEING DONE
	HLRZ TAC1,DTNEXT(DEVDAT)	;OUTPUT BLOCK NO. TO WIRTE
	TRNE IOS,UDSD		;SUPPRESSING DIRECTORY?
	JRST UOUT2		;YES
	CAIN TAC1,1		;TRYING TO WRITE BLOCK 1?
	JRST UOUT4		;YES, COPY INTO MONITOR DIR. AREA
UOUT2:	MOVEI TAC,WRITE		;SETUP DISPATCH WHEN CURRENT BLOCK NO. FOUND
	PUSHJ PDP,UINTER	;CHECK INTERLOCK

;HERE AT INTERRUPT LEVEL IF NEXT BUFFER READY WITH DATA TO GO OUT

UOUTGO:	MOVEI TAC,@DEVOAD(DEVDAT)	;ABS. ADR. OF USER OUTPUT BUFFER
	MOVEM TAC,UBUF
	TLZ IOS,ULINKF		;FLAG THIS BLOCK NOT LINKED TO FREE STORAGE
	HLRZ TAC1,1(TAC)	;BLOCK TIE FROM BUFFER(NEXT BLOCK)
	JUMPN TAC1,UOUT1	;USE BLOCK NO.INDICATED IF NON ZERO
	TLO IOS,UNWFRE+ULINKF	;FLAG LINKED TO FREE STORAGE
	AOS TAC1,UFREE(DEVDAT)	;NEXT FREE BLOCK
UOUT1:	MOVEM IOS,DEVIOS(DEVDAT)
				;STORE WHETHER THIS BLOCK
				;LINKED TO FREE STORAGE
				;AND FREE BLOCK POINTER
				;MODIFIED.
	TLZ TAC1,-1		;GET UFREE ALONE
	CAIN TAC1,1		;IF 1, THIS IS LAST BLOCK(SET BY CLOSE)
	MOVEI TAC1,0		;SET BLOCK TIE TO 0
	HRLM TAC1,1(TAC)	;IN USER BUFFER
	HLRZ TAC,DTNEXT(DEVDAT)	;BLOCK TO WRITE NOW
	HRLM TAC1,DTNEXT(DEVDAT)	;STORE BLOCK TO WRITE NEXT
	JRST FILL		;GO START TAPE

DTNOPO:	SHUFFLE
	PUSHJ PDP,ADVBFE	;WORD COUNT WAS ZERO. IGNORE BUFFER
	JFCL
	POPJ PDP,		;RETURN TO UUOCON
;WRITE BLOCK 1 - COPY USER BUFFER INTO EXEC DIRECTORY CORE BUFFER



UOUT4:	NOSHUFFLE		;NO SHUFFLING DURING BLT
	MOVEI TAC1,@DEVOAD(DEVDAT)	;ABS. ADR. OF USER BUFFER
	MOVSI TAC1,1(TAC1)	;SOURCE IS THIRD WORD OF USER BUFFER
	HRR TAC1,UDIR(DEVDAT)	;ADR. OF DIRECTORY BUFFER IN EXEC
	MOVE TAC,TAC1
	BLT TAC1,177(TAC)	;MOVE 200 WORDS FROM USER TO EXEC
	SETZM CURENT(DDB)	;THIS MAY NOT BE TRUE NOW!
	TLO IOS,UDIREN		;FLAG. DIR. ENTERED INTO
	MOVEM IOS,DEVIOS(DEVDAT)
	PUSHJ PDP,ADVBFE
	JFCL
	SHUFFLE		;ALLOW CORE SHUFFLING AGAIN
	JRST DIRCH1		;SET DVDIREN AND UFREE
;INPUT UUO ROUTINE - RING BUFFERED



UIN:	TLZ IOS,UDMPI+IO	;CLEAR INPUT DUMP BIT AND FLAG AS INPUT
	HRRZ TAC,DTNEXT(DEVDAT)	;NEXT BLOCK TO READ
	TRNE IOS,UDSD		;SUPPRESSING DIRECTORY?
	JRST UIN3		;YES
	CAIN TAC,1		;TRYING TO READ DIRECTORY?
	JRST UIN2		;YES, COPY CORE INTO USER AREA
UIN3:	MOVEI TAC,READ		;SETUP DISPATCH WHEN BLOCK NO. FOUND
	PUSHJ PDP,UINTER	;NO,CHECK DECTAPE AND DATA CONTROL INTERLOCK

;HERE AT INTERRUPT LEVEL IF NEXT INPUT BUFFER READY FOR DATA

UINGO:	MOVEI TAC,@DEVIAD(DEVDAT)	;ABS ADR OF USER BUFFER
	MOVEM TAC,UBUF
	HRRZ TAC,DTNEXT(DEVDAT)	;NEXT BLOCK TO READ

;HERE FROM OUTPUT UUO ALSO - BLOCK TO READ OR WRITE IN TAC

FILL:	HRRM TAC,UBKN		;STORE BLOCK NO.TO READ OR WRITE
	TRNE IOS,UDSD		;NON-STANDARD TAPE?
	JRST FILL1		;YES. DON'T CHECK BLOCK NO.
	CAIL TAC,1102		;IS IT TOO LARGE?
	JRST UTBERR		;YES,ILLEGAL BLOCK NO.
FILL1:	SETZM UERRCN		;CLEAR NO. OF ERRORS FOR THIS OPERATION
	SETZM ERRFLG		;CLEAR DC DATA MISSED FLAG
FILLER:	MOVE TAC,[JSR RDBN]	;SETUP TO READ BLOCK NOS.
	MOVEM TAC,@DCLOC	;IN EVEN DC PI LOC
	PUSHJ PDP,STOIOS	;STORE IOS AND RESET HUNG DEVICE COUNT
	MOVEI TAC,RBNTRY	;NUMBER OF REVERSALS WE WILL ALLOW
	MOVEM TAC,RBNCNT
	MOVE TAC,DTUNIT		;GET UNIT NO + DTC CHANNEL
	CONO DC,DCIN		;SET TO READ BLOCK NOS FROM DECTAPE
	CONO PI,DCTON		;TURN DC PI CHANNEL ON
	CONSZ DTC,20000		;IS TAPE MOVING? (IE ARE WE AT INTERRUPT LEVEL)
	JRST FILLC		;YES
	TLNN IOS,UREV		;NO, WAS LAST DIRECTION REVERSE?
	IORI TAC,GR		;NO,REVERSE THIS TIME
	HRLI TAC,17		;CONSZ TEST FLAGS
	IORI TAC,SL+DTR+RB+EE	;CONO FLAGS
	STARTDV DTC
	POPJ PDP,		;RETURN

FILLC:	CONSZ DTC,GR		;TAPE ALREADY MOVING, GOING BACKWARD?
	IORI TAC,DT		;YES,TURN AROUND DELAY
	CONO DTC,SL+RB+EE(TAC)	;MAKE GO FORWARD ALWAYS
	POPJ PDP,		;RETURN AT UUO LEVEL OR DISMISS INTERRUPT
;ILLEGAL BLOCK NO.


UTBERR:	TRO IOS,IOBKTL		;SET IOBKTL TO INDICATE ILLEGAL BLOCK NO.
	JRST DTC1		;STOP TAPE AND DESELECT

;COPY CORE IF TRYING TO READ BLOCK 1



UIN2:	PUSHJ PDP,DIRCHK	;CHECK IF DIRECTORY IN CORE
	MOVE TAC1,UFREE(DEVDAT)	;PLACE FREE BLOCK POINTER
	HRLM TAC1,@UDIR(DEVDAT)	;IN DIRECTORY
	NOSHUFFLE		;PREVENT CORE SHUFFLING DURING BLT
	MOVEI TAC,@DEVIAD(DEVDAT)	;ABS. OF 2ND WORD OF BUFFER
	MOVEI TAC1,1(TAC)	;BUFFER ADDRESS DESTINATION
	HRL TAC1,UDIR(DEVDAT)	;SOURCE
	BLT TAC1,200(TAC)	;MOVE DIRECTORY TO BUFFER
	PUSHJ PDP,ADVBFF	;ADVANCE INPUT BUFFER
	JFCL			;IGNORE IF NEXT ONE STILL FULL
	SHUFFLE
	POPJ PDP,
;COMMON ROUTINE TO CHECK INTERLOCK, INITIALIZE
;CALLED ONLY AT UUO LEVEL
;BITS IN IOS HAVE BEEN SET BUT NOT STORED
;TAC CONTAINS DISPATCH ADR. WHEN BLOCK NO. FOUND
;(READ,WRITE,DREAD,DWRITE)



DINTER:	TLOA IOS,URDIR		;FLAG DIRECTORY OPERATION
UINTER:	TLZ IOS,URDIR		;CLEAR DIRECTORY OPERATION BIT
	PUSHJ PDP,GETDCDT	;GET DATA CONTROL AND DECTAPE CONTROL
	AOSE	DTREQ		;ARGUMENT EXECUTED BY GETDCDT
	CONO DC,0		;TURN OFF DATA CONTROL
	HRRM TAC,BNDISP		;STORE DISPATCH ADR. WHEN BLOCK NO. FOUND
	LDB TAC,PUNIT		;UNIT NO. OF THIS DECTAPE
	LSH TAC,3		;SHIFT TO UNIT POSITION
	IORI TAC,DTCCHN		;OR IN DT CHANNEL
	MOVEM TAC,DTUNIT	;SAVE
	MOVEI TAC,116
	HRRM TAC, CONSZ1
	HLRE TAC,UFREE(DEVDAT)	;RESET BLOCK QUANTUM ALLOTMENT
	MOVEM TAC,BLKCNT	;LET THIS JOB READ THIS MANY BLOCKS
				;BEFORE SWITCHING TO ANOTHER JOB
				;AS LONG AS TAPE KEEPS MOVING
	MOVE TAC,[JSR ENPT]	;SETUP END FOR NON-DUMP DC OPERATIONS
	MOVEM TAC,@DCLOC1	;IN PI TRAP LOC+1
	PUSHJ PDP,SETACT	;SET DEV. ACTIVE FLAG AND STORE
				;IOS. ALSO RESET HUNG DEVICE TIME COUNT
	MOVEM DEVDAT,USVDB	;SAVE ADR. OF DEVICE DATA BLOCK
	MOVEM PROG,UPROG	;SAVE ABS.LOC. OF USER AREA
	POPJ PDP,
;ROUTINE TO CHECK IF DIRECTORY IN CORE
;IF NOT, IT IS READ IN


DIRCHK:	TRNN IOS,UDSD		;DIRECTORY BEING SUPPRESSED?
	SKIPGE DEVMOD(DEVDAT)	;NO. DIRECTORY IN CORE?
	POPJ PDP,		;YES
	MOVEI TAC,READ		;DISPATCH ADR. WHEN BLOCK NO. FOUND
	PUSHJ PDP,UTPRL1	;READ DIR. AND RETURN WHEN FINISHED
	HRRZ TAC,@UDIR(DEVDAT)	;CHECK REL. POINTER TO FIRST DIR. ENTRY
	JUMPE TAC,DIRERR	;BAD IF ZERO
	CAIL TAC,174
	JRST DIRERR		;PRINT BAD DIRECTORY AND DO NOT RETURN
	TLZ IOS,UDIREN+ULINKF+UNWFRE	;BUT NOT ENTERED INTO, LINKED TO FREE
				;STORAGE, OR FREE BLOCK POINTER CHANGED
DIRCH1:	MOVSI TAC,DVDIRIN	;SET DIRECTORY IN CORE BIT. CLEARED BY ASSIGN
	IORM TAC,DEVMOD(DEVDAT)
	HLRZ TAC,@UDIR(DEVDAT)	;LAST BLOCK WRITTEN
	HRRM TAC,UFREE(DEVDAT)	;SAVE IN DEVICE DATA BLOCK
	POPJ PDP,
;CLOSE UUO
;CALLED ONLY IF THIS USER CHANNEL HAS DONE OUTPUT



UTPCLS:	SETZM CURENT(DDB)		;CLEAR CURRENT ENTRY POINTER
	LDB TAC,PIOMOD		;GET DATA MODE?
	CAIGE TAC,DR		;IS IT DR OR D(DUMP MODE)?
	TLNN IOS,ULINKF		;NO, NOT LINKED TO FREE STORAGE?
	POPJ PDP,		;YES, DO NOT WRITE OUT LAST BUFFERFUL
	MOVE TAC,DEVOAD(DEVDAT)	;ADR. OF USER OUTPUT BUFFER
	AOS TAC			;ADDRESS THIRD WORD
	MOVEI TAC1,1		;SET LINK TO 1 IN LH OF THIRD WORD
	HRLM TAC1,@TAC		;IN USER AREA(FLAG AS LAST BLOCK)
	JRST OUT		;DO OUTPUT
;UTPCLR UUO - CLEAR DECTAPE DIRECTORY

UTPCLR:	TRNE IOS,UDSD		;DIRECTORY BEING SUPPRESSED?
	POPJ PDP,		;YES
	TLO IOS,UDIREN+UNWFRE	;NO. FLAG DIR. ENTERED INTO AND UFREE MODIF.
	MOVE TAC,UDIR(DEVDAT)	;INITIALIZE EXEC CORE DIRECTORY
	MOVE TAC1,[XWD 1,5]	;SET FIRST WORD IN DIRECTORY
	MOVEM TAC1,(TAC)	;LH=LAST BLOCK USED,RH=FIRST 
				;FREE REL. DIR. ENTRY.
	HRL TAC,TAC
	AOBJN TAC,.+1		;INCREMENT BOTH HALVES
	SETZM (TAC)		;CLEAR SECOND WORD
	MOVE TAC1,TAC
	AOS TAC
	BLT TAC,176(TAC1)	;CLEAR REST OF 200 WORD DIRECTORY
	PUSHJ PDP,DIRCH1	;SET DVDIRIN AND UFREE
				;ALWAYS WIRITE TAPE

;RELEASE UUO
;WRITE DIRECTORY IF CORE VERSION DIFFERS FROM TAPE VERSION(BLOCK 1)



UTPREL:	TRZE IOS,UDSD		;SUPPRESSING DIRECTORY?
	JRST SETI1		;YES, STORE IOS AND RETURN
	SKIPG DEVMOD(DEVDAT)	;HAS ASSIGN COMMAND BEEN TYPED
				;SINCE DIRECTORY READ IN?
	TLZN IOS,UDIREN+UNWFRE	;NO, DIR. ENTERED INTO OR
				;FREE BLOCK POINTER MODIFIED?
	POPJ PDP,		;NO, DO NOT WRITE DIRECTORY
	MOVEI TAC,WRITE		;DISPATCH ADR. WHEN BLOCK NO. FOUND
UTPRL1:	PUSHJ PDP,DINTER	;CHECK INTERLOCK AND FLAG DIRECT. OPER.
	MOVE TAC,UFREE(DEVDAT)	;NEW FREE BLOCK POINTER
	HRLM TAC,@UDIR(DEVDAT)	;STORE IN LH OF FIRST WORD OF DIR.
	HRRZ TAC,UDIR(DEVDAT)	;ADD. OF EXEC DIR. CORE BUFFER
	SOS TAC			;ADRRESS-1
	MOVEM TAC,UBUF		;STORE BUFFER ADR.
	MOVEI TAC,1		;WRITE (OR READ) BLOCK 1
	PUSHJ PDP,FILL		;GO START TAPE
	JRST WAIT1		;WAIT BEFORE RETURNING TO USER
;USETI UUO - SET NEXT INPUT BLOCK NO TO READ



SETI:	PUSHJ PDP,BLKCHK	;CHECK FOR ILLEGAL BLOCK NO.
	PUSHJ PDP,WAIT1		;WAIT TILL ALL BUFFERS FILLED.
	TLZ IOS,IOEND		;CLEAR END OF FILE BIT
	TRZ IOS,IODEND		;SYSTEM AND USER
	HRRM UUO,DTNEXT(DEVDAT)	;STORE NEXT BLOCK TO READ IN DDB
SETI1:	MOVEM IOS,DEVIOS(DEVDAT)
	POPJ PDP,

;USETO UUO - SET NEXT OUTPUT BLOCK NO. TO WRITE



SETO:	PUSHJ PDP,BLKCHK	;CHECK FOR LILLEGAL BLOCK NO.
	PUSHJ PDP,WAIT1		;WAIT TILL ALL BUFFERS EMPTIED.
	HRLM UUO,DTNEXT(DEVDAT)	;SET NEXT BLOCK NO. IN DEVICE DATA BLOCK
	POPJ PDP,

;ROUTINE TO CHECK FOR ILLEGAL BLOCK NUMBER
;CALL MOVE UUO,BLOCK #
;	PUSHJ PDP,BLKCHK
;	RETURN IF BLOCK NO. OK

;IF NON-STANDARD TAPE (UDSD=1), ALL BLOCK NOS. ARE LEGAL
;OTHERWISE, IF UUO>1101, SETS IOBKTL AND RETURNS TO USER.

BLKCHK:	TLZ UUO,-1		;CLEAR LEFT HALF UUO FOR COMPARE.
	TRNE IOS,UDSD		;NON-STANDARD TAPE?
	POPJ PDP,		;YES
	CAIG UUO,1101		;NO. LEGAL BLOCK NUMBER?
	POPJ PDP,		;YES
	TRO IOS,IOBKTL		;NO. SET IOBKTL, STORE IOS
	JRST SETI1		;AND RETURN TO USER.
;UGETF UUO - GET NEXT FREE BLOCK NO.
;IF DIRECTORY IS SUPPRESSED, RETURN XWD NEXT BLOCK TO WRITE,NEXT
; BLOCK TO READ.



GETF:	PUSHJ PDP,WAIT1		;WAIT TILL DEVICE INACTIVE
	MOVE TAC,DTNEXT(DEVDAT)
	TRNE IOS,UDSD		;IS DIRECTORY BEING SUPPRESSED?
	JRST STOTAC		;YES
	PUSHJ PDP,DIRCHK	;CHECK TO SEE IF DIRECTORY IN CORE
	TLO IOS,UNWFRE		;FLAG FREE BLOCK POINTER ALTERED
	MOVEM IOS,DEVIOS(DEVDAT)
	AOS TAC,UFREE(DEVDAT)	;GET FREE BLOCK POINTER
	HRLM TAC,DTNEXT(DEVDAT)	;SET NEXT BLOCK TO WRITE
	TLZ TAC,-1
	JRST STOTAC		;STORE TAC IN USER AREA
;READ BLOCK NOS.



↑RDBN1:	MOVEM TAC,DTTAC
	EXCH DEVDAT,USVDB	;RESET HUNG DEVICE TIME COUNT
	LDB TAC,PDVTIM		;TIME IN SECONDS
	DPB TAC,PDVCNT		;COUNT DOWN TO 0 BEFORE HUNG
	EXCH DEVDAT,USVDB
	DATAI DC,TAC		;READ IN BLOCK NO. JUST READ
	ANDI TAC,7777		; FOR PDP-8 FORMAT TAPE, MASK OUT CRAP
	SUBI TAC,@UBKN		;COMPARE WITH DESIRED ONE
	JUMPE TAC,@BNDISP	;IS IT EQUAL?
	SOS BLKCNT		;DECREMENT COUNT OF BLOCKS READ
	JUMPL TAC,LOW		;NO,IS IT LESS THAN DESIRED?
	MOVE TAC,DTUNIT		;NO, UNIT NO.+DT CHANNEL
	CONSZ DTC,GR		;IS TAPE GOING BACKWARD?
	JRST BAKWRD
	SOSGE RBNCNT		;ANOTHER REVERESAL
	JRST RBNLOS		;TOO MANY!
	IORI TAC,DT		;NO,ADD IN DELAY TO CHANGE DIRECTION
BAKWRD:	CONO DTC,SL+RB+GR+EE(TAC);MAKE TAPE GO BACKWARD
	JRST DXIT

LOW:	MOVE TAC,DTUNIT		;POSITION IS BEFORE DESIRED
	CONSO DTC,GR		;IS TAPE GOING FORWARD
	JRST ISLOW
	SOSGE RBNCNT		;ANOTHER REVERSAL
	JRST RBNLOS		;TOO MANY!
	IORI TAC,DT		;NO, ADD IN DELAY TO CHANGE DIRECTION
ISLOW:	CONO DTC,SL+RB+EE(TAC)	;MAKE TAPE GO FORWARD
DXIT:	MOVE TAC,DTTAC
	CONO DC,DCIN		;SET DATA CONTROL TO READ BLOCK NOS.
	JEN @RDBN

RBNLOS:	CONO DC,0		;SHUT OFF DATA CONTROL
	CONO PI,DCTOFF		;TELL PI ABOUT SHUTTING OFF DECTAPE
	CONO DTC,200000!JDE!TFE!DTR(TAC)	;SELECT, TURN OFF, SET DELAY, INTERRUPT AT END
	MOVEI	TAC,DTTRY	;MAKE SURE THAT WE
	MOVEM	TAC,UERRCN	;DON'T TRY AGAIN
	MOVEI	TAC,20		;TURN ON A BIT
	IORM	TAC,DTCCON	;WHERE CH.4 GETS TO TEST IT
	SETOM	ERRFLG		;MAKE SURE IT LOOKS LIKE AN ERROR!
	MOVE	TAC,DTTAC	;RESTORE TAC
	JEN	@RDBN		;DISMISS
;HERE WHEN BLOCK NO.FOUND FOR DUMP OUTPUT


DWRITE:	MOVE TAC,DTUNIT		;UNIT+DT CHANNEL
	CONSZ DTC,GR		;TAPE GOING IN REVERSE?
	JRST BAKWRD		;YES, MAKE IT GO BACKWARD ONE MORE BLOCK
	CONO DC,DCOUT		;SET DATA CONTROL TO WRITE ON DC CHANNEL
	CONO DTC,SL+WD+JDE+EE(TAC)
	MOVE TAC,[BLKO DC,BLKPTR]	;IO INSTR. FOR PI LOC
	JRST DEXIT

;HERE WHEN BLOCK NO. FOUND FOR DUMP INPUT


DREAD:	MOVE TAC,DTUNIT		;UNIT + DT CHANNEL
	CONSZ DTC,GR		;GOING BACKWARDS?
	JRST BAKWRD		;YES, MAKE IT GO BACKWARD ONE MORE BLOCK.
	CONO DTC,SL+RD+JDE+EE(TAC)	;NO, SET TO READ(JOB DONE ENABLED)
	MOVE TAC,[BLKI DC,BLKPTR]
DEXIT:	MOVEM TAC,@DCLOC	;STORE BLKI/BLKO IN EVEN DC CHANNEL LOC.
	EXCH DEVDAT,USVDB	;SET HUNG DEVICE COUNT TO 60 SECONDS
	MOVEI TAC,=60		;SINCE DUMP MODE CAN TAKE A LONG TIME
	DPB TAC,PDVCNT
	EXCH DEVDAT,USVDB
	MOVE TAC,DMPPTR		;SETUP DUMP BLKI OR BLKO POINTER
	JRST BNEXIT
;HERE WHEN BLOCK NUMBER FOUND FOR BUFFERED WRITING


WRITE:	CONO DC,DCOUT		;SET DC FOR WRITING ON DC CHANNEL
	MOVE TAC,DTUNIT		;DT UNIT+DT CHANNEL
	CONSO DTC,GR		;GOING BACKWARD?
	JRST WRFORW		;NO,WRITE FORWARD
	CONO DTC,SL+WD+GR+JDE+EE(TAC)	;YES, SET TO WRTIE REVERSED
	MOVE TAC,[JSR WTRV]	;PLACE TO GE FOR EVERY WORD
	JRST REVBLK		;SET BLKPTR FOR REVERSE

WRFORW:	CONO DTC,SL+WD+JDE+EE(TAC)	;WRITE FORWARD(JOB DONE ENABLED)
	MOVE TAC,[BLKO DC,BLKPTR]	;BLKO POINTER FOR INTERRUPT LOCATION
	JRST FORBLK		;SET BLKPTR FOR FORWARD
;HERE WHEN BLOCK NUMBER FOUND FOR BUFFERED INPUT


READ:	MOVE TAC,DTUNIT		;UNIT+UTC CHANNEL
	CONSO DTC,GR		;GOING BACKWARD?
	JRST RDFORW		;NO,READ FORWARD
	CONO DTC,SL+GR+RD+JDE+EE(TAC)	;YES, READ BACKWARD(JOB DONE ENB.)
	MOVE TAC,[JSR RDRV]	;PLACE TO GO FOR EACH WORD
REVBLK:	MOVEM TAC,@DCLOC	;STORE JSR FOR REVERSE INTERRUPT ON EACH WORD
	MOVE TAC,UBUF		;ADDRESS OF BUFFER-1(SECOND WORD)
	ADDI TAC,200-1		;LAST ADDRESS OF 200 WORD BUFFER
	JRST BLKXIT		;STORE BLKI/BLKO POINTER

RDFORW:	CONO DTC,SL+RD+JDE+EE(TAC)	;READ FORWARD(JOB DONE ENABLED)
	MOVE TAC,[BLKI DC,BLKPTR]	;BLKI POINTER
FORBLK:	MOVEM TAC,@DCLOC	;STORE BLKI/BLKO IN INTERRUPT LOC.
	MOVE TAC,UBUF		;ADDRESS OF BUFFER
BLKXIT:	HRLI TAC,-200		;WORD COUNT FOR 1 BLOCK
BNEXIT:	MOVEM TAC,BLKPTR	;SOTRE BLKI OR BLKO POINTER
	MOVE TAC,DTTAC		;RESTORE TAC
	JEN @RDBN		;DISMISS DC CHANNEL INTERRUPT
;WRITE 1 BLOCK IN REVERSE DIRECTION

↑WTRV1:	BLKO DC,BLKPTR
	JSR ENPT1
	SOS BLKPTR
	SOS BLKPTR
	JEN @WTRV

;READ 1 BLOCK IN REVERSE DIRECTION

↑RDRV1:	BLKI DC,BLKPTR
	JSR ENPT1
	SOS BLKPTR
	SOS BLKPTR
	JEN @RDRV
↑ENPT0:	JSR ENPT1
	JEN @ENPT

;END OF BLKI OR BLKO BUFFERED IO
;OR END OF DUMP MODE COMAND LIST


↑ENPT2:	CONSZ DC,10000		;DATA MISSED?
	SETOM ERRFLG		;YES,SET FLAG
	CONSO DTC,400		;WRITING?
	CONO DC,0		;NO,READING TURN OFF DATA CONTROL
	CONO PI,DCTOFF		;TURN OFF DATA CONTROL CHANNEL
	JRST @ENPT1

;END OF BLKI OR BLKO DUMP MODE READING OR WRITING

↑DMPA0:	MOVEM TAC,DTTAC
	AOSA TAC,DMPLST
DMPA1:	HRRZM TAC,DMPLST
	SKIPN TAC,(TAC)
	JRST DMPA3
	ADD TAC,UDPROG		;ADD XWD 0,USER RELOCATION
	JUMPGE TAC,DMPA1
	MOVEM TAC,BLKPTR	;SETUP DUMP MODE BLKI/BLKO POINTER
DMPA2:	MOVE TAC,DTTAC
	JEN @DMPADV

DMPA3:	JSR ENPT1
	JRST DMPA2
;HERE ON INTERRUPTS ON DECTAPE CONTROL AFTER DATA TRANSMITTED



↑DTCINT:	JSR DTCSAV		;SAVE REGISTERS.
	CONSO DTC,JDE		;JOB DONE ENABLED
			;(IE, READ-WRITING DATA OR WAITING
				;FOR TIME FLAG)
	JRST BN			;NO,MUST BE READING BLOCK NOS.
	CONSO	DTC,4000	;TIME FLAG ENABLED?
	JRST	DCCONO		;NO GO TURN OFF DATA CONTROL
	SKIPL	RBNCNT		;BLOCK NUMBER TRIES EXHAUSTED?
	JRST	UTIME		;NOPE, HONEST TIME FLAG ENABLING
	SETZM	RBNCNT		;SO WE DON'T GO THIS WAY AGAIN
	MOVEI	TAC,20		;SHUT OFF BIT THAT RBNLOS SET
	ANDCAM	TAC,DTCCON	;SHUT OFF BIT
DCCONO:	CONO DC,0		;NO,TURN OFF DATA CONTROL
	MOVE DEVDAT,USVDB	;SETUP DEVICE DATA BLOCK ADDRESS
	MOVE PROG,UPROG		;USER RELOC, AND PROTECTION
	MOVE IOS,DEVIOS(DEVDAT)	;IO STATUS
	CONSO DTS,@CONSZ1		;ANY ERRORS?(16 FOR DUMP MODE)
	SKIPE ERRFLG		;NO,DATA CONTROL MISS DATA?
	JRST DTREDO		;YES,REDO OPERATION
	TLZE IOS,IOW		;NO, JOB IN IO WAIT?
	PUSHJ PDP,SETIOD	;YES,SET JOB TO RUN AGAIN
	TLZE IOS,URDIR		;READING DIRECTORY?
	JRST DTC1		;YES
	TLNN IOS,IO		;NO,OUTPUT?
	JRST UIN1		;NO
	TLNN IOS,UDMPO		;YES,OUTPUT DUMP MODE?
	PUSHJ PDP,ADVBFE	;NO,IS NEXT OUTPUT BUFFER NOT READY YET?
	JRST DTC1		;YES,STOP TAPE
	PUSHJ PDP,CHKCNT	;DECREMENT QUANTUM BLOCK COUNT.
				;FINISHED QUANTUM?
	JRST UOUTGO		;NO, GO OUTPUT NEXT BLOCK
	JRST DTC1		;YES, STOP TAPE AND LET OTHER USER HAVE IT

UIN1:	TLNE IOS,UDMPI		;INPUT DUMP MODE?
	JRST DTC1		;YES, STOP TAPE
	MOVEI TAC, @DEVIAD(DEVDAT)	;NO,GET ABS. ADR OF 
				;BUFFER JUST READ INTO
	HLRZ TAC1,1(TAC)	;GET LINK TO NEXT BLOCK
	HRRM TAC1,DTNEXT(DEVDAT)	;STORE NEXT BLOCK TO READ
	JUMPN TAC1,.+2		;WAS THIS LAST BLOCK
	TLO IOS,IOEND		;YES,SET END OF FILE
	PUSHJ PDP,ADVBFF	;ADVANCE INPUT BUFFER
	JRST DTC1		;NOT EMPTIED BY USER YET,STOP TAPE
	TLNE IOS,IOEND		;WAS THIS LAST BLOCK?
	JRST DTC1		;YES, STOP TAPE
	PUSHJ PDP,CHKCNT	;NO, REDUCE QUANTUM BLOCK COUNT.
				;FINISHED QUANTUM?
	JRST UINGO		;NO, GO READ IN NEXT BLOCK
				;YES, STOP TAPE AND SCHEDULER WILL RUN WAITING JOB
;STOP TAPE AND DESELECT THIS UNIT BEFORE GOING TO ANOTHER UNIT




DTC1:	CONSO DTC,20000		;IS TAPE MOVING? I.E., AT INTERRUPT LEVEL?
	JRST DTC2		;NO.
	SKIPG TAC,BLKCNT	;RESTORE BLOCK COUNT
	MOVEI TAC,BLKQNT
	HRLM TAC,UFREE(DEVDAT)
	MOVEI TAC,DTCCHN	;DTC PI CHANNEL
	TLO IOS,UREV		;REMEMBER DIRECTION, SET REVERSE BIT
	CONSO DTC,GR		;TAPE GOING FORWARDS?
	TLZA IOS,UREV		;YES, CLEAR REVERSE BIT
	TRO TAC,GR		;NO, PRESERVE DIRECTION FOR STOP CONO
	MOVEI TAC1,20	;ENABLE SOFTWARE FOR TIME FLAG ONLY
	HRRM TAC1,DTCCON
	CONO DTC,TFE+RDS+JDE(TAC)	;STOP TAPE AND ENABLE
				;TIME FLAG AND JOB DONE(AS A FLAG ONLY)
				;SO WONT THINK READING BLOCK NOS. AT
				;DTCINT+1 CONSO INSTRUCTION
DTC3:	SOSL DCREQ		;DECREMENT DATA CONTROL REQUEST COUNT
	SETOM DCAVAL
	PUSHJ PDP,CLRACT	;CLEAR DEVICE ACTIVE FLAG, STORE IOS
	LDB ITEM,PJOBN
	TLNN DEVDAT,SYSDEV	;SYSTEM TAPE?
	POPJ PDP,		;NO
	HLRZ TAC,JBTSTS(ITEM)	;YES
	TRNN TAC,CMWB		;DELAY ↑C?
	POPJ PDP,		;NO
	JRST RELEA9		;YES. RELEASE SYSTEM TAPE.

DTC2:	PUSHJ PDP,DTC3		;FREE DC AND SYSTEM TAPE
	SOSL DTREQ
	SETOM DTAVAL
	CONO DC,0
	CONO PI,DCTOFF
	CONO	DTC,0
	HLLZS	DTCCON
	POPJ PDP,


;CHECK BLKCNT. IF IT IS < 0 AND SOMEONE IS WAITING FOR THE
;DATA CONTROL OR DECTAPE CONTROL, STOP THE TAPE.

;CALL	PUSHJ PDP,CHKCNT
;	CONTINUEα;	STOP TAPE


CHKCNT:	SOSLE BLKCNT		;COUNT RUN OUT?
	POPJ PDP,		;NO. CONTINUE
	SKIPN DCREQ		;YES. IS SOMEONE WAITING FOR DATA CONTROL?
	SKIPE DTREQ		;NO. DECTAPE CONTROL?
	AOS (PDP)		;YES. STOP TAPE.
	POPJ PDP,
;INTERRUPT ON DT CHANNEL WHILE READING BLOCK NOS. ON DC CHANNEL

BN:	CONSZ DTS,2		;END OF TAPE FLAG?
	JRST ENDZON		;YES,REVERSE DIRECTION
			;MUST BE AN ERROR FLAG OF SOME SORT.
	JRST DCCONO		;YES, STOP TAPE

ENDZON:	MOVE TAC,DTUNIT		;MUST BE READING BLOCK NOS.
	CONSO DTC,GR		;GOING BACKWARDS?
	IORI TAC,GR		;NO, MAKE IT GO BACKWARDS.
	CONO DTC,SL+RB+EE+DT(TAC)	;KEEP READING BLOCK NOS.
	CONO DC,DCIN		;SET DC TO READ BLOCK NOS. AGAIN.
	POPJ PDP,

;INTERRUPT FROM TIME FLAG AFTER STOP DEVICE



UTIME:
	SOSL DTREQ		;YES, REDUCE DECTAPE CONTROL REQUEST COUNT
	SETOM DTAVAL		;SOME OTHER JOB WAITING, SET AVAILABLE FLAG
				;FOR SCHEDULER
	CONO DTC,0		;CLEAR CONTROL(AND UTS)
	HLLZS DTCCON		;CLEAR CONSO UTS, FLAGS
	POPJ PDP,		;DISMISS INTERRUPT.

;HERE ON EACH OF 5 TYPES OF HARDWARE DETECTED ERRORS
;EACH OPERATION CAUSING AN ERROR IS TRIED "DTTRY" TIMES AS
;DEFINED ON THE CONFIGURATION
;A "FATAL ERROR" IS ONE WHICH FAILS DTTRY TIMES IN A ROW
;   THEN AND ONLY THEN THE IOS WORD IS SET APPROPRIATELY
;   TO INDICATE TO THE USER THAT AN ERROR HAS OCCURRED
;A RECORD OF ALL ERRORS(FATAL AND NON-FATAL) IS KEPT FOR
;ALL DRIVES COMBINED
;A RECORD OF EACH FATAL ERROR IS ALSO KEPT FOR EACH
;DRIVE AS WELL AS FOR ALL DRIVES COMBINED

;THE ERROR COUNT IS SPLIT INTO 5 FIELDS TO MAKE A TOTAL
;IF 36 BITS:
;THE 5 TYPES IF ERRORS ARE:
;ERROR COUNT	;IOS BIT	;DESCRIPTION
ECDERR←←1	;(RH)IODERR	;DC DETECTS DATA MISSED(DEVICE ERROR)
ECDTER←←1000	;(RH)IODTER	;PARITY ERROR(UTS)(DATA ERROR)
ECBKTL←←1	;(LH)IOBKTL	;INCOMPLETE BLOCK(UTS)(BLOCK TOO LARGE)
ECIMPM←←100	;(LH)IOIMPM	;TWO UNITS DIALED THE SAME
				;OR MARK TRACK ERROR, BOTH DETECTED
				;WHILE READING BLOCK NOS.(IMPROPER MODE)
ECIMP1←←10000	;(LH)IOIMPM	;ATTEMPT TO WRITE ON WRITE-LOCKED TAPE
DTREDO:	SKIPE TAC,ERRFLG	;CLEAR ERROR COUNT,DID DC MISS DATA?
	MOVEI TAC,IODERR+ECDERR	;YES, CLEAR TAC,SET DEVICE ERROR 
				;FLAG, ERROR COUNT POSITION
	CONSZ DTS,10		;NO, PARITY ERROR?
	TRO TAC,IODTER+ECDTER	;YES, SET DATA ERROR FLAG+COUNT
	CONSZ DTS,100		;NO, INCOMPLETE BLOCK?
	TDO TAC,[XWD ECBKTL,IOBKTL]	;YES, SET BLOCK TOO LARGE+COUNT
	CONSO DTS,4		;NO, ILLEGAL OPERATION?
	JRST ERSTOP		;NO
	TRO TAC,IOIMPM		;YES, FLAG AS IMPROPER MODE
	CONSO DTC,JDE		;READING BLOCK NOS.(JOB DONE NOT ENABLED)?
	TLOA TAC,ECIMPM		;YES, 2 UNITS MUST BE DIALED THE SAME
	TLO TAC,ECIMP1		;NO, MUST BE WRITE LOCKED
ERSTOP:	MOVE TAC1,TAC		;INCREMENT ERROR COUNT
	TRZ TAC1,IODERR+IODTER+IOBKTL+IOIMPM	;CLEAR OUT IOS ERROR BITS
	ADDM TAC1,DTOTAL	;ADD TO TOTAL ERROR COUNT FOR ALL UNITS
	AOS DAT,UERRCN		;INCREMENT ERROR COUNT
	CAIGE DAT,DTTRY		;EQUAL TO DTTRY YET?
	JRST DTRED1		;NO, TRY AGAIN
	ADDM TAC1,DFTOTAL	;ADD TO TOTAL FATAL ERROR COUNT
	ADDM TAC1,DTERR(DEVDAT)	;ADD TO FATAL COUNT FOR THIS UNIT
	TRZ TAC,ECDERR+ECDTER	;CLEAR RH COUNT BITS
	TRNE IOS,IOIMPM		;HAS USER BEEN TOLD ABOUT BAD OPERATION?
	TLZ IOS,URDIR		;YES. CLEAR URDIR SO WILL RETURN TO USER
	TRO IOS,(TAC)		;SET ERROR BITS IN IO STATUS WORD
	TLZE IOS,IOW		;JOB IN IO WAIT?
	PUSHJ PDP,SETIOD	;YES, START JOB UP AGAIN
	TLZN IOS,URDIR		;DIRECTORY ERROR?
	JRST DTC1		;NO, STOP TAPE WITHOUT SETTING BUFFER USE BIT
	PUSHJ PDP,DTC1
DIRERR:	MOVSI TAC,DVDIRIN	;YES, CLEAR DIRECTORY IN CORE BIT
	ANDCAM TAC,DEVMOD(DEVDAT)
	LDB ITEM,PJOBN		;LOAD JOB NUMBER INTO ITEM.
	JRST BADDIR		;PRINT BAD DIRECTORY AND STOP JOB


DTRED1:	LDB TAC1,PIOMOD
	CAIGE TAC1,16		;DUMP MODE?
	JRST FILLER		;NO
	TRNE TAC,IODTER+IODERR	;YES. PARITY OR DATA MISSED?
	SOS DMPLST		;YES. BACK UP POINTER
	JRST FILLER

BEND DTCSER
