COMMENT ⊗   VALID 00034 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	BEGIN	XGPSER	↔SUBTTL	XGPSER	SERVICE ROUTINES FOR XEROX GRAPHICS PRINTER
C00006 00003		DISPATCH FOR XGPSERVICE
C00007 00004		MTAPE UUO for the XGP.
C00011 00005		MTAPE UUO
C00016 00006		SET ERROR CODE ROUTINES.
C00018 00007		INITIALIZATION, RELEASE.
C00020 00008		DUMP MODE OUTPUT UUO.
C00023 00009		START THE XGP FROM THE PDP-10
C00025 00010		SET I-LEVEL DISPATCH AT FIRST UUO.
C00027 00011		XGP BUFFERED MODE OUTPUT UUO, CLOSE UUO
C00034 00012		XGPIOW	START XGP AND WAIT UNTIL IT EMPTIES THE BUFFER
C00036 00013		XGPUUO	COMMUNICATE TO/FROM THE FONT COMPILER
C00038 00014		FONT COMPILER ROUTINES.  FCREQ, FCWAIT, XWAKE, XPAUSE,FCWAKE
C00043 00015		MORE ROUTINES FOR FC
C00047 00016		INTERPROCESSOR COMMUNICATION AT CLOCK LEVEL. HUNG TIMEOUT
C00050 00017		User Programming for the XGP
C00057 00018		INTERRUPT LEVEL ROUTINES
C00064 00019		HERE FOR 'NOT XGPOK'	ALSO, QUEUE CUT MARKS.
C00066 00020		MODE 17 I-LEVEL
C00072 00021		XADV	ADVANCE IOWD AT I-LEVEL
C00075 00022		BUFFER ADVANCE AT I-LEVEL
C00080 00023		Character Mode for the XGP
C00091 00024		MODE 0	COMMENTS ABOUT INTERNAL STRUCTURE.
C00102 00025		MODE 0  CHANNEL 2 INTERRUPTS
C00112 00026		MODE 0 I-LEVEL  'SCAN PHASE'
C00116 00027		ROUTINES TO MANIPULATE COMMAND HEADER BLOCKS.
C00123 00028		XGP LINE COMPILER CO-ROUTINES
C00128 00029		HERE TO QUEUE A TEXT NODE.
C00136 00030		MODE 0	GET NEXT CHARACTER
C00139 00031		HERE FOR SPECIALS
C00141 00032		HERE TO PROCESS RUBOUT
C00154 00033		HERE FOR A 'NORMAL' CHARACTER
C00158 00034	BEND	XGPSER
C00159 ENDMK
C⊗;
BEGIN	XGPSER	↔SUBTTL	XGPSER	SERVICE ROUTINES FOR XEROX GRAPHICS PRINTER
;R. E. GORIN JANUARY, 1973

;BITS FOR THE XGP:

;CONO XGP,

SETX←←140000			;SETS THE COLUMN REGISTER IN INTERFACE
SETN←←150000			;TURNS ON 1 BITS IN INTERFACE
SETPI←←160000			;SET PI CHANNEL, DONENB, BLANK, PAPER,CLRDON
	DONENB←←100		;ALLOWS DONE TO BE SET
;	BLANK←←40		;IGNORE BUFFER DATA
	PAPER←←20		;TURN ON THE PAPER
	CLRDON←←10		;CLEAR DONE
	SETALL←←SETPI+PAPER+DONENB+CLRDON+XGPCHN
				;THIS IS USUAL CONO WHILE SENDING DATA
	

SETCON←←170000			;ALLOWS SWPBUF,CUTNOW, AND MARKIT COMMANDS
	SWPBUF←←4		;SWAP BUFFERS
	CUTNOW←←2		;CUT PAPER RIGHT NOW.
	MARKIT←←1		;MARK PAPER TO BE CUT LATER.

;CONI XGP,
	XGPOK←←100		;INTERFACE AND XGP ARE READY WHEN THIS BIT IS OFF!
;	VIDENB←←40		;VIDEO DATA IS HAPPENING RIGHT NOW.
	NZ←←20			;SET WHEN INTERFACE IS READY FOR ANOTHER COMMAND
	↑XGPDON←←10		;DONE. (REFERENCED IN OUTER)

;LH BITS IN XGPIOS
	XPAPER←←200		;XGP IS RUNNING PAPER NOW (PAPER UP TO SPEED)
	XGPERR←←400		;PDP-6 DETECTED ERROR


TNSIZE←←100			;SIZE OF TEXT NODE
VNSIZE←←5			;VECTOR NODE SIZE


ERRMSK←←IOIMPM!IODTER!IODERR!IOBKTL	;ERROR BITS

;	DISPATCH FOR XGPSERVICE

	JRST	XGPINI			;SYSTEM INITIALIZATION
	JRST	HUNG			;HUNG TIME OUT
↑XGPDSP:
	JRST	XGPREL			;RELEASE
	JRST	XCLSO			;CLOSE OUTPUT
	JRST	XOUT			;BUFFERED OUTPUT
	JRST	ILLINP			;INPUT ILLEGAL
	JRST	CPOPJ1			;ENTER
	JRST	CPOPJ1			;LOOKUP
	JRST	XDMPO			;DUMP MODE OUTPUT
	JRST	ILLINP			;DUMP INPUT
	POPJ	P,			;USETO
	POPJ	P,			;USETI
	POPJ	P,			;UGETF
	JRST	CPOPJ1			;RENAME
	POPJ	P,			;CLOSE INPUT
	POPJ	P,			;UTPCLR
	JRST	XMTAPE			;MTAPE


DWCNT:	POINT	6,XGPGCW,35		;WORD COUNT
LNSKIP:	POINT	11,XGPGCW,11
COLSKP:	POINT	12,XGPGCW,23
;	MTAPE UUO for the XGP.
COMMENT $

	MTAPE  CHAN,ADR
where CHAN is the channel number on which the  XGP has been opened is
interpreted as follows:
	ADR contains  the operation selector.  The  data at ADR+1 and
following depends on the operation selected.

Operation

0		Return error status.
		ADR+1/	major error code
		ADR+2,3,4/ error data

1		Font selection.
		ADR+1/ Font file name in sixbit
		ADR+2/ Font extension
		ADR+3/ PPN of font file
		ADR+4/ font identification number. (0 to 15.)
		(This UUO will skip if there is no error).

		The font named will be read by  the font compiler. It
		will be  assigned the font identification number that
		you supply. The  identification number  is used  only
		by the Font selection operator.

2		Read Margins
		ADR+1/ Top of page margin
		ADR+2/ Page body size
		ADR+3/ Bottom of page margin.
		ADR+4/ Left margin
		ADR+5/ Right side margin
		ADR+6/ Minimum interline space

3		Set Margins
		ADR+1/ Top of page margin 		<37777
		ADR+2/ Page body size			<37777
		ADR+3/ Bottom of page margin.		<37777
		ADR+4/ Left Margin			< 3777
		ADR+5/ Right side margin. 		Left < Right < 7777
		ADR+6/ Minimum interline space		< 3777

		If the bottom of page margin is set to 0 then the paper
		will not be cut.  If the page body size is set to 0 then
		the paper will be cut only when a form feed is encountered.
		The action of form feed in this case is to space down by the
		amount specified in the bottom of page margin and then cut.

4		Get status
		ADR+1/	XGPIOS is returned
		ADR+2/	-1 if I-level is running, else 0.

5		Pseudo Close. 
		Contents of the system buffer are transmitted to the XGP.
		XGP is not marked as CLOSEd, but another CLOSE is nearly
		a no-op.

6		Set Node Counts
		ADR+1/  The number of Text Nodes (currently =16)
		ADR+2/  The number of Vector Nodes (Currently =100)
		Zero in either parameter will use the default.
$
;	MTAPE UUO
XMTAPE:	XCTR	XR,[SKIPL TAC,(UUO)]	;N.B. THIS ADDRESS CHECKS BEGINNING OF DATA
	CAIL	TAC,XMTTLN
	MOVNI	TAC,1
	SKIPG	XMTTAB(TAC)		;SKIP UNLESS WE NEED A CLOSE FIRST.
	TDNN	IOS,[DEVSBB,,IOACT]	;DEVICE MUST NOT BE ACTIVE.
	JRST	@XMTTAB(TAC)		;DISPATCH
	PUSH	P,UUO
	MOVEI	UUO,0			;MAKE THE EFFECTIVE ADDRESS 0 FOR CLOSE.
	PUSHJ	P,XCLSO			;FORCE A CLOSE FIRST
	POP	P,UUO
	XCTR	XR,[MOVE TAC,(UUO)]	;GET DISPATCH AGAIN  (CAN'T BE WRONG)
	JRST	@XMTTAB(TAC)

		CPOPJ
XMTTAB:		XMTP0
	SETZ	XMTP1
		XMTP2
	SETZ	XMTP3
		XMTP4
		XCLSP			;FORCE DATA TRANSMISSION, PSEUDO CLOSE.
	SETZ	XMTP6			;SET NODE COUNTS
XMTTLN←←.-XMTTAB

XMTP0:	XCTR	XR,[MOVE TAC,4(UUO)]	;ADDRESS CHECK LAST WORD (FIRST WORD IS OK)
	HRRI	TAC1,1(UUO)		;DESTINATION
	PUSHJ	P,RELOCA		;RELOCATE DESTINATION
	JRST	ADRERR			;ADDRESS CHECK
	JUMPL	TAC1,ADRERR		;WRITE PROTECTED
	HRLI	TAC1,XGPERC		;SOURCE
	MOVEI	TAC,3(TAC1)
	BLT	TAC1,(TAC)
	SETZM	XGPERC			;CLEAR ERROR COUNT
	POPJ	P,

XMTP1:	XCTR	XR,[MOVE TAC,4(UUO)]	;ADDRESS CHECK THE END OF THE TRANSFER
	MOVEI	TAC1,1(UUO)		;RELATIVE FIRST LOC OF SOURCE
	PUSHJ	P,RELOCA
	JRST	ADRERR
	MOVSI	TAC,(TAC1)		;SWAP TO SOURCE
	HRRI	TAC,XGPNST+1		;DESTINATION
	BLT	TAC,XGPNST+4

	MOVEI	TAC,2			;OP CODE FOR FONT COMPILER.
	MOVEM	TAC,XGPNST
	PUSHJ	P,FCREQ
	POPJ	P,			;LOSE ERROR CODE WILL BE SET ALREADY
	MOVE	TAC,XGPOST		;GET OLD STATUS
	CAIE	TAC,2			;EXPECTED REPLY IS YESSIR
	JRST	FCERRX			;OOPS FC REPLIED WRONG.
	MOVE	TAC,XGPOST+1		;GET RELATIVE ADDRESS OF FONT TABLE
	MOVE	TAC1,XGPNST+4		;GET FONT NUMBER THAT WE TOLD THE FC.
	MOVEM	TAC,XFTADR(TAC1)
	JRST	CPOPJ1

XMTP2:	XCTR	XR,[MOVE TAC,6(UUO)]	;ADDRESS CHECK LAST WORD (FIRST WORD IS OK)
	MOVEI	TAC1,1(UUO)		;DESTINATION
	PUSHJ	P,RELOCA
	JRST	ADRERR
	JUMPL	TAC1,ADRERR
	HRLI	TAC1,XGPPS1		;SOURCE
	MOVEI	TAC,5(TAC1)		;LAST WORD OF DESTINATION
	BLT	TAC1,(TAC)
	POPJ	P,

XMTP3:	MOVEI	TAC1,0
XMTP3A:	XCTR	XR,[MOVE TAC,1(UUO)]
	ANDI	TAC,37777
	MOVEM	TAC,XGPPS1(TAC1)
	ADDI	UUO,1
	CAIGE	TAC1,2
	AOJA	TAC1,XMTP3A
	XCTR	XR,[MOVE TAC,1(UUO)]	;LEFT MARGIN
	ANDI	TAC,3777
	MOVEM	TAC,XGPLMR
	XCTR	XR,[MOVE TAC,2(UUO)]	;RIGHT MARGIN
	ANDI	TAC,7777
	CAMG	TAC,XGPLMR
	MOVEI	TAC,7777
	MOVEM	TAC,XGPRMR
	XCTR	XR,[MOVE TAC,3(UUO)]
	ANDI	TAC,3777
	MOVEM	TAC,XGPILS
	POPJ	P,

XMTP4:	MOVE	IOS,XGPIOS
	XCTR	XW,[MOVEM IOS,1(UUO)]
	MOVE	TAC,XGPIGO
	XCTR	XW,[MOVEM TAC,2(UUO)]
	POPJ	P,

XMTP6:	XCTR	XR,[SKIPG TAC,1(UUO)]	;GET THE TEXT NODE COUNT
	MOVEI	TAC,NTNODE
	MOVEM	TAC,XNTNOD
	XCTR	XR,[SKIPG TAC,2(UUO)]
	MOVEI	TAC,NVNODE
	MOVEM	TAC,XNVNOD
	POPJ	P,
;	SET ERROR CODE ROUTINES.
XERR1:	JSP	TAC,XERRC		;FC LOSSAGE: JOB CAPACITY EXCEEDED
XERR2:	JSP	TAC,XERRC		;FC LOSSAGE: NO INITIAL RESPONSE.
XERR3:	JSP	TAC,XERRC		;FC LOSSAGE: NO INTERMEDIATE RESPONSE.
XERR4:	JSP	TAC,XERRC		;FC LOSSAGE: ILLEGAL RESPONSE.
XERR5:	JSP	TAC,XERRC		;I-LEVEL  DATA MISSED. - BUFFERED MODE.
XERR6:	JSP	TAC,XERRC		;XGP IS HUNG - HUNG TIMEOUT.
XERR7:	JSP	TAC,XERRC		;ILLEGAL MODE.
XERR10:	JSP	TAC,XERRC		;LINE COMPILER ERROR. LINE TOO COMPLEX.
XERR11:	JSP	TAC,XERRC		;OUT OF ORDER
XERR12:	JSP	TAC,XERRC		;I MISSED IT!
XERR13:	JSP	TAC,XERRC		;PAGE TOO LONG
XERR14:	JSP	TAC,XERRC		;ILLEGAL VECTOR PARAMETERS

XERRC:	SKIPE	XGPERC			;ONLY LET ONE ERROR THROUGH
	POPJ	P,			;
	SUBI	TAC,XERR1
	HRRZM	TAC,XGPERC		;SET ERROR CODE FOR USER.
XERRCL:	SETZM	XGPERC+1		;AND CLEAR EXTRA ERROR WORDS.
	SETZM	XGPERC+2
	SETZM	XGPERC+3
	POPJ	P,

FCERRX:	PUSHJ	P,XERR4			;SET ERROR CODE.
	MOVE	TAC,[XGPOST,,XGPERC+1]	;GET FC STATUS
	BLT	TAC,XGPERC+3		;STORE FC STATUS AS 3 EXTRA ERROR WORDS.
	POPJ	P,
;	INITIALIZATION, RELEASE.

XGPINI:	SYNINI	XGPCSC		;INITIALIZE XGP SYNCHRONIZATION CELLS.
	SETZM	XFLAPC		;FLAPPER COUNT
	SETZM	XFLAPB		;FLAPPER BITS
	SETZM	XFLAPA		;MORE FLAPPER BITS
	SETZM	XCUTQ
	MOVE	TAC,[POINT 36,XCUTQ-1,35]
	MOVEM	TAC,XCUTBP
	SETZM	XIBUF		;THERE IS NO INTERNAL BUFFER FOR DEVICE.

XCPIN1:	SETZM	XGPGO		;NO ONE READY TO XFER DATA.
	SETZM	XGPHDW		;ZERO HEADER IOWD
	SETZM	XGPAT2
	SETZM	XGPMDP		;INITIALIZE DUMP MODE STUFF
	SETZM	XGPNXC	
	SETZM	XGPBIG
	SETZM	XGPIWD
	SETZM	XGPERC		;CLEAR ERROR CODE.
	MOVE	TAC,[XMSET,,XGPPS1]
	BLT	TAC,XGPBLN
	JRST	XERRCL		;CLEAR MINOR ERROR CODES AND RETURN


↑XGPIN2:			;P2 INITIALIZE THE XGP.
	MOVSI	IOS,XPAPER
	PUSHJ	P,XGPCLR
	SETZM	P2CH2		;SO XGPP2 WILL START XGP NOW.
	SETOM	XGPP2F		;LET CLOCK LEVEL START US.
	JRST	XGPP2		;RUN OUR CLOCK LEVEL AND RETURN TO SYSINI


XGPREL:	SETOM	XGPKIL
	PUSHJ	P,FCKILL	;KILL THE FONT COMPILER
	SKIPE	AC1,XIBUF
	PUSHJ	P,FSGIVE
	SETZM	XIBUF
	PUSHJ	P,PSYNCX	;
	SETZM	XGPBIT		;TELL PDP-6 THAT WE DON'T HAVE ANY MORE.
	MOVE	IOS,[XGPERR!IOW!DEVSBB!IOBEG!IOEND,,ERRMSK!IOACT]
	ANDCAM	IOS,XGPIOS
	PUSHJ	P,XSYNCX	;RELEASE SYNCHRONIZER
	JRST	XCPIN1

;	DUMP MODE OUTPUT UUO.
XDMPO2:	TRNE	IOS,ERRMSK
	POPJ	P,			;DON'T WAIT IF HE'S GOT ERROR BITS ON.
	PUSHJ	P,WSYNC			;STOP FOR A WHILE. (SETS IOW)
XDMPO:	SKIPE	XGPNXC			;IS THERE A 'NEXT' COMMAND ALREADY?
	JRST	XDMPO2			;YES. WAIT UNTIL THERE ISN'T ONE

	PUSHJ	P,COMCHK		;CHECK COMMAND LIST
	JRST	ADRERR			;ADDRESS ERROR IN COMMAND.
	MOVE	J,JOB(PID)		;FIX J, CLOBBERED BY COMCHK
					;UUO POINTS TO FIRST COMMAND IOWD OR 0.
	HRRZ	TAC,UUO			;COMMAND LIST POINTER
	HRLI	TAC,PROG
	SKIPN	@TAC			;GET ACTUAL COMMAND WORD.
	POPJ	P,			;NULL COMMAND LIST. DO NOTHING.
	MOVEM	TAC,XGPNXC		;POINTER TO COMMAND SAVED AS 'NEXT COMMAND'
	SKIPE	XGPMDP			;IS THERE A CURRENT MAIN POINTER?
	JRST	XDMPO5			;YES.
	SETZM	XGPNXC			;XGP IS IDLE, CLEAR NEXT
	SUBI	TAC,1
	MOVEM	TAC,XGPMDP		;AND SET MAIN.
XDMPO5:	PUSHJ	P,PSYNCX
	MOVE	IOS,XGPIOS
	TLZE	IOS,IOBEG		;IF IOBEG,
	PUSHJ	P,SETXIO		;SET I-LEVEL DATA DISPATCH.
	TRNE	IOS,ERRMSK
	JRST	XSYNCX			;IN CASE OF ERROR, DESYNCHRONIZE AND RETURN
	PUSHJ	P,XSYNCX
	PUSHJ	P,XGPSTR		;START THE XGP. (DON'T CLOBBER J,PROG)
	PUSHJ	P,PSYNCX
	MOVE	IOS,XGPIOS
	TRNE	IOS,ERRMSK
	JRST	XSYNCX			;FLUSH ERRORS.
	MOVEM	PROG,XGPROG		;SET UP FOR XADV
	PUSHJ	P,SETACT
	PUSHJ	P,XSYNCX
	SETOM	XGPGO			;TELL PDP-6 TO START DOING DATA.
	TRNE	IOS,100			;CONTINUOUS MODE?
	JRST	TPOPJ			;AVOID CALLING WSYNC IN UUOCON
XDMPO8:	PUSHJ	P,WAIT1			;RETURN WHEN IOACT OFF.
XDMPO1:	SETZM	XGPGO
	PUSHJ	P,PSYNCX
	SETZM	XGPBIT
	JRST	XSYNCX
;	START THE XGP FROM THE PDP-10
XGPSTR:	SETZM	XGPKIL			;HERE TO START THE XGP
	SETZM	XGPAOK			;
XGSTR1:	PUSHJ	P,PSYNCX
	SETOM	XGPCNY			;IF PAPER IS MOVING, I-LEVEL JUMPS TO PAPOON.
	SETOM	XGPBIT			;TELL PDP-6 WE WANT PAPER MOTION.
	LDB	TAC,PDVTIM
	DPB	TAC,PDVCNT
	MOVE	IOS,XGPIOS		;GET CURRENT STATE OF AFFAIRS
	TDNE	IOS,[DEVSBB,,IOACT]	;IS THE BEAST RUNNING NOW?
	JRST	XGSTR4			;YES. RETURN QUICK
	PUSHJ	P,XSIOS			;SET IOS RIGHT.
	PUSHJ	P,XSYNCX
	LDB	J,PJOBN
	MOVNI	IOS,DIOWQ		;REQUEUE TO DIOW TO ALLOW SYNC.
	MOVEM	IOS,JOBQUE(J)
XGSTR2:	PUSHJ	P,WSCHED		;RESCHEDULE.
	MOVE	IOS,XGPIOS
	TLNE	IOS,IOW			;DID THE RIGHT GUY BRING ME OUT?
	JRST	XGSTR2			;NO. WAIT SOME MORE.
	TRNE	IOS,ERRMSK		;ANY ERRORS?
	POPJ	P,			;YES. RETURN THEM
	PUSHJ	P,PSYNCX
	PUSHJ	P,XSIOS			;SET SOME GOOD BITS IN XGPIOS.
XGSTR4:	TLO	IOS,IO!IOW
	TRNE	IOS,100			;OVERLAPPED MODE?
	TLZ	IOS,IOW			;YES. THEN NOT REALLY IN IOW.
	MOVEM	IOS,XGPIOS
	JRST	XSYNCX			;RETURN. PAPER IN MOTION.

XSIOS:	MOVSI	IOS,IOW!IO!DEVSBB	;ASSUME BUFFERED MODE
	MOVE	TAC,XGPDDB+DEVCMR
	TLNN	TAC,DEVIBF		;SKIP IF REALLY BUFFERED MODE
	TDC	IOS,[DEVSBB,,IOACT]	;FLUSH DEVSBB, TURN ON IOACT FOR DUMP MODE.
	IORB	IOS,XGPIOS		;SET THOSE BITS.
	POPJ	P,
;	SET I-LEVEL DISPATCH AT FIRST UUO.
SETXIO:	LDB	TAC,PIOMOD
	MOVE	TAC,XIODSP(TAC)
	TRNE	IOS,100		;SPECIAL MODE?
	MOVS	TAC,TAC
	HRRZM	TAC,XDISP2	;
	TRNE	TAC,-1		;SKIP IF ZERO DISPATCH
	JRST	SETXI1
	TRO	IOS,IOIMPM	;ILLEGAL.
	PUSHJ	P,XERR7
SETXI1:	MOVEM	IOS,XGPIOS
	LDB	TAC,PIOMOD
	MOVE	IOS,XGPDDB+DEVCMR
	CAIL	TAC,D
	TLZA	IOS,DEVIBF	;NO INTERNAL BUFFER IN DUMP MODE
	TLO	IOS,DEVIBF	;INTERNAL BUFFER IN BUFFERED MODE.
	MOVEM	IOS,XGPDDB+DEVCMR
	MOVE	IOS,XGPIOS
	POPJ	P,

XIODSP:	0,,XCIBEG		;MODE 0
	0,,XCIBEG		;MODE 1
	0			;MODE 2
	0			;MODE 3
	0			;MODE 4
	0			;MODE 5
	0			;MODE 6
	0			;MODE 7
	0			;MODE 10
	0			;MODE 11
	0			;MODE 12
	0,,XCIBEG		;MODE 13 - SAME AS MODE 0
	0			;MODE 14
	0			;MODE 15
	0			;MODE 16
	XDI,,XDI		;MODE 17 

XGPSET:	PUSHJ	P,PSYNCX
	IORB	IOS,XGPIOS
XSYNCX:	XSYNC	XGPCSC
	POPJ	P,

XGPCLR:	PUSHJ	P,PSYNCX
	ANDCAB	IOS,XGPIOS
	JRST	XSYNCX

PSYNCX:	PSYNC	XGPCSC
	POPJ	P,
;	XGP BUFFERED MODE OUTPUT UUO, CLOSE UUO
XCLSP:	MOVEI	UUO,0			;KLUDGE FOR MTAPE 5.
XCLSO:	MOVSI	IOS,IOEND		;FLAG CLOSE UUO.
	PUSHJ	P,XGPSET
	LDB	TAC,PIOMOD		;GET THE MODE.
	CAIL	TAC,SD			;IS THIS A DUMP MODE?
	JRST	XDMPO8			;YES. WAIT FOR ALL IO AND STOP XGP
	PUSHJ	P,OUT			;DO ONE MORE OUTPUT.
	MOVSI	IOS,IOBEG		;NOW, READY TO INITIALIZE AGAIN.
	JRST	XGPSET			;SET IOBEG IN DEVIOS AND RETURN.

XOUT:	MOVEI	IOS,ERRMSK		;CLEAR ANY ERRORS
	PUSHJ	P,XGPCLR		;...
	TLNN	IOS,IOBEG		;FIRST OPERATION?
	JRST	XOUT1			;NO.
	MOVE	AC3,XGPBLN
	SKIPN	AC1,XIBUF		;IN CASE SOMEONE LEFT IT HERE
	PUSHJ	P,UFSGET		;GET A BLOCK OF FREE STORAGE.
	MOVEM	AC1,XIBUF		;FIRST LOC OF BUFFER.
	MOVEM	AC1,XTAKE		;TAKE POINTER
	MOVEM	AC1,XPUT		;PUT POINTER
	SETZM	XBFCNT			;BUFFER COUNT.
	ADD	AC1,XGPBLN
	MOVEM	AC1,XIBFND		;END OF BUFFER+1
	PUSHJ	P,NFONT			;IF WE NEED A FONT, GET ONE.
	JRST	F.LOSE			;(N.B. DON'T CLEAR IOBEG!)
	PUSHJ	P,PSYNCX
	MOVE	IOS,XGPIOS		;ONCE THIS IS SET UP,...
	TLZ	IOS,IOBEG		;NOW, NO LONGER THE BEGINNING
	PUSHJ	P,SETXIO
	PUSHJ	P,XSYNCX
XOUT1:	MOVE	IOS,XGPIOS		;IF ERRORS, REPORT THEM TO USER
	TRNE	IOS,ERRMSK		;DON'T TRY TO GO ON.
	POPJ	P,
	PUSHJ	P,DEVSTU		;SET UP TO PROCESS THIS BUFFER
	JRST	XOUT3			;BUFFER IS ALREADY EMPTY?
	CAMLE	AC2,XGPBLN		;COULD IT EVER FIT?
	JRST	XBTLRR			;NO. FLUSH LOSER.
	JUMPE	AC2,XOUT2A		;TAKE 2 GIANT STEPS IF EMPTY BUFFER
	MOVE	TAC,XGPBLN
	SUB	TAC,XBFCNT		;TAC←SPACE REMAINING.
	CAILE	AC2,(TAC)		;IS THERE SPACE ENOUGH?
	JRST	XOUT4			;NO ROOM. WE HAVE TO WAIT
	MOVE	TAC,XPUT
	CAMGE	TAC,XTAKE
	JRST	XOUT2			;PUT<TAKE DATA FITS FROM PUT TO TAKE
					;WE NEED TO DO ONLY ONE BLT.

	MOVE	TAC1,XIBFND		;POINTER TO THE END OF THE BUFFER+1
	SUBI	TAC1,(TAC)		;CALCULATE SPACE TO THE END.
	CAIL	TAC1,(AC2)		;COMPARE WITH DATA SIZE...
	JRST	XOUT2			;ONE BLT WILL SUFFICE.

	HRLI	TAC,(AC3)		;S,,D FOR BLT
	MOVE	AC1,XIBFND		;END OF THE BLT+1
	BLT	TAC,-1(AC1)		;FROM USER THRU THE END OF THE BUFFER.
	MOVE	TAC,XIBUF		;NEW XPUT INTO TAC.
	ADDI	AC3,(TAC1)		;MAKE NEW POINTER TO USER.
	SUBI	AC2,(TAC1)		;MAKE NEW COUNT.
	PUSHJ	P,PSYNCX
	ADDM	TAC1,XBFCNT		;INCREMENT THE BUFFER USE COUNT.
	PUSHJ	P,XSYNCX
XOUT2:	HRLI	TAC,(AC3)		;DATA WILL FIT UPWARDS FROM PUT.
	MOVEI	AC1,(TAC)		;S,,D IN TAC.  D IN AC1.
	ADDI	AC1,(AC2)		;COMPUTE LAST DESTINATION OF BLT+1
	BLT	TAC,-1(AC1)		;MOVE DATA.
	CAML	AC1,XIBFND		;IS POINTER AT THE END NOW?
	MOVE	AC1,XIBUF		;YES. WRAP BACK TO FRONT.
	MOVEM	AC1,XPUT		;SAVE THE NEW PUT POINTER.
	PUSHJ	P,PSYNCX
	ADDM	AC2,XBFCNT		;INCREMENT BUFFER SIZE.
	PUSHJ	P,XSYNCX
XOUT2A:	PUSHJ	P,ADVBFE		;ADVANCE THE OUTPUT BUFFER
	JRST	XOUT3			;NO MORE DATA THERE.
	JRST	XOUT1			;PROCESS NEXT BUFFER FULL.

XOUT3:					;HERE IF SYSTEM BUFFER IS NOT FULL.
	TLNE	IOS,IOEND		;IS THIS THE LAST UUO?
	SKIPG	XBFCNT			;LAST UUO. IS THERE DATA TO SEND?
	POPJ	P,			;NO DATA OR NOT LAST (LET USER ADD MORE).
	SETZM	XGPWSZ			;ZERO WAITING SIZE ⊃ LAST UUO.
					;XGP WILL RESDUCE XBFCNT TO 0 BEFORE
					;REACTIVATING P1.
	PUSHJ	P,XGPIOW		;YES. START XGP AND WAIT.
	JRST	F.LOSE			;FONT COMPILER LOSES
	POPJ	P,			;HERE WE LOST WITH XGP ERROR.
	MOVSI	IOS,IOEND		;NO LONGER LAST UUO.
	PUSHJ	P,XGPCLR		;CLEAR BIT.
	JRST	XDMPO1			;CLEAR OUT REMAINING BITS AND CELLS.


XOUT4:					;HERE IF SYSTEM BUFFER TOO FULL.
	SUB	AC2,XGPBLN
	MOVNM	AC2,XGPWSZ		;WHEN XBFCNT≤XGPWSZ, P2 REACTIVATES P1.
					;SPACE THAT WE'LL NEED.
	TLNN	IOS,IOEND		;LAST UUO?
	PUSHJ	P,DEVCR			;NOT LAST. CHECK BUFFER RING USE BIT.
	JRST	XOUT5			;USER HAS NO FREE BUFFERS. OR CLOSE UUO
	POPJ	P,			;WAIT UNTIL USER FILLS ALL HIS BUFFERS.
XOUT5:	PUSHJ	P,XGPIOW		;USER HAS NO FREE BUFFERS. START XGP. WAIT.
	JRST	F.LOSE			;FONT COMPILER LOSES
	POPJ	P,			;WE LOST WITH XGP HUNG.
	JRST	XOUT1			;SYSTEM BUFFER ¬FULL. GOBBLE USER BUFFER.


XBTLRR:	SETOM	XGPKIL			;STOP THE XGP. GRIND. ARRGH.
	JRST	BTLERR			;GIVE USER A MESSAGE.
;	XGPIOW	START XGP AND WAIT UNTIL IT EMPTIES THE BUFFER

XGPIOW:
	SKIPE	XGPBIT			;ARE WE TELLING PDP-6 WE WANT PAPER?
	JRST	XGPIO1			;YES. THEN PAPER MUST BE GOING.
					;NO IT'S TIME TO START XGP.
	SKIPG	XFCJN			;DOES FC EXIST?
	JRST	XGPIO0			;NO SO DON'T LOCK IT
	PUSHJ	P,FCLOCK
	POPJ	P,
XGPIO0:	PUSHJ	P,XGPSTR		;START THE XGP.
	MOVE	IOS,XGPIOS
	TRNE	IOS,ERRMSK
	JRST	CPOPJ1			;ERRORS.  TELL LOSER.
XGPIO1:	MOVSI	IOS,IOW!DEVSBB		;IOWAIT, SYSTEM BUFFER BUSY
	PUSHJ	P,XGPSET
	SETOM	XGPGO			;DATA IS IN CORE (SYSTEM) AND READY.
	MOVNI	TAC,DIOWQ		;REQUE TO DEVICE WAIT...
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,WSCHED
	MOVE	IOS,XGPIOS
	TLNE	IOS,IOW			;REALLY DONE?
	JRST	XGPIO1			;NO
	JRST	CPOPJ2			;YES
;	XGPUUO	COMMUNICATE TO/FROM THE FONT COMPILER
;	CALLED BY CALL AC,['XGPUUO']

;	AC LEFT POINTS TO FC CURRENT STATUS BLOCK. (20 WORDS)
;	AC RIGHT POINTS TO FC NEW STATUS BLOCK.(20 WORDS)
;	IF THERE IS NO NEW STATUS, JOB WILL BE REQUEUED TO WAIT.

↑XGPUUO:
	MOVE	TAC,JBTPRV(J)
	TLNN	TAC,XGPPRV
	POPJ	P,			;WRONG CREDENTIALS.

	SETZM	XGPOST			;ASSUME BY DEFALT, NULL OLD STATUS.
	XCTR	XR,[HLRZ TAC,(UCHN)]	;GET THE OLD SATAUS ADDRESS.
	JUMPE	TAC,XGPUU1		;JUMP IF THERE IS NO OLD STATUS
	MOVEI	TAC1,17(TAC)		;CHECK ENDING ADDRESS FOR LEGALITY
	XCTR	XR,[MOVE TAC1,(TAC1)]	;WE LOSE CONTROL ON ADDRESS CHECK.
	ADDI	TAC,(PROG)		;ADDRESS OF NEW STATUS.
	MOVSI	TAC,(TAC)		;SOURCE
	HRRI	TAC,XGPOST		;OLD STATUS BLOCK
	BLT	TAC,XGPOST+17		;GOBBLE OLD STATUS
XGPUU1:	PUSHJ	P,XWAKE			;REPORT OLD STATUS TO ONE WHO WAITS.
	PUSHJ	P,XPAUSE		;AND PUT US TO BED.
	XCTR	XR,[HRRZ TAC,(UCHN)]	;GET THE NEW STATUS ADDRESS.
	JUMPE	TAC,XGPUU2		;JUMP IF NO NEW STATUS BLOCK.
	MOVEI	TAC1,17(TAC)		;CHECK ENDING ADDRESS FOR LEGALITY
	XCTR	XR,[MOVE TAC1,(TAC1)]
	HRLI	TAC,XGPNST		;NEW STATUS BLOCK
	ADDI	TAC,(PROG)
	MOVEI	TAC1,17(TAC)
	BLT	TAC,(TAC1)
XGPUU2:	POPJ	P,
;	FONT COMPILER ROUTINES.  FCREQ, FCWAIT, XWAKE, XPAUSE,FCWAKE
;	NEW STATUS FOR XGP HAS TO BE SET UP BEFORE CALL.

FCREQX:	POP	P,J
	MOVE	PROG,JBTADR(J)
	JRST	XERR1			;LOSE BECAUSE OF JOB CAPACITY EXCEEDED

FCREQ:	SKIPE	XFCJN			;DOES FC EXIST?
	JRST	FCREQ1			;YES. JUST WAKE IT UP.
	PUSH	P,J			;CREATE A FONT COMPILER
	PUSHJ	P,INIJOB		;ATTEMPT TO GLOM A JOB SLOT
	JRST	FCREQX			;NONE AVAILABLE
	JRST	FCREQX			;WAIT FOR FREE STORAGE. (CAN'T HAPPEN).
	MOVE	AC3,['XGPSYS']		;PPN OF FONT COMPILER.
	MOVEM	AC3,PRJPRG(J)
	MOVEM	AC3,JOBPPN(J)
	MOVE	AC1,['[-FC-]']		;NAME OF FONT COMPILER.
	MOVEM	AC1,JOBNAM(J)
IFN FTSTAT,<PUSHJ P,NAMSTT>
	MOVSI	AC1,XGPPRV
	MOVEM	AC1,JBTPRV(J)
	MOVEM	AC1,JB2PRV(J)		;ALSO PASSIVE ONES
	MOVSI	AC1,JNA
	IORM	AC1,JBTSTS(J)
	MOVEM	J,XFCJN
	LSH	J,=12
	ADD	J,[GETBT0,,1]		;PLANT CLOCK REQUEST.
	CONO	PI,PIOFF
	IDPB	J,CLOCK
	CONO	PI,PION
	POP	P,J			;RESTORE J AND WAIT.
	MOVE	PROG,JBTADR(J)		;RESET THIS
	PUSHJ	P,FCWAIT		;AND WAIT FOR IT TO TELL US 'READY'
	JRST	XERR2			;OOPS.
FCREQ1:	MOVE	TAC,PRJPRG(J)
	MOVEM	TAC,XGPNST+17		;SET USER PPN AS PART OF NEW STATUS
	MOVEM	J,XGPNST+16		;AND USER JOB NUMBER TOO.
	PUSHJ	P,FCWAKE		;WAKE THE FONT COMPILER.  GIVE IT NEW STATUS
	PUSHJ	P,FCWAIT		;WAIT FOR FC TO RESPOND
	JRST	XERR3			;OOPS.
	JRST	CPOPJ1			;CALLER WILL INSPECT FC STATUS.


FCWAIT:	MOVE	TAC,XCLKNM
	LSH	TAC,=12
	ADD	TAC,[FCRQCK,,=60*JIFSEC]
	CONO	PI,PIOFF
	IDPB	TAC,CLOCK
	CONO	PI,PION
;HERE XGPSER WAITS FOR FC (OR TIMEOUT)
	SETOM	XGPFC1			;FLAG THAT WE ARE WAITING FOR FC
	SETZM	FCRQER			;INITIALLY, NO ERROR.
FCWAT1:	MOVNI	TAC,IOWQ
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,WSCHED		;DELAY
	SKIPE	XGPFC1			;IS THIS WAKEUP LEGITIMATE?
	JRST	FCWAT1			;NO. WAIT MORE.
	SKIPE	FCRQER			;CLOCK TIME OUT?
	POPJ	P,			;YES. FAILURE. (OOPS)
	AOS	TAC,XCLKNM		;CANCEL THE CLOCK REQUEST.
	CAILE	TAC,77
	SETZM	XCLKNM
	JRST	CPOPJ1			;RETURN SUCCESS.

FCRQCK:	CAME	TAC,XCLKNM
	POPJ	P,
	SETOM	FCRQER			;CLOCK ERROR
;HERE FC (OR TIMEOUT) WAKES XGPSER
XWAKE:	SETZM	XGPFC1			;XGP NOT WAITING FOR FC ANY MORE.
	PUSH	P,J
	MOVEI	DDB,XGPDDB
	LDB	J,PJOBN
	JUMPE	J,XWAKE1
	SKIPL	JBTSTS(J)		;DON'T START HIM IF HE CANT RUN
	JRST	XWAKE1
	MOVNI	TAC,RUNQ
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,REQUE
XWAKE1:	POP	P,J
	POPJ	P,

;HERE THE FC WAITS FOR XGPSER
XPAUSE:	SETOM	XGPFC2			;FC WAITS FOR SYSTEM
	HRRZM	PROG,XFCADR		;SAVE REL ADDRESS OF FC
	MOVNI	TAC,IOWQ
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,WSCHED
	SKIPE	XGPFC2
	JRST	XPAUSE			;WOKEN FOR THE WRONG REASON
	POPJ	P,

;HERE XGPSER WAKES UP THE FC
FCWAKE:	PUSH	P,J			;WAKE UP FC
	SETZM	XGPFC2			;FC NOT WAITING FOR SYSTEM ANY MORE
	SKIPLE	J,XFCJN			;SKIP IF THERE'S NO SUCH JOB
	SKIPL	JBTSTS(J)		;JOB EXISTS. SKIP IF IT CAN BE RUN
	JRST	XWAKE1			;CANT RUN OR NO SUCH JOB
	MOVNI	TAC,RUNQ
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,REQUE
	JRST	XWAKE1

;	MORE ROUTINES FOR FC
FCLOCK:	MOVEI	TAC,3
	MOVEM	TAC,XGPNST
	PUSHJ	P,FCREQ
	POPJ	P,			;TIME OUT.  ERROR CODE IS SET ALREADY
	SKIPE	XGPOST			;EXPECTED REPLY IS 'READY'
	JRST	FCERRX			;BARF! SET EXTENDED ERRORS
	JRST	CPOPJ1

FCKILL:	SETZM	XGPNST
	SETZM	XFTADR			;CLEAR OUT OUR MEMORY OF OLD FONTS
	MOVE	TAC,[XFTADR,,XFTADR+1]
	BLT	TAC,XFTADR+17
	SKIPG	TAC,XFCJN		;GET OLD JOB NUMBER
	POPJ	P,
	MOVSI	TAC1,XGPPRV
IFE FTSTAT,<
	TDNE	TAC1,JBTPRV(TAC)	;ARE WE SURE THIS IS THE RIGHT JOB?
	SETZM	JOBNAM(TAC)		;YES. CLEAR JOB NAME.
>;IFE FTSTAT
IFN FTSTAT,<
	TDNN TAC1,JBTPRV(TAC)
	JRST $FCKIL
	SETZM JOBNAM(TAC)
	PUSH P,J
	MOVE J,TAC
	PUSHJ P,NAMSTT
	POP P,J
$FCKIL:
>;FTSTAT
	ANDCAM	TAC1,JBTPRV(TAC)	;CLEAR OUT PRIVILEGES
	PUSHJ	P,FCWAKE		;WAKE HIM UP TO DIE.
	SETZM	XFCJN
	POPJ	P,

XBIDSP:	4001			;BITS ON FOR MODES THAT NEED FONTS

NFONT:	LDB	TAC,PIOMOD	;GET THE MODE AGAIN
	MOVEI	TAC1,1
	LSH	TAC1,(TAC)
	TDNN	TAC1,XBIDSP	;NEEDING A FONT?
	JRST	CPOPJ1		;NO.
	MOVEI	TAC,1		;ALLOCATE COMMAND
	MOVEM	TAC,XGPNST
	MOVE	TAC,XNTNOD	;NUMBER OF TEXT NODES
	IMULI	TAC,TNSIZE	;TIMES THEIR SIZE
	MOVEM	TAC,XGPNST+1	;STORE
	MOVE	TAC,XNVNOD	;NUMBER OF VECTOR NODES
	IMULI	TAC,VNSIZE	;TIMES THEIR SIZE
	ADDM	TAC,XGPNST+1	;ADD TO TEXT NODE SPACE, TOTAL NODE SPACE NEEDED
	PUSHJ	P,FCREQ		;REQUEST ALLOCATION FROM FC
	POPJ	P,		;LOSE.
	MOVE	TAC,XGPOST
	CAIE	TAC,1		;EXPECTED RESPONSE IS 'ALLOCATION MADE'
	JRST	FCERRX		;UNEXPECTED RESPONSE.
	MOVE	TAC,XGPOST+1
	MOVEM	TAC,XFREBA	;SAVE ADDRESS OF THE ALLOCATION.
	SKIPE	XFTADR		;YES. WE NEED A FONT. SKIP UNLESS WE HAVE ONE.
	JRST	CPOPJ1		;NO. MAKES THINGS EASY.
	SETZM	XGPNST+1
	SETZM	XGPNST+2
	SETZM	XGPNST+3
	SETZM	XGPNST+4
	MOVEI	TAC,2
	MOVEM	TAC,XGPNST
	PUSHJ	P,FCREQ
	POPJ	P,		;TIME OUT. ERROR CODE IS SET ALREADY.
	MOVE	TAC,XGPOST
	CAIE	TAC,2
	JRST	FCERRX		;ERROR. UNEXPECTED RESPONSE.  SET EXTENDED ERROR
	MOVE	TAC,XGPOST+1
	MOVEM	TAC,XFTADR	;STOW FONT ADDRESS
	JRST	CPOPJ1

F.LOSE:	MOVEI	IOS,IODTER		;USE THIS BIT FOR FC LOSSAGE
	JRST	XGPSET			;SET BIT IN IOS AND RETURN TO UUOCON.

;	INTERPROCESSOR COMMUNICATION AT CLOCK LEVEL. HUNG TIMEOUT

HUNG:	SKIPN	XGPAOK		;IS THE MAJIC CELL SET?
	JRST	HUNG1		;NO.. IT MUST REALLY BE HUNG
	SETZM	XGPAOK
	LDB	TAC,PDVTIM
	DPB	TAC,PDVCNT	;RESET HUNG TIME..
	JRST	CPOPJ1		;THE XGP IS STILL THERE.

HUNG1:	SETOM	XGPKIL		;KILL THE XGP
	MOVEI	IOS,IOIMPM	;TELL HIM AN ERROR.
	PUSHJ	P,XGPSET	;SET BITS
	PUSHJ	P,XERR6		;SET ERROR CODE
	TRNE	IOS,200		;IS USER ENABLED TO HANDLE HUNG XGP?
	AOS	(P)		;YES.  DON'T GIVE HIM HUNG DEVICE THEN.
	PUSHJ	P,XDMPO1	;SHUT OFF XGPGO, XGPBIT
	MOVE	IOS,[DEVSBB,,IOACT]
	PUSHJ	P,XGPCLR	;CLEAR IOACT AND KICK THE PDP-10

;PDP-10 HERE 
↑XGPP1:	SETZM	XGPP1F			;CLEAR REQUEST SET BY P2.
	MOVEI	DDB,XGPDDB		;DDB ADDRESS FOR STTIOD

	PUSHJ	P,PSYNCX
	MOVE	IOS,XGPIOS
	TLZE	IOS,IOW			;WAS HE IN WAIT?
	PUSHJ	P,STTIOD		;YES, GET HIM OUT FAST
	MOVEM	IOS,XGPIOS
	JRST	XSYNCX			;UNSYNCHRONIZE AND POPJ


;	PDP-6 HERE EVERY SECOND TO MAKE SURE THAT XGP IS RUNNING.
↑XGPP2:	MOVEI	TAC,JIFSEC
	MOVEM	TAC,XGPP2F		;BACK HERE IN 1 SECOND.
	MOVEI	TAC,0			;
	EXCH	TAC,P2CH2		;
	JUMPN	TAC,CPOPJ		;XGP HAS INTERRUPTED.
	CONSZ	XGP,XGPOK		;IS THE XGP STILL HAPPY?
	POPJ	P,			;NO. WELL, WHAT CAN I DO?
	CONO	PI,XGPOFF		;SNEAK IN.
	CONO	XGP,SETPI+XGPCHN+DONENB	;ASSIGN PI CHANNEL. WAIT FOR INTERRUPT.
	PUSHJ	P,XIHNG0		;SET UP TO RESYNCHRONIZE.
	CONO	PI,XGPON		;MAKE SURE CHANNEL IS LISTENING.
	POPJ	P,			;RETURN TO CLOCK LEVEL.
;	User Programming for the XGP
COMMENT $
	This  document reflects  the  state  of  the software  as  of
system 6.12/N.   Changes may be made without prior notice and without
maintaining compatability with earlier systems.

	The Xerox Graphics  Printer (XGP) provides a means  of making
a hardcopy listing  of virtually any drawing that can be expressed as
a one-bit raster.   The XGP  accepts as data  a bit array  describing
each  scan-line that  is printed.   Each  scan line  is approximately
1700 bits;  scan lines  are spaced at  about 190  per inch along  the
paper.   A picture is  built by sending successive  scan lines to the
XGP.

	There are presently two distinct modes  of operating the XGP,
video mode and character mode.

	Video Mode

	In video mode,  36 bit words  are interpreted as  video data.
Words  are grouped together into  portions of a scan-line  by the use
of a Group Command Word (GCW).  The GCW precedes the data  portion of
the group.  The GCW specifies how  many words of video data are to be
found  in this  group.   Also  the GCW  allows the  video data  to be
positioned anywhere along  the scan  line.  The  exact format of  the
GCW is:

	BYTE (1)MARK (11)LNSKIP (12)COLSKP (6)UNUSED, DWCNT

	The fields of the GCW are interpreted as follows:

	The  paper will  be advanced  by  LNSKIP blank  lines
	before  printing.   LNSKIP =  1  is used  for normal,
	single spacing. LNSKIP  = 0  prevents any advance  to
	the next  scan line  and prints on  the same  line as
	the last group.

	The column register in the XGP  interface will be set
	to COLSKP before transmitting data. 

	DWCNT words following the GCW will  be transmitted to
	the  XGP as  video data  (a bit  = 0  is white,  1 is
	black). If DWCNT = 0 then there are no data words  in
	this group and the next word is another GCW.

	After data is sent,  if the MARK bit is  1, the paper
	will  be marked  for cutting.   Paper cutting  is not
	exact so a MARK  should be preceeded and followed  by
	several blank lines.

	The field  labeled UNUSED  has no  meaning currently.
	It  should be set to zero  to avoid confusion if some
	other meaning is attached to this field.


	
	Modes 17  and 117  are used  for video  data.   All of  these
modes accept the format that is described above.

	In mode 17,  the effective address of the OUT uuo points to a
standard dump  mode command  list.   The command  list specifies  the
data  to send  to the  XGP.   Each  OUT  will wait  until the  entire
command  list is processed before  returning to the  user.  The paper
will be cut at the completion of each command list.  

	Mode 117 is like mode  17 except that the OUT uuo  returns to
the user while data is being  sent to the XGP.  In this mode the user
can overlap the input of one  data block with the output of  another.
Three data blocks are  needed in this mode: one being  emptied by the
XGP, another  pending, and another being filled  by the user program.
The first two  OUT uuos will  return immediately (having  established
the current  and pending output  blocks).   After the user  fills his
third block  and gives an OUT uuo he will be forced to wait until the
current block  is  empty (at  which time  the  pending block  becomes
current and  the  block specified  in this  OUT will  become the  new
pending block).   When the third OUT returns, the first block will be
free to use.  In  video mode the XGP  requires up to 10,000 words  of
data per second.   Care should be exercised in  programming to always
have data ready for the XGP.

	Another requirement  of mode  117 is  that the command  lists
that  point to the  three data blocks  must be disjoint.   The actual
requirement is that  the command list  for each  block must be  valid
while the block is  being output.  In particular, don't  use the same
physical location in your program for more than one command list.

	In mode 117 you must do a CLOSE UUO  after the last OUTPUT to
force  the transmission of  all buffers to  the XGP.   It is possible
that a user  program may not be  able to supply  data fast enough  in
mode 117.  In this event,  the output will  be cut wherever  the data
runs  out.  A status bit, 2000  (IOTEND), is provided which warns the
program that this  has occurred.   This bit is  set only in mode  117
when the data runs out and no CLOSE has been done.

$
;	INTERRUPT LEVEL ROUTINES
;LOCATIONS MARKED WITH *1 ARE FIRST LEVEL DISPATCH TARGETS.
;LOCATIONS MARKED WITH *2 ARE SECOND LEVEL DISPATCH TARGETS.
;LOCATIONS MARKED WITH *4 ARE DISPATCH TARGETS AT PI CHANNEL 4. (TEXT MODE)
       

SDISP1:	MOVEM	TAC,XDISP1		;JSP TAC,SDISP1 TO SET NEW DISPATCH ADDRESS
	POPJ	P,			;JSR XGPSAV MUST HAVE BEEN DONE ALREADY.

↑XGPINT:
	CONO	XGP,SETALL≠PAPER	;CLEAR DONE. SET DONE ENABLE, ETC.
	SOSLE	XFLAPC			;DECREMENT FLAPPER COUNT
	JRST	XGINT1
	MOVEM	TAC,XGPTMP		;SAVE TAC
	MOVEI	TAC,=100
	MOVEM	TAC,XFLAPC		;SET UP FLAPPER COUNT
	MOVE	TAC,XFLAPA		;WORD 1
	EXCH	TAC1,XFLAPB		;WORD 2
	LSHC	TAC,1			;SHIFT THEM BOTH
	MOVEM	TAC,XFLAPA		;STORE 1
	EXCH	TAC1,XFLAPB		;AND 2
	TRNE	TAC,1000		;TIME TO FLAP?
	DATAO	500,[20,,0]		;YES: FLAP THE FLAPPER
	MOVE	TAC,XGPTMP

XGINT1:	SOSE	XCUTQ			;TIME TO CUT NOW?
	JRST	XGINT2			;NO.
	CONO	XGP,SETCON!CUTNOW
	SOS	XCUTBP
	MOVEM	TAC,XGPTMP
	MOVE	TAC,[XCUTQ+1,,XCUTQ]
	BLT	TAC,XCUTQ+=46		;MOVE QUEUE NODES DOWN
	MOVE	TAC,XGPTMP

XGINT2:	CONSZ	XGP,XGPOK		;IS THE XGP STILL ALIVE?
	JRST	XIHUNG			;INTERFACE REPORTS XGP LOSSAGE.
	SETOM	XGPAOK			;TELL PDP-10 THAT WE STILL SEE INTERRUPTS.
	CONO	XGP,SETX
	CONO	XGP,SETCON!SWPBUF
	CONO	XGP,SETX
	JRST	@XDISP1			;DISPATCH LEVEL1


;*1	HERE TO ESTABLISH XGP SYNCHRONIZATION.
XGSYNC:	SETZM	XGPIGO
	SOSLE	XYNCNT			;COUNT BUFFER SWITCHES.
	JEN	@XGPCHL			;DISMISS INTERRUPT
	JSR	XGPSAV
	MOVEI	TAC,=4096
	MOVEM	TAC,XYNCNT
XGIDLE:	JSP	TAC,SDISP1		;WE ARE NOW IN SYNC. -SET TO IDLE

;*1	HERE TO MAINTAIN SYNCHRONIZATION.
	MOVEM	TAC,XGPTMP
	MOVE	TAC,XGPBIT
	JUMPN	TAC,XGSYGO		;IS THE PDP-10 REQUESTING ACTION?
	MOVE	TAC,XGPTMP
	JEN	@XGPCHL			;KEEP IDLING.

XGSYGO:	MOVE	TAC,XGPTMP
	JSR	XGPSAV
	MOVEI	TAC,=600		;SET UP COUNT
	MOVEM	TAC,XGPCNT
	JSP	TAC,SDISP1		;SET NEW DISPATCH AND DISMISS

;*1 	RUN THE PAPER FOR 600 LINES UNTIL IT'S GOING FAST ENOUGH.
	CONO	XGP,SETALL		;START THE PAPER.
	SOSLE	XGPCNT
	JEN	@XGPCHL
	JSR	XGPSAV
	MOVSI	IOS,XPAPER
	PUSHJ	P,PSYNCX		;SET A BIT IN IOS,
	IORM	IOS,XGPIOS
	MOVE	IOS,XGPBIT		;THIS CELL HOLDS THE PDP-10'S DESIRES.
	JUMPE	IOS,.+2
PAPOON:	SETOM	XGPP1F			;TELL PDP-10 TO LOOK.
	MOVE	IOS,[DEVSBB,,IOACT]
	ANDCAM	IOS,XGPIOS
	PUSHJ	P,XSYNCX
	JSP	TAC,SDISP1		;SET NEW DISPATCH.

;*1	HERE WE WAIT UNTIL PDP-10 SAYS DATAREADY
	CONO	XGP,SETALL
	JSR	XGPSAV
	MOVE	IOS,XGPKIL
	JUMPN	IOS,XMITFF		;JUMP IF PDP-10 IS KILLING THIS TRANSFER.
	MOVE	IOS,XGPGO
	JUMPE	IOS,CPOPJ
	JSP	TAC,SDISP1		;SET NEW DISPATCH AND DISMISS.

;*1	HERE FOR INTERRUPT AND WE WANT TO SEND DATA.
XMITIN:					;DATA TRANSMIT INTERRUPT.
	SETOM	XGPIGO			;I-LEVEL DATA TRANSFER IN PROGRESS.
	CONO	XGP,SETALL		;CLEAR DONE, SET DONE ENABLE,PI, AND PAPER
	JSR	XGPSAV			;SAVE ALL AC'S FOR I LEVEL CODE.
	MOVE	TAC,XGPKIL		;LOOK TO SEE IF PDP-10 HAS TIMED OUT
	JUMPN	TAC,XMITFF		;PDP-10 THINKS WE'RE HUNG. STOP QUICK.
	PUSHJ	P,@XDISP2		;DISPATCH ACCORDING TO DATA MODE.
	POPJ	P,			;NORMAL RETURN. DISMISS.
	JRST	XMITFG			;END OF TRANSFER.
XMITFF:	PUSHJ	P,QCUT			;FORCED END. CUT PAPER.
XMITFG:	MOVEI	PID,P2PID		;MAKE SURE PID IS RIGHT.
	PUSHJ	P,PSYNCX
	MOVE	IOS,[DEVSBB,,IOACT]
	ANDCAM	IOS,XGPIOS
	SETZM	XGPBIT			;CLEAR XGPBIT SO IF THE 10 HANGS, WE DONT
	SETZM	XGPIGO			;I-LEVEL DATA XFER IDLE.
	SETOM	XGPP1F			;TELL PDP-10 THAT DATA XFER COMPLETE
;TRANSMISSION DONE. COUNT AS THE PAPER RUNS OUT 5000 LINES.
;CUT THE PAPER EVERY 2200 LINES (11 INCHES) SO THE STACKER WILL NOT HAVE
;20 INCH PAGES TO CONTEND WITH.
	MOVEI	TAC,=16
	MOVEM	TAC,XGPCNY		;16 TIMES 263 LINES
XMITD1:	PUSHJ	P,XSYNCX		;RELEASE INTERLOCK
	MOVEI	TAC,=275
	MOVEM	TAC,XGPCNT
	JSP	TAC,SDISP1

;*1	HERE AFTER COMMAND LIST HAS RUN OUT. COUNT PAPER FEED.
	SOSLE	XGPCNT			;COUNT PAPER FEED
	JEN	@XGPCHL
	JSR	XGPSAV
	PUSHJ	P,PSYNCX
	SOSLE	TAC,XGPCNY
	TRNN	TAC,7
	PUSHJ	P,QCUT0			;QUEUE CUT (MARK PAPER TOO SO WE DON'T FORGET)
	JUMPG	TAC,XMITD1		;TIME TO STOP COUNTING THE PAPER?
	MOVSI	IOS,XPAPER		;WE WANT TO CLEAR THIS.
	MOVE	TAC,XGPBIT		;DOES PDP-10 HAVE THIS BIT ON?
	JUMPN	TAC,PAPOON		;YES. THEN DON'T CLEAR IT!
	ANDCAM	IOS,XGPIOS
	PUSHJ	P,XSYNCX
	JRST	XGIDLE			;SET IDLE DISPATCH.
;	HERE FOR 'NOT XGPOK'	ALSO, QUEUE CUT MARKS.
XIHUNG: JSR	XGPSAV
	MOVE	TAC,XGPBIT		;ARE WE SUPPOSED TO BE DOING SOMETHING?
	MOVSI	IOS,XPAPER		;
	TDNN	IOS,XGPIOS		;
	JUMPE	TAC,XIHNG0		;WE HAVE BEEN IDLE.
	PUSHJ	P,PSYNCX
	SETZM	XGPBIT			;WE ARE GOING TO BE IDLE.
	MOVEI	TAC,IODERR		;SET ERROR FLAG.
	IORM	TAC,XGPIOS
	ANDCAB	IOS,XGPIOS		;TURN OFF XPAPER IN XGPIOS.
	PUSHJ	P,XERR6			;XGP IS NOT OK.
	SETOM	XGPP1F			;TELL THE PDP-10 WE LOST.
	PUSHJ	P,XSYNCX
XIHNG0:	MOVEI	TAC,=4096
	MOVEM	TAC,XYNCNT
	MOVEI	TAC,XGSYNC		;SET DISPATCH TO RESYNCHRONIZE XGP.
	MOVEM	TAC,XDISP1		;
	MOVEM	TAC,XGPIGO		;NOT IN DATA PORTION OF I-LEVEL
	POPJ	P,			;(POSITIVE DENOTES UNHAPPY!)

QCUT0:	CONO	XGP,SETCON!MARKIT	;MARK PAPER TOO (SO WE DON'T FORGET)
QCUT:	PUSH	P,TAC
	PUSH	P,TAC1
	MOVEI	TAC,XCUTQ		;GET THE ADDRESS OF THE CUT QUEUE
	MOVEI	TAC1,=4650		;THIS IS THE CUT DELAY (TWIDDLE)
QCUT1:	CAILE	TAC,@XCUTBP		;ARE WE STILL IN THE LIST?
	JRST	QCUT2			;NO. (DONE)
	SUB	TAC1,(TAC)		;DECREMENT
	AOJA	TAC,QCUT1		;LOOK FOR MORE

QCUT2:	CAILE	TAC1,=100		;CUT TOO SMALL?
	IDPB	TAC1,XCUTBP		;NO. ADD IT TO THE QUEUE
	POP	P,TAC1
	JRST	TPOPJ			;RESTORE TAC AND RETURN

;	MODE 17 I-LEVEL
;XGPIWD HAS ABSOLUTE AOBJN POINTER
;XGPMDP HAS PROG,,REL ADDRESS OF THIS IOWD.
;XGPROG HAS RELOCATION OF CURRENT JOB.

;*2	HERE AT FIRST LINE OF TRANSFER, OR FIRST LINE OF PAGE
XDI:	SETZM	XSCNLN				;COUNT SCAN-LINES.
	MOVEI	TAC,XDILIN
	MOVEM	TAC,XDISP2
	JRST	XDILIN

XDI4:	JSP	AC3,XADV			;HERE TO ADVANCE TO NEXT COMMAND

;*2	HERE WE KNOW THAT WE ARE ON A NEW SCAN LINE.
XDILIN:	MOVE	TAC,XGPIWD			;GET CURRENT IOWD
	JUMPGE	TAC,XDI4			;JUMP IF IT HAS RUN OUT.
XDI0:	MOVE	DAT,(TAC)			;GET GROUP COMMAND WORD.
	MOVEM	DAT,XGPGCW			;SAVE IT.
	LDB	DAT,LNSKIP			;GET THE LINE SKIP COUNT
	ADDM	DAT,XSCNLN			;COUNT SCAN-LINES
	SOJLE	DAT,XDI1			;JUMP IF THERE ARE NO LINES TO SKIP.
	MOVEM	DAT,XGPCNT			;SAVE COUNT
	JSR	XDISP2				;SET DISPATCH AND DISMISS INTERRUPT.

;*2	HERE TO SKIP LINES FOR A WHILE.
	SOSLE	XGPCNT				;DECREMENT COUNT OF LINES TO SKIP.
	POPJ	P,				;DISMISS
	MOVEI	DAT,XDILIN			;RESET INTERRUPT DISPATCH
	MOVEM	DAT,XDISP2
	MOVE	TAC,XGPIWD			;REFORM AC'S.
XDI1:	LDB	DAT,COLSKP			;HOW FAR TO SKIP?
	CONO	XGP,SETX(DAT)			;SET X POSITION IN XGP
	AOBJN	TAC,.+1				;ADVANCE AOBJN POINTER.
	MOVEM	TAC,XGPIWD
XDI1A:	HLRO	TAC1,TAC			;GET -(COUNT REMAINING)
	MOVM	TAC1,TAC1			;GET (COUNT REMAINING)
	LDB	AC1,DWCNT			;GET DATA COUNT FROM USER
	MOVEI	DDB,(AC1)			;A COPY.
	CAILE	AC1,(TAC1)			;DATA COUNT SHOULD BE SMALLER
	MOVEI	AC1,(TAC1)			;SET TO MAX ALLOWED COUNT.
	SUBI	DDB,(AC1)			;REMAINDER AFTER OVERFLO.
	DPB	DDB,DWCNT			;SAVE REMAINDER.
	MOVEI	TAC1,(AC1)			;AND THIS IS HOW WE FIX IOWD
	HRLI	TAC1,(TAC1)
	ADDM	TAC1,XGPIWD			;FIX AOBJN POINTER.
	JUMPE	AC1,XDI3			;POSSIBLE ZERO DATA WORDS.
	MOVNI	AC1,(AC1)			;AND FORM AOBJN POINTER IN TAC
	HRLI	TAC,(AC1)
	MOVE	AC1,TAC				;AOBJN POINTER IN AC1
	MOVEM	P,XGPTMP			;SAVE PUSHDOWN POINTER
	MOVSI	13,XDI2				;SOURCE,,DESTINATION
	BLT	13,13				;STUFF CODE IN AC'S
	JRST	XDI2A				;JUMP INTO THE START
						;RUN THE INNER LOOP IN THE AC'S.

XDI2:
	PHASE	0				;CODE ASSUMES AC1>13
XDI2A::	MOVE	AC3,(AC1)			;0 GET 36 BITS OF VIDEO DATA.
	MOVEI	AC2,0				;1
	LSHC	AC2,=16				;2
	DATAO	XGP,AC2				;3 SEND 16 BITS
	MOVEI	AC2,0				;4
	LSHC	AC2,=16				;5
	DATAO	XGP,AC2				;6 ANOTHER 16
	LSHC	AC2,=16				;7
	IORI	AC2,200004			;10 OR BITS FOR SPECIAL MODE, WIDTH 4.
	DATAO	XGP,AC2				;11 SEND DATA
	AOBJN	AC1,XDI2A			;12 LOOP.
	JRST	XDI2B				;13
	DEPHASE

XDI2B:	MOVE	P,XGPTMP			;RESTORE P
	MOVEI	PID,P2PID			;RESTORE PID
	LDB	TAC,DWCNT
	JUMPE	TAC,XDI3			;JUMP IF NO IOWD OVERFLOW.
	JSP	AC3,XADV			;ADVANCE TO NEW IOWD.
	MOVE	TAC,XGPIWD			;GET A NEW AOBJN POINTER.
	JRST	XDI1A				;PROCESS MORE VIDEO.

XDI3:	SKIPGE	XGPGCW
	PUSHJ	P,XDICUT			;MAKE PAPER GET CUT
	SKIPL	TAC,XGPIWD			;PEEKING AT NEXT GCW
	POPJ	P,				;IOWD RAN OUT-NO NEXT GCW
	LDB	DAT,[POINT 11,(TAC),11]		;GET THE LINE SKIP FROM NEXT GCW
	JUMPE	DAT,XDI0			;IF COUNT=0, DO MORE ON THIS LINE.
	POPJ	P,				;RETURN. DONE WITH LINE.

XDICUT:	PUSHJ	P,QCUT				;QUEUE A PAPER CUT
	MOVEI	TAC,XDI
	MOVEM	TAC,XDISP2
	MOVE	TAC,XSCNLN
	CAIL	TAC,=2000
	CAILE	TAC,=2200
	POPJ	P,				;PAGE SIZE IS UNUSUAL
	MOVEI	TAC,1
	IORM	TAC,XFLAPB			;FLAP THE FLAPPER (LATER)
	POPJ	P,				;
;	XADV	ADVANCE IOWD AT I-LEVEL
XADV:	SKIPE	TAC1,XGPBIG		;PART OF A BIG TRANSFER LEFT?
	JRST	XADV2			;YES. SKIP SOME CODE
	MOVE	PROG,XGPROG		;HERE THE IOWD RAN OUT.
	SKIPN	XGPMDP			;IS THERE A COMMAND IN PROGRESS?
	JRST	XADV3			;NO. GET THE NEW COMMAND IF ANY.
	AOS	TAC1,XGPMDP		;GET RELATIVE POINTER AND INCREMENT
XADV1:	HRLI	TAC1,PROG
	MOVEM	TAC1,XGPMDP
	MOVE	TAC1,@TAC1
	JUMPE	TAC1,XADV3		;COMMAND HAS RUN OUT. SEE IF ANOTHER
	TLNN	TAC1,-1
	JRST	XADV1			;FOLLOW JUMPS
	ADDI	TAC1,1(PROG)		;MAKE IT ABSOLUTE AOBJN WORD.
	MOVEM	TAC1,XGPIWD		;STORE AOBJN WORD.
	JUMPL	TAC1,(AC3)		;RETURN IF SMALL AOBJN WORD.
	TLC	TAC1,400000		;MAKE COUNT 400000 SMALLER.
	MOVEM	TAC1,XGPIWD		;SAVE THE SMALL PART TO DO FIRST
	HLRE	PROG,TAC1		;GET - COUNT OF FIRST PART
	SUB	TAC1,PROG		;CALC FIRST ADDR OF SECOND PART
	HRLI	TAC1,400000		;THIS IS HOW MANY WORDS
	MOVEM	TAC1,XGPBIG		;FLAG MORE TO DO
	JRST	(AC3)

XADV2:	MOVEM	TAC1,XGPIWD
	SETZM	XGPBIG			;ONLY ONCE
	JRST	(AC3)

XADV3:	MOVE	TAC1,XGPNXC		;SWAP ZERO FOR THE NEW COMMAND
	JUMPE	TAC1,XADV4		;FINISHED IF NO NEW COMMAND
	SETZM	XGPNXC			;CLEAR NEW COMMAND
	SETOM	XGPP1F			;KICK THE PDP-10
	JRST	XADV1			;AND PROCESS THE NEW COMMAND

XADV4:	SETZM	XGPMDP			;NO MAJOR COMMAND
	AOS	(P)			;WE SHALL STOP XGP ON RETURN
	PUSHJ	P,PSYNCX
	MOVE	IOS,XGPIOS
	TRNE	IOS,100			;OVERLAPPED MODE?
	TLNE	IOS,IOEND		;YES.  CLOSE UUO DONE YET?
	JRST	XSYNCX			;NOT OVERLAPPED OR CLOSE DONE.
					;RELEASE SYNCHRONIZER AND STOP XGP.
	MOVEI	IOS,IOTEND		;OVERLAPPED MODE, END OF DATA AND NO CLOSE.
	IORM	IOS,XGPIOS		;TURN ON ERROR BIT
	JRST	XSYNCX			;RELEASE SYNCHRONIZER.
;	BUFFER ADVANCE AT I-LEVEL
;BFOSET IS CALLED AT THE BEGINNING OF EACH SCAN LINE TO CALCULATE AN
;AOBJN POINTER TO THE SYSTEM BUFFER. POINTER IS RETURNED IN TAC.

;BFNSET IS CALLED AT THE END OF EACH SCAN LINE TO ADJUST THE BUFFER COUNTS
;AND THINGS. ARGUMENT IS TAC, THE REMAINDER OF THE AOBJN POINTER.

;IF THE AOBJN POINTER RUNS OUT IN THE MIDDLE OF A SCAN LINE IT MAY BE DUE
;TO EITHER WRAP AROUND OR LACK OF DATA. CALL BFNSET TO REFORM PARAMETERS
;FOLLOWED BY BFOSET TO GET A NEW POINTER.  IN CASES OF NO DATA LEFT IN THE
;BUFFER, TAC WILL COME BACK AS A POSITIVE QUANTITY.

BFOSET:	MOVN	AC1,XBFCNT			;GET -DATA COUNT IN BUFFER.
	MOVE	TAC,XTAKE			;GET TAKE POINTER
	SUB	TAC,XIBFND			;MAKE -COUNT FROM TAKE TO THE END.
	CAMGE	AC1,TAC				;SKIP IF DATA DOESN'T WRAP.
	MOVE	AC1,TAC				;WRAP AROUND. DO THE REST LATER.
	MOVE	TAC,XTAKE
	HRLI	TAC,(AC1)			;FORM AOBJN POINTER IN TAC
	MOVEM	TAC,XGPIWD			;SAVE HERE TOO.
	JRST	(AC3)				;RETURN.

BFNSET:	MOVE	AC1,XTAKE
	SUBI	AC1,(TAC)			;COMPUTE -COUNT OF WORDS USED UP.
	HLLI	TAC,				;CLEAR TAC LEFT.
	CAML	TAC,XIBFND			;DID WE WRAP AROUND?
	MOVE	TAC,XIBUF			;YES. RESET TAKER
	MOVEM	TAC,XTAKE
	PUSHJ	P,PSYNCX
	ADDB	AC1,XBFCNT			;DECREASE COUNT OF SPACE IN USE.
	CAMG	AC1,XGPWSZ			;IS IT PROPER TO REACTIVATE PDP-10?
	SKIPN	XGPWSZ				;YES. SPECIAL FLAG FOR CLOSE?
	JRST	BFNST1				;NOT TIME YET, OR CLOSE IN PROGRESS
	MOVSI	IOS,DEVSBB
	ANDCAM	IOS,XGPIOS			;SYSTEM BUFFER NOT BUSY.
	SETOM	XGPWSZ				;DON'T REACTIVATE AGAIN SOON.
	SETOM	XGPP1F				;ACTIVATE PDP-10
BFNST1:	PUSHJ	P,XSYNCX
	JRST	(AC3)
;	Character Mode for the XGP
COMMENT $

	Modes 0 and 13 are the character modes in  the XGP.  In these
modes,  36 bit words are  interpreted as five 7-bit  bytes.  There is
no fixed mapping between byte values and particular  graphic symbols.
The graphic  symbol for any  byte is defined  by the current  font in
use.  Certain  byte  values have  special  meanings  consistient with
ASCII and  one byte  value, octal  177, is  used as  an escape  which
gives the bytes that follow a special meaning.

	Character  mode  permits vectors  and  multiple  active  text
lines.

	Character mode interprets  7-bit bytes taken from  the user's
buffer as follows:

Byte	Usual meaning			Escape significance

0	Null - byte is ignored		Normal
1	Normal				XGP ESCAPE 1
2	Normal				XGP ESCAPE 2
3	Normal				XGP ESCAPE 3
4	Normal				XGP ESCAPE 4
5-10	Normal				Reserved
11	TAB				Normal
12	LF				Normal
13	Normal				Reserved
14	FF				Normal
15	CR				Normal
16-37	Normal				Reserved
40-176	Normal				Normal
177	ESCAPE				Normal

Normal means the definition of this byte in  the current font will be
printed.  If this byte is  undefined in the current  font, it will be
ignored.

ESCAPE causes the next  byte to  have an  alternate meaning  selected
from the column "Escape significance".

TAB produces  a column  select to  the column which  is at  least the
width  of a blank  to the right  of the current  column position, and
some multiple of 8 blank widths to the right of the left margin.

LF activates the current  text line. The current text  will be queued
to printed.   The default Y position of text  will be advanced by the
number of scanlines it  takes to draw this  line, plus the number  of
lines specified  by the  interline space argument  to the  margin set
MTAPE.   This default Y position will be  used for the next text line
(unless changed by a vector command or ESCAPE-3.

FF, like  LF, activates  the text.   In  addition, FF  causes a  page
eject  after the  current text  line is  printed.   FF also  sets the
defalut Y position to the first line below the top of page  margin on
the new page.

CR  causes  a  column  select  to  the  current  left  margin  to  be
generated.

XGP ESCAPE  1 ('177&'001) causes  the next  7 bits  to be  read as  a
special operation code.  The following codes are implemented:

	0-17	Font select.
		The code, 0 to 17 is taken as the font identification
		number of the font to use.

	20-37	Reserved for future use.

	40	XGP Column Selector
		The  next  14  bits  are taken  modulo  4096  as  the
		x-position to print  at next.  (The  intention  is to
		allow arbitrary width spaces for text justification.)

	41	XGP Underscore
		The next byte (in two's complement)  is  the relative
		scan line  on which the underscore is to occur, where
		0  represents  the  baseline  of  the  text, negative
		values   represent   lines  above  the  baseline  and
		positive  values  lines  below  it.  The next 14 bits
		(modulo 4096) specify the length of  the  underscore.
		(If  the  underscore command is the first thing on  a
		line, the baseline will be set to the baseline of the
		current font.)

	42	Line space.
		This does  a line feed and then takes the byte as the
		number of blank lines to insert before the next line.

	43	Base-line adjust.
		The next  7 bits are taken in two's complement as the
		base-line adjustment  to  the  current  font.     The
		adjustment sticks  until  reset  by  another   adjust
		command or a font select. The intention is to allow a
		font to be  used  for  subscripts  and  superscripts.
		(Increment baseline  for  superscript,  decrement for
		subscript).  

	44	Print the paper page number.
		The paper page number is set to 1 by a form feed.  It
		is  incremented  each  time  the  paper  is cut.  The
		decimal value of this count is printed.

	45	Accept heading text.
		The next  byte  is a  count of bytes to follow. Those
		bytes  will be read into the heading line.  When that
		count is exhausted, the heading line will be printed.
		If a line feed or line space command  is  given  that
		would cause text to be printed below the current text
		area,  a  form  feed  is inserted by the XGP and if a 
		heading is defined, it will be printed.

	46	Start Underline.
		Set the left end of an underline. See Stop Underline.

	47	Stop Underline.
		The  next byte is the scan line on which to write the
		underline (same as XGP Underscore).   The  extent  of
		the underscore is defined by this command  and  Start
		Underline. If this command is not preceded by a Start
		Underline, the results will be unpredictable.  Beware
		of column selects.  No  underline  will  happen until 
		this command is given.

	50	Set Inter-Character Space.  The next byte is taken as
		the  column  increment to add  after  each character. 
		Note:   this takes a major amount of extra compuation
		in the Stanford implementation.   Use of this feature
		may produce documents that cannot be listed.

XGP ESCAPE 2  ('177&'002) causes the next 7  bits to be taken  as the
column  increment.    This  quantity  is  signed: 0-77  are  positive
increments 100 to 177 are negative increments (100 → -100, 177 → -1).

XGP ESCAPE 3 ('177&'003) causes  the next 2 bytes to be  taken as the
scan line  number on which to  start this text line.   Scan line 0 is
the first  scan line  on the  page (immediately  following the  cut).
The topmost scanline  of the present text line will  be placed on the
scan  line indicated in this  command.  (If there  is no current text
line, the next text line will be put there.)

XGP ESCAPE 4 ('177&'004).   This escape is used to  specify a vector.
It is followed by 11 bytes describing the vector:

	2 bytes	Y0	Scan line number of first line of vector.
	2 bytes X0	Column  position of left  edge of first  line
			of the vector.
	3 bytes DX	Delta X. 1 bit of sign; 11  bits  of integer;
			9 bits of fraction.
	2 bytes N	The number of scan lines on which this vector
			is visible.
	2 bytes W	The column width of each scan-line.

The  XGP   service  must   be  presented   with  vectors  sorted   by
ascendending  values  of Y0.   If  the  vectors are  not  sorted, the
output will be wrong.

The escape significance  of codes 5 through  10,  13, and  16 through
37 is not defined at the present time but reserved for future use.

$
;	MODE 0	COMMENTS ABOUT INTERNAL STRUCTURE.
COMMENT $
	The code  to process  text in mode  0 is  broken up into  two
phases.   There is  the 'line assembly'  phase which  occurs once per
text line  and  the 'scan'  phase  which  occurs once  per  generated
scanline.

	The 'scan' phase  is intended to  be quite simple.  The inner
loop for this phase  is at SCANX, and runs in the accumulators on the
PDP-6.   The  scan phase  excutes commands  from  a buffer  that  was
generated during  the line  assembly.  The  buffer has  the following
format:

XLINE:
	CAIL	AC1,MIN 		;←----(UCHN - MAJOR COMMAND)
	CAIL	AC1,MAX
L1:	JRST	L2			;JUMP TO NEXT MC
	MOVEI	TAC,(AC1)
	SUBI	TAC,@.-4
	ROT	TAC,-1
	JSP	AC2,.+2	
	0,,L8				;POINT TO NEXT MINOR GROUP
					;USED BY JRST @(AC2)

;THIS GROUP MAY BE REPEATED FOR EVERY EXPLICIT COLUMN SELECT.-------------⊗
	CONO	XGP,140000+COLUMN	;COLUMN SELECT FOR MINOR GROUP	  |
	JSP	AC3,SCAN		;CALL ROUTINE TO TRANSMIT DATA	  |	
 	-N,,.+1				;←----(DSER - CURRENT AOBJN)	  |
	BLOCK	N			;DATA TO SEND 			  |
;-------------------------------------------------------------------------⊗

	JRST	@(AC2)
L2:	CAIL	AC1,MIN			;SECOND MAJOR COMMAND
	CAIL	AC1,MAX
L3:	JRST	L6			;JUMP TO NEXT MC
	MOVEI	TAC,(AC1)
	SUBI	TAC,@.-4
	ROT	TAC,-1
	JSP	AC2,.+2
	0,,L5				;POINT TO NEXT MINOR GROUP
	CONO	XGP,
	JSP	AC3,SCAN
	-N,,.+1
	BLOCK	N
	JRST	@(AC2)
L4:	JSP	AC2,.+2
	0,,L1				;POINT TO NEXT MINOR GROUP
	....
	JRST	@(AC2)
L5:	JSP	AC2,.+2
	0,,L3
	...
	JRST	@(AC2)
L6:	CAIL	AC1,MIN
	CAIL	AC1,MAX
L7:	JRST	CPOPJ
	MOVEI	TAC,(AC1)
	SUBI	TAC,@.-4
	ROT	TAC,-1
	JSP	AC2,.+2
	0,,L7
	...
	JRST	@(AC2)
L8:	JSP	AC2,.+2
	0,,L4
	...	
	JRST	@(AC2)

In  an attempt  to provide  job  security, the  author  made this  so
complicated  that no one else  can understand it.   That he failed is
evident: he doesn't understand it either.

Pending Queue and Active Lists.
The line compiler processes  text and compiles text nodes  and vector
nodes.   These nodes  are queued  on a single  list.  The  Scan Phase
processes these queues and  activates nodes at the appropriate  time.
There are 4  kinds of nodes; narrow vectors, wide  vectors, text, and
page mark.  Each of  these node types (except the page  mark node) is
linked  onto a separate  list for  the per-scanline processing.   The
page mark node causes all active nodes to be cancelled.

   Narrow Vector  Wide Vector	Text		Page
	
0  Link		  Link		Link		Link
1  Y0		  Y0		Y0		Y0
2  X0,,n	  X0,,n		-n		0
3  Width	  Width		Link-2		-1
4  DX		  DX		Unspecified	EOFFLG

Y0 in  all  cases denotes  the scan  line  number on  which the  node
becomes active. 'n'  denotes the number of lines on which the node is
active.  The  nodes are  all queued on  a single pending  list.   The
nodes are distinguished  by word 2 (negative means text  node) and by
word  3 (negative means page node,  narrow and wide are distinguished
by the values of Width).

Vector nodes are 5 words.  Text nodes are 64. words.

The first interrupt to  transmit data activates XCIBEG in  channel 2.
This routine arranges  for XCPINI, the compiler initialization, to be
run in  channel  4, and  it actiavates  an  interrupt in  channel  4.
XCIBEG also  initializes the  pending queue and  the active  lists to
empty.

Subsequent  channel 2 interrupts  will inspect the  pending queue and
activate the first  node on that queue  when ready.  Nodes  that have
been activated are  linked onto one of the three active lists. (There
is no list  for page  nodes, since only  one can be  active).   After
activating  any pending  nodes that  have become  active, the  active
lists  are  processed.    As  each  active  node  is  processed,  its
activation  counter is  decremented.    When the  activation  counter
reaches 0,  the node is deactivated  by delinking it  from the active
list and linking it to the appropriate free list.  Whenever additions
to the free lists are made, the compiler is activated.

Page  mark  nodes  are  treated specially.    When  such  a  node  is
activated  the paper is  marked for cutting.   Since  there should be
nothing active across the cut mark, all active nodes  are deactivated
without further processing and returned to free storage.  If the cell
EOFFLG in the page mark node contains  a non-negative quantity,  that
signifies that the  end of text processing has been reached.  Channel
2 will  exit  to the  co-routines that  feed  paper and  prepare  for
another transfer.

The active  vector nodes are  processed quite simply.   X←X+dX.   The
vector is  drawn at the new X position for  the specified width.  The
only peculiarity  about vectors  is the  separation,  by width,  into
narrow and wide  vectors.  This separation is  necessary because wide
vectors  take longer to process  in the XGP  interface and no further
interface commands  may be issued  until the  processing of the  wide
vector stops.

Active text  nodes are  processed by  loading AC1  with the  scanline
number and  executing the subroutine that was  compiled into the text
node.  The  text subroutine is  called with  a PUSHJ P,  instruction.
The first location of the subroutine is the fourth word of the node.

The compiler is initialized at XCPINI.  The  address of XCPINI is set
into X2DISP, the  compiler co-routine restart address, by XCIBEG. The
initialization builds the  free vector  node list and  the free  text
node list.   The initial column  position,  Y position,  and font are
set here.   The compilation of each line is started at XCI.  When the
first printing  character (or  underscore  command) is  compiled,   a
text  node  is taken  from  the free  list  and  initialized.   PDP-6
instructions are compiled  into the  text node.   If  there are  more
instructions than  will fit,  another text  node is  gotten from  the
free list and  linked appropriately to the existing nodes.  If at any
point there are no text nodes free, the compiler sets  an appropriate
co-routine restart  address and dismisses until  activated by channel
2.    When a  vertical  spacing  character is  encountered,  the line
compilation is terminated. The text node is linked to  the end of the
pending  queue.   From  the particular  line  spacing character,  the
vertical position of the  next line is calculated.   (Form feed  will
cause a page mark node to be generated and  queued, as will line feed
off  the bottom of the  page body.) After queuing  the text node, the
compiler starts on the next text line.

$
;	MODE 0  CHANNEL 2 INTERRUPTS
;*2	HERE ON FIRST INTERRUPT TO SEND DATA.
XCIBEG:	MOVEI	TAC,XCPINI		;INITIAL DISPATCH FOR THE COMPILER
	MOVEM	TAC,X2DISP		;SET FOR CHANNEL 4.
	SETZM	XPENDH			;NO PENDING LIST.
	MOVEI	TAC,XPENDH
	MOVEM	TAC,XPENDT		;TAIL OF THE PENDING LIST POINTS TO HEAD.
	SETZM	XASVLH			;NO ACTIVE LISTS.
	SETZM	XALVLH
	SETZM	XATLH
	SETOM	XSCNLN			;MORE INITIALIZATION
	PUSHJ	P,QCUT			;MAKE A CUT HERE.
	CONO	PI,1B24!<1⊗<7-XGPC2N>>	;MAKE AN INTERRUPT ON CH4
	MOVE	TAC,[JRST P2CH4S]
	MOVEM	TAC,P2CH4E		;CLOBBER CHANNEL 4 EXIT ROUTINES.
	JSR	XDISP2			;SET DISPATCH FOR ALL OTHER INTERRUPTS.

;*2	HERE ON NORMAL, CH 2 DATA TRANSFER INTERRUPT.
XCW:	SETZM	XACT4			;NO NEED TO KICK CH4 YET.
	AOS	AC1,XSCNLN		;INCREMENT PAGE POSITION.
XCW1:	SKIPE	AC2,XPENDH		;ANY PENDING NODES?
	CAMGE	AC1,1(AC2)		;YES.  TIME YET?
	JRST	XCW3			;NONE PENDING OR NOT YET.
	CAMG	AC1,1(AC2)		;DID WE MISS IT?
	JRST	XCW1X			;NO. RIGHT ON TIME
	MOVE	IOS,[XGPERR,,IODERR]	;SET ERROR BIT FOR USER. WE CONTINUE
	PUSHJ	P,XGPSET		;UNTIL THE END OF THE NEXT LINE IN CH4
	SKIPE	XGPERC			;ERROR CODE SET YET?
	JRST	XCW1X			;AVOID DOING IT AGAIN
	PUSHJ	P,XERR12		;I MISSED IT!
	MOVEM	AC1,XGPERC+1		;SAVE CURRENT SCANLINE NUMBER FOR LOSER
	MOVE	AC3,1(AC2)		;GET Y0 OF NEXT NODE
	MOVEM	AC3,XGPERC+2		;GIVE THAT TO THE LOSER TOO.
XCW1X:	MOVE	AC3,(AC2)		;GET OLD LINK OUT.
	MOVEM	AC3,XPENDH		;SET OLD LINK OUT INTO LIST HEAD.
	JUMPN	AC3,XCW1A		;JUMP UNLESS LIST IS EMPTY.
	MOVEI	AC3,XPENDH		;ADDRESS OF LIST HEAD.
	MOVEM	AC3,XPENDT		;TAIL POINTS TO LIST HEAD.
XCW1A:	SKIPGE	AC3,2(AC2)		;GET X0,,N
	JRST	XCW1C			;THIS IS A TEXT NODE.
	HRRZM	AC3,1(AC2)		;STORE N TO CLOBBER Y0.
	ANDCMI	AC3,-1			;LEFT SIDE ONLY IS X0
	SKIPL	4(AC2)			;DON'T BUGGER X0 IF DX<0 6/12/73
	SUB	AC3,4(AC2)		;X0-DX
	MOVEM	AC3,2(AC2)		;CLOBBER X0 WITH X0-DX.
	SKIPG	AC3,3(AC2)		;GET THE WIDTH FIELD.
	JRST	XCW1D			;THIS IS A PAGE NODE.  CUT THE PAPER.
	CAILE	AC3,SETN+=200		;IS IT SMALL ENOUGH TO GET DONE QUICK?
	JRST	XCW1B			;NO. THIS GOES IN THE WIDE VECTOR LIST.
	EXCH	AC2,XASVLH		;STORE POINTER IN ACTIVE NARROW V. LIST HEAD
	MOVEM	AC2,@XASVLH		;STORE OLD LIST IN NEWLY ACTIVATED.
	JRST	XCW1			;LOOK FOR MORE NEWLY ACTIVATED

XCW1B:	EXCH	AC2,XALVLH		;STORE POINTER IN ACTIVE WIDE V. LIST HEAD
	MOVEM	AC2,@XALVLH		;STORE OLD LIST IN NEWLY ACTIVATED.
	JRST	XCW1			;LOOK FOR MORE NEWLY ACTIVATED

XCW1C:	MOVEM	AC1,1(AC2)		;SET STARTING LINE NUMBER.
	EXCH	AC2,XATLH		;SET ACTIVE TEXT HEADER
	MOVEM	AC2,@XATLH		;LINK NEW NODE TO OLD LIST.
	JRST	XCW1			;LOOK FOR MORE.

XCW1D:	SKIPG	XGPPS3			;TOP OF PAGE. IS THERE A BOTTOM MARGIN?
	JRST	XCW1DA			;NO BOTTOM MARGIN: NO CUT
	PUSHJ	P,QCUT			;CUT THE PAPER.
	MOVE	TAC,XSCNLN
	CAIL	TAC,=2000
	CAILE	TAC,=2200
	JRST	XCW1DA			;PAGE SIZE IS UNUSUAL
	MOVEI	TAC,1
	IORM	TAC,XFLAPB		;TURN ON A BIT TO MAKE IT FLAP
XCW1DA:	SETOM	XSCNLN			;NEXT SCAN LINE IS 0
	MOVE	TAC1,4(AC2)		;GET THE END OF FILE INDICATOR.
	EXCH	AC2,XVNFL		;FREE THIS PAGE MARK NODE.
	MOVEM	AC2,@XVNFL

	MOVEI	AC2,0			;FREE NARROW ACTIVE VECTORS
	EXCH	AC2,XASVLH		;AC2←LIST HEADER; LIST HEADER←0
XCW1E:	SKIPN	AC3,AC2			;AC3←FIRST ELEMENT IN LIST
	JRST	XCW1F
	MOVE	AC2,(AC2)		;ADVANCE IN LIST.
	EXCH	AC3,XVNFL		;FREE NODE THAT AC3 POINTS TO
	MOVEM	AC3,@XVNFL
	JRST	XCW1E

XCW1F:	MOVEI	AC2,0			;FREE WIDE ACTIVE VECTORS.
	EXCH	AC2,XALVLH		;AC2←LIST HEADER; LIST HEADER←0
XCW1G:	SKIPN	AC3,AC2
	JRST	XCW1H
	MOVE	AC2,(AC2)
	EXCH	AC3,XVNFL
	MOVEM	AC3,@XVNFL
	JRST	XCW1G

XCW1H:	MOVEI	AC2,0			;FREE TEXT NODES.	
	EXCH	AC2,XATLH		;AC2←LIST HEADER; LIST HEADER←0
XCW1I:	SKIPN	AC3,AC2
	JRST	XCW1K
	MOVE	AC2,(AC2)		;LINK AHEAD.
XCW1J:	MOVEI	TAC,(AC3)
	EXCH	AC3,XTNFL
	MOVEM	AC3,@XTNFL
	SKIPE	AC3,3(TAC)
	JRST	XCW1J
	JRST	XCW1I

XCW1K:	SETOM	XACT4			;NODES HAVE BEEN FREED
	JUMPL	TAC1,XCW6		;WAKE COMPILER UNLESS EOF.
	MOVEI	TAC1,XCIBEG
	MOVEM	TAC1,XDISP2		;SET DISPATCH THRU THE TOP.
	JRST	CPOPJ1			;SKIP RETURN INDICATES EOF.

XCW3:	SKIPN	XALVLH			;ANY WIDE VECTORS?
	SKIPE	XASVLH			;NO. ANY NARROW VECTORS?
	JRST	.+2			;THERE ARE SOME ACTIVE VECTORS.
	JRST	XCW5			;NO VECTORS ACTIVE.
	MOVEM	P,XGPTMP		;SAVE P FOR LATER.
	MOVSI	AC3,XNVC		;PICKUP THE NARROW VECTOR CODE
	BLT	AC3,XNVC3		;LOAD NVC INTO THE AC'S.
	MOVEI	AC1,XASVLH		;POINTER TO FIRST VECTOR.
	JRST	XNVC1			;EXECUTE THE CODE IN THE AC'S.

XCW4:	SKIPN	XALVLH			;ANY WIDE VECTORS?
	JRST	XCW4A			;NO. AVOID THIS STUFF.
	MOVE	AC3,[XWVC,,XWVC1]
	BLT	AC3,XWVC2
	MOVEI	AC3,XCW4A
	HRRM	AC3,XWVC3		;SET RETURN ADDRESS.
	MOVEI	AC1,XALVLH
	JRST	XNVC1			;DO LONG VECTORS. RETURN TO XCW4A

XCW4A:	MOVE	P,XGPTMP		;HERE AFTER ALL VECTORS DONE
XCW5:	MOVEI	AC3,XATLH		;FOR ACTIVE TEXT LIST.
	MOVE	IOS,[SCANX,,SCAN]	;SOURCE,,DESTINATION
	BLT	IOS,SCAND		;MOVE CODE INTO THE AC'S.
					;IOS,TAC,TAC1,AC2,3 ARE 'FREE'
					;P IS FOR STACK. AC1=MAJOR SCANLINE #.
XCW5A:	MOVEI	AC2,(AC3)		;LINK AHEAD. AC2=LAST ONE DONE.
XCW5B:	SKIPN	AC3,(AC2)		;GET THE FORWARD LINK
	JRST	XCW6			;THERE IS NONE LEFT.
	PUSH	P,AC2
	MOVE	AC1,XSCNLN
	SUB	AC1,1(AC3)		;RELATIVE SCAN LINE NUMBER.
	PUSHJ	P,4(AC3)		;EXECUTE THE NODE.
	POP	P,AC2
	MOVE	AC3,(AC2)		;SET UP AGAIN.
	AOSGE	2(AC3)			;COUNT A LINE USED UP.
	JRST	XCW5A			;NODE IS STILL ACTIVE.
					;DELINK HEADER FROM ACTIVE LIST.
	MOVE	TAC,(AC3)		;GET THE LINK TO NEXT ACTIVE TEXT NODE.
	MOVEM	TAC,(AC2)		;STORE INTO THE GUY WHO POINTS HERE.
					;ADD HEADER AND LINKED BLOCKS TO FREE LIST.
XCW5C:	MOVEI	TAC,(AC3)		;SAVE THIS BLOCK ADDRESS
	EXCH	AC3,XTNFL		;LINK THIS BLOCK INTO TEXT NODE FREE LIST.
	MOVEM	AC3,@XTNFL		;STORE OLD FL POINTER INTO NEW BLOCK.
	SKIPE	AC3,3(TAC)		;SKIP IF THERE IS NO FURTHER LINK
	JRST	XCW5C			;GIVE BACK ANOTHER BLOCK.
	SETOM	XACT4			;WE WILL KICK CH4.
	JRST	XCW5B			;DON'T ADVANCE AC2.

XCW6:	SKIPN	XACT4
	POPJ	P,
	CONO	PI,1B24!<1⊗<7-XGPC2N>>	;ACTIVATE INTERRUPT ON COMPILER CHANNEL.
	MOVE	TAC,[JRST P2CH4S]
	MOVEM	TAC,P2CH4E		;CLOBBER CHANNEL 4 EXIT ROUTINES.
	POPJ	P,			;DISMISS CHANNEL 2.
;	MODE 0 I-LEVEL  'SCAN PHASE'
;ENTER SCANE FOR LEFT SIDE (EVEN)
;ENTER SCANO FOR RIGHT SIDE (ODD)
;IOS, TAC, AC3 ARE IN USE.  TAC1 IS FREE, P IS STACK.

SCANX:	PHASE	4
SCAN::	MOVE	AC3,(AC3)		;4 CALLED BY JSP AC3,  GET AOBJN PTR
	JUMPL	TAC,SCANO		;5 JUMP TO ODD SIDE SCAN
SCANE::	HLRZ	IOS,@(AC3)		;6 LOAD DATA
	DATAO	XGP,IOS			;7 SEND DATA
	AOBJN	AC3,SCANE		;10 LOOP IN MINOR COMMAND
	JRST	(AC3)			;11 RETURN TO COMMAND BUFFER
SCANO::	DATAO	XGP,@(AC3)		;12 SEND DATA
	AOBJN	AC3,SCANO		;13 LOOP
SCAND::	JRST	(AC3)			;14 RETURN. END OF PHASED CODE.
	DEPHASE	

;REGISTER ASSIGNMENTS:
;IOS  FREE EXCEPT CLOBBERED INSIDE SCAN
;TAC  HAS RELATIVE LINE NUMBER AND ODD/EVEN INDICATOR
;TAC1 FREE
;P    STACK
;AC1  MAJOR SCANLINE NUMBER
;AC2  RETURN ADDRESS FOR CURRENT MINOR COMMAND
;AC3  ARGUMENT ADDRESS FOR SCAN.

;NARROW VECTOR PROCESSING:
XNVC:	PHASE	0			;AC1 SET UP INITIALLY.
XNVC1::	MOVEI	AC3,(AC1)		;0 LINK AHEAD. AC1=LAST ONE DONE.
XNVC2::	SKIPN	AC1,(AC3)		;1 GET THE FORWARD LINK
XWVC3::	JRST	XCW4			;2 THERE IS NONE.  ;*CLOBBERED FOR WIDE
	MOVE	AC2,4(AC1)		;3 DX
	ADDB	AC2,2(AC1)		;4 X←X+DX
	HLRZ	AC2,AC2			;5 GET X AS A RIGHT SIDE QUANTITY
	CONO	XGP,SETX(AC2)		;6 SET X COLUMN REGISTER
	CONO	XGP,@3(AC1)		;7 SEND THE WIDTH.
	SOSLE	1(AC1)			;10 DECREMENT N
	JRST	XNVC1			;11 ADVANCE TO THE NEXT VECTOR
XNVC3::	JRST	XNVC4			;12 RUN THE CODE TO FLUSH THIS VECTOR
	DEPHASE	

XWVC:	PHASE	10			;HERE FOR WIDE VECTORS.
XWVC1::	CONSO	XGP,NZ			;10 WAIT HERE FOR DONE
	JRST	XWVC1			;11 LOOP.
	SOSLE	1(AC1)			;12
	JRST	XNVC1			;13
XWVC2::	JRST	XNVC4			;14
	DEPHASE				;15, 16, 17 ARE AC1,2,3
	
XNVC4:	MOVE	AC2,(AC1)		;GET THE LINK TO NEXT ACTIVE VECTOR
	MOVEM	AC2,(AC3)		;STORE INTO THE GUY WHO POINTS HERE.
	EXCH	AC1,XVNFL		;LINK TO VECTOR NODE FREE LIST.
	MOVEM	AC1,@XVNFL		;STORE OLD FL POINTER INTO NEW BLOCK.
	SETOM	XACT4			;WE WILL KICK CHANNEL 4.
	JRST	XNVC2			;DON'T ADVANCE IN LIST.
;	ROUTINES TO MANIPULATE COMMAND HEADER BLOCKS.
;SCHB, OFFCHB, ACHB
;ALL OF THESE ARE CALLED BY JSP AC1,
;MOST REQUIRE THAT AC2, AC3 BE SET UP WITH MINIMUM AND MAXIMUM VALUES.
;CAUTION----DON'T CLOBBER DAT INSIDE THESE ROUTINES!

;SEARCH FOR A COMMAND BLOCK WITH THE RIGHT PARAMETERS, ELSE MAKE ONE.
;AC2 = MIN, AC3 = MAX
SCHB:	SKIPN	UUO,XCHBGO			;HAVE WE ANY BLOCKS AT ALL?
	JRST	FCHB				;NO. WE SHALL MAKE THE FIRST.
	MOVEI	UUO,4(UUO)			;POINT TO FIRST EXECUTABLE
SCHB1:	MOVEI	UCHN,(UUO)			;LINK ON
	CAIN	AC2,@(UCHN)
	CAIE	AC3,@1(UCHN)
	JRST	SCHB2				;NO MATCH. LOOK AT NEXT LINK
	CAIGE	PROG,3(TEM)			;IS THERE ROOM FOR MORE?
	PUSHJ	P,ADDNOD			;NO. ADD A NODE. RESET TEM,PROG.
	MOVEI	AC3,1(TEM)			;GET POINTER TO NEXT AVAIL. WORD.
	EXCH	AC3,7(UCHN)			;SET NEW INTER-GROUP LINK.
	JRST	ADBH1				;GO ADD THE DATA BLOCK HEADER

SCHB2:	HRRZ	UUO,2(UCHN)			;UUO SET WITH NEXT LINK
	CAIE	UUO,CPOPJ			;WAS THIS THE LAST LINK?
	JRST	SCHB1				;NO. KEEP LOOKING ALONG LIST.
						;MAKE A NEW COMMAND HEADER.

;ADD A COMMAND HEADER BLOCK.  UCHN POINTS TO LAST CHB IN THE LIST. AC2, AC3 SET
ACHB:	CAIGE	PROG,11(TEM)			;WE ARE ADDING 9 MORE WORDS.
	PUSHJ	P,ADDNOD			;NO ROOM.  ADD A NEW NODE.
	MOVEI	UUO,1(TEM)			;POINTER TO NEXT AVAIL CELL.
	HRRM	UUO,2(UCHN)			;CLOBBER LAST GUY'S RETURN ADDRESS.
	JRST	FCHB1				;NOW MAKE THE COMMAND HEADER BLOCK

;FCHB CALLED FROM SCHB TO MAKE FIRST COMMAND BLOCK.  GET TEXT NODE FROM FREE LIST.
FCHB0:	CONO	PI,PION
	JSR	X2DISP				;SET CO-ROUTINE ADDRESS FOR LATER
;*4
FCHB:	CONO	PI,PIOFF
	SKIPN	UUO,XTNFL			;GET DATA FROM THE FREE LIST
	JRST	FCHB0
	MOVE	UCHN,(UUO)
	MOVEM	UCHN,XTNFL
	CONO	PI,PION
	MOVEM	UUO,XCHBGO
	SETZM	XNODUS				;COUNT OF NODES IN THIS LINE.
	SETZM	(UUO)				;MAJOR LINK
	SETZM	3(UUO)				;LINK-2
	MOVEI	TEM,3(UUO)			;PDL POINTER. LEFT HALF ZERO.
	MOVEI	PROG,TNSIZE-1(UUO)		;LAST ADDRESS THAT CAN BE USED
						;CAIGE PROG,n(TEM) WILL SKIP
						;IF n MORE THINGS CAN BE PUSHED.
	MOVE	DSER,TEM			;WE ARE NOT INSIDE A TEXT STRING.

;MAKE COMMAND HEADER BLOCK.  AC2 = MIN, AC3 = MAX
FCHB1:	PUSH	TEM,[CAIL AC1,0]		;0 STUFF INSTRUCTION
	HRRM	AC2,(TEM)			;SET MINIMUM
	MOVEI	UCHN,(TEM)			;SET UCHN TO POINT TO HEADER.
	PUSH	TEM,[CAIL AC1,0]		;1 ANOTHER INSTRUCTION.
	HRRM	AC3,(TEM)			;SET ARGUMENT IN INSTRUCTION
	CAMLE	AC3,XHMAX			;IS THIS BIGGER THAN CURRENT MAX?
	MOVEM	AC3,XHMAX			;YES. SET MAXIMUM VALUE OF SCAN LINE
	PUSH	TEM,[JRST CPOPJ]		;2 SET RETURN ADDRESS.
	PUSH	TEM,[MOVEI TAC,(AC1)]		;3 MORE CODE
	PUSH	TEM,[SUBI TAC,@0]		;4 MORE CODE
	HRRM	UCHN,(TEM)			;FIX ADDRESS PART
	PUSH	TEM,[ROT TAC,-1]		;5 MORE CODE.
	MOVEI	AC3,2(UCHN)			;SET UP RETURN ADDRESS.
;HERE TO ADD A DATA BLOCK HEADER TO COMMAND BLOCK ADDRESSED BY UCHN
ADBH1:	PUSH	TEM,[JSP AC2,0]			;SET HEADER WORD
	MOVEI	UUO,2(TEM)
	HRRM	UUO,(TEM)			;SET JUMP ADDRESS
	PUSH	TEM,AC3				;SET RETURN ADDRESS.
	JRST	(AC1)

;HERE TO OFFSET THE MIN,MAX VALUES.  OFFSET IS IN AC3.
OFFCHB:	MOVE	UCHN,XCHBGO
	MOVEI	UCHN,4(UCHN)			;OFFSET TO FIRST INSTRUCTION
OFFCH1:	ADDM	AC3,(UCHN)
	ADDM	AC3,1(UCHN)
	HRRZ	UUO,2(UCHN)
	CAIN	UUO,CPOPJ
	JRST	(AC1)				;RETURN WITH UCHN SET UP.
	MOVEI	UCHN,(UUO)
	JRST	OFFCH1

;ADDNOD MAKES A NEW TEXT NODE.  TEM IS OLD PDL, AT LEAST 1 NEEDED IN OLD BLOCK.
;CALLED WITH A PUSHJ.  CLOBBERS UUO.  RETURNS WITH TEM=DSER=NEW PDL. PROG=LAST.
ADDND2:	PUSHJ	P,XERR10			;ERROR-LINE TOO COMPLEX
	POP	P,(P)				;FLUSH RETURN ADDRESS.
	JRST	XCIG2A				;SET ERROR BIT.
	
ADDND1:	CONO	PI,PION
	CAML	DSER,XNTNOD			;HOW MANY NODES IN USE?
	JRST	ADDND2				;TOO MANY NODES ARE IN USE.
	JSR	X2DISP				;WAIT FOR A FREE NODE.
	JRST	.+2
ADDNOD:	AOS	DSER,XNODUS
	CONO	PI,PIOFF
	SKIPN	UUO,XTNFL			;GET FROM FREE LIST
	JRST	ADDND1				;NONE THERE
	MOVE	DSER,(UUO)
	MOVEM	DSER,XTNFL
	CONO	PI,PION
	PUSH	TEM,[JRST]			;SET JRST AT END OF OLD BLOCK.
	MOVEI	DSER,4(UUO)			;JUMP TARGET
	HRRM	DSER,(TEM)
	MOVEI	TEM,3(UUO)			;NEW PDL.
	MOVEI	PROG,TNSIZE-1(UUO)		;LAST ADDRESS THAT CAN BE USED
	MOVE	DSER,XCHBGO
	EXCH	UUO,3(DSER)			;SET LINK TO US.
	MOVEM	UUO,(TEM)			;OLD LINK IN US.
	MOVE	DSER,TEM
	POPJ	P,
;	XGP LINE COMPILER CO-ROUTINES
;*4 HERE FOR FIRST COMPILER ACTIVATION.
XCPINI:	MOVE	TAC,XFREBA		;GET THE BASE OF FREE SPACE.
	ADD	TAC,XFCADR		;ADD RELOCATION OF THE FC
	MOVEM	TAC,XVNFL		;BASE OF VECTOR NODE FREE LIST
	MOVE	TAC1,XNVNOD		;MAKE THIS MANY NODES.
	ADDI	TAC,VNSIZE		;THIS IS THE NODE SIZE
	MOVEM	TAC,-VNSIZE(TAC)	;STORE LINK
	SOJG	TAC1,.-2		;LOOP LINKING BLOCKS.
	SETZM	-VNSIZE(TAC)		;LAST LINK IS ZERO.
	MOVEM	TAC,XTNFL		;BASE OF TEXT NODE FREE LIST.
	MOVE	TAC1,XNTNOD		;THIS MANY
	ADDI	TAC,TNSIZE		;THIS SIZE
	MOVEM	TAC,-TNSIZE(TAC)
	SOJG	TAC1,.-2
	SETZM	-TNSIZE(TAC)		;CLEAR OUT LAST LINK.

	SETZM	XLFTKF			;SET THE KERN FLAG OFF.
	MOVE	TAC,XGPPS1		;GET THE SIZE OF TOP MARGIN
	MOVEM	TAC,XCYPOS		;CURRENT (DEFAULT) Y POSITION.
	SETZM	XGPLYP			;LAST Y POSITION WRITTEN WAS 0
	SETZM	XTOFRM			;XGP IS AT 'TOP OF FORM'
	MOVE	TAC,XFTADR		;GET THE FONT ADDRESS OF FONT 0
	ADD	TAC,XFCADR		;ADD RELOCATION OF FONT COMPILER
	HRRZM	TAC,XFTCAD		;SAVE AS RELOCATED ADDRESS OF CURRENT FONT.
	MOVE	J,XGPLMR		;SET INITIAL COLUMN AT LEFT MARGIN.
	LDB	TAC,[POINT 5,(TAC),22]	;GET THE COLUMN POS ADJUSTMENT
	SUBI	J,(TAC)			;AND USE IT TO BUGGER THE COLUMN POSITION.
	SETZM	XGPPG2			;PAPER PAGE ← 0
	MOVE	P,XGPPDL		;PDL FOR COMPILER.
	MOVEI	PID,P2PID		;NOT RANDOMNESS

;HERE WE PREPARE TO COMPILE A VECTOR NODE OR A TEXT NODE.

XCI:	JSP	AC3,BFOSET		;SET UP AOBJN POINTER IN TAC
	JUMPGE	TAC,XCI0		;JUMP IF THERE'S NO DATA TO BE HAD.
;REGISTER USE IN THE COMPILER.
;LINE INITIALIZATION STUFF.
;J ← COLUMN COUNT IN XGP.
;TEM ← POINTER TO NEXT FREE WORD IN BUFFER.
;DSER ← LOCATION OF CURRENT AOBJN WORD IN TEXT NODE.
;UCHN ← LOCATION OF CURRENT COMMAND HEADER BLOCK.
;TAC1←5 INITIAL NUMBER OF BYTES IN THE WORD.
XCIA:	MOVEI	TAC1,5
	SETOM	XLBL			;CURRENT BASELINE POSITION.
	SETZB	TEM,XHMAX		;CURRENT MAXIMUM HEIGHT
	SETZB	DSER,XCHBGO		;FLAG SCHB THERE ARE NO COMMAND BLOCKS YET.
	SETZB	UCHN,XVNODE		;NO VECTORS TO QUEUE YET.

	MOVE	DAT,@XFTCAD		;DEFINE CURRENT FONT PARAMETERS.
	HLRZM	DAT,XCFBL		;BASE LINE.
	ANDI	DAT,17777		;OMIT THE COLUMN POS ADJ BITS
	HRRZM	DAT,XCFH		;FONT HEIGHT
	LDB	DAT,[POINT 5,@XFTCAD,22];GET THE COLUMN POS ADJUSTMENT
	MOVEM	DAT,XCFCPA		;SAVE COLUMN POS ADJ

;CHARACTER BY CHARACTER LOOP.
XCI1:	JSP	AC3,XCIG		;GET A CHARACTER
	CAIN	DAT,177			;SKIP IF NOT ESCAPE.
	JRST	XCI2			;PROCESS DLE
	CAIG	DAT,15
	CAIG	DAT,10
	JUMPN	DAT,XCI2A		;JUMP IF NORMAL CHARACTER.
	JUMPE	DAT,XCI1		;THROW OUT NULLS.
;PROCESS SPECIALS HERE  (TAB, LF, VT, FF, CR)
	JRST	@.+1-11(DAT)		;DAT HAS CODE BETWEEN 11 AND 15
	XCI1A				;HT (11)
	XCI4				;LF (12)
	XCI2A				;VT (13) IS JUST ANOTHER CHARACTER.
	XCI4				;FF (14)
	XCI1B				;CR (15)
;	HERE TO QUEUE A TEXT NODE.
;LINE OVERFLOW ROUTINES.
XCI1D:	MOVE	J,XGPLMR		;SET MARGIN. (CR)
	SUB	J,XCFCPA		;ADJUST COLUMN POSITION
XCI1F:	MOVEI	DAT,0			;LINE OVERFLOW.

;HERE AT END OF LINE.  DAT HAS THE BREAK CHARACTER.  ONLY FF IS SIGNIFICANT.
XCI4:	SKIPN	XGPAT2			;THIS SHOULDN'T SKIP EXCEPT IF SCREWED
	SKIPE	XGPHIP			;HEADING IN PROGRESS?
	JRST	XCI4A			;YES. AVOID CLOBBERING IT.
	MOVE	AC3,MTB(TAC1)		;HERE AT END OF A CHARACTER LINE.
	ANDM	AC3,(TAC)		;MASK OUT USED UP BYTES.
	JSP	AC3,BFNSET		;ADVANCE BUFFER POINTERS.
	JRST	XCI4B

XCI4A:	MOVE	TAC,XSVCAD
	SKIPE	XGPHIP
	MOVEM	TAC,XFTCAD
	SETZM	XGPHIP			;NO LONGER HEADING IN PROGRESS
	SETZM	XGPAT2			;DRD STRIKES AGAIN.
XCI4B:	SKIPG	UUO,XHMAX		;IS THE MAXIMUM HEIGHT SET?
	MOVE	UUO,XCFH		;NO. SET IT FROM THE CURRENT FONT HEIGHT
	MOVEM	UUO,XHMAX		
	JUMPE	TEM,XCI5		;JUMP IF THERE IS NO COMMAND GROUP.
	PUSH	TEM,[JRST @(AC2)]	;STOP THE CURRENT COMMAND GROUP.
	MOVE	TAC,XCHBGO		;GET THE ADDRESS OF THIS TEXT NODE.
	MOVNM	UUO,2(TAC)		;SAVE THE ACTIVE LINE COUNT.
	MOVE	TAC1,XCYPOS		;GET THE Y POSITION.
	MOVEM	TAC1,1(TAC)		;STORE IN TEXT NODE.
	EXCH	TAC1,XGPLYP		;STORE THIS AS THE LAST Y WE DID.
	SETZM	(TAC)			;ZERO THE LINK OUT
	CONO	PI,PIOFF
	MOVEM	TAC,@XPENDT		;STORE THRU THE TAIL.
	MOVEM	TAC,XPENDT		;STORE NEW QUEUE TAIL
	CONO	PI,PION
	CAMLE	TAC1,XGPLYP		;IS Y0 > OR = THE LAST Y WE DID?
	PUSHJ	P,XGPOOO		;OUT OF ORDER.
	SETOM	XTOFRM			;FLAG TEXT IS ON PAGE.
XCI5:	CAIN	DAT,14			;FF?
	JRST	XCI6A			;YES.
	SKIPN	UUO,XVNODE		;ANY VECTOR NODE TO QUEUE?
	JRST	XCI6			;NO.
	MOVE	TAC1,1(UUO)		;GET THE Y0 OF THIS VECTOR
	MOVEM	TAC1,XCYPOS		;USE AS THE Y0 OF THE NEXT TEXT
	EXCH	TAC1,XGPLYP		;STORE AS THE LAST Y0 THAT WAS QUEUED
	CONO	PI,PIOFF		;QUEUE THE VECTOR NODE.
	MOVEM	UUO,@XPENDT
	MOVEM	UUO,XPENDT
	CONO	PI,PION
	CAMLE	TAC1,XGPLYP
	PUSHJ	P,XGPOOO		;OUT OF ORDER
	SETOM	XTOFRM			;FLAG TEXT EXISTS ON PAGE.
	CAIN	DAT,14
	JRST	XCI6A			;IN CASE OF ACCIDENT HE ALWAYS ...
	JRST	XCI6Z			;(DAT IS ZERO)
	
XCI6:	SKIPG	DAT,XGPSLS		;SPECIAL LINE SPACE, IF ANY,
	MOVE	DAT,XGPILS		;ELSE THE REGULAR LINE SPACE.
	SETZM	XGPSLS			;(AND NO SPECIAL LINE SPACE ANYMORE)
	ADD	DAT,XHMAX		;PLUS LINE HEIGHT.
XCI6Z:	ADDB	DAT,XCYPOS		;PLUS Y0 OF THIS LINE, ICS Y0 OF NEXT LINE.
	SKIPG	TAC,XGPPS2
	JRST	XCI6ZZ			;PMAR=0 MEANS DON'T CUT UNLESS TOLD
	ADD	TAC,XGPPS1		;SUM OF TOP MARGIN+PAGE BODY SIZE
	CAIL	DAT,(TAC)		;SKIP UNLESS WE NEED A FORM FEED HERE.
	JRST	XCI6B			;HERE WE NEED A FORM FEED.
XCI6ZZ:	MOVSI	TAC,XGPERR		;ERROR FLAG UP?
	TDNE	TAC,XGPIOS		;?
	JRST	XCI6E			;YES.  SCREECH
	JRST	XCI			;GO DO THE NEXT LINE.

XCI6A:	SETZM	XGPPG2			;REAL FF. PAPER PAGE ← 0
XCI6B:	MOVSI	TAC,XGPERR		;IS THERE AN ERROR?
	TDNE	TAC,XGPIOS
	JRST	XCI6E			;ERROR.  FAKE EOF.
	JSP	AC3,BFOSET		;SEE IF THERE'S  MORE DATA TO SEND
	JRST	XCI6DX			;TAC<0 MEANS MORE DATA.

XCI6E:	PUSHJ	P,PSYNCX		;HERE FOR ERROR.
	ANDCA	TAC,XGPIOS		;CLEAR PRIMARY ERROR
	IORI	TAC,IODERR		;TURN ON USER'S ERROR
	MOVEM	TAC,XGPIOS
	SETZM	XGPBIT			;WON'T RUN PAPER.
	PUSHJ	P,XSYNCX
	MOVEI	TAC,1			;MAKE TAC>0 LIKE EOF.
XCI6DX:	SKIPN	XTOFRM			;ANY TEXT ON THIS PAGE?
	JUMPL	TAC,XCI6F		;NO. AVOID BLANK PAGES. (ONLY IF MORE DATA)
	JRST	XCI6D

XCI6C:	CONO	PI,PION			;RESTORE PI'S
	JSR	X2DISP			;SET RESTART ADDRESS AND DISMISS.
;*4
XCI6D:	CONO	PI,PIOFF
	SKIPN	TAC1,XVNFL		;GET A FREE VECTOR.
	JRST	XCI6C			;HAVE TO WAIT FOR A FREE NODE.
	MOVE	DAT,(TAC1)		;GET LINK
	MOVEM	DAT,XVNFL		;STORE LINK
	CONO	PI,PION
	SETZM	(TAC1)			;FIX LINK OUT
	SKIPG	DAT,XGPPS2		;PMAR
	SKIPA	DAT,XCYPOS		;PMAR = 0 USE CURRENT Y POSITION AS A GUIDE
	ADD	DAT,XGPPS1
	ADD	DAT,XGPPS3		;TOTAL PAGE SIZE
	MOVEM	DAT,1(TAC1)		;STORE Y0 IN THE WORD.
	SETZM	2(TAC1)			;N=0 DENOTES VECTOR TYPE NODE.
	SETOM	3(TAC1)			;WIDTH<0 DENOTES PAGE NODE
	MOVEM	TAC,4(TAC1)		;STORE POSITIVE FOR EOF.
	CONO	PI,PIOFF		;QUEUE THE PAGE MARK NODE.
	MOVEM	TAC1,@XPENDT		;STORE AT END OF QUEUE
	MOVEM	TAC1,XPENDT		;UPDATE END OF QUEUE.
	CONO	PI,PION
	SETZM	XTOFRM			;NO TEXT ON PAGE ANY MORE.
XCI6F:	JUMPGE	TAC,XCIP3		;JUMP IF EOF
	MOVE	TAC,XGPPS1
	MOVEM	TAC,XCYPOS		;SET CURRENT Y POSITION.
	SETZM	XGPLYP			;LAST Y QUEUED WAS 0
	AOS	TAC1,XGPPG2		;INCREMENT "PAPER PAGE" COUNT
	SKIPGE	TAC,XGPHDW		;IS THERE AN AOBJN POINTER FOR HEADING?
	CAIG	TAC1,1			;YES. SKIP IF AFTER FIRST PAPER PAGE.
	JRST	XCI			;NO HEADING OR FIRST PAPER PAGE. SEND DATA.
XCIP2:	SETOM	XGPHIP			;HEADING IN PROGRESS
	MOVE	TAC1,XFTCAD		;SAVE PRESENT FONT.
	MOVEM	TAC1,XSVCAD		;SAVE IT.
	JRST	XCIA			;GO DO THE HEADING

XCIP3:	JSR	X2DISP			;EOF. DISMISS INTERRUPT.
	JRST	.-1			;IGNORE FURTHER INTERRUPTS.

XGPOOO:	MOVEI	DAT,14			;SET TO KILL TRANSFER
	MOVSI	IOS,XGPERR
	PUSHJ	P,XGPSET
	JRST	XERR11			;OUT OF ORDER
;	MODE 0	GET NEXT CHARACTER
BTB:	POINT	7,(TAC),34		;(BYTE THE BAG?)
	POINT	7,(TAC),27
	POINT	7,(TAC),20
	POINT	7,(TAC),13
	POINT	7,(TAC),6

MTB:	0
	377
	77777
	17,,-1
	3777,,-1
	-1				;NOT REDUNDANT! USED TO UNTAKE A CHARACTER

;HERE WHEN WE HAVE END OF HEADING DATA.
XCIG4:	MOVEI	DAT,20			;SET SPECIAL LINE SPACE COUNT
	MOVEM	DAT,XGPSLS
	JRST	XCI1F			;MAKE END OF LINE OCCUR.

XCIG3:	SKIPN	XGPAT2			;PAGE NUMBER HACK?
	JRST	XCIG4			;NO. JUST HEADING HACK
	SETZM	XGPAT2			;CLEAR PAGE NUMBER CELL
	MOVE	TAC,XGPAT0		;RESTORE TAC, TAC1
	MOVE	TAC1,XGPAT1		;GET NEXT CHARACTER

; JSP AC3,XCIG TO GET NEXT CHARACTER INTO DAT
XCIG:	SOJL	TAC1,XCIG1		;COUNT DOWN IN WORD.
	LDB	DAT,BTB(TAC1)		;GOBBLE A BYTE
	JRST	(AC3)			;RETURN
XCIG1:	MOVEI	TAC1,5			;HERE THE WORD RAN OUT.
	AOBJN	TAC,XCIG		;ADVANCE TO NEXT WORD.
	SKIPN	XGPHIP			;HEADING IN PROGRESS OR 
	SKIPE	XGPAT2			;ARE WE IN PAGE NUMBER HACK?
	JRST	XCIG3			;YES. DO IT
	PUSH	P,AC3			;NO NEXT WORD.  SAVE RETURN
	PUSH	P,AC1
	JSP	AC3,BFNSET		;DO THE BUFFER FROTZ
	JSP	AC3,BFOSET
	POP	P,AC1
	POP	P,AC3			;RESTORE RETURN ADDRESS
	JUMPL	TAC,XCIG		;JUMP IF THERE'S DATA LEFT.
XCI0:	MOVE	DAT,XGPWSZ		;NO DATA LEFT. IS THIS CLOSE TIME?
	JUMPE	DAT,XCI3		;JUMP IF CLOSE UUO DONE.
;WE RAN OUT OF DATA WITHOUT A CLOSE UUO.
	PUSHJ	P,XERR5			;SET DATA MISS ERROR CODE.
XCIG2A:	MOVSI	IOS,XGPERR		;SET ERROR STATUS.
	PUSHJ	P,XGPSET
XCI3:	MOVEI	DAT,14			;HERE FOR END OF DATA.
	JRST	XCI4A			;DO A FORM-FEED.
;	HERE FOR SPECIALS
;H. TAB
XCI1A:	MOVE	AC3,XFTCAD
	MOVE	AC3,41(AC3)		;LOAD AOBJN POINTER
	LDB	AC3,[POINT 9,(AC3),8]	;GET WIDTH OF A SPACE.
	JUMPE	AC3,XCI1		;IF A SPACE IS ZERO WIDTH, SO IS A TAB
	ADDI	J,(AC3)			;ADVANCE AT LEAST ONE SPACE.
	LSH	AC3,3			;TIMES 8
	SUB	J,XGPLMR		;TAB. COMPUTE DISTANCE FROM MARGIN
	IDIVI	J,(AC3)			;QUOTIENT IN J REMAINDER IN DAT
	JUMPE	DAT,.+2
	ADDI	J,1
	IMULI	J,(AC3)
	ADD	J,XGPLMR		;ADD THE MARGIN SIZE BACK IN.
	JRST	XCI1C			;NOW WE LOOK LIKE A COLUMN SELECT

XCI1B:	MOVE	J,XGPLMR		;HERE FOR CR. LOAD LEFT MARGIN
					;AND DO A COLUMN SELECT.
XCI1C:	SUB	J,XCFCPA		;MAKE COLUMN ADJUSTMENT
;HERE TO DO SPECIAL COL SEL FROM KERNING FONT.
XCI1CA:	CAMN	TEM,UCHN		;IS THIS MCG EMPTY?
	JRST	XCI1			;YES. DO COLUMN SELECT BY AN NON-EMPTY MCG
	CAIGE	PROG,2(TEM)		;ROOM LEFT FOR THIS AND JUMP?
	PUSHJ	P,ADDNOD		;NO. ADD A NEW TEXT NODE.
	PUSH	TEM,[CONO XGP,SETX]	
	ADDM	J,(TEM)
	MOVE	DSER,TEM		;DSER NO LONGER POINTS TO AOBJN POINTER.
	JRST	XCI1
;	HERE TO PROCESS RUBOUT
;HERE FOR RUBOUT. - GET NEXT CHARACTER.
XCI2:	JSP	AC3,XCIG		;HERE FOR DLE. GET NEXT -  PROCESS AS NORMAL
	CAIGE	DAT,XCI2ZL
	JRST	@XCI2Z(DAT)		;DISPATCH THRU TABLE
	CAIL	DAT,20			;TREAT '177 '20 THRU '177 '24 AS LINE SPACE
	CAILE	DAT,24
	JRST	XCI2A			;TREAT AS NORMAL
	MOVEI	DAT,0			;TREAT AS LINE-FEED
	JRST	XCI4			;SINCE ALL CAUSE SPACING ON THE LPT.

XCI2Z:	XCI2A				;'177 '0 IS NORMAL
	ESC1				;'177 '1 IS ESCAPE 1
	ESC2				;'177 '2 IS ESCAPE 2
	ESC3				;'177 '3 IS ESCAPE 3
	ESC4				;'177 '4 IS ESCAPE 4
XCI2ZL←←.-XCI2Z

;HERE FOR '177 '001 - XGP ESCAPE 1.
ESC1:	JSP	AC3,XCIG		;GET NEXT CHARACTER
	CAIGE	DAT,40			;IS THIS A COMMAND OR FONT SELECT
	JRST	ESC1A			;FONT SELECT OR ILLEGAL
	CAIL	DAT,XCI2YL+40
	JRST	XCI1			;ILLEGAL COMMAND. GET NEXT CHARACTER
	JRST	@XCI2Y-40(DAT)
XCI2Y:	ES1.0				;'177 '001 '040	 COLUMN SELECT
	ES1.1				;'177 '001 '041  UNDERSCORE
	ES1.2				;'177 '001 '042	 LINE SPACE SET.
	ES1.3				;'177 '001 '043  FONT BASE LINE TWIDDLE.
	ES1.4				;'177 '001 '044  PAPER PAGE NUMBER
	ES1.5				;'177 '001 '045  SET&PRINT HEADING.
	ES1.6				;'177 '001 '046  START UNDERLINE.
	ES1.7				;'177 '001 '047  STOP UNDERLINE.
XCI2YL←←.-XCI2Y

ES1.0:	MOVEI	AC2,2			;2 BYTES
	PUSHJ	P,GLOM
	ANDI	AC1,3777		;REDUCE TO REASONABILITY
	MOVEI	J,(AC1)
	JRST	XCI1C			;GO SET COLUMN POSITION.

ES1.7:	EXCH	J,XUSBEG		;SPECIAL UNDERSCORE COMMAND
	JRST	ES1.1X
ES1.1:	HRROS	XUSBEG			;FLAG NORMAL UNDERSCORE COMMAND
ES1.1X:	JUMPE	TEM,ES1.1A
	CAIGE	PROG,2(TEM)		;ROOM TO END THIS COMMAND?
	PUSHJ	P,ADDNOD		;NO. ADD MORE SPACE.
	CAME	UCHN,TEM		;IS THERE AN MCG IN PROGRESS?
	PUSH	TEM,[JRST @(AC2)]	;YES. CLOSE IT.
ES1.1A:	JSP	AC3,XCIG		;GET SCAN LINE NUMBER
	TRNE	DAT,100			;NEGATIVE?
	ORCMI	DAT,77			;YES. SIGN EXTEND.
	SKIPGE	AC2,XLBL		;LINE BASE-LINE SET YET?
	MOVE	AC2,XCFBL		;NOT YET. DO SO NOW.
	MOVEM	AC2,XLBL
	ADD	AC2,DAT
	MOVEI	AC3,1(AC2)		;GET MAXIMUM
	JSP	AC1,SCHB		;SEEK FOR APPROPRIATE CHB, ELSE MAKE ONE.
	CAIGE	PROG,6(TEM)		;ROOM FOR 6 LEFT?
	PUSHJ	P,ADDNOD		;NO. ADD ANOTHER NODE.
	PUSH	TEM,[CONO XGP,SETX]
	ADDM	J,(TEM)			;SET COLUMN SELECT CODE
	PUSH	TEM,[CONO XGP,SETN]
	SKIPL	XUSBEG			;SKIP IF NORMAL US.
	JRST	ES1.7B			;SPECIAL US.
	MOVEI	AC2,2
	PUSHJ	P,GLOM			;READ 2 BYTES
	ANDI	AC1,7777
ES1.1C:	ADDM	AC1,(TEM)
	ADDI	J,(AC1)			;GRONK OUR COLUMN POSITION APPROPRIATELY
	PUSH	TEM,[CONSO XGP,NZ]
	MOVEI	UUO,(TEM)
	PUSH	TEM,[JRST]
	HRRM	UUO,(TEM)
ES1.1B:	PUSH	TEM,[JRST @(AC2)]
	MOVE	UCHN,TEM
	MOVE	DSER,TEM
	JRST	XCI1

ES1.7B:	MOVE	AC1,XUSBEG
	SUBI	AC1,(J)
	JUMPGE	AC1,ES1.1C
	MOVEI	AC1,0
	JRST	ES1.1C

ES1.2:	JSP	AC3,XCIG
	MOVEM	DAT,XGPSLS		;SET SPECIAL LINE SPACE
	JRST	XCI1F

ESC1A:	CAILE	DAT,17			;SKIP IF FONT SELECT
	JRST	XCI1			;THIS IS A CODE FROM 20 TO 37. RESERVED.
	MOVEM	J,1(P)			;SAVE COLUMN ADDRESS. NOTE!!! DON'T DO PUSHJ
	ADD	J,XCFCPA		;ADD ADJUSTMENT WHEN LEAVING FONT
	SKIPN	UUO,XFTADR(DAT)		;SEE IF THERE'S A FONT HERE
	MOVE	UUO,XFTADR		;NONE THERE. USE FONT 0
	ADD	UUO,XFCADR		;RELOCATE THE FONT BASE.
	HRRZM	UUO,XFTCAD		;SAVE AS BASE OF CURRENT FONT
	LDB	DAT,[POINT 5,(UUO),22]	;GET NEW COLUMN POS ADJ
	MOVEM	DAT,XCFCPA		;SAVE IT
	SUBI	J,(DAT)			;AND ADJUST COLUMN POSITION
	HRRZ	DAT,(UUO)		;GET THE NEW FONT HEIGHT
	ANDI	DAT,17777		;MASK OFF THE COLUMN POSITION ADJUST FIELD
	HLRZ	UUO,(UUO)		;AND THE NEW BASELINE
	CAMN	DAT,XCFH		;COMPARE OLD AND NEW HEIGHTS
	CAME	UUO,XCFBL		;OLD AND NEW BASELINES
	JRST	ESC1B			;FONTS ARE NOT COMPATABLE
	CAME	J,1(P)			;DID COLUMN POSITION CHANGE?
	JRST	XCI1CA			;YES. DO A COLUMN SELECT NOW.
	JRST	XCI1			;FOR COMPATABLE FONTS, NO EXTRA WORK

ES1.3:	JSP	AC3,XCIG		;GET NEXT CHARACTER
	CAIL	DAT,100
	ORCMI	DAT,177
	HLRZ	UUO,@XFTCAD		;GET REAL BASE-LINE
	ADD	UUO,DAT			;ADD THE TWIDDLE
	JRST	ESC1C			;PRETEND WE SAW A NEW FONT.

ESC1B:	MOVEM	DAT,XCFH		;STORE NEW HEIGHT
ESC1C:	MOVEM	UUO,XCFBL		;NEW BASELINE
	CAMN	UCHN,TEM		;CHECK TO SEE IF OLD MCG IS EMPTY
	JRST	XCI1			;NO NEED TO CLOSE AN EMPTY MCG
	CAIGE	PROG,2(TEM)		;ROOM TO CLOSE THIS HERE?
	PUSHJ	P,ADDNOD		;NO. MAKE ANOTHER NODE.
	JRST	ES1.1B			;SET RETURN, SET UP FOR NEW CHB

;HERE FOR '177 '001 '044 - INSERT PAPER PAGE NUMBER.
ES1.4:	MOVE	DAT,XGPPG2
	CAILE	DAT,=99999
	JRST	XCI1			;FLUSH.
	MOVEM	TAC,XGPAT0
	MOVEM	TAC1,XGPAT1		
	MOVEI	TAC,(DAT)
	MOVE	DAT,[POINT 7,XGPAT2]
	PUSHJ	P,ES1.4B
	MOVEI	TAC,XGPAT2
	MOVEI	TAC1,5
	JRST	XCI1
ES1.4B:	IDIVI	TAC,=10
	HRLM	TAC1,(P)
	JUMPE	TAC,.+2
	PUSHJ	P,ES1.4B
	HLRZ	TAC,(P)
	ADDI	TAC,"0"
	IDPB	TAC,DAT
	POPJ	P,

;HERE FOR '177 '1 '45 - SET AND PRINT HEADING
ES1.5:	MOVSI	AC2,XGPHDB
	HLRZM	AC2,XGPHDW		;CLEAR HEADING COUNT
	SETZM	XGPHDB			;CLEAR HEADING BUFFER
	HRRI	AC2,XGPHDB+1
	BLT	AC2,XGPHDB+=25		;CLEAR 130 CHARACTERS
	JSP	AC3,XCIG		;GET A CHARACTER. THIS IS THE COUNT.
	MOVEI	AC1,(DAT)		;KEEP THE COUNT.
	JUMPE	AC1,XCI1		;COUNT OF ZERO MEANS FLUSH HEADING.
	MOVE	AC2,[POINT 7,XGPHDB]
ES1.5A:	JSP	AC3,XCIG
	IDPB	DAT,AC2
	SOJG	AC1,ES1.5A		;DECREMENT COUNT AND LOOP UNLESS RUN OUT
	ANDI	AC2,-1			;GET THE ADDRESS ONLY
	SUBI	AC2,XGPHDB-1		;COMPUTE WORD COUNT
	MOVNI	AC2,(AC2)
	HRLM	AC2,XGPHDW
	MOVE	DAT,MTB(TAC1)
	ANDM	DAT,(TAC)		;CLEAR OUT THE TEXT WE'VE PROCESSED
	JSP	AC3,BFNSET		;GIVE BACK SOME BUFFER SPACE
	MOVE	TAC,XGPHDW		;READY FOR THE HEADING
	JRST	XCIP2			;SET DO THE HEADING.  (OOF)

;HERE FOR '177 '1 '46 - START UNDERLINE.
ES1.6:	MOVEM	J,XUSBEG		;STORE PRESENT COLUMN FOR START OF UNDERLINE
	JRST	XCI1			;DO MORE.

;HERE FOR '177 '002 - XGP ESCAPE 2
ESC2:	JSP	AC3,XCIG		;GET ANOTHER CHARACTER
	CAIL	DAT,100			;SKIP IF INTERPRETED AS POSITIVE
	ORCMI	DAT,177			;EXTEND NEGATIVE SIGN
	ADD	J,DAT			;DO FULL WORD ADD.
	JUMPGE	J,XCI1CA		;NOW IT'S LIKE TAB OR CR
	MOVEI	J,0			;PREVENT BACKSPACE OFF LEFT END
	JRST	XCI1CA			;

GLOM:	MOVEI	AC1,0			;ACCUMULATE MULTIPLE BYTES
					;COUNT IN AC2, RETURNS IN AC1
GLOM1:	JSP	AC3,XCIG		;GET A BYTE
	LSH	AC1,7
	IORI	AC1,(DAT)
	SOJG	AC2,GLOM1		;DECREMENT COUNT
	POPJ	P,			;RETURN.

;HERE FOR '177 '003 - SET Y POSITION OF CURRENT TEXT LINE.
ESC3:	MOVEI	AC2,2			;GET 2 BYTES
	PUSHJ	P,GLOM			;GOBBLE GOBBLE
	MOVEM	AC1,XCYPOS		;SET CURRENT Y POSITION.
	JRST	XCI1			;COMPILE MORE.

;HERE FOR '177 '004
ESC4A:	CONO	PI,PION			;HERE TO WAIT FOR A NODE.
	JSR	X2DISP
ESC4:	CONO	PI,PIOFF
	SKIPN	UUO,XVNFL		;GOBBLE FROM VECTOR NODE FREE LIST.
	JRST	ESC4A			;WAIT.
	MOVE	DAT,(UUO)
	MOVEM	DAT,XVNFL
	CONO	PI,PION			;UUO NOW POINTS TO THE NEW NODE.
	SETZM	(UUO)
	MOVEI	AC2,2			;2 BYTES OF Y0
	PUSHJ	P,GLOM
	MOVEM	AC1,1(UUO)		;STORE Y0
	MOVEI	AC2,2			;2 BYTES OF X0
	PUSHJ	P,GLOM
	ANDI	AC1,7777		;RESTRICT X0 TO RANGE
	HRLZM	AC1,2(UUO)		;STORE X0
	MOVEI	AC2,3			;3 BYTES OF DX
	PUSHJ	P,GLOM
	TLNE	AC1,4			;SIGN BIT?
	TLO	AC1,777770		;SIGN EXTEND.
	LSH	AC1,11			;SHIFT 9 BITS
	MOVEM	AC1,4(UUO)		;STUFF DX
	MOVEI	AC2,2			;2 BYTES OF N
	PUSHJ	P,GLOM
	HRRM	AC1,2(UUO)		;STORE N
	MOVEI	AC2,2
	PUSHJ	P,GLOM
	ANDI	AC1,7777		;REASONABLENESS
	IORI	AC1,SETN		;TURN ON THE RIGHT BITS
	MOVEM	AC1,3(UUO)		;STORE WIDTH.
	MOVEM	UUO,XVNODE		;STORE NODE ADDRESS.
	SKIPN	DAT,XGPPS2		;SKIP UNLESS SPECIAL PAGE HACK
	JRST	ESC4B			;SPECIAL PAGE HACK. LEAVE IT ALONE.
	ADD	DAT,XGPPS1		;SEE IF WE HAVE A PAGE TOO LONG
	CAML	DAT,1(UUO)		;SKIP IF WE'VE LOST
	JRST	ESC4B			;WE'RE OK SO FAR.
	PUSHJ	P,XERR13		;THIS WILL SET THE ERROR CODE
ESC4X:	SETZM	1(UUO)			;(THIS WILL FORCE OOO ERROR)
	JRST	XCI1F			;QUEUE THIS TEXT NODE.
ESC4B:	HRRZ	DAT,2(UUO)		;GET N
	HLLZ	AC1,2(UUO)		;GET X0
	IMUL	DAT,4(UUO)		;N*DX
	ADD	DAT,AC1			;+X0
	CAMG	DAT,[7777,,-1]		;OR TO FAR T'OTHER WAY
	JUMPGE	DAT,XCI1F		;SMALL ENOUGH. JUMP IF BIG ENOUGH
	PUSHJ	P,XERR14		;LOSE - ILLEGAL VECTOR PARAMETERS
	SETZM	4(UUO)			;SET DX TO 0
	HLLZS	2(UUO)			;SET N TO 0
	JRST	ESC4X			;GO FORCE OOO ERROR.
;	HERE FOR A 'NORMAL' CHARACTER
XCI2A:	ADD	DAT,XFTCAD		;ADD BASE OF TABLE
	SKIPN	AC3,1(DAT)		;SKIP IF THERE'S A CHARACTER THERE.
	JRST	XCI1			;NONE THERE GET ANOTHER CHARACTER
	LDB	AC2,[POINT 1,(AC3),10]	
	JUMPN	AC2,XCI2AW		;JUMP IF THIS IS A LEFT-KERN CHARACTER
XCI2AX:	CAML	J,XGPRMR		;ARE WE ABOUT TO OVERSTEP RIGHT MARGIN?
	AOJA	TAC1,XCI1D		;YES. PUT BACK THIS CHARACTER.
	CAME	DSER,TEM		;SKIP IF THIS IS A NEW SUBGROUP
	JRST	XCI2B			;NOT NEW
	CAME	UCHN,TEM		;SKIP IF THIS IS A NEW MCG
	JRST	XCI2AZ			;NO. JUST NEW SUBGROUP
	JUMPE	TEM,XCI2AC		;JUMP IF THERE ARE NO MCG'S
	SKIPL	AC2,XLBL		;ARE THERE OTHER CHB'S YET?
	JRST	XCI2AA			;YES.
XCI2AC:	MOVE	AC2,XCFBL
	MOVEM	AC2,XLBL
XCI2AA:	SUB	AC2,XCFBL		;SUBTRACT TO FIND BASELINE OFFSET.
	JUMPL	AC2,XCI2AB		;NEW BASELINE IS BIGGER (DEEPER)
	MOVEI	AC3,(AC2)
	ADD	AC3,XCFH
	JSP	AC1,SCHB		;SEARCH FOR A BLOCK THAT'S RIGHT
	SKIPGE	AC2,XLBL		;LINE BASE-LINE SET YET?
	MOVE	AC2,XCFBL		;NOT YET. DO SO NOW.
	MOVEM	AC2,XLBL
	JRST	XCI2AY
 
XCI2AB:	MOVM	AC3,AC2			;THE AMOUNT TO ADD TO ALL PRIOR COMMANDS.
	ADDM	AC3,XHMAX		;MAX HEIGHT MUST BE INCREASED
	MOVE	AC1,XCFBL
	MOVEM	AC1,XLBL		;SET NEW LINE BASE-LINE
	JSP	AC1,OFFCHB		;SET OFFSET IN ALL PRIOR COMMANDS
	HRRZ	AC3,XCFH		;SET MAX FOR THIS TERM
	MOVEI	AC2,0			;MIN
	JSP	AC1,ACHB		;ADD A NEW COMMAND HEADER BLOCK
	
XCI2AY:	CAIGE	PROG,2(TEM)
	PUSHJ	P,ADDNOD
	PUSH	TEM,[CONO XGP,SETX]
	ADDM	J,(TEM)			;SET COLUMN SELECTOR.
XCI2AZ:	HLRO	AC3,1(DAT)		;GET THE CHARACTER WIDTH (WORDS)
	ADDI	AC3,(PROG)
	CAIGE	AC3,3(TEM)		;ROOM FOR JSP,PTR,data,JRST?
	PUSHJ	P,ADDNOD		;NO. ADD A NEW NODE.
	PUSH	TEM,[JSP AC3,SCAN]	;STUFF COMMAND INTO BUFFER.
	MOVE	DSER,TEM
	MOVEI	UUO,2(TEM)
	PUSH	TEM,UUO
	MOVE	AC3,1(DAT)		;GET THE DATUM AGAIN.
XCI2B:	HLRO	AC2,AC3			;GET SIZE OF THIS ITEM.
	ADDI	AC2,(PROG)
	CAIGE	AC2,1(TEM)		;WILL THIS FIT?
	JRST	XCI2AZ			;NO. START A NEW NODE.
	HLLZ	AC2,AC3
	ADDM	AC2,1(DSER)
	LDB	AC1,[POINT 9,(AC3),8]	;GET THE WIDTH
	ADDI	J,(AC1)			;ADD THE WIDTH TO THE COLUMN COUNTER
	LDB	AC1,[POINT 1,(AC3),9]	;GET WIDTH KLUDGE BIT
	PUSH	TEM,(AC3)		;STUFF POINTERS
	AOBJN	AC3,.-1
	JUMPE	AC1,XCI1		;BACK TO GET ANOTHER UNLESS WIDTH KLUDGE
	JRST	XCI1CA			;ELSE EXPLICITLY SET COLUMN POSITION.

XCI2AW:	AOSN	XLFTKF			;LEFT-KERN FLAG SET?
	JRST	XCI2AX			;YES. WE WERE THRU HERE LAST TIME
	SETOM	XLFTKF
	LDB	AC2,[POINT 9,-1(AC3),35]	;GET KERN-OFFSET
	SUBI	J,(AC2)
	AOJA	TAC1,XCI1CA		;GO SET THE COLUMN POSTION. PUT CHR BACK
BEND	XGPSER
